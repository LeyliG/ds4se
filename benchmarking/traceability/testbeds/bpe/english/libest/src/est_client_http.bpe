▁/* ▁** ▁signed ▁long ▁to ▁signed ▁int ▁*/ ▁int ▁curl x _ s l to s i ( long ▁ slnum ) ▁{ ▁# if def ▁ _ _ INTE L _ C O M P IL ER ▁# ▁p ra gm a ▁warning ( push ) ▁# ▁p ra gm a ▁warning ( disable : 8 10) ▁/* ▁conversion ▁ma y ▁l ose ▁signifi c ant ▁bit s ▁*/ ▁# endif ▁assert ( slnum ▁>= ▁0); ▁# if ▁( SIZE OF _ INT ▁< ▁CURL _ SIZE OF _ LONG ) ▁assert ( ( un signed ▁long ) ▁ slnum ▁< = ▁( un signed ▁long ) ▁CURL _ MA SK _ S INT ); ▁# endif ▁return ▁( int ) ( slnum ▁& ▁( long ) ▁CURL _ MA SK _ S INT ); ▁# if def ▁ _ _ INTE L _ C O M P IL ER ▁# ▁p ra gm a ▁warning ( pop ) ▁# endif ▁} ▁/* ▁* ▁parse date () ▁* ▁* ▁Returns : ▁* ▁* ▁ PARSE DATE _ OK ▁- ▁a ▁fine ▁conversion ▁* ▁ PARSE DATE _ FAIL ▁- ▁failed ▁to ▁convert ▁* ▁ PARSE DATE _ LATER ▁- ▁time ▁overflow ▁at ▁the ▁far ▁end ▁of ▁time _ t ▁* ▁ PARSE DATE _ SOONER ▁- ▁time ▁under f low ▁at ▁the ▁ low ▁end ▁of ▁time _ t ▁*/ ▁static ▁int ▁parse date ( const ▁char ▁* date , ▁time _ t ▁* output ); ▁/* ▁return s : ▁-1 ▁no ▁day ▁0 ▁m onday ▁- ▁6 ▁ s unday ▁*/ ▁static ▁int ▁check day ( const ▁char ▁* check , ▁size _ t ▁len ) ▁{ ▁int ▁i ; ▁const ▁char ▁* ▁const ▁* what ; ▁int ▁found = ▁0; ▁if ( len ▁> ▁3) ▁what ▁= ▁& w ee k day [0 ] ; ▁else ▁what ▁= ▁& Curl _ w k day [0 ] ; ▁for ( i =0; ▁i < 7 ; ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what [0 ] )) ▁{ ▁found =1; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? i :-1; ▁} ▁/* ▁return s : ▁-1 ▁no ▁day ▁0 ▁m onday ▁- ▁6 ▁ s unday ▁*/ ▁static ▁int ▁check month ( const ▁char ▁* check ) ▁{ ▁int ▁i ; ▁const ▁char ▁* ▁const ▁* what ; ▁int ▁found = ▁0; ▁what ▁= ▁& Curl _ month [0 ] ; ▁for ( i =0; ▁i < 12 ; ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what [0 ] )) ▁{ ▁found =1; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? i :-1; ▁/* ▁return ▁the ▁offset ▁or ▁-1, ▁no ▁real ▁offset ▁is ▁-1 ▁*/ ▁} ▁/* ▁return ▁the ▁time ▁zone ▁offset ▁between ▁GMT ▁and ▁the ▁input ▁one , ▁in ▁number ▁of ▁seconds ▁or ▁-1 ▁if ▁the ▁ timezone ▁was n ' t ▁found / le g al ▁*/ ▁static ▁int ▁check tz ( const ▁char ▁* check ) ▁{ ▁un signed ▁int ▁i ; ▁const ▁struct ▁ tz info ▁* what ; ▁int ▁found = ▁0; ▁what ▁= ▁ tz ; ▁for ( i =0; ▁i < ▁sizeof ( tz ) / sizeof ( tz [0 ] ); ▁i ++) ▁{ ▁if ( est _ client _ Curl _ raw _ equal ( check , ▁what -> name )) ▁{ ▁found =1; ▁break ; ▁} ▁what ++; ▁} ▁return ▁found ? what -> offset * 6 0 :-1; ▁} ▁/* ▁return ▁the ▁time ▁zone ▁offset ▁between ▁GMT ▁and ▁the ▁input ▁one , ▁in ▁number ▁of ▁seconds ▁or ▁-1 ▁if ▁the ▁ timezone ▁was n ' t ▁found / le g al ▁*/ ▁static ▁void ▁skip _ over _ white ( const ▁char ▁** date ) ▁{ ▁/* ▁skip ▁everything ▁that ▁are n ' t ▁letters ▁or ▁digits ▁*/ ▁while ( ** date ▁&& ▁! IS AL NUM ( ** date )) ▁(* date ) ++; ▁} ▁/* ▁struct ▁tm ▁to ▁time ▁since ▁e po c h ▁in ▁GMT ▁time ▁zone . ▁* ▁This ▁is ▁similar ▁to ▁the ▁ standard ▁m k time ▁function ▁but ▁for ▁GMT ▁only , ▁and ▁* ▁does n ' t ▁ s uff er ▁from ▁the ▁vari ous ▁bug s ▁and ▁port ability ▁problem s ▁that ▁* ▁some ▁system s ' ▁implementation s ▁have . ▁*/ ▁static ▁time _ t ▁my _ time gm ( struct ▁my _ tm ▁* tm ) ▁{ ▁static ▁const ▁int ▁month _ days _ c u mu lative ▁[ 12 ] ▁= ▁{ ▁0, ▁31 , ▁5 9 , ▁90 , ▁120 , ▁15 1, ▁1 81, ▁2 12 , ▁24 3, ▁ 27 3, ▁30 4, ▁3 34 ▁} ; ▁int ▁month , ▁year , ▁leap _ days ; ▁if ( tm -> tm _ year ▁< ▁70 ) ▁/* ▁we ▁don ' t ▁support ▁years ▁before ▁1970 ▁as ▁they ▁will ▁cause ▁this ▁function ▁to ▁return ▁a ▁negative ▁value ▁*/ ▁return ▁-1; ▁year ▁= ▁tm -> tm _ year ▁+ ▁1900 ; ▁month ▁= ▁tm -> tm _ mon ; ▁if ( month ▁< ▁0) ▁{ ▁year ▁+= ▁( 11 ▁- ▁month ) ▁/ ▁12; ▁month ▁= ▁11 ▁- ▁( 11 ▁- ▁month ) ▁% ▁12; ▁} ▁else ▁if ( month ▁>= ▁12 ) ▁{ ▁year ▁- = ▁month ▁/ ▁12; ▁month ▁= ▁month ▁% ▁12; ▁} ▁leap _ days ▁= ▁year ▁- ▁( tm -> tm _ mon ▁< = ▁1); ▁leap _ days ▁= ▁( ( leap _ days ▁/ ▁4) ▁- ▁( leap _ days ▁/ ▁100 ) ▁+ ▁( leap _ days ▁/ ▁400 ) ▁- ▁( 19 69 ▁/ ▁4) ▁+ ▁( 19 69 ▁/ ▁100 ) ▁- ▁( 19 69 ▁/ ▁400 )); ▁return ▁( ( ( ( time _ t ) ▁( year ▁- ▁1970 ) ▁* ▁365 ▁+ ▁leap _ days ▁+ ▁month _ days _ c u mu lative ▁[ month ] ▁+ ▁tm -> tm _ m day ▁- ▁1) ▁* ▁24 ▁+ ▁tm -> tm _ hour ) ▁* ▁60 ▁+ ▁tm -> tm _ min ) ▁* ▁60 ▁+ ▁tm -> tm _ se c ; ▁} ▁/* ▁* ▁parse date () ▁* ▁* ▁Returns : ▁* ▁* ▁ PARSE DATE _ OK ▁- ▁a ▁fine ▁conversion ▁* ▁ PARSE DATE _ FAIL ▁- ▁failed ▁to ▁convert ▁* ▁ PARSE DATE _ LATER ▁- ▁time ▁overflow ▁at ▁the ▁far ▁end ▁of ▁time _ t ▁* ▁ PARSE DATE _ SOONER ▁- ▁time ▁under f low ▁at ▁the ▁ low ▁end ▁of ▁time _ t ▁*/ ▁static ▁int ▁parse date ( const ▁char ▁* date , ▁time _ t ▁* output ) ▁{ ▁time _ t ▁t ▁= ▁0; ▁int ▁ wdaynum =-1; ▁/* ▁day ▁of ▁the ▁we e k ▁number , ▁0 - 6 ▁( mon - su n ) ▁*/ ▁int ▁monnum =-1; ▁/* ▁month ▁of ▁the ▁year ▁number , ▁0 -1 1 ▁*/ ▁int ▁mdaynum =-1; ▁/* ▁day ▁of ▁month , ▁1 ▁- ▁31 ▁*/ ▁int ▁ hournum =-1; ▁int ▁ minnum =-1; ▁int ▁secnum =-1; ▁int ▁yearnum =-1; ▁int ▁ tzoff =-1; ▁struct ▁my _ tm ▁tm ; ▁enum ▁assume ▁ dig next ▁= ▁DATE _ MDAY ; ▁const ▁char ▁* in date ▁= ▁date ; ▁/* ▁save ▁the ▁original ▁pointer ▁*/ ▁int ▁part ▁= ▁0; ▁/* ▁max ▁6 ▁part s ▁*/ ▁while (* date ▁&& ▁( part ▁< ▁ 6)) ▁{ ▁int ▁found =0; ▁skip _ over _ white (& date ); ▁if ( IS AL PHA (* date )) ▁{ ▁/* ▁a ▁name ▁coming ▁up ▁*/ ▁char ▁buf [ EST _ CURL _ MAX _ NAME _ STR ] =" "; ▁size _ t ▁len ; ▁ s scan f ( date , ▁"% 31 [ AB C DEF G HI J K LM NO P Q RS TUV W XY Z abcdef g hij k l m no pq rs t u v w x y z ] ", ▁buf ); ▁len ▁= ▁ strnlen _ s ( buf , ▁EST _ CURL _ MAX _ NAME _ STR ); ▁if ( wdaynum ▁== ▁-1) ▁{ ▁ wdaynum ▁= ▁check day ( buf , ▁len ); ▁if ( wdaynum ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ▁&& ▁( monnum ▁== ▁-1) ) ▁{ ▁monnum ▁= ▁check month ( buf ); ▁if ( monnum ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ▁&& ▁( tzoff ▁== ▁-1) ) ▁{ ▁/* ▁this ▁just ▁must ▁be ▁a ▁time ▁zone ▁string ▁*/ ▁ tzoff ▁= ▁check tz ( buf ); ▁if ( tzoff ▁ != ▁-1) ▁found ▁= ▁1; ▁} ▁if (! found ) ▁return ▁ PARSE DATE _ FAIL ; ▁/* ▁bad ▁string ▁*/ ▁date ▁+= ▁len ; ▁} ▁else ▁if ( IS D IG IT (* date )) ▁{ ▁/* ▁a ▁digit ▁*/ ▁int ▁val ; ▁char ▁* end ; ▁if ( ( secnum ▁== ▁-1) ▁&& ▁( 3 ▁== ▁ s scan f ( date , ▁"% 02 d :% 02 d :% 02 d ", ▁& hournum , ▁& minnum , ▁& secnum ))) ▁{ ▁/* ▁time ▁stamp ! ▁*/ ▁date ▁+= ▁8 ; ▁} ▁else ▁if ( ( secnum ▁== ▁-1) ▁&& ▁( 2 ▁== ▁ s scan f ( date , ▁"% 02 d :% 02 d ", ▁& hournum , ▁& minnum ))) ▁{ ▁/* ▁time ▁stamp ▁without ▁seconds ▁*/ ▁date ▁+= ▁5 ; ▁secnum ▁= ▁0; ▁} ▁else ▁{ ▁long ▁ lval ; ▁int ▁error ; ▁int ▁old _ errno ; ▁old _ errno ▁= ▁ERRNO ; ▁SET _ ERR NO (0); ▁ lval ▁= ▁str to l ( date , ▁& end , ▁10); ▁error ▁= ▁ERRNO ; ▁if ( error ▁ != ▁old _ errno ) ▁SET _ ERR NO ( old _ errno ); ▁if ( error ) ▁return ▁ PARSE DATE _ FAIL ; ▁if ( ( lval ▁> ▁( long ) INT _ MAX ) ▁|| ▁( lval ▁< ▁( long ) INT _ MIN )) ▁return ▁ PARSE DATE _ FAIL ; ▁val ▁= ▁curl x _ s l to s i ( lval ); ▁if ( ( tzoff ▁== ▁-1) ▁&& ▁( ( end ▁- ▁date ) ▁== ▁4) ▁&& ▁( val ▁< = ▁1400 ) ▁&& ▁( in date < ▁date ) ▁&& ▁( ( date [ -1 ] ▁== ▁' + ' ▁|| ▁date [ -1 ] ▁== ▁' - ' ))) ▁{ ▁/* ▁fou r ▁digits ▁and ▁a ▁value ▁ less ▁than ▁or ▁equal ▁to ▁1400 ▁( to ▁take ▁into ▁account ▁all ▁sort s ▁of ▁f un ny ▁time ▁zone ▁diff s ) ▁and ▁it ▁is ▁preceded ▁with ▁a ▁ plus ▁or ▁min us . ▁This ▁is ▁a ▁time ▁zone ▁indication . ▁1400 ▁is ▁pi c ked ▁since ▁+ 130 0 ▁is ▁f r equent ly ▁used ▁and ▁+ 1 400 ▁is ▁ ment ion ed ▁as ▁an ▁ ed ge ▁number ▁in ▁the ▁document ▁" ISO ▁C ▁200 X ▁ Pro pos al : ▁ Time z one ▁Function s " ▁at ▁http :// d a v id . tr i bble . com / text / c 0 x timezone . html ▁If ▁anyone ▁has ▁a ▁more ▁authorit at ive ▁source ▁for ▁the ▁exact ▁maximum ▁time ▁zone ▁offset s , ▁p lease ▁sp e a k ▁up ! ▁*/ ▁found ▁= ▁1; ▁ tzoff ▁= ▁( val / 10 0 ▁* ▁60 ▁+ ▁val % 10 0 )* 6 0 ; ▁/* ▁the ▁+ ▁and ▁- ▁prefix ▁indicate s ▁the ▁local ▁time ▁compare d ▁to ▁GMT , ▁this ▁we ▁need ▁the r ▁r ever s ed ▁ma th ▁to ▁get ▁what ▁we ▁want ▁*/ ▁ tzoff ▁= ▁date [ -1 ] = =' + ' ? - tzoff : tzoff ; ▁} ▁if ( ( ( end ▁- ▁date ) ▁== ▁8 ) ▁&& ▁( yearnum ▁== ▁-1) ▁&& ▁( monnum ▁== ▁-1) ▁&& ▁( mdaynum ▁== ▁-1) ) ▁{ ▁/* ▁8 ▁digits , ▁no ▁year , ▁month ▁or ▁day ▁yet . ▁This ▁is ▁ YYYY MM DD ▁*/ ▁found ▁= ▁1; ▁yearnum ▁= ▁val / 1000 0 ; ▁monnum ▁= ▁( val % 10000) / 10 0 -1 ; ▁/* ▁month ▁is ▁0 ▁- ▁11 ▁*/ ▁mdaynum ▁= ▁val % 10 0 ; ▁} ▁if (! found ▁&& ▁( dig next ▁== ▁DATE _ MDAY ) ▁&& ▁( mdaynum ▁== ▁-1) ) ▁{ ▁if ( ( val ▁> ▁0) ▁&& ▁( val < 3 2)) ▁{ ▁mdaynum ▁= ▁val ; ▁found ▁= ▁1; ▁} ▁ dig next ▁= ▁DATE _ YEAR ; ▁} ▁if (! found ▁&& ▁( dig next ▁== ▁DATE _ YEAR ) ▁&& ▁( yearnum ▁== ▁-1) ) ▁{ ▁yearnum ▁= ▁val ; ▁found ▁= ▁1; ▁if ( yearnum ▁< ▁1900 ) ▁{ ▁if ( yearnum ▁> ▁70 ) ▁yearnum ▁+= ▁1900 ; ▁else ▁yearnum ▁+= ▁2000 ; ▁} ▁if ( mdaynum ▁== ▁-1) ▁ dig next ▁= ▁DATE _ MDAY ; ▁} ▁if (! found ) ▁return ▁ PARSE DATE _ FAIL ; ▁date ▁= ▁end ; ▁} ▁} ▁part ++; ▁} ▁if ( -1 ▁== ▁secnum ) ▁secnum ▁= ▁ minnum ▁= ▁ hournum ▁= ▁0; ▁/* ▁no ▁time , ▁make ▁it ▁zero ▁*/ ▁if ( ( -1 ▁== ▁mdaynum ) ▁|| ▁(-1 ▁== ▁monnum ) ▁|| ▁(-1 ▁== ▁yearnum )) ▁/* ▁lack s ▁vi t al ▁info , ▁fail ▁*/ ▁return ▁ PARSE DATE _ FAIL ; ▁# if ▁ SIZE OF _ TIME _ T ▁< ▁5 ▁/* ▁ 32 ▁bit ▁time _ t ▁can ▁only ▁hold ▁dates ▁to ▁the ▁ beginning ▁of ▁2038 ▁*/ ▁if ( yearnum ▁> ▁20 3 7 ) ▁{ ▁* output ▁= ▁0 x 7 fffffff ; ▁return ▁ PARSE DATE _ LATER ; ▁} ▁# endif ▁if ( yearnum ▁< ▁1970 ) ▁{ ▁* output ▁= ▁0; ▁return ▁ PARSE DATE _ SOONER ; ▁} ▁if ( ( mdaynum ▁> ▁31 ) ▁|| ▁( monnum ▁> ▁11 ) ▁|| ▁( hournum ▁> ▁2 3 ) ▁|| ▁( minnum ▁> ▁59) ▁|| ▁( secnum ▁> ▁60 )) ▁return ▁ PARSE DATE _ FAIL ; ▁/* ▁clear ly ▁an ▁illegal ▁date ▁*/ ▁tm . tm _ se c ▁= ▁secnum ; ▁tm . tm _ min ▁= ▁ minnum ; ▁tm . tm _ hour ▁= ▁ hournum ; ▁tm . tm _ m day ▁= ▁mdaynum ; ▁tm . tm _ mon ▁= ▁monnum ; ▁tm . tm _ year ▁= ▁yearnum ▁- ▁1900 ; ▁/* ▁my _ time gm () ▁return s ▁a ▁time _ t . ▁time _ t ▁is ▁of t en ▁ 32 ▁bit s , ▁even ▁on ▁many ▁a rc h ite cture s ▁that ▁feature ▁64 ▁bit ▁' long ' . ▁Some ▁system s ▁have ▁64 ▁bit ▁time _ t ▁and ▁deal ▁with ▁years ▁be y ond ▁2038 . ▁How ever , ▁even ▁on ▁some ▁of ▁the ▁system s ▁with ▁64 ▁bit ▁time _ t ▁m k time () ▁return s ▁-1 ▁for ▁dates ▁be y ond ▁0 3 : 14 : 07 ▁U TC , ▁ January ▁19 , ▁2038 . ▁( S uch ▁as ▁A IX ▁5 10 0 - 0 6 ) ▁*/ ▁t ▁= ▁my _ time gm (& tm ); ▁/* ▁time ▁zone ▁a d just ▁( ca st ▁t ▁to ▁int ▁to ▁compare ▁to ▁negative ▁one ) ▁*/ ▁if ( -1 ▁ != ▁( int ) t ) ▁{ ▁/* ▁Add ▁the ▁time ▁zone ▁diff ▁between ▁local ▁time ▁zone ▁and ▁GMT . ▁*/ ▁long ▁delta ▁= ▁( long ) ( tzoff != -1 ? tzoff : 0 ); ▁if ( ( del ta > 0 ) ▁&& ▁( t ▁+ ▁delta ▁< ▁t )) ▁return ▁-1; ▁/* ▁time _ t ▁overflow ▁*/ ▁t ▁+= ▁delta ; ▁} ▁* output ▁= ▁t ; ▁return ▁ PARSE DATE _ OK ; ▁} ▁/* ▁Find ▁next ▁Field ▁** ▁ --------------- ▁** ▁Find s ▁the ▁next ▁RFC 82 2 ▁token ▁in ▁a ▁string ▁** ▁On ▁entry , ▁** ▁* pstr ▁point s ▁to ▁a ▁string ▁containing ▁a ▁ word ▁separate d ▁** ▁by ▁white ▁white ▁space ▁"," ▁" ; " ▁or ▁" =" . ▁The ▁ word ▁** ▁can ▁optional ly ▁be ▁ quoted ▁using ▁< "> ▁or ▁"< " ▁" > " ▁** ▁Comment s ▁ su r r round ed ▁by ▁' (' ▁' ) ' ▁are ▁filtered ▁out ▁** ▁** ▁On ▁exit , ▁** ▁* pstr ▁has ▁been ▁move d ▁to ▁the ▁first ▁ del im i ter ▁past ▁the ▁** ▁field ▁** ▁T HE ▁ STRING ▁ HAS ▁B EEN ▁M UT IL ATE D ▁by ▁a ▁0 ▁terminat or ▁** ▁** ▁Returns ▁a ▁pointer ▁to ▁the ▁first ▁ word ▁or ▁NULL ▁on ▁error ▁*/ ▁static ▁char ▁* ▁HTNextField ▁( char ▁** ▁ps tr ) ▁{ ▁char ▁* ▁p ; ▁char ▁* ▁start ▁= ▁NULL ; ▁if ▁(! pstr ▁|| ▁!* pstr ) ▁{ ▁return ▁NULL ; ▁} ▁p ▁= ▁* pstr ; ▁while ▁(1) ▁{ ▁/* ▁ Str ip ▁white ▁space ▁and ▁other ▁delimiters ▁*/ ▁while ▁(* p ▁&& ▁( is space ( ( int )* p ) ▁|| ▁* p ▁== ▁ ',' ▁|| ▁* p ▁== ▁' ; ' ▁|| ▁* p ▁== ▁' =' )) ▁{ ▁p ++; ▁} ▁if ▁(! * p ) ▁{ ▁* pstr ▁= ▁p ; ▁return ▁NULL ; ▁/* ▁No ▁field ▁*/ ▁} ▁if ▁(* p ▁== ▁' " ' ) ▁{ ▁/* ▁ quoted ▁field ▁*/ ▁start ▁= ▁ ++ p ; ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁' " '; ▁p ++) ▁{ ▁if ▁(* p ▁== ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁escaped ▁char s ▁*/ ▁} ▁} ▁break ; ▁/* ▁k r 9 5 -1 0-9 : ▁needs ▁to ▁stop ▁here ▁*/ ▁} ▁else ▁if ▁(* p ▁== ▁' < ' ) ▁{ ▁/* ▁ quoted ▁field ▁*/ ▁start ▁= ▁ ++ p ; ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁' > '; ▁p ++) ▁{ ▁if ▁(* p ▁== ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁escaped ▁char s ▁*/ ▁} ▁} ▁break ; ▁/* ▁k r 9 5 -1 0-9 : ▁needs ▁to ▁stop ▁here ▁*/ ▁} ▁else ▁if ▁(* p ▁== ▁' (' ) ▁{ ▁/* ▁Comment ▁*/ ▁for ▁( ; ▁* p ▁&& ▁* p ▁ != ▁' ) '; ▁p ++) ▁{ ▁if ▁(* p ▁== ▁'\\' ▁&& ▁* ( p ▁+ ▁1)) ▁{ ▁p ++; ▁/* ▁S kip ▁escaped ▁char s ▁*/ ▁} ▁} ▁p ++; ▁} ▁else ▁{ ▁/* ▁S po ol ▁field ▁*/ ▁start ▁= ▁p ; ▁while ▁(* p ▁&& ▁! is space ( ( int )* p ) ▁&& ▁* p ▁ != ▁ ',' ▁&& ▁* p ▁ != ▁' ; ' ▁&& ▁* p ▁ != ▁' =' ) ▁{ ▁p ++; ▁} ▁break ; ▁/* ▁Go t ▁it ▁*/ ▁} ▁} ▁if ▁(* p ) ▁{ ▁* p ++ ▁= ▁'\0'; ▁} ▁* pstr ▁= ▁p ; ▁return ▁start ; ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁authentication ▁token s ▁from ▁* ▁the ▁server ▁when ▁the ▁server ▁is ▁requesting ▁HTTP ▁digest ▁* ▁authentication . ▁The ▁token s ▁are ▁required ▁to ▁generate ▁* ▁a ▁valid ▁authentication ▁response ▁in ▁future ▁HTTP ▁* ▁requests . ▁*/ ▁static ▁EST _ ERROR ▁est _ io _ parse _ auth _ token s ▁( EST _ CTX ▁* ctx , ▁char ▁* hdr ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁char ▁* p ▁= ▁hdr ; ▁char ▁* token ▁= ▁NULL ; ▁char ▁* value ▁= ▁NULL ; ▁int ▁diff ; ▁errno _ t ▁safe c _ rc ; ▁/* ▁* ▁header ▁will ▁come ▁in ▁with ▁the ▁basic ▁or ▁digest ▁field ▁st ill ▁on ▁the ▁front . ▁* ▁skip ▁over ▁it . ▁*/ ▁token ▁= ▁HTNextField (& p ); ▁while ▁( ( token ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁(! est _ strcasecmp _ s ( token , ▁" realm ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> realm , ▁ MAX _ REALM , ▁value , ▁ MAX _ REALM )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" nonce ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> s _ nonce , ▁ MAX _ NONCE , ▁value , ▁ MAX _ NONCE )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" qop ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( value [0 ] ▁== ▁'\0') ▁{ ▁EST _ LOG _ WARN (" Un supported ▁qop ▁value : ▁% s ", ▁value ); ▁} ▁else ▁{ ▁safe c _ rc ▁= ▁mem cmp _ s ( value , ▁sizeof (" auth "), ▁" auth ", ▁sizeof (" auth "), ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem cmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁if ▁( diff ▁&& ▁( safe c _ rc ▁== ▁EOK )) ▁{ ▁EST _ LOG _ WARN (" Un supported ▁qop ▁value : ▁% s ", ▁value ); ▁} ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" algorithm ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p )) ▁&& ▁est _ strcasecmp _ s ( value , ▁" md 5 ")) ▁{ ▁EST _ LOG _ ERR (" Un supported ▁digest ▁algorithm : ▁% s ", ▁value ); ▁/* ▁** ▁We ▁only ▁support ▁MD 5 ▁for ▁the ▁moment ▁*/ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" error ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> token _ error , ▁ MAX _ TOKEN _ ERROR , ▁value , ▁ MAX _ TOKEN _ ERROR )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( token , ▁" error _ description ")) ▁{ ▁if ▁( ( value ▁= ▁HTNextField (& p ))) ▁{ ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> token _ error _ desc , ▁ MAX _ TOKEN _ ERROR _ DESC , ▁value , ▁ MAX _ TOKEN _ ERROR _ DESC )) ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ INVALID _ TOKEN ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" Un supported ▁auth ▁token ▁ignored : ▁% s ", ▁token ); ▁} ▁if ▁( rv ▁== ▁EST _ ERR _ INVALID _ TOKEN ) ▁{ ▁mem zero _ s ( ctx -> s _ nonce , ▁ MAX _ NONCE +1 ); ▁break ; ▁} ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁authentication ▁token s ▁from ▁* ▁the ▁server ▁when ▁the ▁server ▁is ▁requesting ▁HTTP ▁digest ▁* ▁authentication . ▁The ▁token s ▁are ▁required ▁to ▁generate ▁* ▁a ▁valid ▁authentication ▁response ▁in ▁future ▁HTTP ▁* ▁requests . ▁*/ ▁static ▁HTTP _ HEADER ▁* ▁parse _ http _ headers ▁( un signed ▁char ▁** buf , ▁int ▁* num _ headers ) ▁{ ▁int ▁i ; ▁HTTP _ HEADER ▁* hdrs ; ▁char ▁* hdr _ end ; ▁errno _ t ▁safe c _ rc ; ▁* num _ headers ▁= ▁0; ▁hdrs ▁= ▁malloc ( sizeof ( HTTP _ HEADER ) ▁* ▁ MAX _ HEADERS ); ▁if ▁(! hdrs ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failure "); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁Find ▁offset ▁of ▁header ▁de li min ter ▁*/ ▁safe c _ rc ▁= ▁ strstr _ s ( ( char ▁* ) ▁* buf , ▁ strnlen _ s ( ( char ▁* ) ▁* buf , ▁R SIZE _ MAX _ STR ) , ▁"\ r \ n \ r \ n ", ▁ MAX _ HEADER _ DEL I MI T ER _ LEN , ▁& hdr _ end ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strstr _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁/* ▁* ▁S kip ▁the ▁first ▁line ▁*/ ▁skip ( ( char ▁* *) buf , ▁"\ r \ n "); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ MAX _ HEADERS ; ▁i ++) ▁{ ▁hdrs [ i ] . name ▁= ▁skip _ quoted ( ( char ▁* *) buf , ▁":" , ▁" ▁" , ▁0); ▁hdrs [ i ] . value ▁= ▁skip ( ( char ▁* *) buf , ▁"\ r \ n "); ▁f flu sh ( stdout ); ▁EST _ LOG _ INFO (" Found ▁HTTP ▁header ▁ -> ▁% s :% s ", ▁hdrs [ i ] . name , ▁hdrs [ i ] . value ); ▁f flu sh ( stdout ); ▁if ▁( hdrs [ i ] . name [0 ] ▁== ▁'\0') ▁{ ▁break ; ▁} ▁* num _ headers ▁= ▁i ▁+ ▁1; ▁if ▁( (* buf ) ▁> ▁( un signed ▁char ▁* ) hdr _ end ) ▁{ ▁break ; ▁} ▁} ▁EST _ LOG _ INFO (" Found ▁% d ▁HTTP ▁headers \ n ", ▁* num _ headers ); ▁return ▁( hdrs ); ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁HTTP ▁status ▁code ▁* ▁in ▁the ▁first ▁header . ▁Only ▁a ▁hand f ul ▁of ▁codes ▁are ▁* ▁handled ▁by ▁EST . ▁We ▁are ▁not ▁a ▁full ▁HTTP ▁stack . ▁Any ▁* ▁un recognize d ▁codes ▁will ▁result ▁in ▁an ▁error . ▁* ▁Note ▁that ▁HTTP ▁1.1 ▁is ▁expected . ▁*/ ▁static ▁int ▁est _ io _ parse _ response _ status _ code ▁( un signed ▁char ▁* buf ) ▁{ ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _200, ▁ strnlen _ s ( EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁200 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _202, ▁ strnlen _ s ( EST _ HTTP _ HDR _202, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁202 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _204, ▁ strnlen _ s ( EST _ HTTP _ HDR _204, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁204 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _400, ▁ strnlen _ s ( EST _ HTTP _ HDR _400, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁400 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _401, ▁ strnlen _ s ( EST _ HTTP _ HDR _401, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁401 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _ 4 04, ▁ strnlen _ s ( EST _ HTTP _ HDR _ 4 04, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁404 ; ▁} ▁else ▁if ▁(! strnc mp ( ( const ▁char ▁* ) buf , ▁EST _ HTTP _ HDR _ 4 2 3, ▁ strnlen _ s ( EST _ HTTP _ HDR _ 4 2 3, ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁423 ; ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Un handle d ▁HTTP ▁response ▁% s ", ▁buf ); ▁return ▁-1; ▁} ▁} ▁/* ▁* ▁This ▁function ▁search es ▁for ▁and ▁process es ▁the ▁W WW - Authenticate ▁header ▁from ▁* ▁the ▁server . ▁The ▁result ▁is ▁the ▁setting ▁of ▁the ▁auth _ mode ▁value ▁in ▁the ▁* ▁context . ▁If ▁there ▁is ▁no ▁W WW - Authenticate ▁header , ▁or ▁the ▁values ▁in ▁the ▁* ▁header ▁are ▁invalid , ▁it ▁will ▁set ▁the ▁auth _ mode ▁to ▁a ▁failure ▁setting . ▁If ▁* ▁there ▁are ▁multiple ▁ Authenticate ▁headers , ▁only ▁the ▁first ▁one ▁will ▁be ▁* ▁processed . ▁*/ ▁static ▁void ▁est _ io _ parse _ http _ auth _ request ▁( EST _ CTX ▁* ctx , ▁HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt ) ▁{ ▁int ▁i ; ▁EST _ ERROR ▁rv ; ▁int ▁auth _ found ▁= ▁0; ▁/* ▁* ▁W alk ▁the ▁headers ▁look ing ▁for ▁the ▁W WW - Authenticate . ▁We ' ll ▁* ▁only ▁process ▁the ▁first ▁one . ▁If ▁an ▁err one ous ▁second ▁one ▁* ▁is ▁included , ▁it ▁will ▁be ▁ignored . ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁hdr _ cnt ; ▁i ++) ▁{ ▁if ▁(! strnc mp ( hdrs [ i ] . name , ▁EST _ HTTP _ HDR _ AUTH , ▁ 16)) ▁{ ▁auth _ found ▁= ▁1; ▁if ▁(! strnc mp ( hdrs [ i ] . value , ▁" Basic ", ▁ 5)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ BASIC ; ▁/* ▁Parse ▁the ▁realm ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ token s ( ctx , ▁hdrs [ i ] . value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁if ▁(! strnc mp ( hdrs [ i ] . value , ▁" Digest ", ▁ 6)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ DIGEST ; ▁/* ▁Parse ▁the ▁realm ▁and ▁nonce ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ token s ( ctx , ▁hdrs [ i ] . value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁if ▁(! strnc mp ( hdrs [ i ] . value , ▁" B e ar er ", ▁ 6)) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ TOKEN ; ▁/* ▁Parse ▁the ▁realm ▁and ▁possible ▁token ▁error ▁fields ▁*/ ▁rv ▁= ▁est _ io _ parse _ auth _ token s ( ctx , ▁hdrs [ i ] . value ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Un supported ▁W WW - Authenticate ▁method "); ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁break ; ▁} ▁} ▁if ▁(! auth _ found ) ▁{ ▁EST _ LOG _ ERR (" No ▁W WW - Authenticate ▁header ▁found "); ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁} ▁return ; ▁} ▁/* ▁* ▁This ▁function ▁takes ▁in ▁the ▁list ▁of ▁headers ▁that ▁we re ▁in ▁the ▁server ' s ▁* ▁response , ▁it ▁walk s ▁through ▁the ▁headers ▁look ing ▁for ▁a ▁Re try - After ▁response ▁* ▁header . ▁If ▁one ▁is ▁found , ▁the ▁value ▁is ▁parsed ▁and ▁saved ▁away ▁in ▁the ▁EST ▁* ▁context . ▁This ▁value ▁can ▁be ▁in ▁one ▁of ▁two ▁format s , ▁both ▁are ▁represented ▁as ▁* ▁an ▁ASCII ▁string . ▁The ▁first ▁format ▁can ▁be ▁a ▁count ▁of ▁the ▁number ▁of ▁seconds ▁* ▁the ▁client ▁should ▁wait ▁before ▁retry ing ▁the ▁request . ▁The ▁second ▁format ▁is ▁a ▁* ▁time / date ▁stamp ▁of ▁the ▁point ▁in ▁time ▁at ▁which ▁the ▁client ▁should ▁retry ▁the ▁* ▁request . ▁The ▁result ▁of ▁this ▁function ▁is ▁the ▁setting ▁of ▁the ▁retry _ after ▁* ▁values ▁in ▁the ▁context . ▁If ▁no ▁retry - after ▁header ▁was ▁received , ▁or ▁was ▁* ▁received ▁and ▁could ▁not ▁be ▁parsed , ▁the ▁values ▁will ▁be ▁zero , ▁otherwise , ▁they ▁* ▁are ▁set ▁to ▁the ▁value ▁received . ▁* ▁* ▁NOTE : ▁The ▁EST ▁client ▁currently ▁does ▁not ▁support ▁the ▁time / date ▁format ▁* ▁response ▁and ▁will ▁not ▁process ▁a ▁response ▁in ▁this ▁format . ▁*/ ▁static ▁EST _ ERROR ▁est _ io _ parse _ http _ retry _ after _ resp ▁( EST _ CTX ▁* ctx , ▁HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt ) ▁{ ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ INVALID _ RETRY _ VALUE ; ▁int ▁i ; ▁int ▁ cmp _ result , ▁diff ; ▁int ▁rc ; ▁long ▁long ▁int ▁temp _ ll ; ▁int ▁found ▁= ▁0; ▁/* ▁* ▁Initialize ▁assum ing ▁there ▁was ▁no ▁retry - after ▁header . ▁*/ ▁ctx -> retry _ after _ delay ▁= ▁0; ▁ctx -> retry _ after _ date ▁= ▁0; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁hdr _ cnt ; ▁i ++) ▁{ ▁ cmp _ result ▁= ▁ strcasecmp _ s ( hdrs [ i ] . name , ▁sizeof ( EST _ HTTP _ HDR _ RETRY _ AFTER ) , ▁EST _ HTTP _ HDR _ RETRY _ AFTER , ▁& diff ); ▁if ▁( cmp _ result ▁== ▁EOK ▁&& ▁! diff ) ▁{ ▁EST _ LOG _ INFO (" R etry - After ▁value ▁= ▁% s ", ▁hdrs [ i ] . value ); ▁found ▁= ▁1; ▁/* ▁* ▁Determine ▁whether ▁or ▁not ▁the ▁value ▁is ▁a ▁date / time ▁string ▁* ▁or ▁is ▁an ▁integer ▁representing ▁the ▁number ▁of ▁seconds ▁* ▁that ▁the ▁client ▁must ▁wait . ▁*/ ▁if ▁( is al pha (*( char ▁* ) hdrs [ i ] . value )) ▁{ ▁# if def ▁ RETRY _ AFTER _ DEL AY _ TIME _ S UP PORT ▁int ▁rc ; ▁/* ▁* ▁Convert ▁the ▁date / time ▁string ▁into ▁a ▁time _ t ▁*/ ▁rc ▁= ▁parse date ( hdrs [ i ] . value , ▁& ctx -> retry _ after _ date ); ▁if ▁( rc ▁ != ▁ PARSE DATE _ OK ) ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁could ▁not ▁be ▁parsed "); ▁} ▁# else ▁/* ▁* ▁This ▁format ▁is ▁not ▁currently ▁supported . ▁*/ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁not ▁in ▁the ▁correct ▁format "); ▁# endif ▁} ▁else ▁{ ▁/* ▁* ▁make ▁sure ▁it ' s ▁all ▁digits , ▁make ▁sure ▁it ' s ▁no ▁large r ▁than ▁a ▁* ▁fou r ▁byte ▁integer , ▁and ▁cache ▁away ▁the ▁value ▁returned ▁for ▁* ▁the ▁retry ▁delay . ▁*/ ▁rc ▁= ▁str is digit _ s ( hdrs [ i ] . value , ▁10); ▁// ▁max ▁of ▁10 ▁d ecimal ▁places ▁if ▁( rc ) ▁{ ▁temp _ ll ▁= ▁a to ll ( hdrs [ i ] . value ); ▁if ▁( temp _ ll ▁< = ▁INT _ MAX ) ▁{ ▁ctx -> retry _ after _ delay ▁= ▁( int ) ▁temp _ ll ; ▁rv ▁= ▁EST _ ERR _ CA _ ENROLL _ RETRY ; ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁too ▁large "); ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁value ▁could ▁not ▁be ▁parsed "); ▁} ▁} ▁} ▁} ▁if ▁( found ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" R etry - After ▁header ▁missing "); ▁} ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁function ▁verifie s ▁the ▁content ▁type ▁header ▁and ▁also ▁* ▁return s ▁the ▁length ▁of ▁the ▁content ▁header . ▁The ▁* ▁content ▁type ▁is ▁important . ▁For ▁example , ▁the ▁content ▁* ▁type ▁is ▁expected ▁to ▁be ▁pkcs 7 ▁on ▁a ▁simple ▁enrollment . ▁*/ ▁static ▁int ▁est _ io _ check _ http _ hdrs ▁( HTTP _ HEADER ▁* hdrs , ▁int ▁hdr _ cnt , ▁EST _ OPERATION ▁op ) ▁{ ▁int ▁i ; ▁int ▁cl ▁= ▁0; ▁int ▁content _ type _ present ▁= ▁0, ▁content _ length _ present ▁= ▁0; ▁int ▁ cmp _ result ; ▁/* ▁* ▁T ra ver se ▁all ▁the ▁http ▁headers ▁and ▁process ▁the ▁one s ▁that ▁need ▁to ▁be ▁* ▁checked ▁*/ ▁for ▁( i ▁= ▁0; ▁i ▁< ▁hdr _ cnt ; ▁i ++) ▁{ ▁/* ▁* ▁Content ▁type ▁*/ ▁mem cmp _ s ( hdrs [ i ] . name , ▁sizeof ( EST _ HTTP _ HDR _ CT ) , ▁EST _ HTTP _ HDR _ CT , ▁sizeof ( EST _ HTTP _ HDR _ CT ) , ▁& cmp _ result ); ▁if ▁(! cmp _ result ) ▁{ ▁content _ type _ present ▁= ▁1; ▁/* ▁* ▁Verify ▁content ▁is ▁pkcs 7 ▁data ▁*/ ▁mem cmp _ s ( hdrs [ i ] . value , ▁ strnlen _ s ( est _ op _ map [ op ] . content _ type , ▁est _ op _ map [ op ] . length ) , ▁est _ op _ map [ op ] . content _ type , ▁ strnlen _ s ( est _ op _ map [ op ] . content _ type , ▁est _ op _ map [ op ] . length ) , ▁& cmp _ result ); ▁if ▁( cmp _ result ) ▁{ ▁EST _ LOG _ ERR (" HTTP ▁content ▁type ▁is ▁% s ", ▁hdrs [ i ] . value ); ▁return ▁0; ▁} ▁} ▁else ▁{ ▁/* ▁* ▁Content ▁Length ▁*/ ▁mem cmp _ s ( hdrs [ i ] . name , ▁sizeof ( EST _ HTTP _ HDR _ CL ) , ▁EST _ HTTP _ HDR _ CL , ▁sizeof ( EST _ HTTP _ HDR _ CL ) , ▁& cmp _ result ); ▁if ▁(! cmp _ result ) ▁{ ▁content _ length _ present ▁= ▁1; ▁cl ▁= ▁at oi ( hdrs [ i ] . value ); ▁} ▁} ▁} ▁/* ▁* ▁Make ▁sure ▁all ▁the ▁necessary ▁headers ▁we re ▁present . ▁*/ ▁if ▁( content _ type _ present ▁== ▁0 ▁ ) ▁{ ▁EST _ LOG _ ERR (" Missing ▁HTTP ▁content ▁type ▁header "); ▁return ▁0; ▁} ▁else ▁if ▁( content _ length _ present ▁== ▁0 ▁ ) ▁{ ▁EST _ LOG _ ERR (" Missing ▁HTTP ▁content ▁length ▁header "); ▁return ▁0; ▁} ▁return ▁cl ; ▁} ▁/* ▁* ▁This ▁function ▁verifie s ▁the ▁content ▁type ▁header ▁and ▁also ▁* ▁return s ▁the ▁length ▁of ▁the ▁content ▁header . ▁The ▁* ▁content ▁type ▁is ▁important . ▁For ▁example , ▁the ▁content ▁* ▁type ▁is ▁expected ▁to ▁be ▁pkcs 7 ▁on ▁a ▁simple ▁enrollment . ▁*/ ▁static ▁int ▁est _ ssl _ read ▁( SSL ▁* ssl , ▁un signed ▁char ▁* buf , ▁int ▁buf _ max , ▁int ▁sock _ read _ timeout ) ▁{ ▁int ▁timeout ; ▁int ▁read _ fd ; ▁int ▁rv ; ▁struct ▁poll fd ▁pfd ; ▁/* ▁* ▁load ▁up ▁the ▁time val ▁struct ▁to ▁be ▁passed ▁to ▁the ▁select ▁*/ ▁timeout ▁= ▁sock _ read _ timeout ▁* ▁1000; ▁read _ fd ▁= ▁SSL _ get _ fd ( ssl ); ▁pfd . fd ▁= ▁read _ fd ; ▁pfd . events ▁= ▁POLL IN ; ▁pfd . revent s ▁= ▁0; ▁errno ▁= ▁0; ▁rv ▁= ▁POLL (& p fd , ▁1, ▁timeout ); ▁if ▁( rv ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" Socket ▁poll ▁timeout . ▁No ▁data ▁received ▁from ▁server . "); ▁return ▁-1; ▁} ▁else ▁if ▁( ▁rv ▁== ▁-1) ▁{ ▁EST _ LOG _ ERR (" Socket ▁read ▁failure . ▁errno ▁= ▁% d ", ▁errno ); ▁return ▁-1; ▁} ▁else ▁{ ▁return ▁( SSL _ read ( ssl , ▁buf , ▁buf _ max )); ▁} ▁} ▁/* ▁* ▁This ▁function ▁extract s ▁data ▁from ▁the ▁SSL ▁context ▁and ▁put s ▁* ▁it ▁into ▁a ▁buffer . ▁*/ ▁static ▁int ▁est _ io _ read _ raw ▁( SSL ▁* ssl , ▁un signed ▁char ▁* buf , ▁int ▁buf _ max , ▁int ▁* read _ cnt , ▁int ▁sock _ read _ timeout ) ▁{ ▁int ▁cur _ cnt ; ▁char ▁ peek _ read _ buf ; ▁* read _ cnt ▁= ▁0; ▁cur _ cnt ▁= ▁est _ ssl _ read ( ssl , ▁buf , ▁buf _ max , ▁sock _ read _ timeout ); ▁if ▁( cur _ cnt ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁read ▁error ▁1 "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ SSL _ READ ); ▁} ▁* read _ cnt ▁+= ▁cur _ cnt ; ▁/* ▁* ▁M u ltip le ▁calls ▁to ▁SSL _ read ▁ma y ▁be ▁required ▁to ▁get ▁the ▁full ▁* ▁HTTP ▁payload . ▁*/ ▁while ▁( cur _ cnt ▁> ▁0 ▁&& ▁* read _ cnt ▁< ▁buf _ max ) ▁{ ▁cur _ cnt ▁= ▁est _ ssl _ read ( ssl , ▁( buf ▁+ ▁* read _ cnt ) , ▁( buf _ max ▁- ▁* read _ cnt ) , ▁sock _ read _ timeout ); ▁if ▁( cur _ cnt ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" TLS ▁read ▁error "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁( EST _ ERR _ SSL _ READ ); ▁} ▁* read _ cnt ▁+= ▁cur _ cnt ; ▁} ▁if ▁( (* read _ cnt ▁== ▁buf _ max ) ▁&& ▁SSL _ peek ( ssl , ▁& peek _ read _ buf , ▁1)) ▁{ ▁EST _ LOG _ ERR (" B uff er ▁too ▁small ▁for ▁received ▁message "); ▁return ( EST _ ERR _ READ _ BU FFER _ TOO _ SMALL ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁provide s ▁the ▁ primar y ▁entry ▁point ▁into ▁* ▁this ▁ module . ▁It ' s ▁used ▁by ▁the ▁EST ▁client ▁to ▁read ▁the ▁* ▁HTTP ▁response ▁from ▁the ▁server . ▁The ▁data ▁is ▁read ▁from ▁* ▁the ▁SSL ▁context ▁and ▁HTTP ▁parsing ▁is ▁invoked . ▁* ▁* ▁If ▁EST _ ERR _ NONE ▁is ▁returned ▁then ▁the ▁raw _ buf ▁buffer ▁must ▁* ▁be ▁free d ▁by ▁the ▁caller , ▁otherwise , ▁it ▁is ▁free d ▁here . ▁*/ ▁EST _ ERROR ▁est _ io _ get _ response ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁EST _ OPERATION ▁op , ▁un signed ▁char ▁** buf , ▁int ▁* payload _ len ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁HTTP _ HEADER ▁* hdrs ; ▁int ▁hdr _ cnt ; ▁int ▁http _ status ; ▁un signed ▁char ▁* raw _ buf , ▁* payload _ buf , ▁* payload ; ▁int ▁raw _ len ▁= ▁0; ▁raw _ buf ▁= ▁malloc ( EST _ CA _ MAX ); ▁if ▁( raw _ buf ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory "); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁mem zero _ s ( raw _ buf , ▁EST _ CA _ MAX ); ▁payload ▁= ▁raw _ buf ; ▁/* ▁* ▁ Read ▁the ▁raw ▁data ▁from ▁the ▁SSL ▁connection ▁*/ ▁rv ▁= ▁est _ io _ read _ raw ( ssl , ▁raw _ buf , ▁EST _ CA _ MAX , ▁& raw _ len , ▁ctx -> read _ timeout ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ INFO (" No ▁valid ▁response ▁to ▁process "); ▁free ( raw _ buf ); ▁return ▁( rv ); ▁} ▁if ▁( raw _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" Received ▁empty ▁HTTP ▁response ▁from ▁server "); ▁free ( raw _ buf ); ▁return ▁( EST _ ERR _ HTTP _ NOT _ FOUND ); ▁} ▁EST _ LOG _ INFO (" Read ▁% d ▁bytes ▁of ▁HTTP ▁data ", ▁raw _ len ); ▁/* ▁* ▁Parse ▁the ▁HTTP ▁header ▁to ▁get ▁the ▁status ▁* ▁Look ▁for ▁status ▁200 ▁for ▁success ▁*/ ▁http _ status ▁= ▁est _ io _ parse _ response _ status _ code ( raw _ buf ); ▁ctx -> last _ http _ status ▁= ▁http _ status ; ▁hdrs ▁= ▁parse _ http _ headers (& payload , ▁& hdr _ cnt ); ▁EST _ LOG _ INFO (" HTTP ▁status ▁% d ▁received ", ▁http _ status ); ▁/* ▁* ▁Check ▁the ▁Status ▁header ▁first ▁to ▁see ▁* ▁if ▁the ▁server ▁accepted ▁our ▁request . ▁*/ ▁switch ▁( http _ status ) ▁{ ▁case ▁200 : ▁/* ▁Server ▁reported ▁OK , ▁nothing ▁to ▁do ▁*/ ▁break ; ▁case ▁204 : ▁case ▁404 : ▁EST _ LOG _ ERR (" Server ▁respond ed ▁with ▁204 / 4 04, ▁no ▁content ▁or ▁not ▁found "); ▁if ▁( op ▁== ▁EST _ OP _ CSRATTRS ) ▁{ ▁rv ▁= ▁EST _ ERR _ NONE ; ▁} ▁else ▁if ▁( http _ status ▁== ▁404 ) ▁{ ▁rv ▁= ▁EST _ ERR _ HTTP _ NOT _ FOUND ; ▁} ▁else ▁{ ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁} ▁break ; ▁case ▁202 : ▁/* ▁Server ▁is ▁ask ing ▁for ▁a ▁retry ▁*/ ▁EST _ LOG _ INFO (" EST ▁server ▁respond ed ▁with ▁retry - after "); ▁rv ▁= ▁est _ io _ parse _ http _ retry _ after _ resp ( ctx , ▁hdrs , ▁hdr _ cnt ); ▁break ; ▁case ▁400 : ▁EST _ LOG _ ERR (" HTTP ▁response ▁from ▁EST ▁server ▁was ▁ BAD ▁REQUEST "); ▁rv ▁= ▁EST _ ERR _ HTTP _ BAD _ REQ ; ▁break ; ▁case ▁401 : ▁/* ▁Server ▁is ▁requesting ▁user ▁auth ▁credentials ▁*/ ▁EST _ LOG _ INFO (" EST ▁server ▁requesting ▁user ▁authentication "); ▁/* ▁Check ▁if ▁we ' ve ▁already ▁tri ed ▁authenticating , ▁if ▁so , ▁then ▁bail ▁* ▁First ▁time ▁through , ▁auth _ mode ▁will ▁be ▁set ▁to ▁ NONE ▁*/ ▁if ▁( ctx -> auth _ mode ▁== ▁AUTH _ DIGEST ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ BASIC ▁|| ▁ctx -> auth _ mode ▁== ▁AUTH _ TOKEN ) ▁{ ▁ctx -> auth _ mode ▁= ▁AUTH _ FAIL ; ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL ; ▁break ; ▁} ▁est _ io _ parse _ http _ auth _ request ( ctx , ▁hdrs , ▁hdr _ cnt ); ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL ; ▁break ; ▁case ▁423 : ▁EST _ LOG _ ERR (" Server ▁respond ed ▁with ▁423 , ▁the ▁content ▁we ▁are ▁attempt ing ▁to ▁access ▁is ▁ lock ed "); ▁rv ▁= ▁EST _ ERR _ HTTP _ LOCKED ; ▁break ; ▁case ▁-1 : ▁/* ▁Un supported ▁HTTP ▁response ▁*/ ▁EST _ LOG _ ERR (" Un supported ▁HTTP ▁response ▁from ▁EST ▁server ▁(% d )", ▁http _ status ); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁break ; ▁default : ▁/* ▁Some ▁other ▁HTTP ▁response ▁was ▁given , ▁do ▁we ▁want ▁to ▁handle ▁these ? ▁*/ ▁EST _ LOG _ ERR (" HTTP ▁response ▁from ▁EST ▁server ▁was ▁% d ", ▁http _ status ); ▁rv ▁= ▁EST _ ERR _ HTTP _ UNSUPPORTED ; ▁break ; ▁} ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁/* ▁* ▁Get ▁the ▁Content - Type ▁and ▁Content - Length ▁headers ▁* ▁and ▁verify ▁the ▁HTTP ▁response ▁contains ▁the ▁correct ▁amount ▁* ▁of ▁data . ▁*/ ▁* payload _ len ▁= ▁est _ io _ check _ http _ hdrs ( hdrs , ▁hdr _ cnt , ▁op ); ▁EST _ LOG _ INFO (" HTTP ▁Content ▁len =% d ", ▁* payload _ len ); ▁if ▁(* payload _ len ▁> ▁EST _ CA _ MAX ) ▁{ ▁EST _ LOG _ ERR (" Content ▁Length ▁large r ▁than ▁maximum ▁value ▁of ▁% d . ", ▁EST _ CA _ MAX ); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁* payload _ len ▁= ▁0; ▁* buf ▁= ▁NULL ; ▁} ▁else ▁if ▁(* payload _ len ▁== ▁0) ▁{ ▁* payload _ len ▁= ▁0; ▁* buf ▁= ▁NULL ; ▁} ▁else ▁{ ▁/* ▁* ▁A llocate ▁the ▁buffer ▁to ▁hold ▁the ▁payload ▁to ▁be ▁passed ▁back ▁*/ ▁payload _ buf ▁= ▁malloc (* payload _ len ); ▁if ▁(! payload _ buf ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁memory "); ▁free ( raw _ buf ); ▁free ( hdrs ); ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁memcpy _ s ( payload _ buf , ▁* payload _ len , ▁payload , ▁* payload _ len ); ▁* buf ▁= ▁payload _ buf ; ▁} ▁} ▁if ▁( raw _ buf ) ▁{ ▁free ( raw _ buf ); ▁} ▁if ▁( hdrs ) ▁{ ▁free ( hdrs ); ▁} ▁return ▁( rv ); ▁}