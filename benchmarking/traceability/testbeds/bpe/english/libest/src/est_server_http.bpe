▁static ▁pthread _ t ▁pthread _ self ▁( void ) ▁{ ▁return ▁GetCurrent Th read Id (); ▁} ▁const ▁void * ▁mg _ get _ conn _ ssl ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁return ▁conn ▁? ▁conn -> ssl ▁: ▁NULL ; ▁} ▁static ▁void ▁sockaddr _ to _ string ▁( char ▁* buf , ▁size _ t ▁len , ▁const ▁un ion ▁us a ▁* usa ) ▁{ ▁buf [0 ] ▁= ▁'\0'; ▁# if ▁defined ( US E _ IP V 6 ) ▁in et _ ntop ( usa -> sa . sa _ family , ▁us a -> sa . sa _ family ▁== ▁AF _ INET ▁? ▁( void *)& usa -> sin . sin _ addr ▁: ▁( void *)& usa -> sin 6 . sin 6 _ addr , ▁buf , ▁( sock len _ t ) ▁len ); ▁# el if ▁defined ( _ W IN 32 ) ▁// ▁Only ▁W in d oz e ▁V is ta ▁( and ▁new er ) ▁have ▁in et _ ntop () ▁strncpy _ s ( buf , ▁ MAX _ S RC _ ADDR , ▁in et _ n to a ( usa -> sin . sin _ addr ) , ▁len ); ▁# else ▁in et _ ntop ( usa -> sa . sa _ family , ▁( void *)& usa -> sin . sin _ addr , ▁buf , ▁len ); ▁# endif ▁} ▁// ▁ Print ▁error ▁message ▁to ▁the ▁open ed ▁error ▁log ▁ stream . ▁static ▁void ▁cry ▁( struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁char ▁buf [ MG _ BUF _ LEN ] , ▁src _ addr [ MAX _ S RC _ ADDR ] ; ▁va _ list ▁ap ; ▁time _ t ▁timestamp ; ▁va _ start ( ap , ▁fmt ); ▁( void ) vsnprintf ( buf , ▁sizeof ( buf ) , ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁// ▁Do ▁not ▁ lock ▁when ▁ getting ▁the ▁callback ▁value , ▁here ▁and ▁below . ▁// ▁I ▁ su p pos e ▁this ▁is ▁fine , ▁since ▁function ▁cannot ▁dis app e ar ▁in ▁the ▁// ▁same ▁way ▁string ▁option ▁can . ▁conn -> request _ info . ev _ data ▁= ▁buf ; ▁timestamp ▁= ▁time ( NULL ); ▁sockaddr _ to _ string ( src _ addr , ▁sizeof ( src _ addr ) , ▁& conn -> client . rsa ); ▁EST _ LOG _ ERR ("[ % 0 10 lu ] ▁[ error ] ▁[ client ▁% s ] ▁" , ▁( un signed ▁long ) timestamp , ▁src _ addr ); ▁if ▁( conn -> request _ info . request _ method ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ ERR ("% s ▁% s : ▁" , ▁conn -> request _ info . request _ method , ▁conn -> request _ info . uri ); ▁} ▁EST _ LOG _ ERR ("% s ", ▁buf ); ▁conn -> request _ info . ev _ data ▁= ▁NULL ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁static ▁struct ▁mg _ connection ▁* fc ▁( struct ▁mg _ context ▁* ctx ) ▁{ ▁static ▁struct ▁mg _ connection ▁fake _ connection ; ▁fake _ connection . ctx ▁= ▁ctx ; ▁return ▁& f ake _ connection ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁const ▁char ▁* mg _ version ▁( void ) ▁{ ▁return ▁ MO NG O OSE _ VERSION ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁struct ▁mg _ request _ info ▁* mg _ get _ request _ info ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁return ▁& conn -> request _ info ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁void ▁mg _ strlcpy ▁( re g is ter ▁char ▁* dst , ▁register ▁const ▁char ▁* src , ▁size _ t ▁n ) ▁{ ▁for ▁( ; ▁* src ▁ != ▁'\0' ▁&& ▁n ▁> ▁1; ▁n -- ) ▁{ ▁* dst ++ ▁= ▁* src ++; ▁} ▁* dst ▁= ▁'\0'; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁char ▁* ▁mg _ str n dup ( const ▁char ▁* ptr , ▁size _ t ▁len ) ▁{ ▁char ▁* p ; ▁if ▁( ( p ▁= ▁( char ▁* ) malloc ( len ▁+ ▁1)) ▁ != ▁NULL ) ▁{ ▁mg _ strlcpy ( p , ▁ptr , ▁len ▁+ ▁1); ▁} ▁return ▁p ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁static ▁int ▁lowercase ▁( const ▁char ▁* s ) ▁{ ▁return ▁to lower (*( const ▁un signed ▁char *) s ); ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁static ▁int ▁mg _ strncasecmp ▁( const ▁char ▁* s 1, ▁const ▁char ▁* s 2 , ▁size _ t ▁len ) ▁{ ▁int ▁diff ▁= ▁0; ▁if ▁( len ▁> ▁0) ▁{ ▁do ▁{ ▁diff ▁= ▁lowercase ( s 1 ++) ▁- ▁lowercase ( s 2 ++ ); ▁} ▁while ▁( diff ▁== ▁0 ▁&& ▁ s 1 [ -1 ] ▁ != ▁'\0' ▁&& ▁-- len ▁> ▁0); ▁} ▁return ▁diff ; ▁} ▁// ▁is ▁not ▁applicable ▁at ▁the ▁moment ▁of ▁logging . ▁static ▁int ▁mg _ strcasecmp ▁( const ▁char ▁* s 1, ▁const ▁char ▁* s 2) ▁{ ▁int ▁diff ; ▁do ▁{ ▁diff ▁= ▁lowercase ( s 1 ++) ▁- ▁lowercase ( s 2 ++ ); ▁} ▁while ▁( diff ▁== ▁0 ▁&& ▁ s 1 [ -1 ] ▁ != ▁'\0') ; ▁return ▁diff ; ▁} ▁// ▁in ▁his ▁a ud it ▁report . ▁static ▁int ▁mg _ vsnprintf ▁( struct ▁mg _ connection ▁* conn , ▁char ▁* buf , ▁size _ t ▁buflen , ▁const ▁char ▁* fmt , ▁va _ list ▁ap ) ▁{ ▁int ▁n ; ▁if ▁( buf len ▁== ▁0) ▁{ ▁return ▁0; ▁} ▁n ▁= ▁vsnprintf ( buf , ▁buflen , ▁fmt , ▁ap ); ▁if ▁( n ▁< ▁0) ▁{ ▁cry ( conn , ▁" vsnprintf ▁error "); ▁n ▁= ▁0; ▁} ▁else ▁if ▁( n ▁>= ▁( int ) buf len ) ▁{ ▁cry ( conn , ▁" tr un cat ing ▁vsnprintf ▁buffer : ▁[ % .* s ] ", ▁n ▁> ▁200 ▁? ▁200 ▁: ▁n , ▁buf ); ▁n ▁= ▁( int ) buf len ▁- ▁1; ▁} ▁buf [ n ] ▁= ▁'\0'; ▁return ▁n ; ▁} ▁// PRINT F _ ARG S ( 4, ▁5 ); ▁static ▁int ▁mg _ snprintf ▁( struct ▁mg _ connection ▁* conn , ▁char ▁* buf , ▁size _ t ▁buflen , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁va _ list ▁ap ; ▁int ▁n ; ▁va _ start ( ap , ▁fmt ); ▁n ▁= ▁mg _ vsnprintf ( conn , ▁buf , ▁buflen , ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁return ▁n ; ▁} ▁// PRINT F _ ARG S ( 4, ▁5 ); ▁static ▁size _ t ▁est _ strcspn ( const ▁char ▁* ▁str 1, const ▁char ▁* ▁str 2 ){ ▁r size _ t ▁count ; ▁errno _ t ▁safe c _ rc ; ▁if ▁( ( str 1 ▁ != ▁NULL ) ▁&& ▁( str 1 [0 ] ▁== ▁'\0') ) ▁{ ▁return ▁0; ▁} ▁safe c _ rc ▁= ▁ strcspn _ s ( str 1, ▁ strnlen _ s ( str 1, ▁R SIZE _ MAX _ STR ) , ▁str 2 , ▁R SIZE _ MAX _ STR , ▁& count ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strcspn _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁return ▁0; ▁} ▁return ▁count ; ▁} ▁// PRINT F _ ARG S ( 4, ▁5 ); ▁static ▁size _ t ▁est _ strspn ( const ▁char ▁* ▁str 1, const ▁char ▁* ▁str 2) ▁{ ▁r size _ t ▁count ; ▁errno _ t ▁safe c _ rc ; ▁if ▁( ( str 1 ▁ != ▁NULL ) ▁&& ▁( str 1 [0 ] ▁== ▁'\0') ) ▁{ ▁return ▁0; ▁} ▁safe c _ rc ▁= ▁ strspn _ s ( str 1, ▁ strnlen _ s ( str 1, ▁R SIZE _ MAX _ STR ) , ▁str 2 , ▁R SIZE _ MAX _ STR , ▁& count ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" strspn _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁return ▁0; ▁} ▁return ▁count ; ▁} ▁// ▁ Del im i ters ▁can ▁be ▁ quoted ▁with ▁quotechar . ▁char ▁* s kip _ quoted ▁( char ▁** buf , ▁const ▁char ▁* delimiters , ▁const ▁char ▁* whitespace , ▁char ▁quotechar ) ▁{ ▁char ▁* p , ▁* b eg in _ word , ▁* end _ word , ▁* end _ whitespace ; ▁begin _ word ▁= ▁* buf ; ▁end _ word ▁= ▁begin _ word ▁+ ▁est _ strcspn ( b eg in _ word , delimiters ); ▁// ▁Check ▁for ▁quotechar ▁if ▁( end _ word ▁> ▁begin _ word ) ▁{ ▁p ▁= ▁end _ word ▁- ▁1; ▁while ▁(* p ▁== ▁quotechar ) ▁{ ▁// ▁If ▁there ▁is ▁anything ▁be y ond ▁end _ word , ▁copy ▁it ▁if ▁(* end _ word ▁== ▁'\0') ▁{ ▁* p ▁= ▁'\0'; ▁break ; ▁} ▁else ▁{ ▁r size _ t ▁end _ off ▁= ▁( r size _ t ) ▁est _ strcspn ( end _ word ▁+ ▁1, ▁delimiters ); ▁ memmove _ s ( p , ▁end _ off ▁+ ▁1, ▁end _ word , ▁end _ off ▁+ ▁1); ▁p ▁+= ▁end _ off ; ▁// ▁p ▁must ▁correspond ▁to ▁end _ word ▁- ▁1 ▁end _ word ▁+= ▁end _ off ▁+ ▁1; ▁} ▁} ▁for ▁( p ++; ▁p ▁< ▁end _ word ; ▁p ++) ▁{ ▁* p ▁= ▁'\0'; ▁} ▁} ▁if ▁(* end _ word ▁== ▁'\0') ▁{ ▁* buf ▁= ▁end _ word ; ▁} ▁else ▁{ ▁end _ whitespace ▁= ▁end _ word ▁+ ▁1 ▁+ ▁est _ strspn ( end _ word ▁+ ▁1, ▁ whitespace ); ▁for ▁( p ▁= ▁end _ word ; ▁p ▁< ▁end _ whitespace ; ▁p ++) ▁{ ▁* p ▁= ▁'\0'; ▁} ▁* buf ▁= ▁end _ whitespace ; ▁} ▁return ▁begin _ word ; ▁} ▁// ▁and ▁ whitespace ▁== ▁delimiters ▁char ▁* s kip ▁( char ▁** buf , ▁const ▁char ▁* delimiters ) ▁{ ▁return ▁skip _ quoted ( buf , ▁delimiters , ▁delimiters , ▁0); ▁} ▁// ▁Return ▁HTTP ▁header ▁value , ▁or ▁NULL ▁if ▁not ▁found . ▁static ▁const ▁char ▁* get _ header ▁( const ▁struct ▁mg _ request _ info ▁* ri , ▁const ▁char ▁* name ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁ri -> num _ headers ; ▁i ++) ▁{ ▁if ▁(! mg _ strcasecmp ( name , ▁ri -> http _ headers [ i ] . name )) ▁{ ▁return ▁ri -> http _ headers [ i ] . value ; ▁} ▁} ▁return ▁NULL ; ▁} ▁// ▁Return ▁HTTP ▁header ▁value , ▁or ▁NULL ▁if ▁not ▁found . ▁const ▁char ▁* mg _ get _ header ▁( const ▁struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* name ) ▁{ ▁return ▁get _ header (& conn -> request _ info , ▁name ); ▁} ▁// ▁set ▁up , ▁for ▁example ▁if ▁request ▁parsing ▁failed . ▁static ▁int ▁should _ keep _ alive ▁( const ▁struct ▁mg _ connection ▁* conn ) ▁{ ▁const ▁char ▁* http _ version ▁= ▁conn -> request _ info . http _ version ; ▁const ▁char ▁* header ▁= ▁mg _ get _ header ( conn , ▁" Connection "); ▁/* ▁* ▁S light ▁devi ation ▁from ▁Mon g oose ▁behavio r ▁here . ▁We ▁will ▁close ▁the ▁* ▁connection ▁when ▁send ing ▁a ▁202 ▁Accepted ▁response . ▁We ▁will ▁also ▁* ▁close ▁the ▁connection ▁for ▁any ▁4 xx ▁response , ▁where ▁Mon g oose ▁was ▁only ▁* ▁cl o s ing ▁for ▁the ▁401 ▁U nauthorized ▁*/ ▁if ▁( conn -> must _ close ▁|| ▁conn -> status _ code ▁== ▁EST _ HTTP _ STAT _ 20 2 ▁|| ▁conn -> status _ code ▁>= ▁400 ▁|| ▁! conn -> ctx -> enable _ keepalives ▁|| ▁( header ▁ != ▁NULL ▁&& ▁mg _ strcasecmp ( header , ▁" keep - alive ") ▁ != ▁0) ▁|| ▁( header ▁== ▁NULL ▁&& ▁http _ version ▁&& ▁strnc mp ( http _ version , ▁" 1 . 1", ▁ 3)) ) ▁{ ▁return ▁0; ▁} ▁return ▁1; ▁} ▁// ▁set ▁up , ▁for ▁example ▁if ▁request ▁parsing ▁failed . ▁static ▁const ▁char ▁* suggest _ connection _ header ▁( const ▁struct ▁mg _ connection ▁* conn ) ▁{ ▁return ▁should _ keep _ alive ( conn ) ▁? ▁" keep - alive " ▁: ▁" close "; ▁} ▁// ▁set ▁up , ▁for ▁example ▁if ▁request ▁parsing ▁failed . ▁void ▁mg _ send _ http _ error ▁( struct ▁mg _ connection ▁* conn , ▁int ▁status , ▁const ▁char ▁* reason , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁char ▁buf [ MG _ BUF _ LEN ] ; ▁va _ list ▁ap ; ▁int ▁len ; ▁conn -> status _ code ▁= ▁status ; ▁conn -> request _ info . ev _ data ▁= ▁( void *) ( long ) status ; ▁buf [0 ] ▁= ▁'\0'; ▁len ▁= ▁0; ▁// ▁Errors ▁1 xx , ▁204 ▁and ▁30 4 ▁MUST ▁NOT ▁send ▁a ▁body ▁if ▁( status ▁> ▁199 ▁&& ▁status ▁ != ▁204 ▁&& ▁status ▁ != ▁30 4 ) ▁{ ▁len ▁= ▁mg _ snprintf ( conn , ▁buf , ▁sizeof ( buf ) , ▁" Error ▁% d : ▁% s ", ▁status , ▁reason ); ▁buf [ len ++ ] ▁= ▁'\ n '; ▁va _ start ( ap , ▁fmt ); ▁len ▁+= ▁mg _ vsnprintf ( conn , ▁buf ▁+ ▁len , ▁sizeof ( buf ) ▁- ▁len , ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁} ▁EST _ LOG _ INFO ("[ % s ] ", ▁buf ); ▁mg _ printf ( conn , ▁" HTTP /1.1 ▁% d ▁% s \ r \ n " ▁" Content - Length : ▁% d \ r \ n " ▁" Connection : ▁% s \ r \ n \ r \ n ", ▁status , ▁reason , ▁len , ▁ suggest _ connection _ header ( conn )); ▁conn -> num _ bytes _ sent ▁+= ▁mg _ printf ( conn , ▁"% s ", ▁buf ); ▁} ▁// ▁For ▁Windows , ▁change ▁all ▁ slashes ▁to ▁ backslashes ▁in ▁path ▁names . ▁static ▁void ▁change _ slashes _ to _ backslashes ▁( char ▁* path ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁path [ i ] ▁ != ▁'\0'; ▁i ++) ▁{ ▁if ▁( path [ i ] ▁== ▁'/' ) ▁{ ▁path [ i ] ▁= ▁'\\' ; ▁} ▁// ▁i ▁> ▁0 ▁check ▁is ▁to ▁preserve ▁U NC ▁path s , ▁like ▁ \\ server \ file . txt ▁if ▁( path [ i ] ▁== ▁'\\' ▁&& ▁i ▁> ▁0) ▁{ ▁while ▁( path [ i ▁+ ▁1 ] ▁== ▁'\\' ▁|| ▁path [ i ▁+ ▁1 ] ▁== ▁'/' ) ▁{ ▁( void ) memmove _ s ( path ▁+ ▁i ▁+ ▁1, ▁EST _ URI _ MAX _ LEN , ▁path ▁+ ▁i ▁+ ▁2 , ▁ strnlen _ s ( path ▁+ ▁i ▁+ ▁1, ▁EST _ URI _ MAX _ LEN )); ▁} ▁} ▁} ▁} ▁// ▁wbuf ▁and ▁wbuf _ len ▁is ▁a ▁ target ▁buffer ▁and ▁its ▁length . ▁static ▁void ▁to _ unicode ▁( const ▁char ▁* path , ▁w char _ t ▁* wbuf , ▁size _ t ▁wbuf _ len ) ▁{ ▁char ▁buf [ P ATH _ MAX ] , ▁buf 2 [ P ATH _ MAX ] , ▁* p ; ▁mg _ strlcpy ( buf , ▁path , ▁sizeof ( buf )); ▁change _ slashes _ to _ backslashes ( buf ); ▁// ▁P o int ▁p ▁to ▁the ▁end ▁of ▁the ▁file ▁name ▁p ▁= ▁buf ▁+ ▁ strnlen _ s ( buf , ▁EST _ URI _ MAX _ LEN ) ▁- ▁1; ▁// ▁Convert ▁to ▁Un i code ▁and ▁back . ▁If ▁do u b ly - convert ed ▁string ▁does ▁not ▁// ▁match ▁the ▁original , ▁something ▁is ▁f is h y , ▁reject . ▁mem zero _ s ( wbuf , ▁wbuf _ len ▁* ▁sizeof ( w char _ t )); ▁M ul ti By te To W id e C h ar ( CP _ UTF 8, ▁0, ▁buf , ▁-1, ▁wbuf , ▁( int ) wbuf _ len ); ▁W id e C h ar To M ul ti By te ( CP _ UTF 8, ▁0, ▁wbuf , ▁( int ) wbuf _ len , ▁buf 2 , ▁sizeof ( buf 2) , ▁NULL , ▁NULL ); ▁if ▁( strcmp ( buf , ▁buf 2) ▁ != ▁0) ▁{ ▁wbuf [0 ] ▁= ▁L ' \ 0 '; ▁} ▁} ▁// ▁This ▁function ▁return s ▁non - 0 ▁if ▁path ▁end s ▁with ▁some ▁garbage . ▁static ▁int ▁path _ c annot _ d is close _ c g i ▁( const ▁char ▁* path ) ▁{ ▁static ▁const ▁char ▁* allow ed _ last _ char a c ters ▁= ▁" _ - "; ▁int ▁last ▁= ▁path [ strnlen _ s ( path , ▁EST _ URI _ MAX _ LEN ) ▁- ▁1 ] ; ▁return ▁is al num ( last ) ▁|| ▁str chr ( allow ed _ last _ char a c ters , ▁last ) ▁ != ▁NULL ; ▁} ▁// ▁This ▁function ▁return s ▁non - 0 ▁if ▁path ▁end s ▁with ▁some ▁garbage . ▁static ▁ HANDLE ▁ dl open ▁( const ▁char ▁* dll _ name , ▁int ▁flags ) ▁{ ▁w char _ t ▁wbuf [ P ATH _ MAX ] ; ▁flags ▁= ▁0; ▁// ▁Un us ed ▁to _ unicode ( dll _ name , ▁wbuf , ▁A R RA Y _ SIZE ( wbuf )); ▁return ▁Load L i br ary W ( wbuf ); ▁} ▁// ▁descriptor . ▁Return ▁number ▁of ▁bytes ▁written . ▁static ▁int 64_ t ▁ push ▁( FILE ▁* fp , ▁ SOCKET ▁sock , ▁SSL ▁* ssl , ▁const ▁char ▁* buf , ▁int 64_ t ▁len ) ▁{ ▁int 64_ t ▁sent ; ▁int ▁n , ▁k ; ▁sent ▁= ▁0; ▁while ▁( sent ▁< ▁len ) ▁{ ▁// ▁How ▁many ▁bytes ▁we ▁send ▁in ▁this ▁it e ration ▁k ▁= ▁len ▁- ▁sent ▁> ▁INT _ MAX ▁? ▁INT _ MAX ▁: ▁( int ) ( len ▁- ▁sent ); ▁if ▁( ssl ▁ != ▁NULL ) ▁{ ▁n ▁= ▁SSL _ write ( ssl , ▁buf ▁+ ▁sent , ▁k ); ▁} ▁else ▁if ▁( fp ▁ != ▁NULL ) ▁{ ▁n ▁= ▁( int ) f write ( buf ▁+ ▁sent , ▁1, ▁( size _ t ) k , ▁ fp ); ▁if ▁( f error ( fp )) ▁{ ▁n ▁= ▁-1; ▁} ▁} ▁else ▁{ ▁n ▁= ▁( int ) ▁send ( sock , ▁buf ▁+ ▁sent , ▁( size _ t ) k , ▁M SG _ NOSIGNAL ); ▁} ▁if ▁( n ▁< ▁0) ▁{ ▁break ; ▁} ▁sent ▁+= ▁n ; ▁} ▁return ▁sent ; ▁} ▁// ▁reading , ▁must ▁give ▁up ▁and ▁close ▁the ▁connection ▁and ▁exit ▁ se rv ing ▁thread . ▁static ▁int ▁wait _ until _ socket _ is _ readable ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁struct ▁poll fd ▁pfd ; ▁int ▁result ; ▁int ▁time s _ up ▁= ▁0; ▁EST _ U INT ▁total _ wait _ time ▁= ▁0; ▁EST _ U INT ▁read _ timeout ▁= ▁conn -> read _ timeout ▁* ▁1000; ▁do ▁{ ▁/* ▁acc u ml ate ▁the ▁total ▁amount ▁of ▁time ▁wait ed ▁*/ ▁total _ wait _ time ▁+= ▁M SEC _ P OL L _ WA IT _ TIME ; ▁pfd . fd ▁= ▁conn -> client . sock ; ▁pfd . events ▁= ▁POLL IN ; ▁pfd . revent s ▁= ▁0; ▁errno ▁= ▁0; ▁result ▁= ▁POLL (& p fd , ▁1, ▁M SEC _ P OL L _ WA IT _ TIME ); ▁if ▁( result ▁== ▁0 ▁&& ▁conn -> ssl ▁ != ▁NULL ) ▁{ ▁result ▁= ▁SSL _ p ending ( conn -> ssl ); ▁} ▁/* ▁* ▁check ▁to ▁see ▁if ▁it ' s ▁time ▁to ▁give ▁up . ▁If ▁it ▁is , ▁set ▁* ▁thing s ▁according ly ▁to ▁close ▁the ▁session ▁down ▁*/ ▁if ▁( ( total _ wait _ time ▁> ▁read _ timeout ) ▁&& ▁result ▁== ▁0) ▁{ ▁time s _ up ▁= ▁1; ▁conn -> must _ close ▁= ▁1; ▁result ▁= ▁-1; ▁} ▁/* ▁* ▁ Continue ▁waiting , ▁* ▁- ▁while ▁there ' s ▁nothing ▁to ▁read ▁from ▁the ▁socket ▁or ▁* ▁the ▁poll ▁was ▁int err up t ed ▁by ▁a ▁signal ▁AND ▁* ▁- ▁the ▁ma s ter ▁process ▁has ▁not ▁indicated ▁to ▁stop ▁AND ▁* ▁- ▁the ▁waiting ▁for ▁read ▁timeout ▁has ▁not ▁occurred ▁*/ ▁} ▁while ▁( ( result ▁== ▁0 ▁|| ▁( result ▁< ▁0 ▁&& ▁ERRNO ▁== ▁E INT R )) ▁&& ▁conn -> ctx -> stop _ flag ▁== ▁0 ▁&& ▁! time s _ up ); ▁return ▁conn -> ctx -> stop _ flag ▁|| ▁result ▁< ▁0 ▁? ▁0 ▁: ▁1; ▁} ▁// ▁Return ▁negative ▁value ▁on ▁error , ▁or ▁number ▁of ▁bytes ▁read ▁on ▁success . ▁static ▁int ▁pull ▁( FILE ▁* fp , ▁struct ▁mg _ connection ▁* conn , ▁char ▁* buf , ▁int ▁len ) ▁{ ▁int ▁nread ; ▁int ▁err _ c d ; ▁if ▁( fp ▁ != ▁NULL ) ▁{ ▁// ▁Use ▁read () ▁instead ▁of ▁f read (), ▁because ▁if ▁we ' re ▁reading ▁from ▁the ▁C GI ▁// ▁p ip e , ▁f read () ▁ma y ▁block ▁ until ▁ IO ▁buffer ▁is ▁filled ▁up . ▁We ▁cannot ▁afford ▁// ▁to ▁block ▁and ▁must ▁pass ▁all ▁read ▁bytes ▁ im mediate ly ▁to ▁the ▁client . ▁nread ▁= ▁( int ) ▁read ( file no ( fp ) , ▁buf , ▁( size _ t ) len ); ▁} ▁else ▁if ▁(! conn -> must _ close ▁&& ▁! wait _ until _ socket _ is _ readable ( conn )) ▁{ ▁nread ▁= ▁-1; ▁} ▁else ▁if ▁( conn -> ssl ▁ != ▁NULL ) ▁{ ▁nread ▁= ▁SSL _ read ( conn -> ssl , ▁buf , ▁len ); ▁err _ c d ▁= ▁SSL _ get _ error ( conn -> ssl ▁ , nread ); ▁switch ( err _ c d ) ▁{ ▁case ▁SSL _ ERROR _ NONE : ▁/* ▁No th ing ▁to ▁do , ▁it ' s ▁a ▁ g race f ul ▁shutdown ▁*/ ▁break ; ▁case ▁SSL _ ERROR _ WA NT _ READ : ▁/* ▁* ▁Mo re ▁data ▁ma y ▁be ▁coming , ▁change ▁nread ▁to ▁zero ▁* ▁so ▁Mon g oose ▁will ▁attempt ▁to ▁read ▁more ▁data ▁* ▁from ▁the ▁peer . ▁This ▁woul d ▁occur ▁if ▁the ▁peer ▁* ▁initiate d ▁an ▁SSL ▁re n e go t ation . ▁*/ ▁nread ▁= ▁0; ▁break ; ▁case ▁SSL _ ERROR _ WA NT _ X 509_ LO OK UP : ▁EST _ LOG _ ERR (" SSL _ read ▁error , ▁wants ▁lookup \ n "); ▁break ; ▁default : ▁/* ▁* ▁For ▁all ▁other ▁error s , ▁simpl y ▁log ▁the ▁error ▁* ▁and ▁make ▁sure ▁nread ▁is ▁-1 ▁to ▁indicate ▁an ▁* ▁error ▁to ▁the ▁function ▁above ▁us . ▁*/ ▁EST _ LOG _ ERR (" SSL _ read ▁error , ▁code : ▁% d \ n ", ▁err _ c d ); ▁nread ▁= ▁-1; ▁break ; ▁} ▁} ▁else ▁{ ▁nread ▁= ▁( int ) ▁ recv ( conn -> client . sock , ▁buf , ▁( size _ t ) len , ▁0); ▁} ▁return ▁conn -> ctx -> stop _ flag ▁? ▁-1 ▁: ▁nread ; ▁} ▁// ▁Return ▁negative ▁value ▁on ▁error , ▁or ▁number ▁of ▁bytes ▁read ▁on ▁success . ▁int ▁mg _ read ▁( struct ▁mg _ connection ▁* conn , ▁void ▁* buf , ▁size _ t ▁len ) ▁{ ▁int ▁n , ▁buffered _ len , ▁nread ; ▁const ▁char ▁* body ; ▁r size _ t ▁max _ len ; ▁nread ▁= ▁0; ▁max _ len ▁= ▁( r size _ t ) ▁len ; ▁if ▁( conn -> con sumed _ content ▁< ▁conn -> content _ len ) ▁{ ▁// ▁A d just ▁number ▁of ▁bytes ▁to ▁read . ▁int 64_ t ▁to _ read ▁= ▁conn -> content _ len ▁- ▁conn -> con sumed _ content ; ▁if ▁( to _ read ▁< ▁( int 64_ t ) len ) ▁{ ▁len ▁= ▁( size _ t ) to _ read ; ▁} ▁// ▁Return ▁buffered ▁data ▁body ▁= ▁conn -> buf ▁+ ▁conn -> request _ len ▁+ ▁conn -> con sumed _ content ; ▁buffered _ len ▁= ▁( int ) ▁ (& conn -> buf [ conn -> data _ len ] ▁- ▁body ); ▁if ▁( buffered _ len ▁> ▁0) ▁{ ▁if ▁( len ▁< ▁( size _ t ) buffered _ len ) ▁{ ▁buffered _ len ▁= ▁( int ) len ; ▁} ▁memcpy _ s ( buf , ▁max _ len , ▁body , ▁( r size _ t ) buffered _ len ); ▁len ▁- = ▁buffered _ len ; ▁conn -> con sumed _ content ▁+= ▁buffered _ len ; ▁nread ▁+= ▁buffered _ len ; ▁buf ▁= ▁( char *) buf ▁+ ▁buffered _ len ; ▁} ▁// ▁We ▁have ▁returned ▁all ▁buffered ▁data . ▁ Read ▁new ▁data ▁from ▁the ▁remote ▁socket . ▁while ▁( len ▁> ▁0) ▁{ ▁n ▁= ▁pull ( NULL , ▁conn , ▁( char *) buf , ▁( int ) len ); ▁if ▁( n ▁< ▁0) ▁{ ▁nread ▁= ▁n ; ▁// ▁ Pro p a g ate ▁the ▁error ▁break ; ▁} ▁else ▁if ▁( n ▁> ▁0) ▁{ ▁buf ▁= ▁( char *) buf ▁+ ▁n ; ▁conn -> con sumed _ content ▁+= ▁n ; ▁nread ▁+= ▁n ; ▁len ▁- = ▁n ; ▁} ▁else ▁{ ▁/* ▁n ▁== ▁0 . ▁retry ▁*/ ▁} ▁} ▁} ▁return ▁nread ; ▁} ▁// ▁Return ▁negative ▁value ▁on ▁error , ▁or ▁number ▁of ▁bytes ▁read ▁on ▁success . ▁int ▁mg _ write ▁( struct ▁mg _ connection ▁* conn , ▁const ▁void ▁* buf , ▁size _ t ▁len ) ▁{ ▁int 64_ t ▁total ; ▁total ▁= ▁ push ( NULL , ▁conn -> client . sock , ▁conn -> ssl , ▁( const ▁char *) buf , ▁( int 64_ t ) len ); ▁return ▁( int ) total ; ▁} ▁// ▁Return ▁negative ▁value ▁on ▁error , ▁or ▁number ▁of ▁bytes ▁read ▁on ▁success . ▁int ▁mg _ printf ▁( struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* fmt , ▁...) ▁{ ▁char ▁mem [ MG _ BUF _ LEN ] , ▁* buf ▁= ▁mem ; ▁int ▁len ; ▁va _ list ▁ap ; ▁// ▁ Print ▁in ▁a ▁local ▁buffer ▁first , ▁ h op ing ▁that ▁it ▁is ▁large ▁enough ▁to ▁// ▁hold ▁the ▁who le ▁message ▁va _ start ( ap , ▁fmt ); ▁len ▁= ▁vsnprintf ( mem , ▁sizeof ( mem ) , ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁if ▁( len ▁== ▁0) ▁{ ▁// ▁Do ▁nothing . ▁mg _ printf ( conn , ▁"% s ", ▁" ") ▁was ▁called . ▁} ▁else ▁if ▁( len ▁< ▁0) ▁{ ▁// ▁vsnprintf () ▁error , ▁give ▁up ▁len ▁= ▁-1; ▁cry ( conn , ▁"% s ( % s , ▁...) : ▁vsnprintf () ▁error ", ▁ _ _ func _ _ , ▁fmt ); ▁} ▁else ▁if ▁( len ▁> ▁( int ) sizeof ( mem ) ▁&& ▁( buf ▁= ▁( char *) malloc ( len ▁+ ▁1)) ▁ != ▁NULL ) ▁{ ▁// ▁L o cal ▁buffer ▁is ▁not ▁large ▁enough , ▁allocate ▁big ▁buffer ▁on ▁heap ▁va _ start ( ap , ▁fmt ); ▁vsnprintf ( buf , ▁len ▁+ ▁1, ▁fmt , ▁ap ); ▁va _ end ( ap ); ▁len ▁= ▁mg _ write ( conn , ▁buf , ▁( size _ t ) len ); ▁free ( buf ); ▁} ▁else ▁if ▁( len ▁> ▁( int ) sizeof ( mem )) ▁{ ▁// ▁ Failed ▁to ▁allocate ▁large ▁enough ▁buffer , ▁give ▁up ▁cry ( conn , ▁"% s ( % s , ▁...) : ▁Can ' t ▁allocate ▁% d ▁bytes , ▁not ▁print ing ▁anything ", ▁ _ _ func _ _ , ▁fmt , ▁len ); ▁len ▁= ▁-1; ▁} ▁else ▁{ ▁// ▁Copy ▁to ▁the ▁local ▁buffer ▁succeed ed ▁len ▁= ▁mg _ write ( conn , ▁buf , ▁( size _ t ) len ); ▁} ▁return ▁len ; ▁} ▁// ▁http :// f t p . i cs . u c i . edu / pub / ietf / html / rfc 18 66 . txt ▁static ▁int ▁url _ decode ▁( const ▁char ▁* src , ▁int ▁src _ len , ▁char ▁* dst , ▁int ▁dst _ len , ▁int ▁is _ form _ url _ encoded ) ▁{ ▁int ▁i , ▁j , ▁a , ▁b ; ▁# define ▁ HEX TO I ( x ) ▁( is digit ( x ) ▁? ▁x ▁- ▁ '0' ▁: ▁x ▁- ▁' W ' ) ▁for ▁( i ▁= ▁j ▁= ▁0; ▁i ▁< ▁src _ len ▁&& ▁j ▁< ▁dst _ len ▁- ▁1; ▁i ++ , ▁j ++) ▁{ ▁if ▁( src [ i ] ▁== ▁'% ' ▁&& ▁is x digit (*( const ▁un signed ▁char *) ( src ▁+ ▁i ▁+ ▁1)) ▁&& ▁is x digit (*( const ▁un signed ▁char *) ( src ▁+ ▁i ▁+ ▁2))) ▁{ ▁a ▁= ▁to lower (*( const ▁un signed ▁char *) ( src ▁+ ▁i ▁+ ▁1) ); ▁b ▁= ▁to lower (*( const ▁un signed ▁char *) ( src ▁+ ▁i ▁+ ▁2) ); ▁dst [ j ] ▁= ▁( char ) ( ( HEX TO I ( a ) ▁< < ▁4) ▁| ▁ HEX TO I ( b )); ▁i ▁+= ▁2 ; ▁} ▁else ▁if ▁( is _ form _ url _ encoded ▁&& ▁src [ i ] ▁== ▁' + ' ) ▁{ ▁dst [ j ] ▁= ▁' ▁' ; ▁} ▁else ▁{ ▁dst [ j ] ▁= ▁src [ i ] ; ▁} ▁} ▁dst [ j ] ▁= ▁'\0'; ▁// ▁Null - ter min ate ▁the ▁destination ▁return ▁i ▁>= ▁src _ len ▁? ▁j ▁: ▁-1; ▁} ▁// ▁> 0 ▁actual ▁request ▁length , ▁includ ing ▁last ▁\ r \ n \ r \ n ▁static ▁int ▁get _ request _ len ▁( const ▁char ▁* buf , ▁int ▁buflen ) ▁{ ▁const ▁char ▁* s , ▁* e ; ▁int ▁len ▁= ▁0; ▁for ▁( s ▁= ▁buf , ▁e ▁= ▁ s ▁+ ▁buflen ▁- ▁1; ▁len ▁< = ▁0 ▁&& ▁ s ▁< ▁e ; ▁ s ++) ▁{ ▁// ▁Control ▁characters ▁are ▁not ▁allowed ▁but ▁>= 128 ▁is . ▁if ▁(! is print (*( const ▁un signed ▁char *) s ) ▁&& ▁* s ▁ != ▁'\ r ' ▁&& ▁* s ▁ != ▁'\ n ' ▁&& ▁* ( const ▁un signed ▁char *) s ▁< ▁128) ▁{ ▁len ▁= ▁-1; ▁break ; ▁// ▁[ i _ a ] ▁a b or t ▁ scan ▁as ▁soon ▁as ▁one ▁mal form ed ▁character ▁is ▁found ; ▁don ' t ▁let ▁subs equent ▁\ r \ n \ r \ n ▁w in ▁us ▁over ▁any how ▁} ▁else ▁if ▁( s [0 ] ▁== ▁'\ n ' ▁&& ▁ s [1 ] ▁== ▁'\ n ' ) ▁{ ▁len ▁= ▁( int ) ( s ▁- ▁buf ) ▁+ ▁2 ; ▁} ▁else ▁if ▁( s [0 ] ▁== ▁'\ n ' ▁&& ▁& s [1 ] ▁< ▁e ▁&& ▁ s [1 ] ▁== ▁'\ r ' ▁&& ▁ s [2 ] ▁== ▁'\ n ' ) ▁{ ▁len ▁= ▁( int ) ( s ▁- ▁buf ) ▁+ ▁3 ; ▁} ▁} ▁return ▁len ; ▁} ▁// ▁ex c es s ive ▁'/' ▁and ▁'\ ' ▁characters ▁static ▁void ▁remove _ double _ dots _ and _ double _ slashes ▁( char ▁* s ) ▁{ ▁char ▁* p ▁= ▁ s ; ▁while ▁(* s ▁ != ▁'\0') ▁{ ▁* p ++ ▁= ▁* s ++; ▁if ▁( s [ -1 ] ▁== ▁'/' ▁|| ▁ s [ -1 ] ▁== ▁'\\' ) ▁{ ▁// ▁S kip ▁all ▁following ▁ slashes , ▁ backslashes ▁and ▁double - dots ▁while ▁( s [0 ] ▁ != ▁'\0') ▁{ ▁if ▁( s [0 ] ▁== ▁'/' ▁|| ▁ s [0 ] ▁== ▁'\\' ) ▁{ ▁ s ++; ▁} ▁else ▁if ▁( s [0 ] ▁== ▁' . ' ▁&& ▁ s [1 ] ▁== ▁'.') ▁{ ▁ s ▁+= ▁2 ; ▁} ▁else ▁{ ▁break ; ▁} ▁} ▁} ▁} ▁* p ▁= ▁'\0'; ▁} ▁/* ▁* ▁Perform s ▁parsing ▁of ▁HTTP ▁Authentication ▁header ▁from ▁* ▁the ▁client ▁when ▁Basic ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁mg _ parse _ auth _ hdr _ basic ▁( struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* auth _ header , ▁EST _ HTTP _ AUTH _ HDR ▁* ah ) ▁{ ▁char ▁* value , ▁* s ; ▁char ▁* save _ ptr ; ▁char ▁both [ MAX _ UIDPWD *2+2 ] ; ▁/* ▁will ▁contain ▁both ▁UID ▁and ▁ PWD ▁*/ ▁r size _ t ▁len ; ▁char ▁* se p ▁= ▁":" ; ▁int ▁colon _ found ; ▁char ▁* possible _ pw ; ▁ s ▁= ▁( char ▁* ) ▁auth _ header ▁+ ▁6 ; ▁// ▁Go bble ▁initial ▁space s ▁while ▁( is space (*( un signed ▁char *) s )) ▁{ ▁ s ++; ▁} ▁value ▁= ▁ s ; ▁len ▁= ▁est _ base 64_ decode ( value , ▁both , ▁( MAX _ UIDPWD ▁* ▁2 ▁+ ▁2) ); ▁if ▁( len ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" Base 64 ▁decode ▁of ▁HTTP ▁auth ▁header ▁failed , ▁HTTP ▁auth ▁will ▁fail "); ▁return ; ▁} ▁/* ▁* ▁Make ▁sure ▁there ' s ▁a ▁':' ▁in ▁the ▁string ▁*/ ▁colon _ found ▁= ▁ strstr _ s ( both , ▁len , ▁":" , ▁1, ▁& possible _ pw ); ▁if ▁( c ol on _ found ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ WARN (" I nvalid ▁format ▁of ▁Basic ▁HTTP ▁credentials , ▁missing ▁: "); ▁mem zero _ s ( both , ▁( MAX _ UIDPWD *2+2) ); ▁return ; ▁} ▁/* ▁* ▁did ▁it ▁start ▁with ▁a ▁colon , ▁meaning ▁no ▁userid ? ▁*/ ▁if ▁( both [0 ] ▁== ▁':' ) ▁{ ▁if ▁( len ▁> ▁1) ▁{ ▁/* ▁just ▁a ▁password ▁*/ ▁possible _ pw ++; ▁ah -> pwd ▁= ▁STR NDU P ( possible _ pw , ▁ MAX _ UIDPWD ); ▁EST _ LOG _ INFO (" HTTP ▁Authentication ▁header ▁contains ▁only ▁password "); ▁} ▁else ▁{ ▁/* ▁We ▁got ▁ne i ther ▁userid ▁nor ▁password ▁*/ ▁EST _ LOG _ INFO (" HTTP ▁Authentication ▁header ▁contains ▁no ▁userid ▁or ▁password "); ▁mem zero _ s ( both , ▁( MAX _ UIDPWD *2+2) ); ▁return ; ▁} ▁} ▁else ▁{ ▁/* ▁Start ed ▁with ▁a ▁userid , ▁* ▁Parse ▁the ▁username ▁and ▁password , ▁which ▁are ▁separate d ▁by ▁a ▁":" ▁*/ ▁value ▁= ▁str tok _ s ( both , ▁& len , ▁ se p , ▁& save _ ptr ); ▁if ▁( value ) ▁{ ▁ah -> user ▁= ▁STR NDU P ( value , ▁ MAX _ UIDPWD ); ▁ah -> pwd ▁= ▁STR NDU P ( save _ ptr , ▁ MAX _ UIDPWD ); ▁} ▁} ▁ah -> mode ▁= ▁AUTH _ BASIC ; ▁mem zero _ s ( both , ▁( MAX _ UIDPWD *2+2) ); ▁} ▁/* ▁* ▁Perform s ▁parsing ▁of ▁HTTP ▁Authentication ▁header ▁from ▁* ▁the ▁client ▁when ▁Digest ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁mg _ parse _ auth _ hdr _ digest ▁( struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* auth _ header , ▁EST _ HTTP _ AUTH _ HDR ▁* ah ) ▁{ ▁char ▁* name , ▁* value , ▁* s ; ▁char ▁buf [ MAX _ AUTH _ HDR _ LEN ] ; ▁int ▁i ; ▁ah -> mode ▁= ▁AUTH _ DIGEST ; ▁// ▁Make ▁ mo d if i able ▁copy ▁of ▁the ▁auth ▁header ▁strncpy _ s ( buf , ▁ MAX _ AUTH _ HDR _ LEN , ▁auth _ header ▁+ ▁ 7, ▁ MAX _ AUTH _ HDR _ LEN ); ▁ s ▁= ▁buf ; ▁// ▁Parse ▁authorization ▁header ▁while ▁(1) ▁{ ▁// ▁Go bble ▁initial ▁space s ▁while ▁( is space (*( un signed ▁char *) s )) ▁{ ▁ s ++; ▁} ▁name ▁= ▁skip _ quoted (& s , ▁" =" , ▁" ▁" , ▁0); ▁// ▁ Value ▁is ▁e i ther ▁ q u o te - de limited , ▁or ▁end s ▁at ▁first ▁ com m a ▁or ▁space . ▁if ▁( s [0 ] ▁== ▁'\ " ' ) ▁{ ▁ s ++; ▁value ▁= ▁skip _ quoted (& s , ▁ "\" ", ▁" ▁" , ▁'\\' ); ▁if ▁( s [0 ] ▁== ▁ ',' ) ▁{ ▁ s ++; ▁} ▁} ▁else ▁{ ▁value ▁= ▁skip _ quoted (& s , ▁" , ▁" , ▁" ▁" , ▁0); ▁// ▁IE ▁uses ▁ com m a s , ▁ FF ▁uses ▁space s ▁} ▁if ▁(* name ▁== ▁'\0') ▁{ ▁break ; ▁} ▁mem cmp _ s ( name , ▁ 8, ▁" username ", ▁ 8, ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> user ▁= ▁STR NDU P ( value , ▁ MAX _ UIDPWD ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁6 , ▁" cnonce ", ▁6 , ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> cnonce ▁= ▁STR NDU P ( value , ▁ MAX _ NONCE ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁ 8, ▁" response ", ▁ 8, ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> response ▁= ▁STR NDU P ( value , ▁ MAX _ RESPONSE ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁ 3, ▁" uri ", ▁ 3, ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> uri ▁= ▁STR NDU P ( value , ▁ MAX _ REALM ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁ 3, ▁" qop ", ▁ 3, ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> qop ▁= ▁STR NDU P ( value , ▁ MAX _ QOP ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁2 , ▁" nc ", ▁2 , ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> nc ▁= ▁STR NDU P ( value , ▁ MAX _ NC ); ▁continue ; ▁} ▁mem cmp _ s ( name , ▁5 , ▁" nonce ", ▁5 , ▁& i ); ▁if ▁(! i ) ▁{ ▁ah -> nonce ▁= ▁STR NDU P ( value , ▁ MAX _ NONCE ); ▁} ▁} ▁} ▁/* ▁* ▁Perform s ▁parsing ▁of ▁HTTP ▁Authentication ▁header ▁from ▁* ▁the ▁client ▁when ▁Token ( bearer ) ▁authentication ▁is ▁used . ▁*/ ▁static ▁void ▁mg _ parse _ auth _ hdr _ token ▁( struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* auth _ header , ▁EST _ HTTP _ AUTH _ HDR ▁* ah ) ▁{ ▁char ▁* value , ▁* s ; ▁char ▁value _ decoded [ MAX _ AUTH _ TOKEN _ LEN *2 ] ; ▁int ▁len ; ▁ s ▁= ▁( char ▁* ) ▁auth _ header ▁+ ▁( str len ( EST _ B EAR ER _ TOKEN _ STR ) -1 ); ▁// ▁Go bble ▁initial ▁space s ▁while ▁( is space (*( un signed ▁char *) s )) ▁{ ▁ s ++; ▁} ▁value ▁= ▁ s ; ▁mem zero _ s ( value _ decoded , ▁ MAX _ AUTH _ TOKEN _ LEN *2 ); ▁len ▁= ▁est _ base 64_ decode ( value , ▁value _ decoded , ▁( MAX _ AUTH _ TOKEN _ LEN *2 )); ▁if ▁( len ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" Base 64 ▁decode ▁of ▁HTTP ▁auth ▁credentials ▁failed , ▁HTTP ▁auth ▁will ▁fail "); ▁return ; ▁} ▁if ▁(* s ▁ != ▁'\0') ▁{ ▁/* C op y ▁the ▁token ▁into ▁the ▁auth ▁header ▁structure . ▁*/ ▁ah -> auth _ token ▁= ▁STR NDU P ( value _ decoded , ▁ MAX _ AUTH _ TOKEN _ LEN ); ▁ah -> mode ▁= ▁AUTH _ TOKEN ; ▁if ▁( ah -> auth _ token ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁obtain ▁memory ▁for ▁authentication ▁token ▁buffer "); ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Authentication ▁header ▁from ▁client ▁contain ed ▁no ▁Token "); ▁} ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁HTTP ▁Authentication ▁header ▁* ▁from ▁the ▁client . ▁It ▁will ▁fill ▁in ▁the ▁fields ▁on ▁the ▁* ▁EST _ HTTP _ AUTH _ HDR ▁struct , ▁which ▁are ▁used ▁later ▁for ▁* ▁verifying ▁the ▁user ' s ▁credentials ▁using ▁e i ther ▁HTTP ▁* ▁Basic ▁or ▁HTTP ▁Digest ▁authentication . ▁The ▁ah ▁parameter ▁* ▁should ▁already ▁be ▁allocated ▁when ▁call ing ▁this ▁function . ▁* ▁* ▁Return ▁e i ther ▁good , ▁bad , ▁or ▁missing ▁*/ ▁EST _ HTTP _ AUTH _ HDR _ RE S U LT ▁mg _ parse _ auth _ header ▁( struct ▁mg _ connection ▁* conn , ▁EST _ HTTP _ AUTH _ HDR ▁* ah ) ▁{ ▁const ▁char ▁* auth _ header ; ▁/* ▁* ▁Get ▁the ▁Auth ▁header ▁from ▁the ▁HTTP ▁client ▁*/ ▁if ▁( ( auth _ header ▁= ▁mg _ get _ header ( conn , ▁" Authorization ")) ▁== ▁NULL ) ▁{ ▁return ▁EST _ AUTH _ HDR _ MISSING ; ▁} ▁if ▁( mg _ strncasecmp ( auth _ header , ▁" Digest ▁" , ▁7) ▁== ▁0) ▁{ ▁/* ▁Make ▁sure ▁server ▁is ▁configured ▁for ▁digest ▁auth ▁*/ ▁if ▁( conn -> ctx -> est _ ctx -> auth _ mode ▁ != ▁AUTH _ DIGEST ) ▁{ ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁mg _ parse _ auth _ hdr _ digest ( conn , ▁auth _ header , ▁ah ); ▁} ▁else ▁if ▁( mg _ strncasecmp ( auth _ header , ▁" Basic ▁" , ▁6 ) ▁== ▁0) ▁{ ▁/* ▁Make ▁sure ▁server ▁is ▁configured ▁for ▁basic ▁auth ▁*/ ▁if ▁( conn -> ctx -> est _ ctx -> auth _ mode ▁ != ▁AUTH _ BASIC ) ▁{ ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁mg _ parse _ auth _ hdr _ basic ( conn , ▁auth _ header , ▁ah ); ▁} ▁else ▁if ▁( mg _ strncasecmp ( auth _ header , ▁EST _ B EAR ER _ TOKEN _ STR , ▁str len ( EST _ B EAR ER _ TOKEN _ STR )) ▁== ▁0) ▁{ ▁/* ▁Make ▁sure ▁server ▁is ▁configured ▁for ▁bearer ( token ) ▁auth ▁*/ ▁if ▁( conn -> ctx -> est _ ctx -> auth _ mode ▁ != ▁AUTH _ TOKEN ) ▁{ ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁mg _ parse _ auth _ hdr _ token ( conn , ▁auth _ header , ▁ah ); ▁} ▁else ▁{ ▁/* ▁Only ▁Basic , ▁Digest ▁and ▁Bearer ▁Token ▁authentication ▁are ▁supported ▁*/ ▁ah -> mode ▁= ▁AUTH _ FAIL ; ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁/* ▁* ▁If ▁we ' re ▁do ing ▁digest ▁auth , ▁make ▁sure ▁all ▁the ▁values ▁* ▁we re ▁parsed ▁*/ ▁if ▁( ah -> mode ▁== ▁AUTH _ DIGEST ▁&& ▁(! ah -> uri ▁|| ▁! ah -> nonce ▁|| ▁! ah -> nc ▁|| ▁! ah -> cnonce )) ▁{ ▁EST _ LOG _ ERR (" P a rs ing ▁of ▁HTTP ▁auth ▁header ▁failed "); ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁/* ▁If ▁we ▁we re ▁not ▁ able ▁to ▁parse ▁a ▁user ▁ID ▁and ▁we ' re ▁not ▁* ▁in ▁token ▁auth ▁mode , ▁then ▁make ▁sure ▁we ▁fail ▁the ▁authentication . ▁*/ ▁if ▁( ah -> user ▁== ▁NULL ▁&& ▁ah -> mode ▁ != ▁AUTH _ TOKEN ) ▁{ ▁return ▁EST _ AUTH _ HDR _ BAD ; ▁} ▁if ▁( ah -> mode ▁ != ▁AUTH _ TOKEN ) ▁{ ▁/* ▁* ▁ Save ▁the ▁user ▁ID ▁on ▁the ▁connection ▁context . ▁* ▁We ▁will ▁want ▁to ▁pass ▁this ▁to ▁the ▁CA ▁later . ▁*/ ▁strncpy _ s ( conn -> user _ id , ▁ MG _ UID _ MAX , ▁ah -> user , ▁ MG _ UID _ MAX ); ▁} ▁return ▁EST _ AUTH _ HDR _ GOOD ; ▁} ▁/* ▁* ▁This ▁function ▁parse s ▁the ▁HTTP ▁Authentication ▁header ▁* ▁from ▁the ▁client . ▁It ▁will ▁fill ▁in ▁the ▁fields ▁on ▁the ▁* ▁EST _ HTTP _ AUTH _ HDR ▁struct , ▁which ▁are ▁used ▁later ▁for ▁* ▁verifying ▁the ▁user ' s ▁credentials ▁using ▁e i ther ▁HTTP ▁* ▁Basic ▁or ▁HTTP ▁Digest ▁authentication . ▁The ▁ah ▁parameter ▁* ▁should ▁already ▁be ▁allocated ▁when ▁call ing ▁this ▁function . ▁* ▁* ▁Return ▁e i ther ▁good , ▁bad , ▁or ▁missing ▁*/ ▁void ▁mg _ send _ authorization _ request ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁conn -> status _ code ▁= ▁401 ; ▁switch ▁( conn -> ctx -> est _ ctx -> auth _ mode ) ▁{ ▁case ▁AUTH _ BASIC : ▁mg _ printf ( conn , ▁"% s \ r \ n " ▁"% s : ▁0 \ r \ n " ▁"% s : ▁Basic ▁realm =\"% s \"\ r \ n \ r \ n ", ▁EST _ HTTP _ HDR _401, ▁EST _ HTTP _ HDR _ CL , ▁EST _ HTTP _ HDR _ AUTH , ▁conn -> ctx -> est _ ctx -> realm ); ▁break ; ▁case ▁AUTH _ DIGEST : ▁mg _ printf ( conn , ▁"% s \ r \ n " ▁"% s : ▁0 \ r \ n " ▁"% s : ▁Digest ▁qop =\" auth \ ", ▁" ▁" realm =\"% s \ ", ▁nonce =\"% lu \"\ r \ n \ r \ n ", ▁EST _ HTTP _ HDR _401, ▁EST _ HTTP _ HDR _ CL , ▁EST _ HTTP _ HDR _ AUTH , ▁conn -> ctx -> est _ ctx -> realm , ▁( un signed ▁long ) time ( NULL )); ▁break ; ▁case ▁AUTH _ TOKEN : ▁mg _ printf ( conn , ▁"% s \ r \ n " ▁"% s : ▁0 \ r \ n " ▁"% s : ▁Bearer ▁realm =\"% s \"\ r \ n \ r \ n ", ▁EST _ HTTP _ HDR _401, ▁EST _ HTTP _ HDR _ CL , ▁EST _ HTTP _ HDR _ AUTH , ▁conn -> ctx -> est _ ctx -> realm ); ▁break ; ▁case ▁AUTH _ FAIL : ▁case ▁AUTH _ NONE : ▁default : ▁/* ▁These ▁mode s ▁are ▁not ▁valid ▁at ▁this ▁point ▁* ▁nothing ▁to ▁do ▁here . ▁*/ ▁break ; ▁} ▁} ▁// ▁where ▁parsing ▁stop p ed . ▁static ▁void ▁parse _ http _ headers ▁( char ▁** buf , ▁struct ▁mg _ request _ info ▁* ri ) ▁{ ▁int ▁i ; ▁for ▁( i ▁= ▁0; ▁i ▁< ▁( int ) AR RA Y _ SIZE ( ri -> http _ headers ); ▁i ++) ▁{ ▁ri -> http _ headers [ i ] . name ▁= ▁skip _ quoted ( buf , ▁":" , ▁" ▁" , ▁0); ▁ri -> http _ headers [ i ] . value ▁= ▁skip ( buf , ▁"\ r \ n "); ▁if ▁( ri -> http _ headers [ i ] . name [0 ] ▁== ▁'\0') ▁{ ▁break ; ▁} ▁ri -> num _ headers ▁= ▁i ▁+ ▁1; ▁} ▁} ▁// ▁where ▁parsing ▁stop p ed . ▁static ▁int ▁is _ valid _ http _ method ▁( const ▁char ▁* method ) ▁{ ▁/* ▁EST ▁only ▁allow s ▁GET ▁& ▁POST ▁*/ ▁return ▁! strnc mp ( method , ▁" GET ", ▁3) ▁|| ▁! strnc mp ( method , ▁" POST ", ▁4 ); ▁} ▁// ▁HTTP ▁request ▁component s , ▁header ▁names ▁and ▁header ▁values . ▁static ▁int ▁parse _ http _ message ▁( char ▁* buf , ▁int ▁len , ▁struct ▁mg _ request _ info ▁* ri ) ▁{ ▁int ▁request _ length ▁= ▁get _ request _ len ( buf , ▁len ); ▁if ▁( request _ length ▁> ▁0) ▁{ ▁// ▁ Reset ▁attributes . ▁DO ▁NOT ▁ TO UC H ▁is _ ssl , ▁remote _ ip , ▁remote _ port ▁ri -> request _ method ▁= ▁ri -> uri ▁= ▁ri -> http _ version ▁= ▁NULL ; ▁ri -> num _ headers ▁= ▁0; ▁buf [ request _ length ▁- ▁1 ] ▁= ▁'\0'; ▁// ▁RFC ▁say s ▁that ▁all ▁initial ▁ whitespace s ▁should ▁be ▁ ing or ed ▁while ▁(* buf ▁ != ▁'\0' ▁&& ▁is space (*( un signed ▁char *) buf )) ▁{ ▁buf ++; ▁} ▁ri -> request _ method ▁= ▁skip (& buf , ▁" ▁" ); ▁ri -> uri ▁= ▁skip (& buf , ▁" ▁" ); ▁ri -> http _ version ▁= ▁skip (& buf , ▁"\ r \ n "); ▁parse _ http _ headers (& buf , ▁ri ); ▁} ▁EST _ LOG _ INFO (" request _ len =% d ", ▁request _ length ); ▁EST _ LOG _ INFO (" request ▁uri =% s ", ▁ri -> uri ); ▁return ▁request _ length ; ▁} ▁// ▁HTTP ▁request ▁component s , ▁header ▁names ▁and ▁header ▁values . ▁static ▁int ▁parse _ http _ request ▁( char ▁* buf , ▁int ▁len , ▁struct ▁mg _ request _ info ▁* ri ) ▁{ ▁int ▁result ▁= ▁parse _ http _ message ( buf , ▁len , ▁ri ); ▁if ▁( result ▁> ▁0 ▁&& ▁is _ valid _ http _ method ( ri -> request _ method ) ▁&& ▁! strnc mp ( ri -> http _ version , ▁" HTTP / ", ▁ 5)) ▁{ ▁ri -> http _ version ▁+= ▁5 ; ▁// ▁S kip ▁" HTTP / " ▁} ▁else ▁{ ▁result ▁= ▁-1; ▁} ▁return ▁result ; ▁} ▁// ▁Up on ▁every ▁read ▁operation , ▁increase ▁nread ▁by ▁the ▁number ▁of ▁bytes ▁read . ▁static ▁int ▁read _ request ▁( FILE ▁* fp , ▁struct ▁mg _ connection ▁* conn , ▁char ▁* buf , ▁int ▁bufsiz , ▁int ▁* nread ) ▁{ ▁int ▁request _ len , ▁n ▁= ▁1; ▁request _ len ▁= ▁get _ request _ len ( buf , ▁* nread ); ▁while ▁(* nread ▁< ▁bufsiz ▁&& ▁request _ len ▁== ▁0 ▁&& ▁n ▁>= ▁0) ▁{ ▁n ▁= ▁pull ( fp , ▁conn , ▁buf ▁+ ▁* nread , ▁bufsiz ▁- ▁* nread ); ▁if ▁( n ▁> ▁0) ▁{ ▁* nread ▁+= ▁n ; ▁request _ len ▁= ▁get _ request _ len ( buf , ▁* nread ); ▁} ▁} ▁if ▁( n ▁< ▁0) ▁{ ▁// ▁ recv () ▁error ▁ -> ▁propagate ▁error ; ▁do ▁not ▁process ▁a ▁b 0 rke d - with - very - h i g h - pr ob ability ▁request ▁return ▁-1; ▁} ▁return ▁request _ len ; ▁} ▁/* ▁* ▁This ▁function ▁is ▁called ▁by ▁the ▁Mon g oose ▁code ▁when ▁an ▁* ▁incoming ▁HTTP ▁request ▁is ▁processed . ▁* ▁Returns ▁0 ▁on ▁success , ▁non - zero ▁if ▁the ▁request ▁was n ' t ▁* ▁handled . ▁*/ ▁static ▁int ▁est _ mg _ handle r ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁const ▁struct ▁mg _ request _ info ▁* request _ info ▁= ▁mg _ get _ request _ info ( conn ); ▁EST _ CTX ▁* ectx ▁= ▁conn -> ctx -> est _ ctx ; ▁char ▁* body ; ▁int ▁cl ; ▁int ▁est _ rv ▁= ▁EST _ ERR _ NONE ; ▁const ▁char ▁* cl _ hdr ; ▁/* ▁content ▁length ▁ html ▁header ▁*/ ▁const ▁char ▁* ct _ hdr ; ▁/* ▁content ▁type ▁ html ▁header ▁*/ ▁cl _ hdr ▁= ▁mg _ get _ header ( conn , ▁" Content - Length "); ▁if ▁( cl _ hdr ) ▁{ ▁/* ▁* ▁At ▁this ▁point , ▁Content - Length ▁value ▁has ▁already ▁been ▁* ▁error ▁checked ▁and ▁is ▁ gu ar ant e ed ▁to ▁be ▁within ▁the ▁correct ▁* ▁range . ▁ Obtain ▁the ▁length , ▁allocate ▁the ▁buffer ▁for ▁the ▁* ▁body , ▁and ▁read ▁it ▁in . ▁*/ ▁cl ▁= ▁at oi ( cl _ hdr ); ▁body ▁= ▁malloc ( cl +1 ); ▁mg _ read ( conn , ▁body , ▁cl ); ▁/* ▁Make ▁sure ▁the ▁buffer ▁is ▁null ▁terminated ▁*/ ▁body [ cl ] ▁= ▁0 x 0 ; ▁} ▁else ▁{ ▁cl ▁= ▁0; ▁body ▁= ▁NULL ; ▁} ▁ct _ hdr ▁= ▁mg _ get _ header ( conn , ▁" Content - Type "); ▁if ▁( ectx -> est _ mode ▁== ▁EST _ SERVER ) ▁{ ▁est _ rv ▁= ▁est _ http _ request ( ectx , ▁conn , ▁( char *) request _ info -> request _ method , ▁( char *) request _ info -> uri , ▁body , ▁cl , ▁ct _ hdr ); ▁} ▁else ▁if ▁( ectx -> est _ mode ▁== ▁EST _ PROXY ) ▁{ ▁est _ rv ▁= ▁est _ proxy _ http _ request ( ectx , ▁conn , ▁( char *) request _ info -> request _ method , ▁( char *) request _ info -> uri , ▁body , ▁cl , ▁ct _ hdr ); ▁} ▁if ▁( est _ rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" EST ▁error ▁response ▁code : ▁% d ▁(% s ) \ n ", ▁est _ rv , ▁EST _ ERR _ NUM _ TO _ STR ( est _ rv )); ▁} ▁if ▁( cl _ hdr ) ▁{ ▁free ( body ); ▁} ▁return ▁est _ rv ; ▁} ▁// ▁a ▁directory , ▁or ▁call ▁embedd ed ▁function , ▁etc eter a . ▁static ▁void ▁handle _ request ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁struct ▁mg _ request _ info ▁* ri ▁= ▁& conn -> request _ info ; ▁int ▁uri _ len ; ▁int ▁rv ; ▁if ▁( ( conn -> request _ info . query _ string ▁= ▁str chr ( ri -> uri , ▁' ? ' )) ▁ != ▁NULL ) ▁{ ▁* ( ( char *) conn -> request _ info . query _ string ++) ▁= ▁'\0'; ▁} ▁uri _ len ▁= ▁( int ) strnlen _ s ( ri -> uri , ▁EST _ URI _ MAX _ LEN ); ▁url _ decode ( ri -> uri , ▁uri _ len , ▁( char *) ri -> uri , ▁uri _ len ▁+ ▁1, ▁0); ▁remove _ double _ dots _ and _ double _ slashes ( ( char *) ri -> uri ); ▁EST _ LOG _ INFO ("% s ", ▁ri -> uri ); ▁/* ▁* ▁ Process ▁the ▁request ▁*/ ▁rv ▁= ▁est _ mg _ handle r ( conn ); ▁if ▁( EST _ ERR _ NONE ▁ != ▁rv ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁request ▁failed ▁rv =% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁} ▁} ▁// ▁a ▁directory , ▁or ▁call ▁embedd ed ▁function , ▁etc eter a . ▁static ▁void ▁log _ header ▁( const ▁struct ▁mg _ connection ▁* conn , ▁const ▁char ▁* header ) ▁{ ▁const ▁char ▁* header _ value ; ▁if ▁( ( header _ value ▁= ▁mg _ get _ header ( conn , ▁header )) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ INFO ("% s ", ▁" ▁- "); ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" ▁\ " % s \"" , ▁header _ value ); ▁} ▁} ▁// ▁a ▁directory , ▁or ▁call ▁embedd ed ▁function , ▁etc eter a . ▁static ▁void ▁log _ access ▁( const ▁struct ▁mg _ connection ▁* conn ) ▁{ ▁const ▁struct ▁mg _ request _ info ▁* ri ; ▁char ▁date [ 64 ] , ▁src _ addr [20 ] ; ▁str f time ( date , ▁sizeof ( date ) , ▁"% d /% b /% Y :% H :% M :% S ▁% z ", ▁local time (& conn -> birth _ time )); ▁ri ▁= ▁& conn -> request _ info ; ▁sockaddr _ to _ string ( src _ addr , ▁sizeof ( src _ addr ) , ▁& conn -> client . rsa ); ▁EST _ LOG _ INFO ("% s ▁[ % s ] ▁\ " % s ▁% s ▁HTTP /% s \ " ▁% d ▁% " ▁INT 64_ FM T , ▁src _ addr , ▁date , ▁ri -> request _ method ▁? ▁ri -> request _ method ▁: ▁"-" , ▁ri -> uri ▁? ▁ri -> uri ▁: ▁"-" , ▁ri -> http _ version , ▁conn -> status _ code , ▁conn -> num _ bytes _ sent ); ▁log _ header ( conn , ▁" Refer er "); ▁log _ header ( conn , ▁" User - Agent "); ▁} ▁// ▁Return ▁OpenSSL ▁error ▁message ▁static ▁const ▁char ▁* ssl _ error ▁( void ) ▁{ ▁un signed ▁long ▁err ; ▁err ▁= ▁ ERR _ get _ error (); ▁return ▁err ▁== ▁0 ▁? ▁"" ▁: ▁ ERR _ error _ string ( err , ▁NULL ); ▁} ▁// ▁D ynamic ally ▁load ▁SSL ▁library . ▁Set ▁up ▁ctx -> ssl _ ctx ▁pointer . ▁static ▁int ▁set _ ssl _ option ▁( struct ▁mg _ context ▁* ctx ) ▁{ ▁struct ▁mg _ connection ▁* conn ; ▁EST _ CTX ▁* ectx ; ▁SSL _ CTX ▁* ssl _ ctx ; ▁EC _ KEY ▁* ecdh ▁= ▁NULL ; ▁X 509_ VERIFY _ PARAM ▁* vpm ▁= ▁NULL ; ▁char ▁ s ic [1 2 ] ▁= ▁" EST "; ▁if ▁( ( ssl _ ctx ▁= ▁SSL _ CTX _ new ( SSLv 2 3 _ server _ method ())) ▁== ▁NULL ) ▁{ ▁cry ( fc ( ctx ) , ▁" SSL _ CTX _ new ▁( server ) ▁error : ▁% s ", ▁ssl _ error ()); ▁return ▁0; ▁} ▁ctx -> ssl _ ctx ▁= ▁ssl _ ctx ; ▁ectx ▁= ▁ctx -> est _ ctx ; ▁conn ▁= ▁f c ( ctx ); ▁conn -> request _ info . ev _ data ▁= ▁ctx -> ssl _ ctx ; ▁SSL _ CTX _ set _ verify ( ssl _ ctx , ▁SSL _ VERIFY _ PEER , ▁NULL ); ▁/* ▁* ▁Set ▁the ▁Session ▁ID ▁context ▁to ▁enable ▁OpenSSL ▁session ▁* ▁reuse , ▁which ▁improve s ▁performance . ▁We ▁set ▁the ▁ID ▁to ▁* ▁EST xx xxx xxx , ▁where ▁the ▁x ▁values ▁are ▁random ▁numbers ▁*/ ▁if ▁(! R AND _ bytes ( ( un signed ▁char *)& s ic [3 ] , ▁ 8)) ▁{ ▁EST _ LOG _ WARN (" R NG ▁failure ▁while ▁setting ▁S I C : ▁% s ", ▁ssl _ error ()); ▁} ▁SSL _ CTX _ set _ session _ id _ context ( ssl _ ctx , ▁( void *)& s ic , ▁11 ); ▁// ▁load ▁in ▁the ▁CA ▁cert ( s ) ▁used ▁to ▁verify ▁client ▁certificates ▁SSL _ CTX _ set _ cert _ store ( ssl _ ctx , ▁ectx -> trusted _ certs _ store ); ▁// The ▁ssl ▁code ▁will ▁free ▁this ▁store ▁from ▁ssl _ ctx ▁later ▁ectx -> trusted _ certs _ store ▁= ▁NULL ; ▁/* ▁* ▁Note ▁that ▁we ▁disable ▁TLS ▁ticket s , ▁which ▁is ▁another ▁* ▁way ▁to ▁reuse ▁TLS ▁session s ▁to ▁a void ▁all ▁the ▁key ▁exchange ▁* ▁over head ▁of ▁the ▁TLS ▁handshake . ▁We ' ve ▁enabled ▁session ▁* ▁reuse ▁above . ▁ But ▁session ▁reuse ▁will ▁not ▁* ▁work ▁when ▁ticket ▁support ▁is ▁enabled ▁on ▁the ▁server . ▁* ▁We ▁ma y ▁want ▁to ▁look ▁into ▁e n a b l ing ▁ticket s ▁* ▁in ▁the ▁future , ▁but ▁for ▁now ▁the ▁session ▁reuse ▁* ▁above ▁give s ▁us ▁a ▁performance ▁b o o st . ▁* ▁* ▁The ▁other ▁options ▁set ▁here ▁are ▁to ▁improve ▁forward ▁* ▁ se c re c ty ▁and ▁compl y ▁with ▁the ▁EST ▁d ra f t . ▁*/ ▁SSL _ CTX _ set _ option s ( ssl _ ctx , ▁SSL _ OP _ NO _ SSLv 2 ▁| ▁SSL _ OP _ NO _ SSLv 3 ▁| ▁SSL _ OP _ NO _ TLS v 1 ▁| ▁SSL _ OP _ SING LE _ EC D H _ US E ▁| ▁SSL _ OP _ NO _ T I CK E T ); ▁/* ▁* ▁Set ▁the ▁EC D H ▁single ▁use ▁ parms . ▁Use ▁the ▁configured ▁* ▁curve , ▁or ▁use ▁prime 256 v 1 ▁as ▁the ▁default . ▁*/ ▁if ▁( ectx -> ecdhe _ nid ) ▁{ ▁/* ▁Setup ▁the ▁user ▁selected ▁curve ▁*/ ▁ ecdh ▁= ▁EC _ KEY _ new _ by _ curve _ name ( ectx -> ecdhe _ nid ); ▁EST _ LOG _ INFO (" U s ing ▁non - default ▁ ECDHE ▁curve ▁( nid =% d )", ▁ectx -> ecdhe _ nid ); ▁} ▁else ▁{ ▁/* ▁ Default ▁to ▁prime 256 ▁curve ▁*/ ▁ ecdh ▁= ▁EC _ KEY _ new _ by _ curve _ name ( NID _ X 9 _ 62 _ prime 256 v 1); ▁EST _ LOG _ INFO (" U s ing ▁default ▁ ECDHE ▁curve ▁( prime 256 v 1 )"); ▁} ▁if ▁( ecdh ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁generate ▁temp ▁ ecdh ▁parameters \ n "); ▁return ▁0; ▁} ▁SSL _ CTX _ set _ tmp _ ecdh ( ssl _ ctx , ▁ ecdh ); ▁EC _ KEY _ free ( ecdh ); ▁/* ▁* ▁Setup ▁additional ▁cert ▁checks ▁includ ing ▁CRL , ▁ depth ▁* ▁and ▁purpose . ▁*/ ▁ vpm ▁= ▁X 509_ VERIFY _ PARAM _ new (); ▁/* ▁E nable ▁CRL ▁checks ▁*/ ▁if ▁( ectx -> enable _ crl ) ▁{ ▁X 509_ VERIFY _ PARAM _ set _ flags ( vpm , ▁X 509_ V _ FLAG _ CRL _ CHECK ▁| ▁X 509_ V _ FLAG _ CRL _ CHECK _ ALL ); ▁} ▁X 509_ VERIFY _ PARAM _ set _ depth ( vpm , ▁EST _ TLS _ VERIFY _ DEPTH ); ▁/* ▁Note : ▁the ▁purpose ▁is ▁only ▁checked ▁when ▁the ▁key us age ▁* ▁value ▁is ▁present ▁in ▁the ▁client ' s ▁cert ▁*/ ▁X 509_ VERIFY _ PARAM _ set _ purpose ( vpm , ▁X 509_ PURPOSE _ SSL _ CLIENT ); ▁SSL _ CTX _ set 1 _ param ( ssl _ ctx , ▁ vpm ); ▁X 509_ VERIFY _ PARAM _ free ( vpm ); ▁/* ▁* ▁Set ▁the ▁single - use ▁DH ▁parameters ▁if ▁the ▁application ▁* ▁has ▁requested ▁this ▁ca p ability . ▁*/ ▁if ▁( ectx -> dh _ tmp ) ▁{ ▁SSL _ CTX _ set _ option s ( ssl _ ctx , ▁SSL _ OP _ SING LE _ D H _ US E ); ▁SSL _ CTX _ set _ tmp _ dh ( ssl _ ctx , ▁ectx -> dh _ tmp ); ▁DH _ free ( ectx -> dh _ tmp ); ▁ectx -> dh _ tmp ▁= ▁NULL ; ▁} ▁if ▁( ectx -> enable _ srp ) ▁{ ▁EST _ LOG _ INFO (" E n a b l ing ▁TLS ▁SRP ▁mode \ n "); ▁if ▁(! SSL _ CTX _ set _ cipher _ list ( ssl _ ctx , ▁EST _ C IP HER _ LIST _ SRP _ SERVER )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁set ▁SSL ▁cipher ▁suites \ n "); ▁return ▁0; ▁} ▁/* ▁* ▁Set ▁the ▁application ▁specific ▁handler ▁for ▁* ▁provid ing ▁the ▁SRP ▁parameters ▁dur ing ▁user ▁* ▁authentication . ▁*/ ▁SSL _ CTX _ set _ srp _ username _ callback ( ssl _ ctx , ▁ectx -> est _ srp _ username _ cb ); ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS ▁SRP ▁not ▁enabled "); ▁/* ▁* ▁Set ▁the ▁TLS ▁cipher ▁suites ▁that ▁should ▁be ▁allowed . ▁* ▁This ▁disable s ▁ano nymo us ▁and ▁null ▁cipher s ▁*/ ▁if ▁(! SSL _ CTX _ set _ cipher _ list ( ssl _ ctx , ▁EST _ C IP HER _ LIST )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁set ▁SSL ▁cipher ▁suites \ n "); ▁return ▁0; ▁} ▁} ▁if ▁( SSL _ CTX _ use _ certificate ( ssl _ ctx , ▁ectx -> server _ cert ) ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁server ▁certificate "); ▁return ▁0; ▁} ▁if ▁( SSL _ CTX _ use _ PrivateKey ( ssl _ ctx , ▁ectx -> server _ priv _ key ) ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁set ▁server ▁private ▁key "); ▁return ▁0; ▁} ▁/* ▁* ▁There ▁should ▁be ▁no ▁need ▁to ▁include ▁the ▁cert ▁chain ▁for ▁the ▁* ▁server ' s ▁certificate ▁in ▁the ▁TLS ▁Certificate ▁message ▁from ▁* ▁the ▁server . ▁The ▁reason ▁is ▁the ▁EST ▁d ra f t ▁specifie s ▁that ▁* ▁all ▁the ▁sub ordin ate ▁CA ▁certs ▁should ▁be ▁included ▁in ▁the ▁* ▁cacerts ▁message ▁flow . ▁He nc e , ▁the ▁client ▁will ▁already ▁have ▁* ▁the ▁full ▁cert ▁chain . ▁The r for e , ▁the ▁TLS ▁handshake ▁will ▁only ▁* ▁contain ▁the ▁server ' s ▁cert , ▁not ▁the ▁full ▁chain . ▁* ▁SSL _ CTX _ use _ certificate _ chain _ file ( ctx -> ssl _ ctx , ▁ctx -> est _ ctx -> http _ cert _ file ); ▁*/ ▁return ▁1; ▁} ▁// ▁D ynamic ally ▁load ▁SSL ▁library . ▁Set ▁up ▁ctx -> ssl _ ctx ▁pointer . ▁static ▁void ▁reset _ per _ request _ attributes ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁conn -> path _ info ▁= ▁conn -> request _ info . ev _ data ▁= ▁NULL ; ▁conn -> num _ bytes _ sent ▁= ▁conn -> con sumed _ content ▁= ▁0; ▁conn -> status _ code ▁= ▁-1; ▁conn -> must _ close ▁= ▁conn -> request _ len ▁= ▁0; ▁} ▁// ▁D ynamic ally ▁load ▁SSL ▁library . ▁Set ▁up ▁ctx -> ssl _ ctx ▁pointer . ▁static ▁int ▁is _ valid _ uri ▁( const ▁char ▁* uri ) ▁{ ▁// ▁Con form ▁to ▁http :// w ww . w 3 . org / Pro to c ol s / rfc 2616 / rfc 2616 - se c 5 . html # se c 5 . 1 . 2 ▁// ▁URI ▁can ▁be ▁an ▁as te risk ▁( *) ▁or ▁should ▁start ▁with ▁ s la sh . ▁return ▁uri [0 ] ▁== ▁'/' ▁|| ▁( uri [0 ] ▁== ▁' * ' ▁&& ▁uri [1 ] ▁== ▁'\0') ; ▁} ▁// ▁D ynamic ally ▁load ▁SSL ▁library . ▁Set ▁up ▁ctx -> ssl _ ctx ▁pointer . ▁static ▁void ▁process _ new _ connection ▁( struct ▁mg _ connection ▁* conn ) ▁{ ▁struct ▁mg _ request _ info ▁* ri ▁= ▁& conn -> request _ info ; ▁int ▁keep _ alive _ enabled , ▁keep _ alive , ▁d iscard _ len ; ▁const ▁char ▁* cl ; ▁keep _ alive _ enabled ▁= ▁conn -> ctx -> enable _ keepalives ; ▁keep _ alive ▁= ▁0; ▁// ▁I m port ant : ▁on ▁new ▁connection , ▁reset ▁the ▁receiv ing ▁buffer . ▁ Credit ▁go es ▁// ▁to ▁ c ru le 4 2 . ▁conn -> data _ len ▁= ▁0; ▁do ▁{ ▁reset _ per _ request _ attributes ( conn ); ▁conn -> request _ len ▁= ▁read _ request ( NULL , ▁conn , ▁conn -> buf , ▁conn -> buf _ size , ▁& conn -> data _ len ); ▁assert ( conn -> request _ len ▁< ▁0 ▁|| ▁conn -> data _ len ▁>= ▁conn -> request _ len ); ▁if ▁( conn -> request _ len ▁== ▁0 ▁&& ▁conn -> data _ len ▁== ▁conn -> buf _ size ) ▁{ ▁send _ http _ error ( conn , ▁4 13 , ▁" Request ▁ Too ▁L arg e ", ▁"% s ", ▁" "); ▁return ; ▁} ▁if ▁( conn -> request _ len ▁< = ▁0) ▁{ ▁return ; ▁// ▁Remote ▁end ▁close d ▁the ▁connection ▁} ▁if ▁( parse _ http _ request ( conn -> buf , ▁conn -> buf _ size , ▁ri ) ▁< = ▁0 ▁|| ▁! is _ valid _ uri ( ri -> uri )) ▁{ ▁// ▁Do ▁not ▁put ▁garbage ▁in ▁the ▁access ▁log , ▁just ▁send ▁it ▁back ▁to ▁the ▁client ▁send _ http _ error ( conn , ▁400 , ▁" Ba d ▁Request ", ▁" C annot ▁parse ▁HTTP ▁request : ▁[ % .* s ] ", ▁conn -> data _ len , ▁conn -> buf ); ▁conn -> must _ close ▁= ▁1; ▁} ▁else ▁if ▁( strnc mp ( ri -> http _ version , ▁" 1 . 0 ", ▁3) ▁&& ▁strnc mp ( ri -> http _ version , ▁" 1 . 1", ▁ 3)) ▁{ ▁// ▁Request ▁see m s ▁valid , ▁but ▁HTTP ▁version ▁is ▁str an ge ▁send _ http _ error ( conn , ▁5 05, ▁" HTTP ▁version ▁not ▁supported ", ▁"% s ", ▁" "); ▁log _ access ( conn ); ▁} ▁else ▁{ ▁// ▁Request ▁is ▁valid , ▁handle ▁it ▁if ▁( ( cl ▁= ▁get _ header ( ri , ▁" Content - Length ")) ▁ != ▁NULL ) ▁{ ▁conn -> content _ len ▁= ▁str to ll ( cl , ▁NULL , ▁10); ▁} ▁else ▁if ▁(! mg _ strcasecmp ( ri -> request _ method , ▁" POST ") ▁|| ▁! mg _ strcasecmp ( ri -> request _ method , ▁" P UT ")) ▁{ ▁conn -> content _ len ▁= ▁-1; ▁} ▁else ▁{ ▁conn -> content _ len ▁= ▁0; ▁} ▁/* ▁* ▁E n su re ▁that ▁the ▁content - length ▁value ▁is ▁a ▁size ▁that ▁* ▁the ▁EST ▁code ▁is ▁will ing ▁to ▁accept ▁*/ ▁if ▁( conn -> content _ len ▁> ▁EST _ MAX _ CONTENT _ LEN ) ▁{ ▁EST _ LOG _ WARN (" HTTP ▁request ▁content ▁length ▁greate r ▁than ▁EST " ▁" ▁maximum ▁supported ▁content ▁length ▁(% d )", ▁EST _ MAX _ CONTENT _ LEN ); ▁send _ http _ error ( conn , ▁4 13 , ▁" Content - Length ▁too ▁large ", ▁"% s ", ▁" "); ▁log _ access ( conn ); ▁} ▁else ▁if ▁( conn -> content _ len ▁< ▁0) ▁{ ▁EST _ LOG _ WARN (" HTTP ▁request ▁content ▁length ▁is ▁a ▁negative ▁value "); ▁send _ http _ error ( conn , ▁400 , ▁" Ba d ▁Request ", ▁" Content - Length ▁is ▁negative ", ▁conn -> data _ len , ▁conn -> buf ); ▁log _ access ( conn ); ▁} ▁else ▁{ ▁conn -> birth _ time ▁= ▁time ( NULL ); ▁handle _ request ( conn ); ▁log _ access ( conn ); ▁} ▁} ▁// ▁NOTE ( l s m ) : ▁order ▁is ▁important ▁here . ▁should _ keep _ alive () ▁call ▁// ▁is ▁using ▁parsed ▁request , ▁which ▁will ▁be ▁invalid ▁after ▁ memmove ' s ▁below . ▁// ▁The refore , ▁mem or ize ▁should _ keep _ alive () ▁result ▁now ▁for ▁later ▁use ▁// ▁in ▁loo p ▁exit ▁condition . ▁keep _ alive ▁= ▁should _ keep _ alive ( conn ); ▁// ▁D iscard ▁all ▁buffered ▁data ▁for ▁this ▁request ▁d iscard _ len ▁= ▁conn -> content _ len ▁>= ▁0 ▁&& ▁conn -> request _ len ▁+ ▁conn -> content _ len ▁< ▁( int 64_ t ) conn -> data _ len ▁? ▁( int ) ( conn -> request _ len ▁+ ▁conn -> content _ len ) ▁: ▁conn -> data _ len ; ▁if ▁( ( conn -> data _ len ▁- ▁d iscard _ len ) ▁> ▁0) ▁{ ▁ memmove _ s ( conn -> buf , ▁ MAX _ REQUEST _ SIZE , ▁conn -> buf ▁+ ▁d iscard _ len , ▁conn -> data _ len ▁- ▁d iscard _ len ); ▁} ▁conn -> data _ len ▁- = ▁d iscard _ len ; ▁assert ( conn -> data _ len ▁>= ▁0); ▁assert ( conn -> data _ len ▁< = ▁conn -> buf _ size ); ▁} ▁while ▁( conn -> ctx -> stop _ flag ▁== ▁0 ▁&& ▁keep _ alive _ enabled ▁&& ▁conn -> content _ len ▁>= ▁0 ▁&& ▁keep _ alive ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁to ▁process ▁an ▁EST ▁request . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁a ▁listen er ▁socket . ▁When ▁an ▁EST ▁request ▁come s ▁in ▁on ▁the ▁socket , ▁the ▁application ▁uses ▁this ▁function ▁to ▁hand - off ▁the ▁request ▁to ▁libEST . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST _ CTX , ▁which ▁was ▁provided ▁when ▁est _ server _ init () ▁or ▁est _ proxy _ init () ▁was ▁invoked . ▁@ param ▁fd ▁Fil e ▁descriptor ▁that ▁will ▁be ▁read ▁to ▁retrieve ▁the ▁HTTP ▁request ▁from ▁the ▁client . ▁This ▁is ▁typically ▁a ▁TCP ▁socket ▁file ▁descriptor . ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁when ▁an ▁incoming ▁EST ▁request ▁needs ▁to ▁be ▁processed . ▁This ▁request ▁woul d ▁be ▁a ▁cacerts , ▁simpleenroll , ▁reenroll , ▁or ▁csrattrs ▁request . ▁This ▁is ▁used ▁when ▁implement ing ▁an ▁EST ▁server . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁and ▁listen ing ▁to ▁a ▁TCP ▁socket ▁for ▁incoming ▁EST ▁requests . ▁When ▁data ▁is ▁ready ▁to ▁be ▁read ▁from ▁the ▁socket , ▁this ▁API ▁entry ▁point ▁should ▁be ▁used ▁to ▁allow ▁libEST ▁to ▁read ▁the ▁request ▁from ▁the ▁socket ▁and ▁respond ▁to ▁the ▁request . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ handle _ request ▁( EST _ CTX ▁* ctx , ▁int ▁fd ) ▁{ ▁struct ▁mg _ connection ▁* conn ; ▁struct ▁socket ▁accepted ; ▁sock len _ t ▁len ; ▁char ▁ipstr [ INET 6 _ ADDR STR LEN ] ; ▁int ▁port ; ▁struct ▁sockaddr _ storage ▁addr ; ▁int ▁ssl _ err , ▁err _ code ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁int ▁rc ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁EST ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! ctx -> mg _ ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁EST ▁ MG ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁accepted . sock ▁= ▁fd ; ▁accepted . next ▁= ▁NULL ; ▁len ▁= ▁sizeof ( struct ▁sockaddr _ storage ); ▁rc ▁= ▁get peer name ( fd , ▁( struct ▁sockaddr *)& addr , ▁& len ); ▁if ▁( rc ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" get peer name () ▁failed "); ▁/* ▁This ▁should ▁n ever ▁happen , ▁not ▁sure ▁what ▁woul d ▁cause ▁this ▁*/ ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁// ▁deal ▁with ▁both ▁IPv 4 ▁and ▁IPv 6 : ▁if ▁( addr . s s _ family ▁== ▁AF _ INET ) ▁{ ▁memcpy _ s (& accepted . rsa . sin , ▁sizeof ( struct ▁sockaddr _ in ) , ▁& addr , ▁sizeof ( struct ▁sockaddr _ in )); ▁port ▁= ▁ntoh s ( accepted . rsa . sin . sin _ port ); ▁in et _ ntop ( AF _ INET , ▁& accepted . rsa . sin . sin _ addr , ▁ipstr , ▁sizeof ▁ipstr ); ▁} ▁else ▁{ ▁// ▁AF _ INET 6 ▁memcpy _ s (& accepted . rsa . sin 6, ▁sizeof ( struct ▁sockaddr _ in 6 ) , ▁& addr , ▁sizeof ( struct ▁sockaddr _ in 6 )); ▁port ▁= ▁ntoh s ( accepted . rsa . sin 6 . sin 6 _ port ); ▁in et _ ntop ( AF _ INET 6, ▁& accepted . rsa . sin 6 . sin 6 _ addr , ▁ipstr , ▁sizeof ▁ipstr ); ▁} ▁EST _ LOG _ INFO (" Pe er ▁IP ▁address : ▁% s ", ▁ipstr ); ▁EST _ LOG _ INFO (" Pe er ▁port ▁: ▁% d ", ▁port ); ▁conn ▁= ▁( struct ▁mg _ connection *) calloc ( 1, ▁sizeof (* conn ) ▁+ ▁ MAX _ REQUEST _ SIZE ); ▁if ▁( conn ▁== ▁NULL ) ▁{ ▁cry ( fc ( ctx -> mg _ ctx ) , ▁"% s ", ▁" C annot ▁create ▁new ▁connection ▁struct , ▁O O M "); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁else ▁{ ▁conn -> buf _ size ▁= ▁ MAX _ REQUEST _ SIZE ; ▁conn -> buf ▁= ▁( char *) ( conn ▁+ ▁1); ▁conn -> client ▁= ▁accepted ; ▁conn -> birth _ time ▁= ▁time ( NULL ); ▁conn -> ctx ▁= ▁ctx -> mg _ ctx ; ▁conn -> read _ timeout ▁= ▁ctx -> server _ read _ timeout ; ▁// ▁Fil l ▁in ▁IP , ▁port ▁info ▁e ar ly ▁so ▁even ▁if ▁SSL ▁set up ▁below ▁fails , ▁// ▁error ▁handler ▁woul d ▁have ▁the ▁correspond ing ▁info . ▁conn -> request _ info . remote _ port ▁= ▁ntoh s ( conn -> client . rsa . sin . sin _ port ); ▁memcpy _ s (& conn -> request _ info . remote _ ip , ▁4 , ▁& conn -> client . rsa . sin . sin _ addr . s _ addr , ▁4 ); ▁conn -> request _ info . remote _ ip ▁= ▁ntoh l ( conn -> request _ info . remote _ ip ); ▁conn -> request _ info . is _ ssl ▁= ▁1; ▁/* ▁* ▁EST ▁require ▁TLS , ▁Setup ▁the ▁TLS ▁tunnel ▁*/ ▁conn -> ssl ▁= ▁SSL _ new ( conn -> ctx -> ssl _ ctx ); ▁if ▁( conn -> ssl ▁ != ▁NULL ) ▁{ ▁SSL _ set _ fd ( conn -> ssl , ▁conn -> client . sock ); ▁ssl _ err ▁= ▁SSL _ a c cept ( conn -> ssl ); ▁if ▁( ssl _ err ▁< = ▁0) ▁{ ▁err _ code ▁= ▁SSL _ get _ error ( conn -> ssl , ▁ssl _ err ); ▁switch ▁( err _ code ) ▁{ ▁case ▁SSL _ ERROR _ SYSCALL : ▁EST _ LOG _ ERR (" OpenSSL ▁system ▁call ▁error "); ▁rv ▁= ▁EST _ ERR _ SYSCALL ; ▁break ; ▁case ▁SSL _ ERROR _ SSL : ▁/* ▁Some ▁un known ▁OpenSSL ▁error , ▁ dump ▁the ▁* ▁OpenSSL ▁error ▁log ▁to ▁le ar n ▁more ▁about ▁this ▁*/ ▁ossl _ dump _ ssl _ errors (); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁break ; ▁case ▁SSL _ ERROR _ WA NT _ READ : ▁case ▁SSL _ ERROR _ WA NT _ WRITE : ▁EST _ LOG _ INFO (" App ▁using ▁non - blocking ▁socket "); ▁process _ new _ connection ( conn ); ▁break ; ▁case ▁SSL _ ERROR _ WA NT _ X 509_ LO OK UP : ▁EST _ LOG _ ERR (" SSL _ a c cept ▁error , ▁wants ▁lookup "); ▁rv ▁= ▁EST _ ERR _ UNKNOWN ; ▁break ; ▁case ▁SSL _ ERROR _ NONE : ▁default : ▁break ; ▁} ▁} ▁else ▁{ ▁process _ new _ connection ( conn ); ▁} ▁ssl _ err ▁= ▁SSL _ shutdown ( conn -> ssl ); ▁switch ▁( ssl _ err ) ▁{ ▁case ▁0 : ▁/* ▁OpenSSL ▁do cs ▁say ▁to ▁call ▁shutdown ▁again ▁for ▁this ▁case ▁*/ ▁SSL _ shutdown ( conn -> ssl ); ▁EST _ LOG _ INFO (" T wo - pha se ▁SSL _ shutdown ▁initiate d "); ▁break ; ▁case ▁1 : ▁/* ▁No th ing ▁to ▁do , ▁shutdown ▁worked ▁*/ ▁EST _ LOG _ INFO (" SSL _ shutdown ▁succeed ed "); ▁break ; ▁default : ▁/* ▁Log ▁an ▁error ▁*/ ▁EST _ LOG _ WARN (" SSL _ shutdown ▁failed "); ▁break ; ▁} ▁SSL _ free ( conn -> ssl ); ▁conn -> ssl ▁= ▁NULL ; ▁} ▁mem zero _ s ( conn , ▁sizeof (* conn ) ▁+ ▁ MAX _ REQUEST _ SIZE ); ▁free ( conn ); ▁} ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁to ▁process ▁an ▁EST ▁request . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁a ▁listen er ▁socket . ▁When ▁an ▁EST ▁request ▁come s ▁in ▁on ▁the ▁socket , ▁the ▁application ▁uses ▁this ▁function ▁to ▁hand - off ▁the ▁request ▁to ▁libEST . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST _ CTX , ▁which ▁was ▁provided ▁when ▁est _ server _ init () ▁or ▁est _ proxy _ init () ▁was ▁invoked . ▁@ param ▁fd ▁Fil e ▁descriptor ▁that ▁will ▁be ▁read ▁to ▁retrieve ▁the ▁HTTP ▁request ▁from ▁the ▁client . ▁This ▁is ▁typically ▁a ▁TCP ▁socket ▁file ▁descriptor . ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁when ▁an ▁incoming ▁EST ▁request ▁needs ▁to ▁be ▁processed . ▁This ▁request ▁woul d ▁be ▁a ▁cacerts , ▁simpleenroll , ▁reenroll , ▁or ▁csrattrs ▁request . ▁This ▁is ▁used ▁when ▁implement ing ▁an ▁EST ▁server . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁and ▁listen ing ▁to ▁a ▁TCP ▁socket ▁for ▁incoming ▁EST ▁requests . ▁When ▁data ▁is ▁ready ▁to ▁be ▁read ▁from ▁the ▁socket , ▁this ▁API ▁entry ▁point ▁should ▁be ▁used ▁to ▁allow ▁libEST ▁to ▁read ▁the ▁request ▁from ▁the ▁socket ▁and ▁respond ▁to ▁the ▁request . ▁@ return ▁EST _ ERROR . ▁*/ ▁static ▁void ▁free _ context ▁( struct ▁mg _ context ▁* ctx ) ▁{ ▁// ▁ De allocate ▁SSL ▁context ▁if ▁( ctx -> ssl _ ctx ▁ != ▁NULL ) ▁{ ▁SSL _ CTX _ free ( ctx -> ssl _ ctx ); ▁} ▁// ▁ De allocate ▁context ▁itself ▁free ( ctx ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁to ▁process ▁an ▁EST ▁request . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁a ▁listen er ▁socket . ▁When ▁an ▁EST ▁request ▁come s ▁in ▁on ▁the ▁socket , ▁the ▁application ▁uses ▁this ▁function ▁to ▁hand - off ▁the ▁request ▁to ▁libEST . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST _ CTX , ▁which ▁was ▁provided ▁when ▁est _ server _ init () ▁or ▁est _ proxy _ init () ▁was ▁invoked . ▁@ param ▁fd ▁Fil e ▁descriptor ▁that ▁will ▁be ▁read ▁to ▁retrieve ▁the ▁HTTP ▁request ▁from ▁the ▁client . ▁This ▁is ▁typically ▁a ▁TCP ▁socket ▁file ▁descriptor . ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁when ▁an ▁incoming ▁EST ▁request ▁needs ▁to ▁be ▁processed . ▁This ▁request ▁woul d ▁be ▁a ▁cacerts , ▁simpleenroll , ▁reenroll , ▁or ▁csrattrs ▁request . ▁This ▁is ▁used ▁when ▁implement ing ▁an ▁EST ▁server . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁and ▁listen ing ▁to ▁a ▁TCP ▁socket ▁for ▁incoming ▁EST ▁requests . ▁When ▁data ▁is ▁ready ▁to ▁be ▁read ▁from ▁the ▁socket , ▁this ▁API ▁entry ▁point ▁should ▁be ▁used ▁to ▁allow ▁libEST ▁to ▁read ▁the ▁request ▁from ▁the ▁socket ▁and ▁respond ▁to ▁the ▁request . ▁@ return ▁EST _ ERROR . ▁*/ ▁void ▁mg _ stop ▁( struct ▁mg _ context ▁* ctx ) ▁{ ▁ctx -> stop _ flag ▁= ▁1; ▁free _ context ( ctx ); ▁# if ▁defined ( _ W IN 32 ) ▁&& ▁! defined ( _ _ SYMB IAN 32 _ _ ) ▁( void ) W S AC le anu p (); ▁# endif ▁// ▁ _ W IN 32 ▁} ▁/* ! ▁@ br i ef ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁to ▁process ▁an ▁EST ▁request . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁a ▁listen er ▁socket . ▁When ▁an ▁EST ▁request ▁come s ▁in ▁on ▁the ▁socket , ▁the ▁application ▁uses ▁this ▁function ▁to ▁hand - off ▁the ▁request ▁to ▁libEST . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST _ CTX , ▁which ▁was ▁provided ▁when ▁est _ server _ init () ▁or ▁est _ proxy _ init () ▁was ▁invoked . ▁@ param ▁fd ▁Fil e ▁descriptor ▁that ▁will ▁be ▁read ▁to ▁retrieve ▁the ▁HTTP ▁request ▁from ▁the ▁client . ▁This ▁is ▁typically ▁a ▁TCP ▁socket ▁file ▁descriptor . ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁when ▁an ▁incoming ▁EST ▁request ▁needs ▁to ▁be ▁processed . ▁This ▁request ▁woul d ▁be ▁a ▁cacerts , ▁simpleenroll , ▁reenroll , ▁or ▁csrattrs ▁request . ▁This ▁is ▁used ▁when ▁implement ing ▁an ▁EST ▁server . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁and ▁listen ing ▁to ▁a ▁TCP ▁socket ▁for ▁incoming ▁EST ▁requests . ▁When ▁data ▁is ▁ready ▁to ▁be ▁read ▁from ▁the ▁socket , ▁this ▁API ▁entry ▁point ▁should ▁be ▁used ▁to ▁allow ▁libEST ▁to ▁read ▁the ▁request ▁from ▁the ▁socket ▁and ▁respond ▁to ▁the ▁request . ▁@ return ▁EST _ ERROR . ▁*/ ▁struct ▁mg _ context ▁* mg _ start ▁( void ▁* user _ data ) ▁{ ▁struct ▁mg _ context ▁* ctx ; ▁# if ▁defined ( _ W IN 32 ) ▁&& ▁! defined ( _ _ SYMB IAN 32 _ _ ) ▁WSA DATA ▁data ; ▁ WSAStartup ( MA K E WORD (2, ▁2) , ▁& data ); ▁Initialize CriticalSection (& global _ log _ file _ lock ); ▁# endif ▁// ▁ _ W IN 32 ▁// ▁A llocate ▁context ▁and ▁initialize ▁reason able ▁general ▁case ▁defaults . ▁// ▁TODO ( l s m ) : ▁do ▁proper ▁error ▁handl ing ▁here . ▁if ▁( ( ctx ▁= ▁( struct ▁mg _ context *) calloc ( 1, ▁sizeof (* ctx ))) ▁== ▁NULL ) ▁{ ▁return ▁NULL ; ▁} ▁ctx -> user _ data ▁= ▁user _ data ; ▁ctx -> est _ ctx ▁= ▁( EST _ CTX *) user _ data ; ▁ctx -> enable _ keepalives ▁= ▁1; ▁if ▁(! set _ ssl _ option ( ctx )) ▁{ ▁free _ context ( ctx ); ▁return ▁NULL ; ▁} ▁return ▁ctx ; ▁} ▁/* ! ▁@ br i ef ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁to ▁process ▁an ▁EST ▁request . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁a ▁listen er ▁socket . ▁When ▁an ▁EST ▁request ▁come s ▁in ▁on ▁the ▁socket , ▁the ▁application ▁uses ▁this ▁function ▁to ▁hand - off ▁the ▁request ▁to ▁libEST . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST _ CTX , ▁which ▁was ▁provided ▁when ▁est _ server _ init () ▁or ▁est _ proxy _ init () ▁was ▁invoked . ▁@ param ▁fd ▁Fil e ▁descriptor ▁that ▁will ▁be ▁read ▁to ▁retrieve ▁the ▁HTTP ▁request ▁from ▁the ▁client . ▁This ▁is ▁typically ▁a ▁TCP ▁socket ▁file ▁descriptor . ▁est _ server _ handle _ request () ▁is ▁used ▁by ▁an ▁application ▁when ▁an ▁incoming ▁EST ▁request ▁needs ▁to ▁be ▁processed . ▁This ▁request ▁woul d ▁be ▁a ▁cacerts , ▁simpleenroll , ▁reenroll , ▁or ▁csrattrs ▁request . ▁This ▁is ▁used ▁when ▁implement ing ▁an ▁EST ▁server . ▁The ▁application ▁is ▁responsible ▁for ▁open ing ▁and ▁listen ing ▁to ▁a ▁TCP ▁socket ▁for ▁incoming ▁EST ▁requests . ▁When ▁data ▁is ▁ready ▁to ▁be ▁read ▁from ▁the ▁socket , ▁this ▁API ▁entry ▁point ▁should ▁be ▁used ▁to ▁allow ▁libEST ▁to ▁read ▁the ▁request ▁from ▁the ▁socket ▁and ▁respond ▁to ▁the ▁request . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ send _ csrattr _ data ▁( EST _ CTX ▁* ctx , ▁char ▁* csr _ data , ▁int ▁csr _ len , ▁void ▁* http _ ctx ) ▁{ ▁char ▁http _ hdr [ EST _ HTTP _ HDR _ MAX ] ; ▁int ▁hdrlen ; ▁if ▁( ( csr _ len ▁> ▁0) ▁&& ▁csr _ data ) ▁{ ▁/* ▁* ▁Send ▁HTTP ▁200 ▁header ▁*/ ▁ snprintf ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX , ▁"% s % s % s % s ", ▁EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ STAT _200, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CT , ▁EST _ HTTP _ CT _ CSRATTRS , ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CE , ▁EST _ HTTP _ CE _ BASE 64, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% d % s % s ", ▁EST _ HTTP _ HDR _ CL , ▁csr _ len , ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ EOL ); ▁if ▁(! mg _ write ( http _ ctx , ▁http _ hdr , ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁free ( csr _ data ); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁/* ▁* ▁Send ▁the ▁CSR ▁in ▁the ▁body ▁*/ ▁if ▁(! mg _ write ( http _ ctx , ▁csr _ data , ▁csr _ len )) ▁{ ▁free ( csr _ data ); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁free ( csr _ data ); ▁} ▁else ▁{ ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁/* ▁Send ▁a ▁204 ▁response ▁indicat ing ▁the ▁server ▁does n ' t ▁have ▁a ▁CSR ▁*/ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁}