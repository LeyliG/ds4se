▁/** ** ***** **************** **************** **************** **************** **************** ▁* ▁Authorization ▁routine s ▁ ***** ***** *************** **************** **************** **************** **************** / ▁int ▁ossl _ verify _ cb ▁( int ▁ok , ▁X 509_ STORE _ CTX ▁* ctx ) ▁{ ▁int ▁cert _ error ▁= ▁X 509_ STORE _ CTX _ get _ error ( ctx ); ▁X 509 ▁* current _ cert ▁= ▁X 509_ STORE _ CTX _ get _ current _ cert ( ctx ); ▁EST _ LOG _ INFO (" enter ▁function : ▁ok =% d ▁cert _ error =% d ", ▁ok , ▁cert _ error ); ▁if ▁(! ok ) ▁{ ▁if ▁( current _ cert ) ▁{ ▁X 509_ NAME _ print _ ex _ fp ( stdout , ▁X 509_ get _ subject _ name ( current _ cert ) , ▁0, ▁X N _ FLAG _ ONE L INE ); ▁ printf ("\ n "); ▁} ▁EST _ LOG _ INFO ("% s error ▁% d ▁at ▁% d ▁ depth ▁lookup :% s \ n ", ▁X 509_ STORE _ CTX _ get 0 _ parent _ ctx ( ctx ) ▁? ▁" [ CRL ▁path ] " ▁: ▁"", ▁cert _ error , ▁X 509_ STORE _ CTX _ get _ error _ depth ( ctx ) , ▁X 509_ verify _ cert _ error _ string ( cert _ error )); ▁switch ▁( cert _ error ) ▁{ ▁case ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL : ▁/* ▁* ▁We ' ve ▁enabled ▁CRL ▁checking ▁in ▁the ▁TLS ▁stack . ▁If ▁* ▁the ▁application ▁has n ' t ▁loaded ▁a ▁CRL , ▁then ▁this ▁* ▁verify ▁error ▁can ▁occur . ▁The ▁peer ' s ▁cert ▁is ▁valid , ▁* ▁but ▁we ▁can ' t ▁confirm ▁if ▁it ▁was ▁revoked . ▁We ' ll ▁* ▁warn ▁the ▁application . ▁*/ ▁EST _ LOG _ WARN (" No ▁CRL ▁loaded , ▁TLS ▁peer ▁will ▁be ▁allowed . "); ▁ok ▁= ▁1; ▁break ; ▁case ▁X 509_ V _ ERR _ NO _ EXPLICIT _ P OLIC Y : ▁case ▁X 509_ V _ ERR _ CERT _ HAS _ EXPIRED : ▁/* ▁since ▁we ▁are ▁just ▁checking ▁the ▁certificates , ▁it ▁is ▁* ▁ok ▁if ▁they ▁are ▁self ▁signed . ▁ But ▁we ▁should ▁st ill ▁warn ▁* ▁the ▁user . ▁*/ ▁case ▁X 509_ V _ ERR _ DEPTH _ ZE RO _ SELF _ SIGNED _ CERT : ▁/* ▁ Continue ▁after ▁extension ▁error s ▁too ▁*/ ▁case ▁X 509_ V _ ERR _ INVALID _ CA : ▁case ▁X 509_ V _ ERR _ INVALID _ NON _ CA : ▁case ▁X 509_ V _ ERR _ P ATH _ LEN G TH _ EXCEED ED : ▁case ▁X 509_ V _ ERR _ INVALID _ PURPOSE : ▁case ▁X 509_ V _ ERR _ CRL _ HAS _ EXPIRED : ▁case ▁X 509_ V _ ERR _ CRL _ NOT _ YET _ VALID : ▁case ▁X 509_ V _ ERR _ UN HANDLE D _ CRI TICA L _ EXTEN S ION : ▁case ▁X 509_ V _ ERR _ CERT _ REVOKED : ▁default : ▁EST _ LOG _ WARN (" Certificate ▁verify ▁failed ▁( reason =% d )", ▁cert _ error ); ▁break ; ▁} ▁return ▁ok ; ▁} ▁return ▁( ok ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁load ▁an ▁X 509_ STORE ▁using ▁raw ▁* ▁data ▁from ▁a ▁buffer . ▁The ▁data ▁is ▁expected ▁to ▁be ▁PEM ▁* ▁encoded . ▁* ▁* ▁Returns ▁the ▁number ▁of ▁certs ▁added ▁to ▁the ▁store ▁*/ ▁static ▁int ▁ossl _ init _ cert _ store _ from _ raw ▁( X 509_ STORE ▁* store , ▁un signed ▁char ▁* raw , ▁int ▁size ) ▁{ ▁STA CK _ OF ( X 509_ INFO ) ▁* ▁sk ▁= ▁NULL ; ▁X 509_ INFO ▁* x i ; ▁BIO ▁* in ; ▁int ▁cert _ cnt ▁= ▁0; ▁in ▁= ▁BIO _ new _ mem _ buf ( raw , ▁size ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁the ▁raw ▁CA ▁cert ▁buffer \ n "); ▁return ▁0; ▁} ▁/* ▁This ▁load s ▁from ▁a ▁file , ▁a ▁stack ▁of ▁x 509 / crl / pkey ▁sets ▁*/ ▁sk ▁= ▁PEM _ X 509_ INFO _ read _ bio ( in , ▁NULL , ▁NULL , ▁NULL ); ▁if ▁( sk ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁read ▁PEM ▁encoded ▁certs ▁from ▁BIO "); ▁BIO _ free ( in ); ▁return ▁0; ▁} ▁BIO _ free ( in ); ▁/* ▁ scan ▁over ▁it ▁and ▁pull ▁out ▁the ▁CRL ' s ▁*/ ▁while ▁( sk _ X 509_ INFO _ num ( sk )) ▁{ ▁xi ▁= ▁sk _ X 509_ INFO _ sh if t ( sk ); ▁if ▁( x i -> x 509 ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ INFO (" Add ing ▁cert ▁to ▁store ▁(% s )", ▁xi -> x 509 -> name ); ▁X 509_ STORE _ add _ cert ( store , ▁xi -> x 509 ); ▁cert _ cnt ++; ▁} ▁if ▁( x i -> crl ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ INFO (" Add ing ▁CRL ▁to ▁store "); ▁X 509_ STORE _ add _ crl ( store , ▁xi -> crl ); ▁} ▁X 509_ INFO _ free ( x i ); ▁} ▁if ▁( sk ▁ != ▁NULL ) ▁{ ▁sk _ X 509_ INFO _ pop _ free ( sk , ▁X 509_ INFO _ free ); ▁} ▁return ▁( cert _ cnt ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁populate ▁an ▁X 509_ STORE ▁structure , ▁* ▁which ▁can ▁be ▁used ▁by ▁the ▁OpenSSL ▁TLS ▁stack ▁to ▁verifying ▁* ▁a ▁TLS ▁peer . ▁The ▁X 509_ STORE ▁should ▁already ▁have ▁been ▁allocated . ▁* ▁* ▁ Parameters : ▁* ▁store ▁- ▁ Pointer ▁to ▁X 509_ STORE ▁structure ▁to ▁hold ▁the ▁certs ▁* ▁raw 1 ▁- ▁char ▁array ▁containing ▁PEM ▁encoded ▁certs ▁to ▁put ▁* ▁into ▁the ▁store . ▁* ▁size 1 ▁- ▁Length ▁of ▁the ▁raw 1 ▁char ▁array ▁*/ ▁EST _ ERROR ▁ossl _ init _ cert _ store ▁( X 509_ STORE ▁* store , ▁un signed ▁char ▁* raw 1, ▁int ▁size 1) ▁{ ▁X 509_ STORE _ set _ flags ( store , ▁0); ▁int ▁ cnt ; ▁if ▁( raw 1) ▁{ ▁ cnt ▁= ▁ossl _ init _ cert _ store _ from _ raw ( store , ▁raw 1, ▁size 1); ▁if ▁(! cnt ) ▁{ ▁EST _ LOG _ ERR (" Cert ▁count ▁is ▁zero ▁for ▁store "); ▁return ▁( EST _ ERR _ NO _ CERTS _ FOUND ); ▁} ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁can ▁be ▁used ▁to ▁output ▁the ▁OpenSSL ▁* ▁error ▁buffer . ▁This ▁is ▁useful ▁when ▁an ▁OpenSSL ▁* ▁API ▁call ▁fails ▁and ▁you ' d ▁like ▁to ▁provide ▁some ▁* ▁detail ▁to ▁the ▁user ▁regard ing ▁the ▁cause ▁of ▁the ▁* ▁failure . ▁*/ ▁void ▁ossl _ dump _ ssl _ errors ▁( ) ▁{ ▁BIO ▁* e ▁= ▁NULL ; ▁ BUF _ MEM ▁* bptr ▁= ▁NULL ; ▁e ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁(! e ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁return ; ▁} ▁ ERR _ print _ errors ( e ); ▁( void ) BIO _ flu sh ( e ); ▁BIO _ get _ mem _ ptr ( e , ▁& bptr ); ▁EST _ LOG _ WARN (" O SSL ▁error : ▁% s ", ▁bptr -> data ); ▁BIO _ free _ all ( e ); ▁} ▁/* ! ▁@ br i ef ▁est _ convert _ p 7 b 64_ to _ pem () ▁convert s ▁the ▁base 64 ▁encoded ▁PKCS 7 ▁response ▁from ▁the ▁EST ▁server ▁into ▁PEM ▁format . ▁@ param ▁certs _ p 7 ▁P o int s ▁to ▁a ▁buffer ▁containing ▁the ▁base 64 ▁encoded ▁pkcs 7 ▁data . ▁@ param ▁certs _ len ▁Indicate s ▁the ▁size ▁of ▁the ▁* certs _ p 7 ▁buffer . ▁@ param ▁ pem ▁ Double ▁pointer ▁that ▁will ▁receive ▁the ▁PEM ▁encoded ▁data . ▁S ever al ▁of ▁the ▁EST ▁message ▁return ▁data ▁that ▁contains ▁base 64 ▁encoded ▁PKCS 7 ▁certificates . ▁This ▁function ▁is ▁used ▁to ▁convert ▁the ▁data ▁to ▁PEM ▁format . ▁This ▁function ▁will ▁allocate ▁memory ▁point ed ▁to ▁by ▁the ▁** pem ▁argument . ▁The ▁caller ▁is ▁responsible ▁for ▁rel e a s ing ▁this ▁memory . ▁The ▁return ▁value ▁is ▁the ▁length ▁of ▁the ▁PEM ▁buffer , ▁or ▁-1 ▁on ▁error . ▁@ return ▁int . ▁*/ ▁int ▁est _ convert _ p 7 b 64_ to _ pem ▁( un signed ▁char ▁* certs _ p 7, ▁int ▁certs _ len , ▁un signed ▁char ▁** pem ) ▁{ ▁X 509 ▁* x ; ▁STA CK _ OF ( X 509 ) ▁* certs ▁= ▁NULL ; ▁BIO ▁* b 64, ▁* in , ▁* out ; ▁un signed ▁char ▁* cacerts _ decoded ▁= ▁NULL ; ▁int ▁cacerts _ decoded _ len ▁= ▁0; ▁BIO ▁* p 7 bio _ in ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 = NULL ; ▁int ▁i , ▁nid ; ▁un signed ▁char ▁* pem _ data ; ▁int ▁ pem _ len ; ▁/* ▁* ▁Base 64 ▁decode ▁the ▁incoming ▁ca ▁certs ▁buffer . ▁ De co d ing ▁will ▁* ▁al way s ▁take ▁up ▁no ▁more ▁than ▁the ▁original ▁buffer . ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁(! b 64 ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁return ▁(-1 ); ▁} ▁in ▁= ▁BIO _ new _ mem _ buf ( certs _ p 7, ▁certs _ len ); ▁if ▁(! in ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁return ▁(-1 ); ▁} ▁in ▁= ▁BIO _ push ( b 64, ▁in ); ▁cacerts _ decoded ▁= ▁malloc ( certs _ len ); ▁if ▁(! cacerts _ decoded ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁return ▁(-1 ); ▁} ▁cacerts _ decoded _ len ▁= ▁BIO _ read ( in , ▁cacerts _ decoded , ▁certs _ len ); ▁BIO _ free _ all ( in ); ▁/* ▁* ▁ Now ▁get ▁the ▁PKCS 7 ▁formatt ed ▁buffer ▁of ▁certificates ▁read ▁into ▁a ▁stack ▁of ▁* ▁X 509 ▁certs ▁*/ ▁p 7 bio _ in ▁= ▁BIO _ new _ mem _ buf ( cacerts _ decoded , ▁cacerts _ decoded _ len ); ▁if ▁(! p 7 bio _ in ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁mem ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁free ( cacerts _ decoded ); ▁return ▁(-1 ); ▁} ▁p 7 ▁= ▁d 2 i _ PKCS 7_ bio ( p 7 bio _ in , ▁NULL ); ▁if ▁(! p 7 ) ▁{ ▁EST _ LOG _ ERR (" PEM _ read _ bio _ PKCS 7 ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁free ( cacerts _ decoded ); ▁return ▁(-1 ); ▁} ▁BIO _ free _ all ( p 7 bio _ in ); ▁free ( cacerts _ decoded ); ▁/* ▁* ▁ Now ▁that ▁we ' ve ▁decoded ▁the ▁certs , ▁get ▁a ▁reference ▁* ▁the ▁the ▁stack ▁of ▁certs ▁*/ ▁nid = OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( nid ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁certs ▁= ▁p 7-> d . sign -> cert ; ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁certs ▁= ▁p 7-> d . signed _ and _ e nveloped -> cert ; ▁break ; ▁default : ▁EST _ LOG _ ERR (" I nvalid ▁NID ▁value ▁on ▁PKCS 7 ▁structure "); ▁PKCS 7_ free ( p 7 ); ▁return ▁(-1 ); ▁break ; ▁} ▁if ▁(! certs ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁at ta in ▁X 509 ▁cert ▁stack ▁from ▁PKCS 7 ▁data "); ▁PKCS 7_ free ( p 7 ); ▁return ▁(-1 ); ▁} ▁/* ▁* ▁ Output ▁the ▁certs ▁to ▁a ▁new ▁BIO ▁using ▁the ▁PEM ▁format ▁*/ ▁out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁(! out ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁PKCS 7_ free ( p 7 ); ▁return ▁(-1 ); ▁} ▁for ▁( i =0; ▁i < sk _ X 509_ num ( certs ); ▁i ++) ▁{ ▁x = sk _ X 509_ value ( certs , ▁i ); ▁PEM _ write _ bio _ X 509( out , ▁x ); ▁BIO _ put s ( out , ▁"\ n "); ▁} ▁( void ) BIO _ flu sh ( out ); ▁/* ▁* ▁ Now ▁convert ▁the ▁BIO ▁to ▁char * ▁*/ ▁ pem _ len ▁= ▁( int ) ▁BIO _ get _ mem _ data ( out , ▁( char **)& pem _ data ); ▁if ▁( pem _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" BIO _ get _ mem _ data ▁failed "); ▁PKCS 7_ free ( p 7 ); ▁return ▁(-1 ); ▁} ▁* pem ▁= ▁malloc ( pem _ len ▁+ ▁1); ▁if ▁(! * pem ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁PKCS 7_ free ( p 7 ); ▁return ▁(-1 ); ▁} ▁memcpy _ s (* pem , ▁ pem _ len , ▁ pem _ data , ▁ pem _ len ); ▁(* pem ) [ pem _ len ] ▁= ▁0; ▁// M ake ▁sure ▁it ' s ▁null ▁term i ant ed ▁BIO _ free _ all ( out ); ▁PKCS 7_ free ( p 7 ); ▁return ▁( pem _ len ); ▁}