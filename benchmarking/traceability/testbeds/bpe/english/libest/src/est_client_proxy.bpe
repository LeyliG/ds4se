▁/* ▁Use ▁WSA AddressToString A ▁instead ▁of ▁in et _ ntop ▁on ▁Windows ▁as ▁in et _ ntop ▁does ▁not ▁* ▁exist ▁on ▁Windows ▁X P . ▁* ▁Can ' t ▁use ▁ ` const ▁struct ▁sockaddr ▁* ` ▁here ▁because ▁WSA AddressToString A ▁takes ▁* ▁a ▁ LP SOCK ADDR . ▁*/ ▁static ▁int ▁addr _ to _ str ▁( struct ▁sockaddr ▁* addr , ▁char ▁* str , ▁size _ t ▁str _ size , ▁un signed ▁short ▁int ▁* port ) ▁{ ▁int ▁ret ▁= ▁-1; ▁# if def ▁WI N 32 ▁D WORD ▁d w _ str _ size ; ▁size _ t ▁addr _ len ▁= ▁0; ▁switch ▁( addr -> sa _ family ) ▁{ ▁case ▁AF _ INET : ▁addr _ len ▁= ▁sizeof ( struct ▁sockaddr _ in ); ▁* port ▁= ▁ntoh s ( ( ( struct ▁sockaddr _ in ▁* ) addr ) -> sin _ port ); ▁break ; ▁case ▁AF _ INET 6 : ▁addr _ len ▁= ▁sizeof ( struct ▁sockaddr _ in 6 ); ▁* port ▁= ▁ntoh s ( ( ( struct ▁sockaddr _ in 6 ▁* ) addr ) -> sin 6 _ port ); ▁break ; ▁default : ▁break ; ▁} ▁d w _ str _ size ▁= ▁str _ size ; ▁if ▁( addr _ len ▁ != ▁0 ▁&& ▁WSA AddressToString W ( addr , ▁addr _ len , ▁NULL , ▁( LP W STR ) str , ▁& d w _ str _ size ) ▁== ▁0) ▁{ ▁ret ▁= ▁0; ▁} ▁# else ▁switch ▁( addr -> sa _ family ) ▁{ ▁case ▁AF _ INET : ▁* port ▁= ▁ntoh s ( ( ( struct ▁sockaddr _ in ▁* ) addr ) -> sin _ port ); ▁if ▁( i net _ ntop ( addr -> sa _ family , ▁& ( ( struct ▁sockaddr _ in ▁* ) addr ) -> sin _ addr , ▁str , ▁str _ size )) ▁{ ▁ret ▁= ▁0; ▁} ▁break ; ▁case ▁AF _ INET 6 : ▁* port ▁= ▁ntoh s ( ( ( struct ▁sockaddr _ in 6 ▁* ) addr ) -> sin 6 _ port ); ▁if ▁( i net _ ntop ( addr -> sa _ family , ▁& ( ( struct ▁sockaddr _ in 6 ▁* ) addr ) -> sin 6 _ addr , ▁str , ▁str _ size )) ▁{ ▁ret ▁= ▁0; ▁} ▁break ; ▁default : ▁break ; ▁} ▁# endif ▁return ▁ret ; ▁} ▁/* ▁Use ▁WSA AddressToString A ▁instead ▁of ▁in et _ ntop ▁on ▁Windows ▁as ▁in et _ ntop ▁does ▁not ▁* ▁exist ▁on ▁Windows ▁X P . ▁* ▁Can ' t ▁use ▁ ` const ▁struct ▁sockaddr ▁* ` ▁here ▁because ▁WSA AddressToString A ▁takes ▁* ▁a ▁ LP SOCK ADDR . ▁*/ ▁static ▁t cw _ err _ t ▁t cw _ direct _ close ▁( t cw _ sock _ t ▁* sock ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁if ▁( CLOSE _ SOCKET ( sock -> sock _ fd ) ▁ != ▁0) ▁{ ▁EST _ LOG _ ERR (" close ▁failed : ▁% d ", ▁GET _ SOCK _ ERR ()); ▁ret ▁= ▁TC W _ ERR _ CLOSE ; ▁/* ▁SOCK _ ERR ▁already ▁set ▁*/ ▁go to ▁done ; ▁} ▁sock -> sock _ fd ▁= ▁SOCK _ INVALID ; ▁done : ▁return ▁ret ; ▁} ▁/* ▁* ▁E stablish ▁a ▁direct ▁socket ▁connection ▁with ▁the ▁EST ▁server ▁using ▁* ▁normal ▁system ▁calls ▁*/ ▁static ▁t cw _ err _ t ▁t cw _ direct _ connect ▁( t cw _ sock _ t ▁* sock , ▁t cw _ opts _ t ▁* opts , ▁const ▁char ▁* host , ▁un signed ▁short ▁int ▁port ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁struct ▁ addrinfo ▁* addr s ▁= ▁NULL ; ▁struct ▁ addrinfo ▁* cur _ addr ; ▁SOCK _ TYPE ▁fd ; ▁int ▁err ; ▁int ▁saved _ err ; ▁char ▁port _ str [ 10 ] ; ▁char ▁sock _ addr _ str [ INET 6 _ ADDR STR LEN ] ; ▁un signed ▁short ▁int ▁sock _ port ; ▁struct ▁ addrinfo ▁hint s ▁= ▁{ ▁0 ▁} ; ▁int ▁n ; ▁hint s . ai _ sock type ▁= ▁SOCK _ STR E AM ; ▁hint s . ai _ flags ▁= ▁A I _ ADDR CONF IG ; ▁n ▁= ▁ snprintf ( port _ str , ▁sizeof ( port _ str ) , ▁"% hu ", ▁port ); ▁if ▁( n ▁< ▁0 ▁|| ▁n ▁>= ▁( int ) sizeof ( port _ str )) ▁{ ▁errno ▁= ▁E NOMEM ; ▁ret ▁= ▁TC W _ ERR _ ALLOC ; ▁go to ▁done ; ▁} ▁EST _ LOG _ INFO (" get addrinfo ( % s , ▁% s )", ▁host , ▁port _ str ); ▁if ▁( ( err ▁= ▁get addrinfo ( host , ▁port _ str , ▁& hint s , ▁& addr s )) ▁ != ▁0) ▁{ ▁EST _ LOG _ ERR (" get addrinfo ▁returned ▁% d : ▁% s ", ▁err , ▁ g ai _ str error ( err )); ▁ret ▁= ▁TC W _ ERR _ RESOLV ; ▁# if def ▁WI N 32 ▁/* ▁SOCK _ ERR ▁already ▁set ▁*/ ▁# else ▁switch ▁( err ) ▁{ ▁case ▁E A I _ SYST EM : ▁/* ▁SOCK _ ERR ▁already ▁set ▁*/ ▁break ; ▁case ▁E A I _ MEM OR Y : ▁SET _ SOCK _ ERR _ NOMEM (); ▁break ; ▁default : ▁/* ▁C ould ▁not ▁resolve ▁host ▁*/ ▁SET _ SOCK _ ERR _ NO NAME (); ▁break ; ▁} ▁# endif ▁go to ▁done ; ▁} ▁cur _ addr ▁= ▁addr s ; ▁while ▁( cur _ addr ) ▁{ ▁ret ▁= ▁TC W _ OK ; ▁fd ▁= ▁socket ( cur _ addr -> ai _ family , ▁SOCK _ STR E AM , ▁IP PROTO _ TCP ); ▁if ▁( fd ▁< ▁0) ▁{ ▁EST _ LOG _ WARN (" socket ▁failed : ▁% d ", ▁GET _ SOCK _ ERR ()); ▁ret ▁= ▁TC W _ ERR _ SOCKET ; ▁cur _ addr ▁= ▁cur _ addr -> ai _ next ; ▁continue ; ▁} ▁err ▁= ▁addr _ to _ str ( cur _ addr -> ai _ addr , ▁sock _ addr _ str , ▁sizeof ( sock _ addr _ str ) , ▁& sock _ port ); ▁if ▁(! err ) ▁{ ▁EST _ LOG _ INFO (" connect ( % s ▁port ▁% hu )", ▁sock _ addr _ str , ▁sock _ port ); ▁} ▁if ▁( connect ( fd , ▁cur _ addr -> ai _ addr , ▁cur _ addr -> ai _ addr len ) ▁< ▁0) ▁{ ▁EST _ LOG _ WARN (" connect ▁failed : ▁% d ", ▁GET _ SOCK _ ERR ()); ▁ret ▁= ▁TC W _ ERR _ CONNECT ; ▁/* ▁ CLOSE _ SOCKET () ▁ma y ▁cl ob b er ▁SOCK _ ERR ▁*/ ▁saved _ err ▁= ▁GET _ SOCK _ ERR (); ▁ CLOSE _ SOCKET ( fd ); ▁fd ▁= ▁SOCK _ INVALID ; ▁SET _ SOCK _ ERR ( save d _ err ); ▁cur _ addr ▁= ▁cur _ addr -> ai _ next ; ▁continue ; ▁} ▁break ; ▁} ▁if ▁( fd ▁>= ▁0) ▁{ ▁sock -> sock _ fd ▁= ▁fd ; ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" C ould ▁not ▁connect ▁to ▁% s :% hu ", ▁host , ▁port ); ▁/* ▁ret ▁and ▁SOCK _ ERR ▁already ▁set ▁*/ ▁} ▁done : ▁return ▁ret ; ▁} ▁/* ▁* ▁E stablish ▁a ▁direct ▁socket ▁connection ▁with ▁the ▁EST ▁server ▁using ▁* ▁normal ▁system ▁calls ▁*/ ▁static ▁t cw _ err _ t ▁t cw _ curl _ close ▁( t cw _ sock _ t ▁* sock ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁if ▁( sock -> curl _ handle ) ▁{ ▁curl _ easy _ cleanup ( sock -> curl _ handle ); ▁} ▁sock -> curl _ handle ▁= ▁NULL ; ▁sock -> sock _ fd ▁= ▁SOCK _ INVALID ; ▁return ▁ret ; ▁} ▁/* ▁* ▁E stablish ▁a ▁direct ▁socket ▁connection ▁with ▁the ▁EST ▁server ▁using ▁* ▁normal ▁system ▁calls ▁*/ ▁static ▁t cw _ err _ t ▁set _ blocking _ mode ▁( t cw _ sock _ t ▁* sock , ▁int ▁blocking ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁# if def ▁WI N 32 ▁int ▁result ; ▁un signed ▁long ▁mode ▁= ▁blocking ▁? ▁0 ▁: ▁1; ▁result ▁= ▁ioctlsocket ( sock -> sock _ fd , ▁F ION BIO , ▁& mode ); ▁if ▁( result ▁ != ▁ NO _ ERROR ) ▁{ ▁/* ▁* ▁A s ▁per : ▁* ▁http s :// m s d n . m ic ro soft . com / en - us / library / window s / des k top / m s 74 0 1 26 ( v = v s .85 ) . a s px ▁* ▁* ▁I o c tl ▁and ▁I o c tl socket / W S A I o c tl ▁* ▁* ▁V a ri ous ▁C ▁language ▁run - time ▁system s ▁use ▁the ▁ IO CT L s ▁for ▁purposes ▁* ▁un re lated ▁to ▁Windows ▁ Socket s . ▁A s ▁a ▁con sequence , ▁the ▁ioctlsocket ▁* ▁function ▁and ▁the ▁WSA I o c tl ▁function ▁we re ▁defined ▁to ▁handle ▁socket ▁* ▁functions ▁that ▁we re ▁performed ▁by ▁ IO CT L ▁and ▁ fcntl ▁in ▁the ▁Be rke le y ▁* ▁S of t ware ▁Distribution . ▁* ▁* ▁S ince ▁ioctlsocket ▁is ▁the ▁Windows ▁ equiv a len t ▁of ▁ io c tl / fcntl , ▁just ▁* ▁set ▁return ▁type ▁according ly . ▁*/ ▁ret ▁= ▁TC W _ ERR _ FC NTL ; ▁go to ▁done ; ▁} ▁# else ▁int ▁flags ▁= ▁ fcntl ( sock -> sock _ fd , ▁F _ GET FL ); ▁if ▁( flags ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" fcntl ( F _ GET FL ) ▁failed : ▁% d ", ▁GET _ SOCK _ ERR ()); ▁/* ▁SOCK _ ERR ▁is ▁already ▁set ▁*/ ▁ret ▁= ▁TC W _ ERR _ FC NTL ; ▁go to ▁done ; ▁} ▁flags ▁= ▁blocking ▁? ▁( flags ▁& ▁ ~ O _ NON B LO CK ) ▁: ▁( flags ▁| ▁O _ NON B LO CK ); ▁if ▁( fcntl ( sock -> sock _ fd , ▁F _ SET FL , ▁flags ) ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" fcntl ( F _ SET FL ) ▁failed : ▁% d ", ▁GET _ SOCK _ ERR ()); ▁/* ▁SOCK _ ERR ▁is ▁already ▁set ▁*/ ▁ret ▁= ▁TC W _ ERR _ FC NTL ; ▁go to ▁done ; ▁} ▁# endif ▁/* ▁WI N 32 ▁*/ ▁done : ▁return ▁ret ; ▁} ▁/* ▁* ▁E stablish ▁a ▁socket ▁with ▁the ▁remote ▁server ▁using ▁libcurl . ▁Do ▁not ▁have ▁it ▁* ▁ actually ▁send ▁a ▁ URL . ▁ Le verage ▁libcurl ' s ▁proxy ▁support ▁to ▁just ▁establish ▁* ▁the ▁connection . ▁*/ ▁static ▁t cw _ err _ t ▁t cw _ curl _ connect ▁( t cw _ sock _ t ▁* sock , ▁t cw _ opts _ t ▁* opts , ▁const ▁char ▁* host , ▁un signed ▁short ▁int ▁port ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁size _ t ▁url _ size ; ▁char ▁* url ▁= ▁NULL ; ▁CURL code ▁curlcode ; ▁long ▁curl _ socket ; ▁long ▁auth _ bits ; ▁long ▁proxy _ type ▁= ▁-1; ▁int ▁saved _ err ; ▁const ▁char ▁* proxy _ type _ str ▁= ▁" NONE "; ▁int ▁n ; ▁sock -> curl _ handle ▁= ▁curl _ easy _ init (); ▁if ▁(! sock -> curl _ handle ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ init ▁failed "); ▁errno ▁= ▁E NOMEM ; ▁ret ▁= ▁TC W _ ERR _ ALLOC ; ▁go to ▁done ; ▁} ▁/* ▁* ▁All ▁we ▁want ▁libcurl ▁to ▁do ▁here ▁is ▁establish ▁the ▁connection ▁to ▁* ▁the ▁proxy ▁server . ▁On ce ▁that ' s ▁done ▁we ' ll ▁use ▁the ▁socket ▁* ▁as ▁we ▁normal ly ▁do ▁on ▁a ▁direct ▁connect ▁to ▁the ▁EST ▁server ▁*/ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ CONNECT _ ONLY , ▁1); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ CONNECT _ ONLY ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁url _ size ▁= ▁str len ( host ) ▁+ ▁TC W _ URL _ S CH E MA _ PORT _ SIZE ; ▁url ▁= ▁( char ▁* ) calloc ( 1, ▁url _ size ); ▁if ▁(! url ) ▁{ ▁EST _ LOG _ ERR (" calloc ▁failed "); ▁errno ▁= ▁E NOMEM ; ▁ret ▁= ▁TC W _ ERR _ ALLOC ; ▁go to ▁done ; ▁} ▁/* ▁* ▁" http " ▁here ▁is ▁tell ing ▁libcurl ▁not ▁to ▁wrap ▁what ever ▁data ▁we ▁send ▁in ▁* ▁SSL . ▁*/ ▁n ▁= ▁ snprintf ( url , ▁url _ size -1 , ▁" http :// % s :% hu ", ▁host , ▁port ); ▁if ▁( n ▁< ▁0 ▁|| ▁n ▁>= ▁( int ) url _ size ) ▁{ ▁errno ▁= ▁E NOMEM ; ▁ret ▁= ▁TC W _ ERR _ ALLOC ; ▁go to ▁done ; ▁} ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ URL , ▁url ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ URL ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁/* ▁* ▁proxy ▁host ▁and ▁port ▁*/ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY , ▁opts -> proxy _ host ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY PORT , ▁opts -> proxy _ port ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY PORT ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁/* ▁* ▁proxy ▁protocol ▁includ ing ▁HTTP ▁tunnel ▁mode ▁*/ ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ HTTP _ NOTUNNEL ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ HTTP ; ▁proxy _ type _ str ▁= ▁" HTTP ▁( no ▁tunnel ing ) "; ▁} ▁else ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ HTTP _ TUNNEL ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ HTTP ; ▁proxy _ type _ str ▁= ▁" HTTP ▁( t un n el ing ) "; ▁} ▁else ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ SOCKS 4 ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ SOCKS 4 ; ▁proxy _ type _ str ▁= ▁" SOCKS 4 "; ▁} ▁else ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ SOCKS 5 ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ SOCKS 5 ; ▁proxy _ type _ str ▁= ▁" SOCKS 5 "; ▁} ▁else ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ SOCKS 4 A ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ SOCKS 4 A ; ▁proxy _ type _ str ▁= ▁" SOCKS 4 A "; ▁} ▁else ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ SOCKS 5 _ HOSTNAME ) ▁{ ▁proxy _ type ▁= ▁CURL PROXY _ SOCKS 5 _ HOSTNAME ; ▁proxy _ type _ str ▁= ▁" SOCKS 5 _ HOSTNAME "; ▁} ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY TYPE , ▁proxy _ type ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY TYPE ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁if ▁( opts -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ HTTP _ TUNNEL ) ▁{ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ HTTP PROXY TUNNEL , ▁1); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ HTTP PROXY TUNNEL ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁} ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY AUTH , ▁CURL AUTH _ BASIC | CURL AUTH _ ONLY ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY AUTH ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁/* ▁* ▁username ▁and ▁password ▁*/ ▁if ▁( opts -> proxy _ username ▁&& ▁opts -> proxy _ password ) ▁{ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY USER NAME , ▁opts -> proxy _ username ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY USER NAME ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY PASSWORD , ▁opts -> proxy _ password ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY PASSWORD ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁auth _ bits ▁= ▁0; ▁if ▁( opts -> proxy _ auth ▁& ▁EST _ CLIENT _ PROXY _ AUTH _ BASIC ) ▁{ ▁auth _ bits ▁| = ▁CURL AUTH _ BASIC ; ▁} ▁if ▁( opts -> proxy _ auth ▁& ▁EST _ CLIENT _ PROXY _ AUTH _ NTLM ) ▁{ ▁auth _ bits ▁| = ▁CURL AUTH _ NTLM ; ▁} ▁if ▁( auth _ bits ) ▁{ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ PROXY AUTH , ▁auth _ bits ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ PROXY AUTH ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁} ▁} ▁/* ▁* ▁no ▁signal s ▁generated ▁from ▁libcurl ▁*/ ▁curlcode ▁= ▁curl _ easy _ set opt ( sock -> curl _ handle , ▁CURL OPT _ NOSIGNAL , ▁1); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ set opt ( CURL OPT _ NOSIGNAL ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁/* ▁* ▁perform ▁the ▁curl ▁request ▁*/ ▁EST _ LOG _ INFO (" curl _ easy _ perform ( % s ) , ▁proxy ▁type ▁% s ", ▁url , ▁proxy _ type _ str ); ▁curlcode ▁= ▁curl _ easy _ perform ( sock -> curl _ handle ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ perform ( % s ) ▁returned ▁% d : ▁% s ", ▁url , ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁if ▁( curlcode ▁== ▁CURL E _ C O U L D NT _ RESOLV E _ PROXY ▁|| ▁curlcode ▁== ▁CURL E _ C O U L D NT _ RESOLV E _ HOST ) ▁{ ▁SET _ SOCK _ ERR _ NO NAME (); ▁ret ▁= ▁TC W _ ERR _ RESOLV ; ▁go to ▁done ; ▁} ▁else ▁{ ▁SET _ SOCK _ ERR _ CON N (); ▁ret ▁= ▁TC W _ ERR _ CONNECT ; ▁go to ▁done ; ▁} ▁} ▁/* ▁* ▁retrieve ▁the ▁socket ▁from ▁libcurl ▁*/ ▁curlcode ▁= ▁curl _ easy _ get info ( sock -> curl _ handle , ▁CURL INFO _ LASTSOCKET , ▁& curl _ socket ); ▁if ▁( curlcode ▁ != ▁CURL E _ OK ) ▁{ ▁EST _ LOG _ ERR (" curl _ easy _ get info ( CURL INFO _ LASTSOCKET ) ▁returned ▁% d : ▁% s ", ▁curlcode , ▁curl _ easy _ str error ( curlcode )); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁if ▁( curl _ socket ▁== ▁-1) ▁{ ▁EST _ LOG _ ERR (" CURL INFO _ LASTSOCKET : ▁invalid ▁socket "); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ OT HER ; ▁go to ▁done ; ▁} ▁sock -> sock _ fd ▁= ▁curl _ socket ; ▁/* ▁after ▁connection ▁is ▁made , ▁set ▁socket ▁to ▁blocking ▁*/ ▁ret ▁= ▁set _ blocking _ mode ( sock , ▁1); ▁if ▁( ret ▁ != ▁TC W _ OK ) ▁{ ▁/* ▁SOCK _ ERR ▁is ▁already ▁set ▁*/ ▁EST _ LOG _ ERR (" Failed ▁to ▁set ▁socket ▁to ▁blocking "); ▁go to ▁done ; ▁} ▁done : ▁free ( url ); ▁url ▁= ▁NULL ; ▁if ▁( ret ▁ != ▁TC W _ OK ) ▁{ ▁saved _ err ▁= ▁GET _ SOCK _ ERR (); ▁t cw _ curl _ close ( sock ); ▁SET _ SOCK _ ERR ( save d _ err ); ▁} ▁return ▁ret ; ▁} ▁/* ▁* ▁entry ▁point ▁to ▁establish ▁a ▁connection ▁with ▁the ▁remote ▁EST ▁server ▁*/ ▁t cw _ err _ t ▁t cw _ connect ▁( t cw _ sock _ t ▁* sock , ▁t cw _ opts _ t ▁* opts , ▁const ▁char ▁* host , ▁un signed ▁short ▁int ▁port , ▁SOCK _ TYPE ▁* sock _ fd ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁memset ( sock , ▁0, ▁sizeof ( t cw _ sock _ t )); ▁sock -> sock _ fd ▁= ▁SOCK _ INVALID ; ▁sock -> proxy _ proto ▁= ▁opts -> proxy _ proto ; ▁if ▁( sock -> proxy _ proto ▁ != ▁EST _ CLIENT _ PROXY _ NONE ) ▁{ ▁# if def ▁HAV E _ LIB CURL ▁ret ▁= ▁t cw _ curl _ connect ( sock , ▁opts , ▁host , ▁port ); ▁# else ▁/* ▁* ▁We ▁should ▁not ▁make ▁it ▁this ▁far , ▁but ▁if ▁we ▁do , ▁* ▁log ▁a ▁message ▁as ▁to ▁wh y ▁this ▁is ▁w rong ▁and ▁return ▁*/ ▁EST _ LOG _ ERR (" Proxy ▁setting s ▁currently ▁require ▁libcurl "); ▁errno ▁= ▁E INVAL ; ▁ret ▁= ▁TC W _ ERR _ ARG ; ▁go to ▁done ; ▁# endif ▁} ▁else ▁{ ▁ret ▁= ▁t cw _ direct _ connect ( sock , ▁opts , ▁host , ▁port ); ▁} ▁if ▁( ret ▁ != ▁TC W _ OK ) ▁{ ▁go to ▁done ; ▁} ▁EST _ LOG _ INFO (" Success fully ▁ connected ▁to ▁% s :% hu ", ▁host , ▁port ); ▁* sock _ fd ▁= ▁sock -> sock _ fd ; ▁done : ▁return ▁ret ; ▁} ▁/* ▁* ▁entry ▁point ▁to ▁establish ▁a ▁connection ▁with ▁the ▁remote ▁EST ▁server ▁*/ ▁t cw _ err _ t ▁t cw _ close ▁( t cw _ sock _ t ▁* sock ) ▁{ ▁t cw _ err _ t ▁ret ▁= ▁TC W _ OK ; ▁if ▁( sock -> proxy _ proto ▁== ▁EST _ CLIENT _ PROXY _ NONE ) ▁{ ▁ret ▁= ▁t cw _ direct _ close ( sock ); ▁} ▁else ▁{ ▁# if def ▁HAV E _ LIB CURL ▁ret ▁= ▁t cw _ curl _ close ( sock ); ▁# endif ▁} ▁return ▁ret ; ▁}