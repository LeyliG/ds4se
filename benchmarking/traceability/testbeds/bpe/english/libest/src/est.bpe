▁static ▁void ▁(* est _ log _ func ) ( char ▁* , ▁va _ list ) ▁= ▁NULL ; ▁/* ▁* ▁This ▁is ▁our ▁default ▁logger ▁routine , ▁which ▁just ▁* ▁ dump s ▁log ▁data ▁to ▁ stderr . ▁The ▁application ▁can ▁* ▁override ▁this ▁by ▁call ing ▁est _ init _ logger () ▁and ▁* ▁pass ing ▁in ▁a ▁function ▁pointer ▁to ▁a ▁function ▁* ▁that ▁implement s ▁this ▁prototype . ▁*/ ▁static ▁void ▁est _ logger _ stderr ▁( char ▁* format , ▁va _ list ▁l ) ▁{ ▁# if ndef ▁WI N 32 ▁f lock file ( stderr ); ▁# endif ▁vf printf ( stderr , ▁format , ▁l ); ▁f flu sh ( stderr ); ▁# if ndef ▁WI N 32 ▁f unlock file ( stderr ); ▁# endif ▁} ▁/* ▁* ▁This ▁is ▁our ▁default ▁logger ▁routine , ▁which ▁just ▁* ▁ dump s ▁log ▁data ▁to ▁ stderr . ▁The ▁application ▁can ▁* ▁override ▁this ▁by ▁call ing ▁est _ init _ logger () ▁and ▁* ▁pass ing ▁in ▁a ▁function ▁pointer ▁to ▁a ▁function ▁* ▁that ▁implement s ▁this ▁prototype . ▁*/ ▁static ▁void ▁est _ log _ msg ▁( char ▁* format , ▁...) ▁{ ▁va _ list ▁arguments ; ▁/* ▁* ▁P ul l ▁the ▁arguments ▁from ▁the ▁stack ▁and ▁invoke ▁* ▁the ▁logger ▁function ▁*/ ▁va _ start ( arguments , ▁format ); ▁if ▁( est _ log _ func ▁ != ▁NULL ) ▁{ ▁(* est _ log _ func ) ( format , ▁arguments ); ▁} ▁else ▁{ ▁est _ logger _ stderr ( format , ▁arguments ); ▁} ▁va _ end ( arguments ); ▁} ▁/* ▁* ▁Global ▁function ▁to ▁be ▁called ▁to ▁log ▁something ▁*/ ▁void ▁est _ log ▁( EST _ LOG _ LEVEL ▁lvl , ▁char ▁* format , ▁...) ▁{ ▁va _ list ▁arguments ; ▁/* ▁* ▁check ▁if ▁user ▁is ▁interest ed ▁in ▁this ▁log ▁message ▁*/ ▁if ▁( lvl ▁> ▁est _ desired _ log _ lvl ) ▁{ ▁return ; ▁} ▁/* ▁* ▁P ul l ▁the ▁arguments ▁from ▁the ▁stack ▁and ▁invoke ▁* ▁the ▁logger ▁function ▁*/ ▁va _ start ( arguments , ▁format ); ▁if ▁( est _ log _ func ▁ != ▁NULL ) ▁{ ▁(* est _ log _ func ) ( format , ▁arguments ); ▁} ▁else ▁{ ▁est _ logger _ stderr ( format , ▁arguments ); ▁} ▁va _ end ( arguments ); ▁} ▁/* ▁* ▁Global ▁function ▁to ▁be ▁called ▁to ▁log ▁something ▁*/ ▁static ▁void ▁print Stack T race ( void ) ▁{ ▁un signed ▁int ▁i ; ▁void ▁* stack [100 ] ; ▁un signed ▁short ▁frames ; ▁ SYMB OL _ INFO ▁* ▁symbol ; ▁ HANDLE ▁process ; ▁process ▁= ▁GetCurrent Process (); ▁S y m Init ial ize ( process , ▁NULL , ▁T RU E ); ▁frames ▁= ▁C apt u re Stack Back T race (0, ▁100 , ▁stack , ▁NULL ); ▁symbol ▁= ▁( SYMB OL _ INFO ▁* ) calloc ( sizeof ( SYMB OL _ INFO ) ▁+ ▁256 ▁* ▁sizeof ( char ) , ▁1); ▁symbol -> Max Name L en ▁= ▁255 ; ▁symbol -> S ize Of Str u ct ▁= ▁sizeof ( SYMB OL _ INFO ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁frames ; ▁i ++) ▁{ ▁S y m FromAddr ( process , ▁( D WORD 64 ) ( stack [ i ] ) , ▁0, ▁symbol ); ▁est _ log _ msg ("\ n % i : ▁ [0 x % 0 X ] ▁% s ", ▁( f r ame s ▁- ▁i ▁- ▁1) , ▁symbol -> Address , ▁symbol -> Name ); ▁} ▁free ( s y m b ol ); ▁} ▁/* ▁* ▁Global ▁function ▁to ▁be ▁called ▁to ▁log ▁something ▁*/ ▁void ▁est _ log _ backtrace ▁( void ) ▁{ ▁# if ndef ▁ DISABLE _ BA CK T RA CE ▁# if def ▁WI N 32 ▁/* ▁* ▁Spi t ▁out ▁a ▁ backtrace ▁if ▁this ▁is ▁enabled ▁global ly ▁*/ ▁if ▁( est _ backtrace _ enabled ) ▁{ ▁print Stack T race (); ▁} ▁# else ▁void * ▁ callstack [ 128 ] ; ▁char ▁** str s ; ▁int ▁i , ▁frames ; ▁/* ▁* ▁Spi t ▁out ▁a ▁ backtrace ▁if ▁this ▁is ▁enabled ▁global ly ▁*/ ▁if ▁( est _ backtrace _ enabled ) ▁{ ▁frames ▁= ▁ backtrace ( callstack , ▁128) ; ▁str s ▁= ▁ backtrace _ s y m b ol s ( callstack , ▁frames ); ▁for ▁( i ▁= ▁0; ▁i ▁< ▁frames ; ▁ ++ i ) ▁{ ▁est _ log _ msg ("\ n % s ", ▁str s [ i ] ); ▁// f printf ( stderr , ▁"% s \ n ", ▁str s [ i ] ); ▁} ▁est _ log _ msg ("\ n \ n "); ▁free ( str s ); ▁} ▁# endif ▁/* ▁WI N 32 */ ▁# endif ▁/* ▁ DISABLE _ BA CK T RA CE */ ▁} ▁/* ! ▁@ br i ef ▁est _ get _ version () ▁allow s ▁the ▁application ▁to ▁retrieve ▁the ▁libEST ▁version ▁string . ▁Returns ▁a ▁char * ▁array ▁containing ▁the ▁full ▁version ▁string ▁value ▁for ▁the ▁library . ▁@ return ▁const ▁char * ▁*/ ▁const ▁char ▁* ▁est _ get _ version ▁( void ) ▁{ ▁return ▁EST _ VER _ STRING ; ▁} ▁/* ! ▁@ br i ef ▁est _ get _ api _ level () ▁allow s ▁the ▁application ▁to ▁retrieve ▁the ▁libEST ▁API ▁level . ▁This ▁is ▁a ▁numer ic ▁value ▁that ▁indicate s ▁the ▁API ▁level ▁of ▁the ▁library . ▁When ▁new ▁version s ▁of ▁libEST ▁are ▁release d ▁and ▁the ▁API ▁changes , ▁this ▁value ▁will ▁be ▁i ncrement ed . ▁Application s ▁can ▁use ▁this ▁to ▁determine ▁which ▁capabilities ▁in ▁the ▁libEST ▁library ▁should ▁or ▁should ▁not ▁be ▁attempted . ▁@ return ▁int ▁*/ ▁int ▁est _ get _ api _ level ▁( void ) ▁{ ▁return ▁EST _ API _ LEVEL ; ▁} ▁/* ▁* ▁Use ▁this ▁to ▁log ▁the ▁libEST ▁version ▁to ▁an ▁information ▁* ▁log ▁message . ▁Also ▁log s ▁the ▁compile - time ▁and ▁run - time ▁* ▁OpenSSL ▁version s . ▁*/ ▁void ▁est _ log _ version ▁( void ) ▁{ ▁EST _ LOG _ INFO ("% s ▁( API ▁level ▁% d )", ▁est _ get _ version (), ▁est _ get _ api _ level ()); ▁# if def ▁S OUR CE _ REV IS ION ▁EST _ LOG _ INFO (" Source ▁re pos i tory ▁re v is ion # ▁% d ", ▁S OUR CE _ REV IS ION ); ▁# endif ▁EST _ LOG _ INFO (" Compile d ▁against ▁% s ", ▁O PEN SSL _ VERSION _ TEXT ); ▁EST _ LOG _ INFO (" Link ing ▁to ▁% s ", ▁SSL e a y _ version ( SSL E AY _ VERSION )); ▁} ▁/* ! ▁@ br i ef ▁est _ init _ logger () ▁allow s ▁the ▁application ▁to ▁override ▁the ▁default ▁log ▁handler ▁for ▁EST ▁logging ▁messages . ▁@ param ▁lvl ▁Set s ▁the ▁desired ▁logging ▁level ▁to ▁EST _ LOG _ LEVEL ▁@ param ▁ loggerfunc ▁Set s ▁the ▁callback ▁function ▁to ▁handle ▁logging ▁This ▁function ▁allow s ▁an ▁application ▁that ▁uses ▁EST ▁to ▁provide ▁a ▁function ▁for ▁logging ▁EST ▁messages . ▁EST ▁provide s ▁a ▁default ▁handler ▁that ▁send s ▁messages ▁to ▁ stderr . ▁Application s ▁ma y ▁desire ▁to ▁send ▁messages ▁to ▁sys log ▁or ▁some ▁other ▁logging ▁facility . ▁An ▁application ▁woul d ▁provide ▁a ▁function ▁pointer ▁using ▁this ▁method ▁to ▁inter cept ▁and ▁handle ▁EST ▁log ▁messages . ▁This ▁setting ▁is ▁global ▁to ▁the ▁library ▁and ▁will ▁imp act ▁all ▁context s . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ init _ logger ▁( EST _ LOG _ LEVEL ▁lvl , ▁void ▁(* loggerfunc ) ( char ▁* , ▁va _ list )) ▁{ ▁/* ▁Initialize ▁the ▁logger ▁*/ ▁if ▁( loggerfunc ) ▁{ ▁est _ log _ func ▁= ▁ loggerfunc ; ▁} ▁else ▁{ ▁/* ▁install ▁our ▁default ▁logger ▁*/ ▁est _ log _ func ▁= ▁& est _ logger _ stderr ; ▁} ▁/* ▁* ▁Set ▁the ▁desired ▁logging ▁level ▁*/ ▁est _ desired _ log _ lvl ▁= ▁lvl ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ enable _ backtrace () ▁allow s ▁the ▁application ▁to ▁to gg le ▁whether ▁the ▁stack ▁t race ▁is ▁displayed ▁for ▁WARNING ▁and ▁ ERROR ▁log ▁messages ▁coming ▁from ▁libEST . ▁@ param ▁enable ▁Set ▁to ▁zero ▁to ▁disable ▁stack ▁traces , ▁non - zero ▁to ▁enable ▁stack ▁traces ▁through ▁the ▁logging ▁facility . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁enable ▁stack ▁traces , ▁which ▁ma y ▁be ▁useful ▁for ▁ tr ou ble sh o o ting ▁the ▁libEST ▁library . ▁ Stack ▁traces ▁are ▁disabled ▁by ▁default . ▁Call ▁this ▁function ▁with ▁a ▁non - zero ▁argument ▁to ▁enable ▁stack ▁traces ▁for ▁both ▁WARNING ▁and ▁ ERROR ▁log ▁messages . ▁This ▁setting ▁is ▁global ▁to ▁the ▁library ▁and ▁will ▁imp act ▁all ▁context s . ▁@ return ▁void . ▁*/ ▁void ▁est _ enable _ backtrace ▁( int ▁enable ) ▁{ ▁est _ backtrace _ enabled ▁= ▁enable ; ▁} ▁/* ! ▁@ br i ef ▁est _ read _ x 509_ request () ▁is ▁a ▁ helper ▁function ▁that ▁read s ▁* ▁a ▁char * ▁and ▁convert s ▁it ▁to ▁an ▁OpenSSL ▁X 509_ REQ * . ▁The ▁char * ▁data ▁* ▁can ▁be ▁e i ther ▁PEM ▁or ▁DER ▁encoded . ▁@ param ▁csr ▁This ▁is ▁the ▁char * ▁that ▁contains ▁the ▁PEM ▁or ▁DER ▁encoded ▁X 509 ▁CSR . ▁@ param ▁csr _ len ▁This ▁is ▁the ▁length ▁of ▁the ▁csr ▁char * . ▁DER ▁encoded ▁data ▁ma y ▁contain ▁zero s , ▁which ▁requires ▁the ▁length ▁to ▁be ▁provided ▁by ▁the ▁application ▁layer . ▁@ param ▁csr _ format ▁This ▁parameter ▁specifie s ▁the ▁encoding ▁method ▁of ▁the ▁csr ▁char * ▁that ▁was ▁provided . ▁Set ▁this ▁to ▁e i ther ▁EST _ CERT _ FORMAT _ PEM ▁or ▁EST _ CERT _ FORMAT _ DER . ▁This ▁function ▁convert s ▁a ▁PEM ▁or ▁DER ▁encoded ▁char * ▁to ▁the ▁OpenSSL ▁X 509_ REQ ▁structure . ▁This ▁function ▁will ▁return ▁NULL ▁if ▁the ▁PEM / DER ▁data ▁is ▁corrupted ▁or ▁un able ▁to ▁be ▁parsed ▁by ▁the ▁OpenSSL ▁library . ▁This ▁function ▁will ▁allocate ▁memory ▁for ▁the ▁X 509_ REQ ▁data . ▁You ▁must ▁free ▁the ▁memory ▁in ▁your ▁application ▁when ▁it ' s ▁no ▁long er ▁needed ▁by ▁call ing ▁X 509_ REQ _ free (). ▁@ return ▁X 509_ REQ * ▁*/ ▁X 509_ REQ ▁* est _ read _ x 509_ request ▁( un signed ▁char ▁* csr , ▁int ▁csr _ len , ▁EST _ CERT _ FORMAT ▁csr _ format ) ▁{ ▁X 509_ REQ ▁* req ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁long ▁err ; ▁if ▁(! csr ) ▁{ ▁EST _ LOG _ ERR (" CSR ▁ma y ▁not ▁be ▁NULL "); ▁return ▁( NULL ); ▁} ▁if ▁( csr _ len ▁> ▁EST _ RA W _ CSR _ LEN _ MAX ) ▁{ ▁EST _ LOG _ ERR (" CSR ▁length ▁is ▁greate r ▁than ▁maximum ▁allowed ▁(% d )", ▁EST _ RA W _ CSR _ LEN _ MAX ); ▁return ▁( NULL ); ▁} ▁if ▁( csr _ format ▁ != ▁EST _ CERT _ FORMAT _ PEM ▁&& ▁csr _ format ▁ != ▁EST _ CERT _ FORMAT _ DER ) ▁{ ▁EST _ LOG _ ERR (" Only ▁PEM ▁and ▁DER ▁encoding ▁format s ▁are ▁supported . "); ▁return ▁( NULL ); ▁} ▁in ▁= ▁BIO _ new _ mem _ buf ( csr , ▁csr _ len ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁the ▁CSR ▁memory ▁buffer "); ▁return ▁( NULL ); ▁} ▁switch ▁( csr _ format ) ▁{ ▁case ▁EST _ CERT _ FORMAT _ PEM : ▁req ▁= ▁PEM _ read _ bio _ X 509_ REQ ( in , NULL , NULL , NULL ); ▁break ; ▁case ▁EST _ CERT _ FORMAT _ DER : ▁req ▁= ▁d 2 i _ X 509_ REQ _ bio ( in , NULL ); ▁break ; ▁default : ▁EST _ LOG _ ERR (" I nvalid ▁CSR ▁format ▁specified . "); ▁break ; ▁} ▁/* ▁* ▁Check ▁for ▁an ▁error ▁while ▁parsing ▁the ▁input ▁data ▁*/ ▁if ▁(! req ) ▁{ ▁EST _ LOG _ ERR (" An ▁error ▁occurred ▁in ▁the ▁OpenSSL ▁library ▁while ▁reading ▁the ▁CSR ▁data . "); ▁err ▁= ▁ ERR _ get _ error (); ▁EST _ LOG _ ERR (" OpenSSL ▁error ▁string : ▁% s ", ▁ ERR _ error _ string ( err , ▁NULL )); ▁} ▁BIO _ free _ all ( in ); ▁return ▁( req ); ▁} ▁/* ! ▁@ br i ef ▁est _ load _ key () ▁is ▁a ▁ helper ▁function ▁that ▁read s ▁* ▁a ▁char * ▁and ▁convert s ▁it ▁to ▁an ▁OpenSSL ▁E VP _ PKEY * . ▁The ▁char * ▁data ▁* ▁can ▁be ▁e i ther ▁PEM ▁or ▁DER ▁encoded . ▁@ param ▁key ▁This ▁is ▁the ▁char * ▁that ▁contains ▁the ▁PEM ▁or ▁DER ▁encoded ▁key ▁pair . ▁@ param ▁key _ len ▁This ▁is ▁the ▁length ▁of ▁the ▁key ▁char * . ▁DER ▁encoded ▁data ▁ma y ▁contain ▁zero s , ▁which ▁requires ▁the ▁length ▁to ▁be ▁provided ▁by ▁the ▁application ▁layer . ▁@ param ▁key _ format ▁This ▁parameter ▁specifie s ▁the ▁encoding ▁method ▁of ▁the ▁key ▁char * ▁that ▁was ▁provided . ▁Set ▁this ▁to ▁e i ther ▁EST _ FORMAT _ PEM ▁or ▁EST _ FORMAT _ DER . ▁This ▁function ▁convert s ▁a ▁PEM ▁or ▁DER ▁encoded ▁char * ▁to ▁the ▁OpenSSL ▁E VP _ PKEY * ▁structure . ▁This ▁function ▁will ▁return ▁NULL ▁if ▁the ▁PEM / DER ▁data ▁is ▁corrupted ▁or ▁un able ▁to ▁be ▁parsed ▁by ▁the ▁OpenSSL ▁library . ▁This ▁function ▁will ▁allocate ▁memory ▁for ▁the ▁E VP _ PKEY ▁data . ▁You ▁must ▁free ▁the ▁memory ▁in ▁your ▁application ▁when ▁it ' s ▁no ▁long er ▁needed ▁by ▁call ing ▁E VP _ PKEY _ free (). ▁@ return ▁E VP _ PKEY * ▁*/ ▁E VP _ PKEY ▁* est _ load _ key ▁( un signed ▁char ▁* key , ▁int ▁key _ len , ▁int ▁format ) ▁{ ▁BIO ▁* in ▁= ▁NULL ; ▁E VP _ PKEY ▁* pkey ▁= ▁NULL ; ▁if ▁( key ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" no ▁key ▁data ▁provided "); ▁return ▁NULL ; ▁} ▁in ▁= ▁BIO _ new _ mem _ buf ( key , ▁key _ len ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁the ▁provided ▁key ▁buffer "); ▁return ▁( NULL ); ▁} ▁switch ▁( format ) ▁{ ▁case ▁EST _ FORMAT _ PEM : ▁pkey ▁= ▁PEM _ read _ bio _ PrivateKey ( in , ▁NULL , ▁NULL , ▁NULL ); ▁break ; ▁case ▁EST _ FORMAT _ DER : ▁pkey ▁= ▁d 2 i _ PrivateKey _ bio ( in , ▁NULL ); ▁break ; ▁default : ▁EST _ LOG _ ERR (" I nvalid ▁key ▁format "); ▁BIO _ free ( in ); ▁return ▁NULL ; ▁break ; ▁} ▁BIO _ free ( in ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁Convert s ▁from ▁PEM ▁to ▁pkcs 7 ▁encoded ▁certs . ▁ Optional ly ▁* ▁applies ▁base 64 ▁encoding ▁to ▁the ▁output . ▁This ▁is ▁used ▁* ▁when ▁creating ▁the ▁cached ▁cacerts ▁response . ▁The ▁returned ▁* ▁BIO ▁contains ▁the ▁PKCS 7 ▁encoded ▁certs . ▁The ▁response ▁* ▁can ▁optional ly ▁be ▁base 64 ▁encoded ▁by ▁pass ing ▁in ▁a ▁* ▁non - zero ▁value ▁for ▁the ▁do _ base _ 64 ▁argument . ▁The ▁caller ▁* ▁of ▁this ▁function ▁should ▁invoke ▁BIO _ free _ all () ▁on ▁the ▁* ▁return ▁value ▁to ▁a void ▁memory ▁leak s . ▁Note , ▁BIO _ free () ▁* ▁will ▁not ▁be ▁sufficient . ▁*/ ▁static ▁BIO ▁* ▁est _ get _ certs _ pkcs 7 ▁( BIO ▁* in , ▁int ▁do _ base _ 64 ) ▁{ ▁STA CK _ OF ( X 509 ) ▁* ▁cert _ stack ▁= ▁NULL ; ▁PKCS 7_ SIGNED ▁* p 7 s ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 ▁= ▁NULL ; ▁BIO ▁* out ▁= ▁NULL ; ▁BIO ▁* b 64 ; ▁int ▁buflen ▁= ▁0; ▁/* ▁* ▁Create ▁a ▁PKCS 7 ▁object ▁*/ ▁if ▁( ( p 7 ▁= ▁PKCS 7_ new ()) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" pkcs 7_ new ▁failed "); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁Create ▁the ▁PKCS 7 ▁signed ▁object ▁*/ ▁if ▁( ( p 7 s ▁= ▁PKCS 7_ SIGNED _ new ()) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" pkcs 7_ signed _ new ▁failed "); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁Set ▁the ▁version ▁*/ ▁if ▁(! ASN 1 _ INTE GE R _ set ( p 7 s -> version , ▁1)) ▁{ ▁EST _ LOG _ ERR (" ASN 1 _ int eg er _ set ▁failed "); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁Create ▁a ▁stack ▁of ▁X 509 ▁certs ▁*/ ▁if ▁( ( cert _ stack ▁= ▁sk _ X 509_ new _ null ()) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" stack ▁malloc ▁failed "); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁ Pop ul ate ▁the ▁cert ▁stack ▁*/ ▁if ▁( est _ add _ certs _ from _ BIO ( cert _ stack , ▁in ) ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁load ▁certificates "); ▁ossl _ dump _ ssl _ errors (); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁Create ▁the ▁BIO ▁which ▁will ▁receive ▁the ▁output ▁*/ ▁out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁(! out ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed "); ▁go to ▁cleanup ; ▁} ▁/* ▁* ▁Add ▁the ▁base 64 ▁encode r ▁if ▁needed ▁*/ ▁if ▁( do _ base _ 64 ) ▁{ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁base 64 ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁go to ▁cleanup ; ▁} ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁} ▁p 7-> type ▁= ▁OBJ _ nid 2 obj ( NID _ pkcs 7_ signed ); ▁p 7-> d . sign ▁= ▁p 7 s ; ▁p 7 s -> content s -> type ▁= ▁OBJ _ nid 2 obj ( NID _ pkcs 7_ data ); ▁p 7 s -> cert ▁= ▁cert _ stack ; ▁/* ▁* ▁Convert ▁from ▁PEM ▁to ▁PKCS 7 ▁*/ ▁buflen ▁= ▁i 2 d _ PKCS 7_ bio ( out , ▁p 7 ); ▁if ▁(! buf len ) ▁{ ▁EST _ LOG _ ERR (" PEM _ write _ bio _ PKCS 7 ▁failed "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( out ); ▁out ▁= ▁NULL ; ▁go to ▁cleanup ; ▁} ▁( void ) BIO _ flu sh ( out ); ▁cleanup : ▁/* ▁* ▁Only ▁need ▁to ▁cleanup ▁p 7 . ▁This ▁free s ▁up ▁the ▁p 7 s ▁and ▁* ▁cert _ stack ▁all ocation s ▁for ▁us ▁since ▁these ▁are ▁linked ▁* ▁to ▁the ▁p 7 . ▁*/ ▁if ▁( p 7 ) ▁{ ▁PKCS 7_ free ( p 7 ); ▁} ▁return ▁out ; ▁} ▁/* ▁* ▁T akes ▁a ▁raw ▁char ▁array ▁contain g ▁the ▁CA ▁certificates , ▁read s ▁the ▁data ▁* ▁in ▁and ▁load s ▁the ▁certificates ▁on ▁to ▁the ▁context ▁as ▁pkcs 7 ▁certs . ▁This ▁is ▁* ▁stored ▁on ▁the ▁EST ▁context ▁and ▁used ▁to ▁respond ▁to ▁the ▁/ cacerts ▁request , ▁* ▁which ▁requires ▁PKCS 7 ▁encoding . ▁* ▁* ▁This ▁function ▁also ▁load s ▁the ▁x 509 ▁store ▁on ▁the ▁context ▁used ▁to ▁* ▁verify ▁the ▁peer . ▁*/ ▁EST _ ERROR ▁est _ load _ ca _ certs ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* raw , ▁int ▁size ) ▁{ ▁BIO ▁* cacerts ▁= ▁NULL ; ▁BIO ▁* in ; ▁un signed ▁char ▁* retval ; ▁/* ▁* ▁Only ▁the ▁server ▁and ▁proxy ▁mode s ▁ma y ▁load ▁the ▁cacerts ▁response ▁*/ ▁if ▁( ctx -> est _ mode ▁== ▁EST _ CLIENT ) ▁{ ▁return ▁EST _ ERR _ BAD _ MODE ; ▁} ▁in ▁= ▁BIO _ new _ mem _ buf ( raw , ▁size ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁the ▁raw ▁cert ▁buffer "); ▁return ▁( EST _ ERR _ LO AD _ CACERTS ); ▁} ▁/* ▁* ▁convert ▁the ▁CA ▁certs ▁to ▁PKCS 7 ▁encoded ▁char ▁array ▁* ▁This ▁is ▁used ▁by ▁an ▁EST ▁server ▁to ▁respond ▁to ▁the ▁* ▁cacerts ▁request . ▁*/ ▁cacerts ▁= ▁est _ get _ certs _ pkcs 7 ( in , ▁1); ▁if ▁(! cacerts ) ▁{ ▁EST _ LOG _ ERR (" est _ get _ certs _ pkcs 7 ▁failed "); ▁BIO _ free ( in ); ▁return ▁( EST _ ERR _ LO AD _ CACERTS ); ▁} ▁ctx -> ca _ certs _ len ▁= ▁( int ) ▁BIO _ get _ mem _ data ( cacerts , ▁( char **)& retval ); ▁if ▁( ctx -> ca _ certs _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁copy ▁PKCS 7 ▁data "); ▁BIO _ free _ all ( cacerts ); ▁BIO _ free ( in ); ▁return ▁( EST _ ERR _ LO AD _ CACERTS ); ▁} ▁ctx -> ca _ certs ▁= ▁malloc ( ctx -> ca _ certs _ len ); ▁if ▁(! ctx -> ca _ certs ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁BIO _ free _ all ( cacerts ); ▁BIO _ free ( in ); ▁return ▁( EST _ ERR _ LO AD _ CACERTS ); ▁} ▁memcpy _ s ( ctx -> ca _ certs , ▁ctx -> ca _ certs _ len , ▁ retval , ▁ctx -> ca _ certs _ len ); ▁BIO _ free _ all ( cacerts ); ▁BIO _ free ( in ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁T akes ▁a ▁char ▁array ▁containing ▁the ▁PEM ▁encoded ▁CA ▁certificates , ▁* ▁both ▁implicit ▁and ▁explict ▁certs . ▁These ▁are ▁decoded ▁and ▁loaded ▁* ▁into ▁the ▁trusted _ certs _ store ▁member ▁on ▁the ▁EST ▁context . ▁This ▁cert ▁* ▁store ▁is ▁used ▁by ▁the ▁TLS ▁stack ▁for ▁peer ▁verification ▁at ▁the ▁TLS ▁* ▁layer . ▁* ▁Note : ▁we ▁do ▁not ▁include ▁defensive ▁code ▁to ▁check ▁for ▁NULL ▁arguments ▁* ▁because ▁this ▁function ▁is ▁not ▁part ▁of ▁the ▁public ▁API . ▁These ▁* ▁checks ▁should ▁have ▁already ▁been ▁performed . ▁*/ ▁EST _ ERROR ▁est _ load _ trusted _ certs ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* certs , ▁int ▁certs _ len ) ▁{ ▁EST _ ERROR ▁rv ; ▁/* ▁* ▁Create ▁the ▁combine d ▁cert ▁store ▁on ▁the ▁context ▁* ▁This ▁contains ▁both ▁the ▁implicit ▁and ▁explicit ▁certs ▁*/ ▁ctx -> trusted _ certs _ store ▁= ▁X 509_ STORE _ new (); ▁if ▁( ctx -> trusted _ certs _ store ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁allocate ▁combine d ▁cert ▁store "); ▁return ▁( EST _ ERR _ LO AD _ TRUST _ CERTS ); ▁} ▁X 509_ STORE _ set _ verify _ cb ( ctx -> trusted _ certs _ store , ▁ossl _ verify _ cb ); ▁rv ▁= ▁ossl _ init _ cert _ store ( ctx -> trusted _ certs _ store , ▁certs , ▁certs _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁populate ▁combine d ▁cert ▁store "); ▁return ▁( rv ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ set _ ex _ data () ▁sets ▁the ▁application ▁specific ▁data ▁on ▁the ▁EST ▁context . ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ param ▁ex _ data ▁ Pointer ▁to ▁application ▁specific ▁data ▁that ▁will ▁be ▁passed ▁through ▁to ▁the ▁EST ▁callback s . ▁@ return ▁EST _ ERROR ▁This ▁function ▁is ▁used ▁to ▁link ▁application ▁specific ▁data ▁to ▁the ▁EST _ CTX ▁structure . ▁This ▁can ▁be ▁used ▁by ▁an ▁application ▁to ▁bind ▁application ▁specific ▁data ▁to ▁an ▁EST ▁operation . ▁libEST ▁does ▁not ▁use ▁the ▁application ▁specific ▁data . ▁The ▁* ex _ data ▁pointer ▁is ▁passed ▁back ▁to ▁the ▁application ▁when ▁libEST ▁invoke s ▁the ▁enroll , ▁re - enroll , ▁CSR ▁attributes , ▁and ▁HTTP ▁auth ▁callback s . ▁libEST ▁will ▁not ▁free ▁the ▁memory ▁reference d ▁by ▁the ▁* ex _ data ▁parameter ▁when ▁est _ destroy () ▁is ▁invoked . ▁The ▁application ▁is ▁responsible ▁for ▁rel e a s ing ▁its ▁application ▁specific ▁data . ▁*/ ▁EST _ ERROR ▁est _ set _ ex _ data ▁( EST _ CTX ▁* ctx , ▁void ▁* ex _ data ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( ctx -> ex _ data ) ▁{ ▁EST _ LOG _ WARN (" ex _ data ▁was ▁already ▁set , ▁possible ▁memory ▁leak "); ▁} ▁ctx -> ex _ data ▁= ▁ex _ data ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ get _ ex _ data () ▁retrieve s ▁the ▁application ▁specific ▁data ▁on ▁the ▁EST ▁context . ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ return ▁void * ▁This ▁function ▁is ▁used ▁to ▁at ta in ▁a ▁reference ▁to ▁the ▁application ▁specific ▁data ▁on ▁the ▁EST _ CTX ▁structure . ▁This ▁data ▁should ▁have ▁been ▁set ▁by ▁invoking ▁est _ set _ ex _ data () ▁earlier . ▁Otherwise ▁it ▁will ▁return ▁NULL . ▁*/ ▁void ▁* ▁est _ get _ ex _ data ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( NULL ); ▁} ▁return ▁( ctx -> ex _ data ); ▁} ▁/* ! ▁@ br i ef ▁est _ destroy () ▁free s ▁an ▁EST ▁context ▁@ param ▁ctx ▁ Pointer ▁to ▁an ▁EST ▁context ▁@ return ▁EST _ ERROR ▁This ▁function ▁is ▁used ▁to ▁release ▁all ▁the ▁memory ▁allocated ▁under ▁the ▁EST _ CTX * . ▁This ▁should ▁be ▁called ▁last ▁after ▁perform ing ▁EST ▁operations ▁using ▁the ▁context . ▁*/ ▁EST _ ERROR ▁est _ destroy ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( ctx -> trusted _ certs _ store ▁ != ▁NULL ) ▁{ ▁X 509_ STORE _ free ( ctx -> trusted _ certs _ store ); ▁} ▁if ▁( ctx -> ca _ certs ) ▁{ ▁free ( ctx -> ca _ certs ); ▁} ▁if ▁( ctx -> retrieved _ ca _ certs ) ▁{ ▁free ( ctx -> retrieved _ ca _ certs ); ▁} ▁if ▁( ctx -> retrieved _ csrattrs ) ▁{ ▁free ( ctx -> retrieved _ csrattrs ); ▁} ▁if ▁( ctx -> server _ csrattrs ) ▁{ ▁free ( ctx -> server _ csrattrs ); ▁} ▁if ▁( ctx -> enrolled _ client _ cert ) ▁{ ▁free ( ctx -> enrolled _ client _ cert ); ▁} ▁if ▁( ctx -> ca _ chain _ raw ) ▁{ ▁free ( ctx -> ca _ chain _ raw ); ▁} ▁if ▁( ctx -> uri _ path _ segment ) ▁{ ▁free ( ctx -> uri _ path _ segment ); ▁} ▁if ▁( ctx -> dh _ tmp ) ▁{ ▁DH _ free ( ctx -> dh _ tmp ); ▁} ▁/* ▁Only ▁free ▁the ▁SSL ▁context ▁when ▁ acting ▁as ▁a ▁client . ▁When ▁* ▁operat ing ▁as ▁a ▁server , ▁it ' s ▁expected ▁the ▁web ▁server ▁* ▁will ▁free ▁the ▁context ▁*/ ▁if ▁( ctx -> ssl _ ctx ▁&& ▁( ( ctx -> est _ mode ▁== ▁EST _ CLIENT ) | | ( ctx -> est _ mode ▁== ▁EST _ PROXY ))) ▁{ ▁/* ▁* ▁If ▁the ▁SSL ▁session ▁had ▁been ▁cached , ▁this ▁means ▁that ▁* ▁SSL _ get 1 _ session () ▁has ▁been ▁called , ▁so ▁now ▁it ▁needs ▁to ▁be ▁explict ly ▁* ▁free d ▁to ▁get ▁its ▁ref ▁count ▁de c re mem nt ed . ▁*/ ▁if ▁( ctx -> sess ) ▁{ ▁SSL _ SESSION _ free ( ctx -> sess ); ▁} ▁SSL _ CTX _ free ( ctx -> ssl _ ctx ); ▁} ▁if ▁( ctx -> est _ mode ▁== ▁EST _ PROXY ) ▁{ ▁proxy _ cleanup ( ctx ); ▁} ▁/* ▁* ▁ And ▁finally ▁free ▁the ▁EST ▁context ▁itself ▁*/ ▁free ( ctx ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁used ▁to ▁determine ▁whether ▁the ▁BIO _ FLAG S _ BASE 64_ NO _ NL ▁* ▁option ▁needs ▁to ▁be ▁used ▁when ▁using ▁the ▁OpenSSL ▁* ▁base 64 ▁decode r . ▁It ▁takes ▁a ▁string ▁as ▁input ▁and ▁* ▁checks ▁if ▁it ▁contains ▁newline ▁characters . ▁* ▁* ▁Returns ▁1 ▁if ▁OpenSSL ▁should ▁use ▁the ▁BIO _ FLAG S _ BASE 64_ NO _ NL ▁option ▁* ▁Returns ▁0 ▁otherwise ▁*/ ▁static ▁int ▁est _ base 64_ contains _ nl ▁( const ▁char ▁* src , ▁int ▁len ) ▁{ ▁int ▁i ; ▁if ▁( len ▁< ▁64 ) ▁{ ▁/* ▁* ▁Any ▁base 64 ▁ less ▁than ▁64 ▁bytes ▁should n ' t ▁be ▁a ▁* ▁problem ▁for ▁OpenSSL ▁since ▁this ▁is ▁the ▁minimum ▁* ▁line ▁length ▁for ▁base 64 ▁encoding . ▁*/ ▁return ▁0; ▁} ▁/* ▁* ▁Start ▁look ing ▁for ▁newline s ▁at ▁the ▁64 th ▁ position ▁*/ ▁for ▁( i ▁= ▁6 3 ; ▁i ▁< ▁len -1 ; ▁i ++) ▁{ ▁if ▁( src [ i ] ▁== ▁0 xA ) ▁{ ▁return ▁1; ▁} ▁} ▁return ▁0; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁used ▁to ▁decode ▁base 64 ▁encoded ▁data . ▁* ▁Pass ▁in ▁the ▁base 64 ▁encoded ▁data ▁and ▁a ▁pointer ▁to ▁a ▁buffer ▁* ▁to ▁receive ▁the ▁decoded ▁data . ▁The ▁length ▁of ▁the ▁decoded ▁* ▁data ▁is ▁returned . ▁If ▁the ▁return ▁value ▁is ▁zero ▁or ▁negative , ▁then ▁* ▁an ▁error ▁occurred . ▁The ▁dst _ size ▁parameter ▁is ▁the ▁maximum ▁* ▁allowed ▁size ▁of ▁the ▁decoded ▁data . ▁*/ ▁int ▁est _ base 64_ decode ▁( const ▁char ▁* src , ▁char ▁* dst , ▁int ▁dst _ size ) ▁{ ▁BIO ▁* b 64, ▁* b 64 in ; ▁int ▁len ; ▁int ▁max _ in ; ▁/* ▁* ▁When ▁decoding ▁base 64, ▁the ▁output ▁will ▁al way s ▁be ▁small er ▁by ▁a ▁* ▁r at io ▁of ▁4 : 3 . ▁Determine ▁what ▁the ▁max ▁size ▁can ▁be ▁for ▁the ▁input ▁* ▁based ▁on ▁the ▁size ▁of ▁the ▁given ▁output ▁buffer ▁and ▁then ▁make ▁sure ▁that ▁* ▁the ▁actual ▁input ▁buffer ▁is ▁not ▁too ▁big . ▁*/ ▁max _ in ▁= ▁( ( dst _ size ▁* ▁4) ▁/ ▁3) ▁+ ▁1; ▁/* ▁* ▁Get ▁the ▁length ▁of ▁the ▁base 64 ▁encoded ▁data . ▁Make ▁sure ▁it ' s ▁not ▁too ▁* ▁big ▁*/ ▁len ▁= ▁ strnlen _ s ( src , ▁max _ in +1 ); ▁if ▁( len ▁> ▁max _ in ) ▁{ ▁EST _ LOG _ ERR (" Source ▁buffer ▁for ▁base 64 ▁decode ▁is ▁loo ▁large ▁for ▁destination ▁buffer . ▁" ▁" source ▁buf ▁len ▁= ▁% d , ▁max ▁input ▁len ▁= ▁% d , ▁max ▁d est ▁len ▁= ▁% d ", ▁len , ▁max _ in , ▁dst _ size ); ▁return ▁ (0); ▁} ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁base 64 ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁ (0); ▁} ▁b 64 in ▁= ▁BIO _ new _ mem _ buf ( ( char ▁* ) src , ▁len ); ▁if ▁( b 64 in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁mem ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁ (0); ▁} ▁if ▁(! est _ base 64_ contains _ nl ▁( src , ▁len )) ▁{ ▁/* ▁* ▁E nable ▁the ▁no ▁newline s ▁option ▁if ▁the ▁input ▁* ▁data ▁does n ' t ▁contain ▁any ▁newline ▁characters . ▁* ▁It ' s ▁too ▁bad ▁OpenSSL ▁does n ' t ▁do ▁this ▁implicitly . ▁*/ ▁BIO _ set _ flags ( b 64, BIO _ FLAG S _ BASE 64_ NO _ NL ); ▁} ▁b 64 in ▁= ▁BIO _ push ( b 64, ▁b 64 in ); ▁len ▁= ▁BIO _ read ( b 64 in , ▁dst , ▁dst _ size ); ▁if ▁( len ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" BIO _ read ▁failed ▁while ▁decoding ▁base 64 ▁data ▁(% d )", ▁len ); ▁} ▁else ▁{ ▁/* ▁* ▁Make ▁sure ▁the ▁response ▁is ▁null ▁terminated ▁*/ ▁dst [ len ] ▁= ▁0; ▁} ▁BIO _ free _ all ( b 64 in ); ▁return ▁( len ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁used ▁to ▁encode ▁base 64 ▁data . ▁* ▁Pass ▁in ▁the ▁un encoded ▁data , ▁the ▁length ▁of ▁the ▁source ▁buffer , ▁* ▁and ▁a ▁pointer ▁to ▁a ▁buffer ▁to ▁receive ▁the ▁encoded ▁data . ▁* ▁The ▁length ▁of ▁the ▁encoded ▁data ▁is ▁returned . ▁If ▁the ▁return ▁value ▁* ▁is ▁zero , ▁then ▁an ▁error ▁occurred . ▁The ▁max _ d est _ len ▁parameter ▁* ▁is ▁the ▁maximum ▁allowed ▁size ▁of ▁the ▁encoded ▁data . ▁*/ ▁int ▁est _ base 64_ encode ▁( const ▁char ▁* src , ▁int ▁actual _ src _ len , ▁char ▁* dst , ▁int ▁max _ dst _ len ) ▁{ ▁BIO ▁* b 64 ; ▁BIO ▁* out ; ▁int ▁max _ src _ len ; ▁int ▁actual _ dst _ len ▁= ▁0; ▁int ▁write _ cnt ▁= ▁0; ▁ BUF _ MEM ▁* bptr ▁= ▁NULL ; ▁/* ▁* ▁When ▁encoding ▁base 64, ▁the ▁output ▁will ▁al way s ▁be ▁large r ▁by ▁a ▁* ▁r at io ▁of ▁3 : 4 . ▁Determine ▁what ▁the ▁max ▁size ▁can ▁be ▁for ▁the ▁input ▁* ▁based ▁on ▁the ▁size ▁of ▁the ▁given ▁output ▁buffer ▁and ▁then ▁make ▁sure ▁that ▁* ▁the ▁actual ▁input ▁buffer ▁is ▁not ▁too ▁big . ▁*/ ▁max _ src _ len ▁= ▁( ( max _ dst _ len ▁* ▁3) ▁/ ▁4) ▁+ ▁1; ▁if ▁( act ual _ src _ len ▁> ▁max _ src _ len ) ▁{ ▁EST _ LOG _ ERR (" Source ▁buffer ▁for ▁base 64 ▁encode ▁is ▁loo ▁large ▁for ▁destination ▁buffer . ▁" ▁" max ▁source ▁len ▁= ▁% d , ▁actual _ source ▁len ▁= ▁% d ", ▁max _ src _ len , ▁actual _ src _ len ); ▁return ▁0; ▁} ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁base 64 ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁0; ▁} ▁out ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁( out ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁mem ▁based ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( b 64 ); ▁return ▁0; ▁} ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁/* ▁* ▁We ▁don ' t ▁ ever ▁insert ▁new ▁line s ▁*/ ▁BIO _ set _ flags ( out , ▁BIO _ FLAG S _ BASE 64_ NO _ NL ); ▁/* ▁* ▁ Write ▁the ▁source ▁buffer ▁through ▁the ▁BIO s ▁and ▁then ▁get ▁a ▁pointer ▁* ▁to ▁the ▁result ing ▁memory ▁buffer ▁on ▁the ▁other ▁side ▁to ▁obtain ▁the ▁* ▁result . ▁*/ ▁write _ cnt ▁= ▁BIO _ write ( out , ▁src , ▁actual _ src _ len ); ▁( void ) BIO _ flu sh ( out ); ▁BIO _ get _ mem _ ptr ( out , ▁& bptr ); ▁if ▁( write _ cnt ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" BIO _ write ▁failed ▁while ▁encoding ▁base 64 ▁data ▁(% d )", ▁write _ cnt ); ▁} ▁else ▁{ ▁/* ▁* ▁copy ▁out ▁the ▁result ing ▁base 64 ▁encoded ▁string , ▁make ▁sure ▁it ' s ▁* ▁null ▁terminated , ▁and ▁return ▁the ▁length ▁*/ ▁memcpy _ s ( dst , ▁max _ dst _ len , ▁bptr -> data , ▁bptr -> length ); ▁dst [ bptr -> length ] ▁= ▁'\0'; ▁actual _ dst _ len ▁= ▁bptr -> length ; ▁} ▁BIO _ free _ all ( b 64 ); ▁return ▁( act ual _ dst _ len ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁used ▁to ▁encode ▁base 64 ▁data . ▁* ▁Pass ▁in ▁the ▁un encoded ▁data , ▁the ▁length ▁of ▁the ▁source ▁buffer , ▁* ▁and ▁a ▁pointer ▁to ▁a ▁buffer ▁to ▁receive ▁the ▁encoded ▁data . ▁* ▁The ▁length ▁of ▁the ▁encoded ▁data ▁is ▁returned . ▁If ▁the ▁return ▁value ▁* ▁is ▁zero , ▁then ▁an ▁error ▁occurred . ▁The ▁max _ d est _ len ▁parameter ▁* ▁is ▁the ▁maximum ▁allowed ▁size ▁of ▁the ▁encoded ▁data . ▁*/ ▁char ▁* ▁est _ get _ tls _ uid ▁( SSL ▁* ssl , ▁int ▁is _ client ) ▁{ ▁char ▁finished [ MAX _ FINISHED ] ; ▁BIO ▁* bio ▁= ▁NULL , ▁* b 64 ▁= ▁NULL ; ▁ BUF _ MEM ▁* bptr ▁= ▁NULL ; ▁int ▁len ; ▁char ▁* rv ▁= ▁NULL ; ▁/* ▁* ▁RFC 5929 ▁states ▁the ▁* first * ▁finished ▁message ▁is ▁used ▁* ▁to ▁der ive ▁the ▁tls - unique - id . ▁When ▁session ▁resumption ▁* ▁is ▁used , ▁the ▁server ▁send s ▁the ▁first ▁finished ▁message . ▁* ▁Normally ▁the ▁client ▁send s ▁the ▁first ▁finished ▁message d . ▁*/ ▁if ▁( ( is _ client ▁&& ▁! SSL _ session _ reused ( ssl )) ▁|| ▁(! is _ client ▁&& ▁SSL _ session _ reused ( ssl ))) ▁{ ▁len ▁= ▁( int ) ▁SSL _ get _ finished ( ssl , ▁finished , ▁ MAX _ FINISHED ); ▁} ▁else ▁{ ▁len ▁= ▁( int ) ▁SSL _ get _ peer _ finished ( ssl , ▁finished , ▁ MAX _ FINISHED ); ▁} ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁base 64 ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁rv ; ▁} ▁bio ▁= ▁BIO _ new ( BIO _ s _ mem ()); ▁if ▁( bio ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" BIO _ new ▁failed ▁while ▁attempt ing ▁to ▁create ▁mem ▁based ▁BIO "); ▁ossl _ dump _ ssl _ errors (); ▁return ▁rv ; ▁} ▁( void ) BIO _ flu sh ( bio ); ▁bio ▁= ▁BIO _ push ( b 64, ▁bio ); ▁BIO _ write ( bio , ▁finished , ▁len ); ▁( void ) BIO _ flu sh ( bio ); ▁BIO _ get _ mem _ ptr ( bio , ▁& bptr ); ▁/* ▁* ▁Be ▁ aware ▁that ▁OpenSSL ▁add s ▁a ▁newline ▁character ▁at ▁the ▁* ▁end ▁of ▁the ▁base 64 ▁encoded ▁data ▁*/ ▁if ▁( bptr -> length ▁ != ▁EST _ TLS _ UID _ LEN ) ▁{ ▁EST _ LOG _ WARN (" TLS ▁UID ▁length ▁mismatch ▁(% d /% d )", ▁bptr -> length , ▁EST _ TLS _ UID _ LEN ); ▁} ▁else ▁{ ▁rv ▁= ▁malloc ( EST _ TLS _ UID _ LEN ▁+ ▁1); ▁if ▁( rv ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁allocate ▁buffer "); ▁return ▁rv ; ▁} ▁memcpy _ s ( rv , ▁EST _ TLS _ UID _ LEN , ▁bptr -> data , ▁EST _ TLS _ UID _ LEN ); ▁rv [ EST _ TLS _ UID _ LEN -1 ] ▁= ▁'\0'; ▁EST _ LOG _ INFO (" TLS ▁UID ▁was ▁found "); ▁} ▁BIO _ free _ all ( bio ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁is ▁a ▁utility ▁function ▁to ▁convert ▁a ▁hex ▁value ▁* ▁to ▁a ▁string . ▁This ▁is ▁used ▁with ▁the ▁HTTP ▁digest ▁* ▁authentication ▁logic . ▁*/ ▁void ▁est _ hex _ to _ str ▁( char ▁* dst , ▁un signed ▁char ▁* src , ▁int ▁len ) ▁{ ▁static ▁const ▁char ▁* hex ▁= ▁" 0 12 34 56 7 89 abcdef "; ▁for ▁( ; ▁len -- ; ▁src ++) ▁{ ▁* dst ++ ▁= ▁hex [ src [0 ] ▁> > ▁4 ] ; ▁* dst ++ ▁= ▁hex [ src [0 ] ▁& ▁0 x 0 f ] ; ▁} ▁* dst ▁= ▁'\0'; ▁} ▁/* ! ▁@ br i ef ▁est _ enable _ crl () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁checking ▁of ▁a ▁certificate ▁re v ocation ▁list ▁when ▁validat ing ▁the ▁client ▁TLS ▁peer ▁certificate ▁dur ing ▁the ▁TLS ▁handshake . ▁When ▁enabled , ▁the ▁ca _ chain ▁parameter ▁provided ▁to ▁e i ther ▁est _ server _ init () ▁or ▁est _ client _ init () ▁should ▁contain ▁both ▁the ▁trusted ▁certificates ▁a long ▁with ▁the ▁CRL ▁entries . ▁The ▁CRL ▁entries ▁should ▁be ▁app en ed ▁at ▁the ▁end . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁CRL ▁checking ▁is ▁disabled ▁by ▁default . ▁This ▁function ▁must ▁be ▁called ▁after ▁invoking ▁est _ server _ init () ▁or ▁est _ client _ init () ▁and ▁prior ▁to ▁perform ing ▁any ▁EST ▁operations . ▁The refore , ▁there ▁is ▁no ▁' disable ' ▁version ▁of ▁this ▁method . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ enable _ crl ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> enable _ crl ▁= ▁1; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁est _ asn 1 _ sanity _ test ▁- ▁perform ▁a ▁ sanity ▁test ▁on ▁the ▁CSR ▁* ▁attribute ▁string . ▁This ▁function ▁operate s ▁on ▁an ▁ASN . 1 ▁hex ▁* ▁string , ▁so ▁it ▁should ▁already ▁be ▁un - based 64 . ▁* ▁* ▁return ▁EST _ ERROR ▁and ▁the ▁presence ▁of ▁ c hallengePassword ▁*/ ▁static ▁EST _ ERROR ▁est _ asn 1 _ sanity _ test ▁( const ▁un signed ▁char ▁* string , ▁long ▁out _ len , ▁int ▁* pop _ present ) ▁{ ▁int ▁tag , ▁xclass , ▁j , ▁nid ; ▁long ▁out _ len _ save ▁= ▁out _ len ; ▁long ▁len ; ▁const ▁un signed ▁char ▁* o string ▁= ▁string ; ▁ASN 1 _ OBJECT ▁* a _ object ; ▁int ▁max _ len ▁= ▁ MAX _ CSRATTRS ; ▁/* ▁* ▁A ssume ▁the ▁ c hallengePassword ▁OID ▁is ▁not ▁present ▁*/ ▁* pop _ present ▁= ▁0; ▁/* ▁make ▁sure ▁its ▁long ▁enough ▁to ▁be ▁ASN . 1 ▁*/ ▁if ▁( out _ len ▁< ▁MIN _ ASN 1 _ CSRATTRS ) ▁{ ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX _ TOO _ SHORT ); ▁} ▁while ▁( out _ len ▁> ▁0) ▁{ ▁j ▁= ▁ASN 1 _ get _ object (& string , ▁& len , ▁& tag , ▁& xclass , ▁out _ len ); ▁EST _ LOG _ INFO (" Sanity : ▁tag =% d , ▁len =% d , ▁j =% d , ▁out _ len =% d ", ▁tag , ▁len , ▁j , ▁out _ len ); ▁if ▁( j ▁& ▁0 x 80) ▁{ ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁switch ▁( tag ) ▁{ ▁case ▁V _ ASN 1 _ OBJECT : ▁a _ object ▁= ▁ c 2 i _ ASN 1 _ OBJECT ( NULL , ▁& string , ▁len ); ▁if ▁( a _ object ▁ != ▁NULL ) ▁{ ▁nid ▁= ▁OBJ _ obj 2 nid ( a _ object ); ▁EST _ LOG _ INFO (" NID =% d ", ▁nid ); ▁if ▁( nid ▁== ▁NID _ pkcs 9 _ c hallengePassword ) ▁{ ▁EST _ LOG _ INFO (" c hallengePassword ▁OID ▁found "); ▁* pop _ present ▁= ▁1; ▁/* ▁just ▁signifi y ▁it ' s ▁there ▁*/ ▁max _ len ▁= ▁ MAX _ CSRATTRS _ WITH POP ; ▁} ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁} ▁break ; ▁default : ▁/* ▁have ▁to ▁a d just ▁string ▁pointer ▁here ▁*/ ▁string ▁+= ▁len ; ▁break ; ▁case ▁V _ ASN 1 _ SET : ▁case ▁V _ ASN 1 _ SEQUENCE : ▁break ; ▁} ▁out _ len ▁= ▁( out _ len _ save ▁- ▁( string ▁- ▁ostring )); ▁} ▁if ▁( out _ len ▁ != ▁0) ▁{ ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁if ▁( out _ len _ save ▁> ▁max _ len ) ▁{ ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX _ TOO _ LONG ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁est _ is _ c hallengePassword _ present ▁- ▁take ▁a ▁base 64 ▁* ▁encoded ▁ASN . 1 ▁string ▁and ▁ scan ▁through ▁it ▁to ▁see ▁* ▁if ▁ c hallengePassword ▁is ▁included . ▁* ▁* ▁return ▁EST _ ERROR ▁and ▁the ▁presence ▁of ▁ c hallengePassword ▁*/ ▁EST _ ERROR ▁est _ is _ c hallengePassword _ present ▁( const ▁char ▁* base 64_ ptr , ▁int ▁b 64_ len , ▁int ▁* pres enc e ) ▁{ ▁/* ▁assume ▁its ▁not ▁there ▁*/ ▁* pres enc e ▁= ▁0; ▁/* ▁just ▁return ▁if ▁no ▁data ▁*/ ▁if ▁( ( base 64_ ptr ▁== ▁NULL ) ▁|| ▁( b 64_ len ▁== ▁0) ) ▁{ ▁return ▁( EST _ ERR _ NONE ); ▁} ▁return ▁( est _ asn 1 _ parse _ attributes ( base 64_ ptr , ▁b 64_ len , ▁presence )); ▁} ▁/* ▁* ▁est _ asn 1 _ parse _ attributes ▁- ▁base 64 ▁decode ▁and ▁ sanity ▁test ▁* ▁the ▁given ▁attributes ▁string ▁* ▁* ▁return ▁EST _ ERROR ▁and ▁the ▁presence ▁of ▁ c hallengePassword ▁*/ ▁EST _ ERROR ▁est _ asn 1 _ parse _ attributes ▁( const ▁char ▁* p , ▁int ▁len , ▁int ▁* pop _ present ) ▁{ ▁un signed ▁char ▁* der _ ptr ; ▁int ▁der _ len , ▁rv ; ▁/* ▁* ▁check ▁small est ▁possible ▁base 64 ▁case ▁here ▁for ▁now ▁* ▁and ▁ sanity ▁test ▁will ▁check ▁min / max ▁value ▁for ▁ASN . 1 ▁data ▁*/ ▁if ▁( len ▁< ▁MIN _ CSRATTRS ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁der _ ptr ▁= ▁malloc ( len *2 ); ▁if ▁(! der _ ptr ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁der _ len ▁= ▁est _ base 64_ decode ( p , ▁( char ▁* ) der _ ptr , ▁len *2 ); ▁if ▁( der _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁base 64 ▁encoded ▁data "); ▁free ( der _ ptr ); ▁return ▁( EST _ ERR _ BAD _ BASE 64 ); ▁} ▁rv ▁= ▁est _ asn 1 _ sanity _ test ( der _ ptr , ▁der _ len , ▁pop _ present ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁ASN 1 ▁encoded ▁data . ▁rv ▁= ▁% d ▁(% s )", ▁rv , ▁EST _ ERR _ NUM _ TO _ STR ( rv )); ▁free ( der _ ptr ); ▁return ▁( rv ); ▁} ▁free ( der _ ptr ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁est _ add _ c hallengePassword ▁- ▁caller ▁has ▁verified ▁that ▁ c hallengePassword ▁* ▁is ▁configured ▁and ▁not ▁included , ▁so ▁add ▁it ▁to ▁the ▁attributes ▁here . ▁* ▁No ▁ sanity ▁check ▁is ▁needed ▁since ▁est _ is _ c hallengePassword _ present ▁* ▁has ▁already ▁been ▁called . ▁*/ ▁EST _ ERROR ▁est _ add _ c hallengePassword ▁( const ▁char ▁* base 64_ ptr , ▁int ▁b 64_ len , ▁char ▁** new _ csr , ▁int ▁* pop _ len ) ▁{ ▁const ▁un signed ▁char ▁* der _ ptr ; ▁char ▁* orig _ ptr , ▁* new _ der ▁= ▁NULL , ▁* csrattrs ; ▁int ▁der _ len , ▁tag , ▁xclass , ▁new _ len ; ▁long ▁len ; ▁int ▁e nc _ len ; ▁der _ ptr ▁= ▁malloc ( b 64_ len *2 ); ▁if ▁(! der _ ptr ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁der _ len ▁= ▁est _ base 64_ decode ( base 64_ ptr , ▁( char ▁* ) der _ ptr , ▁b 64_ len *2 ); ▁if ▁( der _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" M al form ed ▁base 64 ▁data "); ▁free ( ( void ▁* ) der _ ptr ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁orig _ ptr ▁= ▁( char ▁* ) der _ ptr ; ▁/* ▁gra b ▁the ▁first ▁one ▁and ▁do ▁the ▁ POP ▁st uff ▁*/ ▁( void ) ASN 1 _ get _ object (& der _ ptr , ▁& len , ▁& tag , ▁& xclass , ▁der _ len ); ▁if ▁( tag ▁ != ▁V _ ASN 1 _ SEQUENCE ) ▁{ ▁EST _ LOG _ ERR (" M al form ed ▁ASN . 1 ▁Hex , ▁no ▁le and ing ▁Se que nc e "); ▁free ( orig _ ptr ); ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁len ▁= ▁( char ▁* ) der _ ptr ▁- ▁orig _ ptr ; ▁new _ len ▁= ▁der _ len ▁- ▁( int ) len ▁+ ▁sizeof ( hex _ chpw ); ▁/* ▁remove ▁le ad ing ▁ sequence ▁and ▁length ▁and ▁copy ▁to ▁new ▁buffer ▁*/ ▁/* ▁if ▁>= ▁256 ▁need ▁4 ▁byte ▁Se q ▁header ▁*/ ▁if ▁( ( der _ len ▁- ▁len ▁+ ▁sizeof ( hex _ chpw )) ▁>= ▁256 ) ▁{ ▁new _ len ▁+= ▁4 ; ▁new _ der ▁= ▁malloc ( new _ len ); ▁if ▁(! new _ der ) ▁{ ▁free ( orig _ ptr ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁mem zero _ s ( new _ der , ▁new _ len ); ▁* ( new _ der ▁+ ▁1) ▁= ▁0 x 82 ; ▁* ( new _ der ▁+ ▁2) ▁= ▁( new _ len ▁- ▁4) ▁> > ▁8 ; ▁* ( new _ der ▁+ ▁3) ▁= ▁( ( new _ len ▁- ▁4) ▁& ▁0 xf f ); ▁memcpy _ s ( new _ der + 4, ▁der _ len ▁- ▁( un signed ▁int ) ▁len , ▁der _ ptr , ▁der _ len ▁- ▁( un signed ▁int ) len ); ▁/* ▁if ▁< = ▁256 , ▁but ▁>= ▁ 128 ▁need ▁3 ▁byte ▁Se q ▁header ▁*/ ▁} ▁else ▁if ▁( ( der _ len ▁- ▁len ▁+ ▁sizeof ( hex _ chpw )) ▁>= ▁128) ▁{ ▁new _ len ▁+= ▁3 ; ▁new _ der ▁= ▁malloc ( new _ len ); ▁if ▁(! new _ der ) ▁{ ▁free ( orig _ ptr ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁mem zero _ s ( new _ der , ▁new _ len ); ▁* ( new _ der ▁+ ▁1) ▁= ▁0 x 8 1 ; ▁* ( new _ der ▁+ ▁2) ▁= ▁new _ len ▁- ▁3 ; ▁memcpy _ s ( new _ der + 3, ▁der _ len ▁- ▁( ( r size _ t ) ▁len ) , ▁der _ ptr , ▁der _ len ▁- ▁( ( r size _ t ) ▁len )); ▁/* ▁else ▁just ▁need ▁2 ▁byte ▁header ▁*/ ▁} ▁else ▁{ ▁new _ len ▁+= ▁2 ; ▁new _ der ▁= ▁malloc ( new _ len ); ▁if ▁(! new _ der ) ▁{ ▁free ( orig _ ptr ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁mem zero _ s ( new _ der , ▁new _ len ); ▁* ( new _ der ▁+ ▁1) ▁= ▁new _ len ▁- ▁2 ; ▁if ▁( ( der _ len ▁- ▁len ) ▁ != ▁0) ▁{ ▁memcpy _ s ( new _ der + 2 , ▁der _ len ▁- ▁( ( r size _ t ) ▁len ) , ▁der _ ptr , ▁der _ len ▁- ▁( ( r size _ t ) ▁len )); ▁} ▁} ▁* new _ der ▁= ▁0 x 30 ; ▁memcpy _ s ( new _ der ▁+ ▁( new _ len ▁- ▁sizeof ( hex _ chpw )) , ▁sizeof ( hex _ chpw ) , ▁hex _ chpw , ▁sizeof ( hex _ chpw )); ▁csrattrs ▁= ▁malloc ( new _ len *2 ); ▁if ▁(! csrattrs ) ▁{ ▁free ( orig _ ptr ); ▁free ( new _ der ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁mem zero _ s ( csrattrs , ▁new _ len *2 ); ▁e nc _ len ▁= ▁est _ base 64_ encode ( ( const ▁char ▁* ) new _ der , ▁new _ len , ▁( char ▁* ) csrattrs , ▁new _ len *2 ); ▁if ▁( enc _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁base 64 ▁encoded ▁data "); ▁free ( orig _ ptr ); ▁free ( new _ der ); ▁free ( csrattrs ); ▁return ▁( EST _ ERR _ BAD _ BASE 64 ); ▁} ▁* new _ csr ▁= ▁csrattrs ; ▁* pop _ len ▁= ▁( int ) ▁ strnlen _ s ( csrattrs , ▁new _ len *2 ); ▁EST _ LOG _ INFO (" CSR ▁reco nstitute d ▁attributes ▁are ( % d /% d ) : ▁% s ", ▁b 64_ len , ▁* pop _ len , ▁csrattrs ); ▁if ▁( new _ der ) ▁{ ▁free ( new _ der ); ▁} ▁if ▁( orig _ ptr ) ▁{ ▁free ( orig _ ptr ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ add _ attributes _ helper () ▁Add ▁a ▁NID ▁and ▁its ▁character ▁string ▁to ▁an ▁X 509_ REQ ▁as ▁an ▁attribute . ▁@ param ▁req ▁an ▁X 509_ REQ ▁structure ▁used ▁for ▁the ▁CSR ▁request ▁@ param ▁nid ▁NID ▁to ▁be ▁added ▁as ▁an ▁attribute ▁@ param ▁string ▁pointer ▁to ▁the ▁NID ▁string ▁if ▁needed ▁@ param ▁chtype ▁type ▁of ▁string ▁used ▁with ▁this ▁NID ▁@ return ▁EST _ ERROR ▁This ▁function ▁is ▁used ▁to ▁add ▁a ▁CSR ▁attribute ▁to ▁a ▁CSR ▁request ▁by ▁the ▁EST ▁client . ▁*/ ▁EST _ ERROR ▁est _ add _ attributes _ helper ▁( X 509_ REQ ▁* req , ▁int ▁nid , ▁void ▁* string , ▁int ▁chtype ) ▁{ ▁if ▁( req ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁( nid ▁== ▁0) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁( string ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁Only ▁MB STRING _ ASC ▁used ▁today , ▁but ▁caller s ▁could ▁pass ▁in ▁other ▁values ▁*/ ▁if ▁( c h type ▁== ▁0) ▁{ ▁chtype ▁= ▁MB STRING _ ASC ; ▁} ▁if (! X 509_ REQ _ add 1 _ attr _ by _ NID ( req , ▁nid , ▁chtype , ▁( un signed ▁char ▁* ) string , ▁-1) ) ▁{ ▁EST _ LOG _ WARN (" Error ▁adding ▁attribute "); ▁return ▁( EST _ ERR _ X 509_ ATTR ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ decode _ attributes _ helper () ▁ Decode ▁a ▁base 64 ▁encoded ▁string ▁into ▁DER ▁format ( ASN . 1 ▁hex ) . ▁@ param ▁csrattrs ▁pointer ▁to ▁a ▁base 64 ▁encoded ▁string ▁@ param ▁csrattrs _ len ▁base 64 ▁string ▁length ▁@ param ▁der _ ptr ▁pointer ▁to ▁a ▁pointer ▁to ▁store ▁the ▁DER ▁encoded ▁string ▁@ param ▁der _ len ▁pointer ▁to ▁store ▁the ▁DER ▁string ▁length ▁@ return ▁EST _ ERROR ▁This ▁function ▁is ▁used ▁decode ▁a ▁base 64 ▁encoded ▁CSR ▁attributes ▁string ▁into ▁DER ▁format . ▁It ▁also ▁perform s ▁range ▁checking ▁on ▁the ▁input ▁parameters . ▁*/ ▁EST _ ERROR ▁est _ decode _ attributes _ helper ▁( char ▁* csrattrs , ▁int ▁csrattrs _ len , ▁un signed ▁char ▁** der , ▁int ▁* len ) ▁{ ▁un signed ▁char ▁* der _ ptr ; ▁int ▁der _ len ; ▁/* ▁just ▁return ▁if ▁no ▁data ▁*/ ▁if ▁( ( csrattrs ▁== ▁NULL ) ▁|| ▁( csrattrs _ len ▁== ▁0) ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁( ( der ▁== ▁NULL ) ▁|| ▁( len ▁== ▁NULL )) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁* ▁check ▁small est ▁possible ▁base 64 ▁case ▁here ▁for ▁now ▁* ▁and ▁ sanity ▁test ▁will ▁check ▁min / max ▁value ▁for ▁ASN . 1 ▁data ▁*/ ▁if ▁( csrattrs _ len ▁< ▁MIN _ CSRATTRS ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁der _ ptr ▁= ▁malloc ( csrattrs _ len *2 ); ▁if ▁(! der _ ptr ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁der _ len ▁= ▁est _ base 64_ decode ( csrattrs , ▁( char ▁* ) der _ ptr , ▁csrattrs _ len *2 ); ▁if ▁( der _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ WARN (" I nvalid ▁base 64 ▁encoded ▁data "); ▁free ( der _ ptr ); ▁return ▁( EST _ ERR _ BAD _ BASE 64 ); ▁} ▁* der ▁= ▁der _ ptr ; ▁* len ▁= ▁der _ len ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ get _ attributes _ helper () ▁get ▁attributes ▁NID ▁from ▁a ▁DER ▁encoded ▁string . ▁@ param ▁der _ ptr ▁pointer ▁to ▁a ▁pointer ▁of ▁DER ▁encoded ▁string ▁@ param ▁der _ len ▁pointer ▁to ▁the ▁DER ▁encoded ▁string ▁length ▁@ param ▁new _ nid ▁pointer ▁to ▁ storage ▁for ▁NID , ▁if ▁found ▁@ return ▁EST _ ERROR ▁This ▁function ▁is ▁used ▁to ▁find ▁the ▁next ▁NID ▁in ▁a ▁DER ▁encoded ▁string . ▁If ▁no ▁NID ▁is ▁found ▁before ▁reach ing ▁the ▁end ▁of ▁the ▁string , ▁then ▁new _ nid ▁returned ▁as ▁zero ▁and ▁EST _ ERR _ BAD _ ASN 1 _ HEX . ▁*/ ▁EST _ ERROR ▁est _ get _ attributes _ helper ▁( un signed ▁char ▁** der _ ptr , ▁int ▁* der _ len , ▁int ▁* new _ nid ) ▁{ ▁int ▁tag , ▁xclass , ▁j , ▁nid ▁= ▁0; ▁int ▁out _ len _ save ; ▁long ▁out _ len ; ▁long ▁len ; ▁const ▁un signed ▁char ▁* string ; ▁const ▁un signed ▁char ▁* o string ; ▁ASN 1 _ OBJECT ▁* a _ object ▁= ▁NULL ; ▁if ▁( der _ ptr ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁string ▁= ▁* der _ ptr ; ▁ostring ▁= ▁* der _ ptr ; ▁if ▁( der _ len ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁out _ len ▁= ▁* der _ len ; ▁out _ len _ save ▁= ▁* der _ len ; ▁if ▁( new _ nid ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁while ▁( out _ len ▁> ▁0) ▁{ ▁j ▁= ▁ASN 1 _ get _ object (& string , ▁& len , ▁& tag , ▁& xclass , ▁out _ len ); ▁if ▁( j ▁& ▁0 x 80) ▁{ ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁switch ▁( tag ) ▁{ ▁case ▁V _ ASN 1 _ OBJECT : ▁a _ object ▁= ▁ c 2 i _ ASN 1 _ OBJECT ( NULL , ▁& string , ▁len ); ▁if ▁( a _ object ▁ != ▁NULL ) ▁{ ▁nid ▁= ▁OBJ _ obj 2 nid ( a _ object ); ▁EST _ LOG _ INFO (" NID =% d ", ▁nid ); ▁* new _ nid ▁= ▁nid ; ▁* der _ len ▁= ▁( out _ len _ save ▁- ▁( int ) ▁( string ▁- ▁ostring )); ▁* der _ ptr ▁= ▁( un signed ▁char ▁* ) string ; ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁break ; ▁default : ▁/* ▁have ▁to ▁a d just ▁string ▁pointer ▁here ▁*/ ▁string ▁+= ▁len ; ▁break ; ▁case ▁V _ ASN 1 _ SET : ▁case ▁V _ ASN 1 _ SEQUENCE : ▁break ; ▁} ▁out _ len ▁= ▁( out _ len _ save ▁- ▁( string ▁- ▁ostring )); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁ cleanse _ auth _ credentials ▁- ▁W alk ▁through ▁the ▁auth _ credentials ▁structure ▁and ▁* ▁over write ▁and ▁free ▁ each ▁value . ▁*/ ▁void ▁ cleanse _ auth _ credentials ( EST _ HTTP _ AUTH _ HDR ▁* auth _ cred ) ▁{ ▁if ▁( auth _ cred ▁== ▁NULL ) ▁{ ▁return ; ▁} ▁if ▁( auth _ cred -> user ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> user , ▁ strnlen _ s ( auth _ cred -> user , ▁ MAX _ UIDPWD )); ▁free ( auth _ cred -> user ); ▁auth _ cred -> user ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> pwd ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> pwd , ▁ strnlen _ s ( auth _ cred -> pwd , ▁ MAX _ UIDPWD )); ▁free ( auth _ cred -> pwd ); ▁auth _ cred -> pwd ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> uri ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> uri , ▁ strnlen _ s ( auth _ cred -> uri , ▁EST _ URI _ MAX _ LEN )); ▁free ( auth _ cred -> uri ); ▁auth _ cred -> uri ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> cnonce ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> cnonce , ▁ strnlen _ s ( auth _ cred -> cnonce , ▁ MAX _ NONCE )); ▁free ( auth _ cred -> cnonce ); ▁auth _ cred -> cnonce ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> qop ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> qop , ▁ strnlen _ s ( auth _ cred -> qop , ▁ MAX _ QOP )); ▁free ( auth _ cred -> qop ); ▁auth _ cred -> qop ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> nc ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> nc , ▁ strnlen _ s ( auth _ cred -> nc , ▁ MAX _ NC )); ▁free ( auth _ cred -> nc ); ▁auth _ cred -> nc ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> nonce ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> nonce , ▁ strnlen _ s ( auth _ cred -> nonce , ▁ MAX _ NONCE )); ▁free ( auth _ cred -> nonce ); ▁auth _ cred -> nonce ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> response ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> response , ▁ strnlen _ s ( auth _ cred -> response , ▁ MAX _ RESPONSE )); ▁free ( auth _ cred -> response ); ▁auth _ cred -> response ▁= ▁NULL ; ▁} ▁if ▁( auth _ cred -> auth _ token ) ▁{ ▁O PEN SSL _ cleanse ( auth _ cred -> auth _ token , ▁ strnlen _ s ( auth _ cred -> auth _ token , ▁ MAX _ AUTH _ TOKEN _ LEN )); ▁free ( auth _ cred -> auth _ token ); ▁auth _ cred -> auth _ token ▁= ▁NULL ; ▁} ▁return ; ▁} ▁/* ▁* ▁Give n ▁an ▁input ▁string , ▁look ▁for ▁the ▁fou r ▁valid ▁operations ▁*/ ▁EST _ OPERATION ▁est _ parse _ operation ▁( char ▁* op _ path ) ▁{ ▁EST _ OPERATION ▁operation ; ▁if ▁(! est _ strcasecmp _ s ( op _ path , ▁EST _ GET _ CACERTS )) ▁{ ▁operation ▁= ▁EST _ OP _ CACERTS ; ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( op _ path , ▁EST _ GET _ CSRATTRS )) ▁{ ▁operation ▁= ▁EST _ OP _ CSRATTRS ; ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( op _ path , ▁EST _ SIMPLE _ ENROLL )) ▁{ ▁operation ▁= ▁EST _ OP _ SIMPLE _ ENROLL ; ▁} ▁else ▁if ▁(! est _ strcasecmp _ s ( op _ path , ▁EST _ SIMPLE _ REENROLL )) ▁{ ▁operation ▁= ▁EST _ OP _ SIMPLE _ REENROLL ; ▁} ▁else ▁{ ▁operation ▁= ▁EST _ OP _ MAX ; ▁} ▁return ▁( operation ); ▁} ▁/* ▁* ▁Give n ▁an ▁input ▁string , ▁look ▁for ▁the ▁fou r ▁valid ▁operations ▁*/ ▁EST _ ERROR ▁est _ parse _ uri ▁( char ▁* uri , ▁EST _ OPERATION ▁* operation , ▁char ▁** path _ seg ) ▁{ ▁/* ▁char ▁* path _ seg _ end ; ▁*/ ▁/* ▁int ▁path _ seg _ len ▁= ▁0; ▁*/ ▁UriPa rs er State A ▁state ; ▁ Uri UriA ▁parsed _ uri ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁int ▁uriparse _ rc ; ▁errno _ t ▁safe c _ rc ; ▁int ▁diff ; ▁* path _ seg ▁= ▁NULL ; ▁state . uri ▁= ▁& parse d _ uri ; ▁uriparse _ rc ▁= ▁uri P ar se UriA (& state , ▁uri ); ▁if ▁( uri parse _ rc ▁ != ▁URI _ SUCCESS ) ▁{ ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁if ▁( parse d _ uri . pathHead ) ▁{ ▁/* ▁* ▁validate ▁the ▁URI ▁* ▁- ▁parse ▁the ▁path - prefix ▁( / . well - known / est ) ▁* ▁- ▁look ▁to ▁see ▁if ▁there ▁is ▁a ▁path ▁segment ▁extension ▁* ▁- ▁determine ▁which ▁operation ▁it ▁is ▁*/ ▁UriPa th Segment A ▁* cur _ seg ▁= ▁parsed _ uri . pathHead ; ▁char ▁* cur _ seg _ str ▁= ▁( char ▁* ) cur _ seg -> text . first ; ▁int ▁cur _ seg _ len ▁= ▁0; ▁char ▁* segment ▁= ▁NULL ; ▁safe c _ rc ▁= ▁mem cmp _ s ( cur _ seg _ str , ▁W E L L _ KNOWN _ SEGMENT _ LEN , ▁" . well - known ", ▁W E L L _ KNOWN _ SEGMENT _ LEN , ▁& diff ); ▁if ▁( diff ▁|| ▁safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ ERR (" URI ▁path ▁does ▁not ▁start ▁with ▁% s , ▁safe c _ rc ▁= ▁0 x % xO \ n ", ▁W E L L _ KNOWN _ SEGMENT , ▁safe c _ rc ); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁cur _ seg ▁= ▁cur _ seg -> next ; ▁cur _ seg _ str ▁= ▁( char ▁* ) cur _ seg -> text . first ; ▁safe c _ rc ▁= ▁mem cmp _ s ( cur _ seg _ str , ▁EST _ SEGMENT _ LEN , ▁" est ", ▁EST _ SEGMENT _ LEN , ▁& diff ); ▁if ▁( diff ▁|| ▁safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ ERR (" URI ▁does ▁not ▁contain ▁% s ▁segment ▁0 x % xO \ n ", ▁EST _ SEGMENT , ▁safe c _ rc ); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁/* ▁* ▁This ▁next ▁segment ▁is ▁e i ther ▁a ▁segment ▁extension ▁* ▁or ▁it ' s ▁the ▁operation ▁*/ ▁cur _ seg ▁= ▁cur _ seg -> next ; ▁cur _ seg _ str ▁= ▁( char ▁* ) cur _ seg -> text . first ; ▁/* ▁* ▁If ▁there ' s ▁another ▁segment ▁after ▁this ▁one ▁then ▁use ▁it ▁* ▁to ▁find ▁the ▁end , ▁else ▁walk ▁this ▁one ▁for ▁the ▁length ▁*/ ▁if ▁( cur _ seg -> text . afterLast ) ▁{ ▁cur _ seg _ len ▁= ▁( ( char ▁* ) cur _ seg -> text . afterLast ) ▁- ▁cur _ seg _ str ; ▁} ▁else ▁{ ▁cur _ seg _ len ▁= ▁ strnlen _ s ( cur _ seg _ str , ▁EST _ MAX _ P ATH _ SEGMENT _ LEN +1 ); ▁} ▁if ▁( cur _ seg _ len ▁> ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ) ▁{ ▁EST _ LOG _ ERR (" path ▁segment ▁exceed s ▁maximum ▁of ▁% d \ n ", ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁/* ▁* ▁Se e ▁if ▁the ▁current ▁segment ▁needs ▁to ▁be ▁put ▁into ▁its ▁own ▁* ▁string ▁*/ ▁if ▁( ( cur _ seg -> text . afterLast ▁ != ▁NULL ) ▁&& ▁* ( cur _ seg -> text . afterLast ) ▁ != ▁'\0') ▁{ ▁segment ▁= ▁STR NDU P ( cur _ seg _ str , ▁cur _ seg _ len ); ▁} ▁else ▁{ ▁segment ▁= ▁STR NDU P ( cur _ seg _ str , ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ); ▁} ▁/* ▁* ▁look ▁to ▁see ▁if ▁the ▁operation ▁path ▁come s ▁next : ▁* ▁cacerts , ▁csrattrs , ▁simpleenroll , ▁ simplereenroll ▁*/ ▁* operation ▁= ▁est _ parse _ operation ( segment ); ▁if ▁(* operation ▁== ▁EST _ OP _ MAX ) ▁{ ▁/* ▁* ▁It ▁was n ' t ▁one ▁of ▁the ▁4 ▁known ▁operations ▁so ▁* ▁it ▁must ▁be ▁a ▁path ▁segment . ▁parse ▁it ▁out . ▁* ▁* ▁Find ▁the ▁end ▁of ▁the ▁path ▁segment , ▁* ▁determine ▁the ▁length , ▁* ▁save ▁it ▁away ▁*/ ▁/* ▁path _ seg _ end ▁= ▁( char ▁* ) cur _ seg -> text . afterLast ; ▁*/ ▁/* ▁if ▁( path _ seg _ end ▁ != ▁NULL ) ▁{ ▁*/ ▁/* ▁path _ seg _ len ▁= ▁path _ seg _ end ▁- ▁cur _ seg _ str ; ▁*/ ▁/* ▁} ▁*/ ▁* path _ seg ▁= ▁malloc ( cur _ seg _ len +1 ); ▁if ▁(* path _ seg ▁== ▁NULL ) ▁{ ▁free ( segment ); ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁safe c _ rc ▁= ▁memcpy _ s (* path _ seg , ▁cur _ seg _ len +1, ▁segment , ▁cur _ seg _ len ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ ERR (" URI ▁path ▁ seg ▁could ▁not ▁copied ▁into ▁the ▁context "); ▁free ( segment ); ▁free (* path _ seg ); ▁* path _ seg ▁= ▁NULL ; ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁* ( (* path _ seg ) + cur _ seg _ len ) ▁= ▁'\0'; ▁/* ▁* ▁now ▁that ▁we ▁have ▁the ▁path ▁segment ▁parsed , ▁try ▁* ▁for ▁the ▁operation ▁again . ▁ ju mp ▁over ▁the ▁path ▁segment ▁* ▁and ▁the ▁next ▁'/' ▁*/ ▁cur _ seg _ str ▁= ▁cur _ seg _ str ▁+ ▁cur _ seg _ len ▁+ ▁1; ▁* operation ▁= ▁est _ parse _ operation ( cur _ seg _ str ); ▁if ▁(* operation ▁== ▁EST _ OP _ MAX ) ▁{ ▁/* ▁* ▁Operation ▁code ▁was ▁ su p pos e ▁to ▁be ▁next ▁but ▁is ▁not ▁*/ ▁free ( segment ); ▁free (* path _ seg ); ▁* path _ seg ▁= ▁NULL ; ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ BAD _ REQ ); ▁} ▁} ▁else ▁{ ▁/* ▁* ▁It ▁was ▁one ▁of ▁the ▁operations , ▁make ▁sure ▁it ' s ▁the ▁end ▁*/ ▁if ▁( ( cur _ seg -> text . afterLast ▁ != ▁NULL ) ▁&& ▁* ( cur _ seg -> text . afterLast ) ▁ != ▁'\0') ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁path ▁segment : ▁contains ▁an ▁operation ▁value "); ▁free ( segment ); ▁free (* path _ seg ); ▁* path _ seg ▁= ▁NULL ; ▁* operation ▁= ▁EST _ OP _ MAX ; ▁uri Free Uri Members A ( state . uri ); ▁return ▁( EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ); ▁} ▁} ▁free ( segment ); ▁uri Free Uri Members A ( state . uri ); ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁Give n ▁an ▁input ▁string , ▁look ▁for ▁the ▁fou r ▁valid ▁operations ▁*/ ▁EST _ ERROR ▁est _ parse _ uri ▁( char ▁* uri , ▁EST _ OPERATION ▁* operation , ▁char ▁** path _ seg ) ▁{ ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁* path _ seg ▁= ▁NULL ; ▁/* ▁* ▁A ssume ▁that ▁the ▁uri ▁is ▁point ing ▁to ▁* ▁/ . well - known / est / < operation > ▁*/ ▁if ▁( strnc mp ( uri , ▁EST _ CACERTS _ URI , ▁EST _ URI _ MAX _ LEN ) ▁== ▁0) ▁{ ▁* operation ▁= ▁EST _ OP _ CACERTS ; ▁} ▁else ▁if ▁( strnc mp ( uri , ▁EST _ SIMPLE _ ENROLL _ URI , ▁EST _ URI _ MAX _ LEN ) ▁== ▁0) ▁{ ▁* operation ▁= ▁EST _ OP _ SIMPLE _ ENROLL ; ▁} ▁else ▁if ▁( strnc mp ( uri , ▁EST _ RE _ ENROLL _ URI , ▁EST _ URI _ MAX _ LEN ) ▁== ▁0) ▁{ ▁* operation ▁= ▁EST _ OP _ SIMPLE _ REENROLL ; ▁} ▁else ▁if ▁( strnc mp ( uri , ▁EST _ CSR _ ATTR S _ URI , ▁EST _ URI _ MAX _ LEN ) ▁== ▁0) ▁{ ▁* operation ▁= ▁EST _ OP _ CSRATTRS ; ▁} ▁else ▁{ ▁* operation ▁= ▁EST _ OP _ MAX ; ▁rc ▁= ▁EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ; ▁} ▁return ▁rc ; ▁} ▁/* ▁* ▁Store ▁the ▁path ▁segment ▁into ▁the ▁context . ▁*/ ▁EST _ ERROR ▁est _ store _ path _ segment ▁( EST _ CTX ▁* ctx , ▁char ▁* path _ segment , ▁int ▁path _ segment _ len ) ▁{ ▁/* ▁* ▁reset ▁what ▁m ight ▁already ▁be ▁cached ▁*/ ▁if ▁( ctx -> uri _ path _ segment ) ▁{ ▁free ( ctx -> uri _ path _ segment ); ▁ctx -> uri _ path _ segment ▁= ▁NULL ; ▁} ▁ctx -> uri _ path _ segment ▁= ▁malloc ( strnlen _ s ( path _ segment , ▁path _ segment _ len ) +1 ); ▁if ▁( ctx -> uri _ path _ segment ▁== ▁NULL ) ▁{ ▁return ▁EST _ ERR _ MALLOC ; ▁} ▁if ▁( EOK ▁ != ▁strncpy _ s ( ctx -> uri _ path _ segment , ▁path _ segment _ len +1, ▁path _ segment , ▁path _ segment _ len )) ▁{ ▁return ▁EST _ ERR _ HTTP _ INVALID _ P ATH _ SEGMENT ; ▁} ▁ctx -> uri _ path _ segment [ path _ segment _ len ] ▁= ▁'\0'; ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ▁* ▁Store ▁the ▁path ▁segment ▁into ▁the ▁context . ▁*/ ▁int ▁est _ strcasecmp _ s ▁( char ▁* s 1, ▁char ▁* s 2) ▁{ ▁errno _ t ▁safe c _ rc ; ▁int ▁diff ; ▁safe c _ rc ▁= ▁ strcasecmp _ s ( s 1, ▁ strnlen _ s ( s 1, ▁R SIZE _ MAX _ STR ) , ▁ s 2 , ▁& diff ); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁/* ▁* ▁Log ▁that ▁we ▁e n counter ed ▁a ▁S a f e C ▁error ▁*/ ▁EST _ LOG _ INFO (" strcasecmp _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁return ▁diff ; ▁}