▁/* ▁* ▁This ▁function ▁send s ▁EST ▁specific ▁HTTP ▁error ▁response s . ▁*/ ▁void ▁est _ send _ http _ error ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁int ▁fail _ code ) ▁{ ▁struct ▁mg _ connection ▁* conn ▁= ▁( struct ▁mg _ connection *) http _ ctx ; ▁switch ▁( fail _ code ) ▁{ ▁case ▁EST _ ERR _ BAD _ PKCS 10 : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _400, ▁EST _ HTTP _ STAT _ 400 _ TXT , ▁EST _ BODY _ BAD _ PKCS 10); ▁break ; ▁case ▁EST _ ERR _ AUTH _ FAIL : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _401, ▁EST _ HTTP _ STAT _ 40 1 _ TXT , ▁EST _ BODY _ UNAUTHORIZED ); ▁break ; ▁case ▁EST _ ERR _ WRONG _ METHOD : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _400, ▁EST _ HTTP _ STAT _ 400 _ TXT , ▁EST _ BODY _ BAD _ ME TH ); ▁break ; ▁case ▁EST _ ERR _ NO _ SSL _ CTX : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _400, ▁EST _ HTTP _ STAT _ 400 _ TXT , ▁EST _ BODY _ BAD _ SSL ); ▁break ; ▁case ▁EST _ ERR _ HTTP _ NOT _ FOUND : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _ 4 04, ▁EST _ HTTP _ STAT _ 40 4 _ TXT , ▁EST _ BODY _ NOT _ FOUND ); ▁break ; ▁case ▁EST _ ERR _ HTTP _ NO _ CONTENT : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _204, ▁EST _ HTTP _ STAT _ 20 4 _ TXT , ▁" "); ▁break ; ▁default : ▁mg _ send _ http _ error ( conn , ▁EST _ HTTP _ STAT _400, ▁EST _ HTTP _ STAT _ 400 _ TXT , ▁EST _ BODY _ UNKNOWN _ ERR ); ▁break ; ▁} ▁} ▁/* ▁* ▁This ▁function ▁send s ▁a ▁HTTP ▁202 ▁Accepted ▁response ▁to ▁the ▁* ▁client ▁with ▁the ▁retry - after ▁value ▁from ▁the ▁CA . ▁This ▁* ▁notifie s ▁the ▁client ▁that ▁it ▁should ▁check ▁back ▁later ▁to ▁* ▁see ▁if ▁the ▁CSR ▁was ▁approved . ▁*/ ▁EST _ ERROR ▁est _ server _ send _ http _ retry _ after ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁int ▁delay ) ▁{ ▁char ▁http _ hdr [ EST _ HTTP _ HDR _ MAX ] ; ▁struct ▁mg _ connection ▁* conn ▁= ▁( struct ▁mg _ connection *) http _ ctx ; ▁ snprintf ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX , ▁"% s % s % s % s % s : ▁% d % s % s ", ▁EST _ HTTP _ HDR _202, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ STAT _202, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ RETRY _ AFTER , ▁delay , ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ EOL ); ▁conn -> status _ code ▁= ▁EST _ HTTP _ STAT _ 20 2 ; ▁if ▁(! mg _ write ( http _ ctx , ▁http _ hdr , ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁EST _ LOG _ ERR (" HTTP ▁write ▁error ▁while ▁pro p a g a ting ▁retry - after "); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁handle s ▁an ▁incoming ▁cacerts ▁request ▁from ▁* ▁the ▁client . ▁*/ ▁int ▁est _ handle _ cacerts ▁( EST _ CTX ▁* ctx , ▁un signed ▁char ▁* ca _ certs , ▁int ▁ca _ certs _ len , ▁void ▁* http _ ctx , ▁char ▁* path _ seg ) ▁{ ▁char ▁http _ hdr [ EST _ HTTP _ HDR _ MAX ] ; ▁int ▁hdrlen ; ▁if ▁( ca _ certs ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ HTTP _ NOT _ FOUND ); ▁} ▁/* ▁* ▁Send ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX , ▁"% s % s % s % s ", ▁EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ STAT _200, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CT , ▁EST _ HTTP _ CT _ PKCS 7, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CE , ▁EST _ HTTP _ CE _ BASE 64, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% d % s % s ", ▁EST _ HTTP _ HDR _ CL , ▁ca _ certs _ len , ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ EOL ); ▁if ▁(! mg _ write ( http _ ctx , ▁http _ hdr , ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁/* ▁* ▁Send ▁the ▁CA ▁certs ▁in ▁the ▁body ▁*/ ▁if ▁(! mg _ write ( http _ ctx , ▁ca _ certs , ▁ca _ certs _ len )) ▁{ ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁EST _ LOG _ INFO (" CA ▁certs ▁successfully ▁sent ▁to ▁EST ▁client "); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Handle ▁a ▁CA ▁certs ▁request . ▁If ▁the ▁application ▁layer ▁has ▁* ▁registered ▁a ▁callback ▁then ▁call ▁it . ▁ El se , ▁if ▁the ▁application ▁* ▁layer ▁has ▁provided ▁a ▁locally ▁configured ▁buffer ▁then ▁send ▁it . ▁* ▁ El se , ▁return ▁an ▁error ▁indicat ing ▁that ▁there ▁are ▁no ▁CA ▁Certs ▁* ▁available . ▁*/ ▁static ▁int ▁est _ server _ handle _ cacerts ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* path _ seg ) ▁{ ▁EST _ ERROR ▁rv ; ▁int ▁ca _ certs _ len ; ▁un signed ▁char ▁* ca _ certs ; ▁/* ▁* ▁If ▁there ▁is ▁a ▁call ▁back ▁set ▁then ▁call ▁it . ▁* ▁otherwise , ▁if ▁there ▁is ▁a ▁locally ▁configured ▁cacerts ▁buffer , ▁* ▁then ▁return ▁that . ▁* ▁otherwise , ▁return ▁an ▁error ▁indicat ing ▁that ▁we ▁don ' t ▁have ▁any ▁cacerts ▁*/ ▁if ▁( ctx -> est _ get _ cacerts _ cb ) ▁{ ▁EST _ LOG _ INFO (" Server : ▁Re tr ie v ing ▁CA ▁certs ▁from ▁application ▁layer "); ▁ca _ certs ▁= ▁ctx -> est _ get _ cacerts _ cb (& ca _ certs _ len , ▁path _ seg , ctx -> ex _ data ); ▁if ▁( ca _ certs ) ▁{ ▁EST _ LOG _ INFO (" Server : ▁Successfully ▁retrieved ▁CA ▁certs ▁from ▁" ▁" application ▁layer "); ▁rv ▁= ▁est _ handle _ cacerts ( ctx , ▁ca _ certs , ▁ca _ certs _ len , ▁http _ ctx , ▁path _ seg ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁rv ▁= ▁EST _ ERR _ NONE ; ▁} ▁} ▁else ▁if ▁( ctx -> ca _ certs ) ▁{ ▁EST _ LOG _ INFO (" Server : ▁CA ▁certs ▁set ▁locally , ▁respond ing ▁with ▁" ▁" loc ally ▁set ▁CA ▁certs ▁response "); ▁rv ▁= ▁est _ handle _ cacerts ( ctx , ▁ctx -> ca _ certs , ▁ctx -> ca _ certs _ len , ▁http _ ctx , ▁path _ seg ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁rv ▁= ▁EST _ ERR _ NONE ; ▁} ▁return ▁( rv ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ generate _ auth _ digest () ▁is ▁used ▁by ▁an ▁application ▁to ▁calculate ▁the ▁HTTP ▁Digest ▁value ▁based ▁on ▁the ▁header ▁values ▁provided ▁by ▁an ▁EST ▁client . ▁@ param ▁ah ▁Authentication ▁header ▁values ▁from ▁client , ▁provided ▁by ▁libEST ▁@ param ▁HA 1 ▁The ▁pre c alculate d ▁HA 1 ▁value ▁for ▁the ▁user . ▁HA 1 ▁is ▁defined ▁in ▁RFC ▁ 2617 . ▁It ' s ▁the ▁MD 5 ▁cal c ul ation ▁of ▁the ▁user ' s ▁ID , ▁HTTP ▁realm , ▁and ▁the ▁user ' s ▁password . ▁This ▁is ▁a ▁ helper ▁function ▁that ▁an ▁application ▁can ▁use ▁to ▁calculate ▁the ▁HTTP ▁Digest ▁value ▁when ▁perform ing ▁HTTP ▁Digest ▁Authentication ▁of ▁an ▁EST ▁client . ▁libEST ▁does ▁not ▁maintain ▁a ▁user ▁database . ▁This ▁is ▁left ▁up ▁to ▁the ▁application , ▁with ▁the ▁int ent ▁of ▁int eg ra ting ▁an ▁external ▁user ▁database ▁( e . g . ▁Radius / A AA ) . ▁The ▁HA 1 ▁value ▁should ▁be ▁calculate d ▁by ▁the ▁application ▁as ▁defined ▁in ▁RFC ▁ 2617 . ▁HA 1 ▁is ▁the ▁MD 5 ▁hash ▁of ▁the ▁user ▁ID , ▁HTTP ▁realm , ▁and ▁user ▁password . ▁This ▁MD 5 ▁value ▁is ▁then ▁convert ed ▁to ▁a ▁hex ▁string . ▁HA 1 ▁is ▁expected ▁to ▁be ▁ 32 ▁bytes ▁long . ▁@ return ▁char * ▁containing ▁the ▁digest , ▁or ▁NULL ▁if ▁an ▁error ▁occurred . ▁*/ ▁char ▁* est _ server _ generate _ auth _ digest ▁( EST _ HTTP _ AUTH _ HDR ▁* ah , ▁char ▁* HA 1) ▁{ ▁E VP _ MD _ CTX ▁* mdctx ; ▁const ▁E VP _ MD ▁* md ▁= ▁E VP _ md 5 (); ▁u int 8 _ t ▁ha 2 [ E VP _ MAX _ MD _ SIZE ] ; ▁un signed ▁int ▁ha 2 _ len ; ▁char ▁ha 2 _ str [3 3 ] ; ▁un signed ▁char ▁digest [ E VP _ MAX _ MD _ SIZE ] ; ▁un signed ▁int ▁d _ len ; ▁char ▁* rv ; ▁if ▁(! ah ) ▁{ ▁EST _ LOG _ ERR (" Null ▁auth ▁header "); ▁return ▁( NULL ); ▁} ▁if ▁(! HA 1) ▁{ ▁EST _ LOG _ ERR (" Null ▁HA 1 "); ▁return ▁( NULL ); ▁} ▁/* ▁* ▁C alculate ▁HA 2 ▁using ▁method , ▁URI , ▁*/ ▁ mdctx ▁= ▁E VP _ MD _ CTX _ create (); ▁E VP _ Digest Init _ ex ( mdctx , ▁md , ▁NULL ); ▁E VP _ Digest Update ( mdctx , ▁" POST ", ▁4 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ah -> uri , ▁ strnlen _ s ( ah -> uri , ▁ MAX _ REALM )); ▁E VP _ Digest Final ( mdctx , ▁ha 2 , ▁& ha 2 _ len ); ▁E VP _ MD _ CTX _ destroy ( mdctx ); ▁est _ hex _ to _ str ( ha 2 _ str , ▁ha 2 , ▁ha 2 _ len ); ▁/* ▁* ▁C alculate ▁auth ▁digest ▁using ▁HA 1, ▁nonce , ▁nonce ▁count , ▁client ▁nonce , ▁qop , ▁HA 2 ▁*/ ▁ mdctx ▁= ▁E VP _ MD _ CTX _ create (); ▁E VP _ Digest Init _ ex ( mdctx , ▁md , ▁NULL ); ▁E VP _ Digest Update ( mdctx , ▁HA 1, ▁ 32 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ah -> nonce , ▁ strnlen _ s ( ah -> nonce , ▁ MAX _ NONCE )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ah -> nc , ▁ strnlen _ s ( ah -> nc , ▁ MAX _ NC )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ah -> cnonce , ▁ strnlen _ s ( ah -> cnonce , ▁ MAX _ NONCE )); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁" auth ", ▁4 ); ▁E VP _ Digest Update ( mdctx , ▁":" , ▁1); ▁E VP _ Digest Update ( mdctx , ▁ha 2 _ str , ▁ha 2 _ len ▁* ▁2 ); ▁E VP _ Digest Final ( mdctx , ▁digest , ▁& d _ len ); ▁E VP _ MD _ CTX _ destroy ( mdctx ); ▁rv ▁= ▁malloc ( 3 3 ); ▁est _ hex _ to _ str ( rv , ▁digest , ▁d _ len ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁allocate s ▁an ▁HTTP ▁authentication ▁header ▁* ▁structure , ▁which ▁is ▁used ▁to ▁pass ▁the ▁auth ▁credentials ▁* ▁to ▁the ▁application ▁layer ▁to ▁allow ▁the ▁app ▁to ▁authenticate ▁* ▁an ▁EST ▁client . ▁*/ ▁static ▁EST _ HTTP _ AUTH _ HDR ▁* ▁est _ create _ ah () ▁{ ▁EST _ HTTP _ AUTH _ HDR ▁* ah ; ▁ah ▁= ▁malloc ( sizeof ( EST _ HTTP _ AUTH _ HDR )); ▁mem zero _ s ( ah , ▁sizeof ( EST _ HTTP _ AUTH _ HDR )); ▁return ▁( ah ); ▁} ▁/* ▁* ▁This ▁function ▁free s ▁all ▁the ▁ element s ▁on ▁an ▁HTTP ▁* ▁authentication ▁header ▁structure . ▁*/ ▁static ▁void ▁est _ destroy _ ah ( EST _ HTTP _ AUTH _ HDR ▁* ah ) ▁{ ▁int ▁len ; ▁if ▁(! ah ) ▁return ; ▁if ▁( ah -> user ) ▁free ( ah -> user ); ▁if ▁( ah -> pwd ) ▁{ ▁/* ▁* ▁Get ▁the ▁length ▁of ▁the ▁password ▁so ▁it ▁can ▁be ▁zero ized ▁*/ ▁len ▁= ▁ strnlen _ s ( ah -> pwd , ▁ MAX _ UIDPWD ); ▁if ▁( len ) ▁{ ▁mem zero _ s ( ah -> pwd , ▁len ); ▁} ▁free ( ah -> pwd ); ▁} ▁if ▁( ah -> uri ) ▁free ( ah -> uri ); ▁if ▁( ah -> cnonce ) ▁free ( ah -> cnonce ); ▁if ▁( ah -> qop ) ▁free ( ah -> qop ); ▁if ▁( ah -> nc ) ▁free ( ah -> nc ); ▁if ▁( ah -> nonce ) ▁free ( ah -> nonce ); ▁if ▁( ah -> response ) ▁free ( ah -> response ); ▁if ▁( ah -> auth _ token ) ▁{ ▁len ▁= ▁ strnlen _ s ( ah -> auth _ token , ▁ MAX _ AUTH _ TOKEN _ LEN ); ▁if ▁( len ) ▁{ ▁mem zero _ s ( ah -> auth _ token , ▁len ); ▁} ▁free ( ah -> auth _ token ); ▁} ▁free ( ah ); ▁} ▁/* ▁* ▁This ▁function ▁verifie s ▁that ▁the ▁peer ▁e i ther ▁provided ▁a ▁certificate ▁* ▁that ▁was ▁ ver if ed ▁by ▁the ▁TLS ▁stack , ▁or ▁HTTP ▁authentication ▁* ▁credentials ▁we re ▁provided . ▁* ▁* ▁Returns ▁a ▁EST _ AUTH _ STATE ▁authorization ▁result ▁*/ ▁EST _ AUTH _ STATE ▁est _ enroll _ auth ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁SSL ▁* ssl , ▁char ▁* path _ seg , ▁int ▁reenroll ) ▁{ ▁EST _ AUTH _ STATE ▁rv ▁= ▁EST _ UNAUTHORIZED ; ▁X 509 ▁* peer ▁= ▁NULL ; ▁struct ▁mg _ connection ▁* conn ▁= ▁( struct ▁mg _ connection *) http _ ctx ; ▁EST _ HTTP _ AUTH _ HDR ▁* ah ; ▁EST _ HTTP _ AUTH _ HDR _ RE S U LT ▁p r ; ▁int ▁v _ result ; ▁/* ▁* ▁Get ▁client ▁certificate ▁from ▁TLS ▁stack . ▁*/ ▁if ▁( ( peer ▁= ▁SSL _ get _ peer _ certificate ( ssl )) ▁ != ▁NULL ) ▁{ ▁// ▁check ▁TLS ▁based ▁client ▁authorization ▁( is ▁client ▁cert ▁authorized ) ▁v _ result ▁= ▁( int ) ▁SSL _ get _ verify _ result ( ssl ); ▁if ▁( X 509_ V _ OK ▁== ▁v _ result ) ▁{ ▁EST _ LOG _ INFO (" TLS : ▁client ▁certificate ▁is ▁valid "); ▁rv ▁= ▁EST _ CERT _ AUTH ; ▁} ▁else ▁if ▁( X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ▁== ▁v _ result ) ▁{ ▁EST _ LOG _ WARN (" Pe er ▁cert ▁is ▁valid , ▁but ▁no ▁CRL ▁was ▁loaded . ▁U nable ▁to ▁determine ▁if ▁peer ▁cert ▁is ▁revoked . "); ▁rv ▁= ▁EST _ CERT _ AUTH ; ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS : ▁client ▁certificate ▁not ▁verified ▁( v _ result =% d )", ▁v _ result ); ▁/* ▁We ▁need ▁to ▁bail ▁since ▁the ▁client ▁is ▁using ▁a ▁bogus ▁cert , ▁* ▁no ▁need ▁to ▁con ti ue ▁with ▁HTTP ▁authentication ▁below ▁*/ ▁X 509_ free ( peer ); ▁return ( EST _ UNAUTHORIZED ); ▁} ▁} ▁else ▁{ ▁EST _ LOG _ INFO (" TLS : ▁no ▁peer ▁certificate "); ▁rv ▁= ▁EST _ UNAUTHORIZED ; ▁} ▁/* ▁* ▁Se e ▁if ▁SRP ▁is ▁being ▁used . ▁If ▁so , ▁there ▁will ▁be ▁no ▁* ▁certificate . ▁*/ ▁if ▁( rv ▁ != ▁EST _ CERT _ AUTH ▁&& ▁SSL _ get _ srp _ username ( ssl ) ▁ != ▁NULL ) ▁{ ▁EST _ LOG _ INFO (" TLS : ▁no ▁certificate ▁from ▁client , ▁SRP ▁login ▁is ▁% s ", ▁SSL _ get _ srp _ username ( ssl )); ▁rv ▁= ▁EST _ SRP _ AUTH ; ▁} ▁/* ▁* ▁If ▁the ▁application ▁layer ▁has ▁enabled ▁HTTP ▁authentication ▁we ▁* ▁will ▁attempt ▁HTTP ▁authentication ▁when ▁TLS ▁client ▁auth ▁fails ▁* ▁or ▁when ▁the ▁require _ http _ auth ▁flag ▁is ▁set ▁by ▁the ▁application . ▁* ▁All ▁this ▁assume s ▁the ▁application ▁layer ▁has ▁provided ▁the ▁HTTP ▁auth ▁* ▁callback ▁facility . ▁*/ ▁if ▁( ctx -> est _ http _ auth _ cb ▁&& ▁( rv ▁== ▁EST _ UNAUTHORIZED ▁|| ▁HTTP _ AUTH _ REQUIRED ▁== ▁ctx -> require _ http _ auth )) ▁{ ▁/* ▁* ▁T ry ▁HTTP ▁authentication . ▁*/ ▁ah ▁= ▁est _ create _ ah (); ▁p r ▁= ▁mg _ parse _ auth _ header ( conn , ▁ah ); ▁switch ▁( pr ) ▁{ ▁case ▁EST _ AUTH _ HDR _ GOOD : ▁/* ▁* ▁I nvoke ▁the ▁application ▁specific ▁auth ▁check ▁now ▁* ▁that ▁we ▁have ▁the ▁user ' s ▁credentials ▁*/ ▁if ▁( ctx -> est _ http _ auth _ cb ( ctx , ▁ah , ▁peer , ▁path _ seg , ▁ctx -> ex _ data )) ▁{ ▁rv ▁= ▁EST _ HTTP _ AUTH ; ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" HTTP ▁authentication ▁failed . ▁Auth ▁type =% d ", ▁ah -> mode ); ▁rv ▁= ▁EST _ UNAUTHORIZED ; ▁} ▁break ; ▁case ▁EST _ AUTH _ HDR _ MISSING : ▁// ▁ask ▁client ▁to ▁send ▁us ▁authorization ▁headers ▁mg _ send _ authorization _ request ( conn ); ▁EST _ LOG _ INFO (" HTTP ▁auth ▁headers ▁missing , ▁send ing ▁HTTP ▁auth ▁request ▁to ▁client . "); ▁rv ▁= ▁EST _ HTTP _ AUTH _ PENDING ; ▁break ; ▁case ▁EST _ AUTH _ HDR _ BAD : ▁default : ▁EST _ LOG _ WARN (" Client ▁sent ▁incomplete ▁HTTP ▁authorization ▁header "); ▁if ▁( reenroll ▁&& ▁rv ▁== ▁EST _ CERT _ AUTH ) ▁{ ▁EST _ LOG _ INFO (" Client ▁cert ▁was ▁authenticated , ▁HTTP ▁auth ▁not ▁required ▁for ▁reenroll "); ▁} ▁else ▁{ ▁rv ▁= ▁EST _ UNAUTHORIZED ; ▁} ▁break ; ▁} ▁est _ destroy _ ah ( ah ); ▁} ▁if ▁( peer ) ▁{ ▁X 509_ free ( peer ); ▁} ▁return ▁( rv ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁to ▁determine ▁if ▁the ▁EST ▁client , ▁which ▁could ▁be ▁* ▁an ▁RA , ▁is ▁using ▁a ▁certificate ▁that ▁contains ▁the ▁id - kp - cmcRA ▁usage ▁* ▁extension . ▁When ▁this ▁usage ▁bit ▁is ▁present , ▁the ▁PoP ▁check ▁is ▁disabled ▁* ▁to ▁allow ▁the ▁RA ▁use ▁case . ▁* ▁* ▁This ▁logic ▁was ▁taken ▁from ▁x 509 v 3 _ c ache _ extensions () ▁in ▁v 3 _ p ur p . c ▁( OpenSSL ) . ▁* ▁* ▁Returns ▁1 ▁if ▁the ▁cert ▁contains ▁id - kp - cmcRA ▁e xtended ▁key ▁usage ▁extension . ▁* ▁Otherwise ▁it ▁return s ▁0 . ▁*/ ▁static ▁int ▁est _ check _ cmcRA ▁( X 509 ▁* cert ) ▁{ ▁int ▁ cmcRA _ found ▁= ▁0; ▁ EXTEN DE D _ KEY _ US AGE ▁* extusage ; ▁int ▁i ; ▁ASN 1 _ OBJECT ▁* obj ; ▁/* ▁* ▁Get ▁the ▁e xtended ▁key ▁usage ▁extension . ▁If ▁found ▁* ▁loo p ▁through ▁the ▁values ▁and ▁look ▁for ▁the ▁i k - kp - cmcRA ▁* ▁value ▁in ▁this ▁extension . ▁*/ ▁if ( ( extusage ▁= ▁X 509_ get _ ext _ d 2 i ( cert , ▁NID _ ext _ key _ us age , ▁NULL , ▁NULL ))) ▁{ ▁/* ▁* ▁Iterat e ▁through ▁the ▁e xtended ▁key ▁usage ▁values ▁*/ ▁for ( i ▁= ▁0; ▁i ▁< ▁sk _ ASN 1 _ OBJECT _ num ( extusage ); ▁i ++) ▁{ ▁obj ▁= ▁sk _ ASN 1 _ OBJECT _ value ( extusage , i ); ▁/* ▁* ▁ Comp a re ▁the ▁current ▁it e ration ▁with ▁the ▁global ▁* ▁id - kp - cmcRA ▁value ▁that ▁was ▁created ▁earlier ▁*/ ▁if ▁(! OBJ _ cmp ( obj , ▁ o _ cmcRA )) ▁{ ▁ cmcRA _ found ▁= ▁1; ▁break ; ▁} ▁} ▁sk _ ASN 1 _ OBJECT _ pop _ free ( extusage , ▁ASN 1 _ OBJECT _ free ); ▁} ▁return ▁( cmcRA _ found ); ▁} ▁/* ▁* ▁This ▁is ▁a ▁utility ▁function ▁to ▁convert ▁the ▁base 64 ▁DER ▁encoded ▁* ▁CSR ▁to ▁an ▁OpenSSL ▁X 509_ REQ ▁pointer . ▁Returns ▁NULL ▁if ▁there ▁* ▁was ▁a ▁problem . ▁*/ ▁X 509_ REQ ▁* ▁est _ server _ parse _ csr ▁( un signed ▁char ▁* pkcs 10 , ▁int ▁pkcs 10_ len ) ▁{ ▁BIO ▁* in , ▁* b 64 ; ▁X 509_ REQ ▁* req ; ▁/* ▁* ▁Get ▁the ▁original ▁pkcs 10 ▁request ▁from ▁the ▁client ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁if ▁( b 64 ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁PKCS 10 ▁b 64 ▁buffer "); ▁return ▁( NULL ); ▁} ▁in ▁= ▁BIO _ new _ mem _ buf ( pkcs 10 , ▁pkcs 10_ len ); ▁if ▁( in ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁open ▁PKCS 10 ▁raw ▁buffer "); ▁BIO _ free ( b 64 ); ▁return ▁( NULL ); ▁} ▁in ▁= ▁BIO _ push ( b 64, ▁in ); ▁/* ▁* ▁ Read ▁the ▁PEM ▁encoded ▁pkcs 10 ▁cert ▁request ▁*/ ▁if ▁( ( req ▁= ▁d 2 i _ X 509_ REQ _ bio ( in , ▁NULL )) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Problem ▁reading ▁DER ▁encoded ▁certificate ▁request "); ▁ossl _ dump _ ssl _ errors (); ▁BIO _ free _ all ( in ); ▁return ▁( NULL ); ▁} ▁BIO _ free _ all ( in ); ▁return ▁req ; ▁} ▁/* ▁* ▁This ▁function ▁implement s ▁the ▁ Proof ▁of ▁P o session ▁check ▁( PoP ) . ▁The ▁TLS ▁UID ▁has ▁* ▁already ▁been ▁saved ▁from ▁the ▁TLS ▁session ▁earlier . ▁This ▁TLS ▁UID ▁should ▁match ▁the ▁* ▁value ▁of ▁the ▁ c hallengePassword ▁attribute ▁in ▁the ▁pkcs 10 ▁client ▁certificate . ▁The ▁* ▁client ▁will ▁have ▁provided ▁this ▁value ▁when ▁signing ▁the ▁pkcs 10 ▁cert ▁request ▁* ▁with ▁its ▁private ▁key , ▁which ▁proves ▁the ▁client ▁is ▁in ▁ possession ▁of ▁the ▁private ▁key . ▁* ▁This ▁check ▁is ▁enforce d ▁as ▁follow s : ▁* ▁1 . ▁If ▁CSR ▁contains ▁the ▁PoP , ▁it ▁must ▁be ▁valid . ▁* ▁2 . ▁If ▁CSR ▁did n ' t ▁contain ▁the ▁PoP ▁and ▁the ▁server ▁is ▁configured ▁* ▁to ▁require ▁the ▁PoP , ▁then ▁the ▁authentication ▁fails . ▁* ▁3 . ▁Otherwise , ▁if ▁CSR ▁did n ' t ▁contain ▁the ▁PoP ▁and ▁the ▁server ▁is ▁not ▁* ▁configured ▁to ▁require ▁PoP , ▁then ▁authentication ▁passes . ▁* ▁* ▁ Parameters : ▁* ▁ctx : ▁ Pointer ▁to ▁EST ▁context ▁* ▁ssl : ▁ Pointer ▁to ▁SSL ▁context ▁* ▁pkcs 10 : ▁ Pointer ▁to ▁raw ▁PKCS 10 ▁data ▁* ▁pkcs 10_ len : ▁Length ▁of ▁raw ▁PKCS 10 ▁data ▁* ▁* ▁Return ▁value : ▁* ▁EST _ ERR _ NONE ▁when ▁PoP ▁check ▁passes ▁*/ ▁int ▁est _ tls _ uid _ auth ▁( EST _ CTX ▁* ctx , ▁SSL ▁* ssl , ▁X 509_ REQ ▁* req ) ▁{ ▁X 509_ ATTRIBUTE ▁* attr ; ▁int ▁i , ▁j ; ▁ASN 1 _ TYPE ▁* at ; ▁ASN 1 _ BI T _ STRING ▁* b s ▁= ▁NULL ; ▁ASN 1 _ TYPE ▁* t ; ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁char ▁* tls _ uid ; ▁int ▁diff ; ▁/* ▁* ▁Get ▁the ▁index ▁of ▁the ▁ c hallengePassword ▁attribute ▁in ▁the ▁request ▁*/ ▁i ▁= ▁X 509_ REQ _ get _ attr _ by _ NID ( req , ▁NID _ pkcs 9 _ c hallengePassword , ▁-1) ; ▁if ▁( i ▁< ▁0) ▁{ ▁EST _ LOG _ INFO (" Cert ▁request ▁does ▁not ▁contain ▁PoP ▁ c hallengePassword ▁attribute "); ▁/* ▁* ▁If ▁PoP ▁is ▁enabled , ▁we ▁must ▁fail ▁at ▁this ▁point ▁* ▁since ▁the ▁client ▁did n ' t ▁send ▁the ▁channel ▁binding ▁* ▁info ▁in ▁the ▁CSR . ▁*/ ▁if ▁( ctx -> server _ enable _ pop ) ▁{ ▁EST _ LOG _ WARN (" PoP ▁enabled , ▁CSR ▁was ▁not ▁authenticated "); ▁return ▁( EST _ ERR _ AUTH _ FAIL _ TLSUID ); ▁} ▁else ▁{ ▁return ▁( EST _ ERR _ NONE ); ▁} ▁} ▁else ▁{ ▁/* ▁* ▁Get ▁a ▁reference ▁to ▁the ▁attribute ▁now ▁that ▁we ▁know ▁where ▁it ' s ▁located ▁* ▁RFC ▁ 7030 ▁requires ▁that ▁we ▁check ▁the ▁PoP ▁when ▁it ' s ▁present ▁*/ ▁attr ▁= ▁X 509_ REQ _ get _ attr ( req , ▁i ); ▁/* ▁* ▁If ▁we ▁found ▁the ▁attribute , ▁get ▁the ▁actual ▁value ▁of ▁the ▁ c hallengePassword ▁*/ ▁if ▁( attr ) ▁{ ▁if ▁( attr -> single ) ▁{ ▁t ▁= ▁attr -> value . single ; ▁b s ▁= ▁t -> value . bit _ string ; ▁} ▁else ▁{ ▁j ▁= ▁0; ▁at ▁= ▁sk _ ASN 1 _ TYPE _ value ( attr -> value . set , ▁j ); ▁b s ▁= ▁at -> value . asn 1 _ string ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" PoP ▁ c hallengePassword ▁attribute ▁not ▁found ▁in ▁client ▁cert ▁request "); ▁return ▁( EST _ ERR _ AUTH _ FAIL _ TLSUID ); ▁} ▁/* ▁* ▁ Now ▁that ▁we ▁have ▁the ▁ c hallengePassword ▁from ▁the ▁client ▁cert ▁request , ▁* ▁compare ▁it ▁to ▁the ▁TLS ▁UID ▁we ▁calculate d ▁on ▁the ▁server ▁side . ▁* ▁This ▁implement s ▁the ▁PoP ▁check ▁to ▁verify ▁the ▁client ▁hold s ▁the ▁private ▁* ▁key ▁used ▁to ▁sign ▁the ▁cert ▁request . ▁*/ ▁tls _ uid ▁= ▁est _ get _ tls _ uid ( ssl , ▁0); ▁if ▁( tls _ uid ) ▁{ ▁i ▁= ▁mem cmp _ s ( tls _ uid , ▁EST _ TLS _ UID _ LEN , ▁b s -> data , ▁EST _ TLS _ UID _ LEN , ▁& diff ); ▁if ▁( i ▁== ▁EOK ▁&& ▁! diff ) ▁{ ▁EST _ LOG _ INFO (" PoP ▁is ▁valid "); ▁rv ▁= ▁EST _ ERR _ NONE ; ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" PoP ▁is ▁not ▁valid "); ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL _ TLSUID ; ▁} ▁free ( tls _ uid ); ▁} ▁else ▁{ ▁EST _ LOG _ WARN (" L o cal ▁TLS ▁channel ▁binding ▁info ▁is ▁not ▁available "); ▁rv ▁= ▁EST _ ERR _ AUTH _ FAIL _ TLSUID ; ▁} ▁} ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁function ▁perform s ▁a ▁simple ▁ sanity ▁check ▁on ▁a ▁PKCS 10 ▁* ▁CSR . ▁It ▁will ▁check ▁the ▁signature ▁in ▁the ▁CSR . ▁* ▁Returns ▁0 ▁for ▁success , ▁non - zero ▁if ▁the ▁ sanity ▁check ▁failed . ▁*/ ▁int ▁est _ server _ check _ csr ▁( X 509_ REQ ▁* req ) ▁{ ▁E VP _ PKEY ▁* pub _ key ▁= ▁NULL ; ▁int ▁rc ; ▁/* ▁* ▁Ex tr act ▁the ▁public ▁key ▁from ▁the ▁CSR ▁*/ ▁if ▁( ( pub _ key ▁= ▁X 509_ REQ _ get _ pub key ( req )) ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁extract ▁public ▁key ▁from ▁CSR "); ▁return ▁1; ▁} ▁/* ▁* ▁Verify ▁the ▁signature ▁in ▁the ▁CSR ▁*/ ▁rc ▁= ▁X 509_ REQ _ verify ( req , ▁ pub _ key ); ▁E VP _ PKEY _ free ( pub _ key ); ▁/* ▁* ▁Check ▁the ▁result ▁*/ ▁if ▁( rc ▁< ▁0) ▁{ ▁EST _ LOG _ ERR (" CSR ▁signature ▁check ▁failed "); ▁return ▁1; ▁} ▁else ▁if ▁( rc ▁== ▁0) ▁{ ▁EST _ LOG _ ERR (" CSR ▁signature ▁mismatch "); ▁return ▁1; ▁} ▁else ▁{ ▁return ▁0; ▁} ▁} ▁/* ▁* ▁ Free s ▁the ▁linked - list ▁containing ▁the ▁attributes ▁in ▁* ▁the ▁client ▁CSR . ▁*/ ▁static ▁void ▁est _ server _ free _ csr _ oid _ list ▁( EST _ OID _ LIST ▁* head ) ▁{ ▁EST _ OID _ LIST ▁* next _ entry ; ▁if ▁(! head ) ▁{ ▁return ; ▁} ▁next _ entry ▁= ▁head -> next ; ▁while ▁( next _ entry ) ▁{ ▁free ( head ); ▁head ▁= ▁next _ entry ; ▁next _ entry ▁= ▁head -> next ; ▁} ▁free ( head ); ▁} ▁/* ▁* ▁Add s ▁a ▁new ▁entry ▁to ▁the ▁t ai l ▁of ▁the ▁list ▁of ▁attributes ▁* ▁in ▁the ▁client ▁CSR . ▁*/ ▁static ▁void ▁est _ server _ add _ oid _ to _ list ▁( EST _ OID _ LIST ▁** list , ▁EST _ OID _ LIST ▁* new _ entry ) ▁{ ▁EST _ OID _ LIST ▁* head ▁= ▁* list ; ▁/* ▁* ▁If ▁the ▁list ▁does n ' t ▁have ▁a ▁head ▁yet , ▁the ▁new ▁entry ▁* ▁simpl y ▁become s ▁the ▁head ▁*/ ▁if ▁( head ▁== ▁NULL ) ▁{ ▁* list ▁= ▁new _ entry ; ▁} ▁else ▁{ ▁/* ▁* ▁W alk ▁the ▁list ▁to ▁find ▁the ▁t ai l , ▁add ▁the ▁new ▁entry ▁to ▁the ▁end ▁*/ ▁while ▁( head -> next ) ▁{ ▁head ▁= ▁head -> next ; ▁} ▁head -> next ▁= ▁new _ entry ; ▁} ▁} ▁/* ▁* ▁This ▁is ▁a ▁re cur s ive ▁routine ▁that ▁walk s ▁through ▁an ▁ASN . 1 ▁blob ▁* ▁look ing ▁for ▁ASN . 1 ▁object ▁definition s . ▁For ▁any ▁that ▁are ▁* ▁found , ▁the ▁OID ▁for ▁the ▁object ▁is ▁added ▁to ▁the ▁EST _ OID _ LIST ▁( first ▁argument ) . ▁* ▁The ▁end ▁result ▁of ▁this ▁routine ▁is ▁** list ▁will ▁contain ▁all ▁the ▁OID ▁* ▁values ▁for ▁every ▁ASN . 1 ▁object ▁in ▁the ▁blob . ▁* ▁This ▁code ▁was ▁ sh ame less ly ▁taken ▁from ▁OpenSSL ▁an s 1 _ parse 2() , ▁which ▁* ▁ex plain s ▁some ▁of ▁the ▁p o or ly ▁cho sen ▁vari able ▁names . ▁*/ ▁static ▁int ▁est _ server _ csr _ asn 1 _ parse ▁( EST _ OID _ LIST ▁** list , ▁const ▁un signed ▁char ▁** blob , ▁long ▁length , ▁int ▁offset ) ▁{ ▁EST _ OID _ LIST ▁* new _ entry ; ▁const ▁un signed ▁char ▁* ptr , ▁* e p , ▁* to t , ▁* op , ▁* op p ; ▁long ▁len ; ▁int ▁tag , ▁xclass ; ▁int ▁hl , ▁j , ▁r ; ▁ASN 1 _ OBJECT ▁* a _ object ▁= ▁NULL ; ▁errno _ t ▁safe c _ rc ; ▁ptr ▁= ▁* blob ; ▁to t ▁= ▁ptr ▁+ ▁length ; ▁op ▁= ▁ptr ▁- ▁1; ▁while ▁( ( ptr ▁< ▁to t ) ▁&& ▁( op ▁< ▁ptr )) ▁{ ▁op ▁= ▁ptr ; ▁j ▁= ▁ASN 1 _ get _ object (& ptr , ▁& len , ▁& tag , ▁& xclass , ▁length ); ▁if ▁( j ▁& ▁0 x 80) ▁{ ▁EST _ LOG _ ERR (" Error ▁in ▁encoding "); ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁hl ▁= ▁ptr ▁- ▁op ; ▁length ▁- = ▁hl ; ▁if ▁( j ▁& ▁V _ ASN 1 _ CON STR UC TED ) ▁{ ▁e p ▁= ▁ptr ▁+ ▁len ; ▁if ▁( len ▁> ▁length ) ▁{ ▁EST _ LOG _ ERR (" length ▁is ▁greate r ▁than ▁% ld ", length ); ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁if ▁( ( j ▁== ▁0 x 21 ) ▁&& ▁( len ▁== ▁0) ) ▁{ ▁r ▁= ▁est _ server _ csr _ asn 1 _ parse ( list , ▁& ptr , ▁( long ) ( to t - ptr ) , ▁offset + ( ptr ▁- ▁* blob )); ▁if ▁( r ▁== ▁0) ▁{ ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁if ▁( ( r ▁== ▁2) ▁|| ▁( ptr ▁>= ▁to t )) ▁break ; ▁} ▁else ▁{ ▁while ▁( ptr ▁< ▁e p ) ▁{ ▁r ▁= ▁est _ server _ csr _ asn 1 _ parse ( list , ▁& ptr , ▁( long ) len , ▁offset + ( ptr ▁- ▁* blob )); ▁if ▁( r ▁== ▁0) ▁{ ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁} ▁} ▁} ▁else ▁if ▁( xclass ▁ != ▁0) ▁{ ▁ptr ▁+= ▁len ; ▁} ▁else ▁{ ▁if ▁( tag ▁== ▁V _ ASN 1 _ OBJECT ) ▁{ ▁op p ▁= ▁op ; ▁if ▁( d 2 i _ ASN 1 _ OBJECT (& a _ object , ▁& op p , ▁len + h l ) ▁ != ▁NULL ) ▁{ ▁new _ entry ▁= ▁malloc ( sizeof ( EST _ OID _ LIST )); ▁if ▁(! new _ entry ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failure "); ▁est _ server _ free _ csr _ oid _ list (* list ); ▁if ▁( a _ object ▁ != ▁NULL ) ▁{ ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁} ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁safe c _ rc ▁= ▁memset _ s ( new _ entry , ▁sizeof ( EST _ OID _ LIST ) , ▁0 x 0 , ▁sizeof ( EST _ OID _ LIST )); ▁if ▁( safe c _ rc ▁ != ▁EOK ) ▁{ ▁EST _ LOG _ INFO (" mem set _ s ▁error ▁0 x % xO \ n ", ▁safe c _ rc ); ▁} ▁i 2 t _ ASN 1 _ OBJECT ( new _ entry -> oid , ▁EST _ MAX _ ATTR _ LEN , ▁a _ object ); ▁EST _ LOG _ INFO (" Bu i ld ▁CSR ▁OID ▁list : ▁% s ", ▁new _ entry -> oid ); ▁est _ server _ add _ oid _ to _ list ( list , ▁new _ entry ); ▁if ▁( a _ object ▁ != ▁NULL ) ▁{ ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁a _ object ▁= ▁NULL ; ▁} ▁} ▁else ▁{ ▁EST _ LOG _ ERR (" Ba d ▁ASN . 1 ▁object "); ▁if ▁( a _ object ▁ != ▁NULL ) ▁{ ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁} ▁* blob ▁= ▁ptr ; ▁return ▁ (0); ▁} ▁} ▁ptr ▁+= ▁len ; ▁if ▁( ( tag ▁== ▁V _ ASN 1 _ E OC ) ▁&& ▁( xclass ▁== ▁0) ) ▁{ ▁* blob ▁= ▁ptr ; ▁return ▁(2) ; ▁} ▁} ▁length ▁- = ▁len ; ▁} ▁* blob ▁= ▁ptr ; ▁return ▁ (1); ▁} ▁/* ▁* ▁Utilit y ▁function ▁that ▁populate s ▁a ▁linked - list ▁containing ▁* ▁the ▁OID ▁( or ▁name ) ▁of ▁the ▁attributes ▁present ▁in ▁the ▁* ▁client ▁CSR . ▁*/ ▁static ▁EST _ ERROR ▁est _ server _ build _ csr _ oid _ list ▁( EST _ OID _ LIST ▁** list , ▁char ▁* body , ▁int ▁body _ len ) ▁{ ▁un signed ▁char ▁* der _ data , ▁* der _ ptr ; ▁int ▁der _ len ; ▁int ▁rv ; ▁/* ▁* ▁gra b ▁some ▁space ▁to ▁hold ▁the ▁decoded ▁CSR ▁data ▁*/ ▁der _ ptr ▁= ▁der _ data ▁= ▁malloc ( body _ len *2 ); ▁if ▁(! der _ data ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁/* ▁* ▁ Decode ▁the ▁CSR ▁data ▁*/ ▁der _ len ▁= ▁est _ base 64_ decode ( ( char ▁* ) body , ▁( char ▁* ) der _ data , ▁body _ len *2 ); ▁if ▁( der _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁base 64 ▁encoded ▁data "); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ BAD _ BASE 64 ); ▁} ▁rv ▁= ▁est _ server _ csr _ asn 1 _ parse ( list , ▁( const ▁un signed ▁char ▁* *)& der _ data , ▁der _ len , ▁0); ▁if ▁(! rv ) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁build ▁OID ▁list ▁from ▁client ▁provided ▁CSR "); ▁est _ server _ free _ csr _ oid _ list (* list ); ▁free ( der _ ptr ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁free ( der _ ptr ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁checks ▁the ▁locally ▁configured ▁CSR ▁attributes ▁* ▁against ▁the ▁attributes ▁in ▁the ▁CSR . ▁If ▁any ▁attributes ▁are ▁* ▁missing ▁from ▁the ▁CSR , ▁then ▁an ▁error ▁is ▁returned . ▁*/ ▁static ▁EST _ ERROR ▁est _ server _ all _ csrattrs _ present ( EST _ CTX ▁* ctx , ▁char ▁* body , ▁int ▁body _ len ) ▁{ ▁int ▁tag , ▁xclass , ▁j , ▁found _ match , ▁nid ; ▁long ▁len ; ▁un signed ▁char ▁* der _ ptr , ▁* save _ ptr ; ▁ASN 1 _ OBJECT ▁* a _ object ; ▁int ▁max _ len ▁= ▁ MAX _ CSRATTRS ; ▁char ▁* csr _ data ; ▁int ▁csr _ len ; ▁long ▁out _ len _ save ; ▁un signed ▁char ▁* der _ data ; ▁int ▁der _ len , ▁out _ len ; ▁int ▁a _ len ; ▁char ▁tbuf [ EST _ MAX _ ATTR _ LEN ] ; ▁EST _ OID _ LIST ▁* csr _ attr _ oids ▁= ▁NULL ; ▁EST _ OID _ LIST ▁* oid _ entry ; ▁int ▁ comparator ; ▁EST _ ERROR ▁rv ; ▁EST _ LOG _ INFO (" CSR ▁attributes ▁enforce ment ▁is ▁enabled "); ▁if ▁(! ctx -> server _ csrattrs ▁&& ▁! ctx -> est _ get _ csr _ cb ) ▁{ ▁EST _ LOG _ WARN (" CSR ▁attributes ▁enforce ment ▁is ▁enabled , ▁but ▁no ▁attributes ▁have ▁been ▁configured "); ▁return ▁EST _ ERR _ NONE ; ▁} ▁/* ▁* ▁Build ▁the ▁list ▁of ▁attributes ▁present ▁in ▁the ▁CSR . ▁This ▁list ▁will ▁be ▁* ▁used ▁later ▁when ▁we ▁confirm ▁the ▁required ▁attributes ▁are ▁present . ▁*/ ▁rv ▁= ▁est _ server _ build _ csr _ oid _ list (& csr _ attr _ oids , ▁body , ▁body _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁return ▁( rv ); ▁} ▁/* ▁* ▁Get ▁the ▁CSR ▁attributes ▁configured ▁on ▁the ▁server . ▁We ' ll ▁need ▁to ▁* ▁look ▁in ▁the ▁CSR ▁to ▁make ▁sure ▁the ▁CSR ▁provided ▁ each ▁of ▁these . ▁* ▁Use ▁the ▁callback ▁if ▁configured , ▁otherwise ▁use ▁the ▁local ▁copy . ▁*/ ▁if ▁( ctx -> est _ get _ csr _ cb ) ▁{ ▁csr _ data ▁= ▁( char ▁* ) ctx -> est _ get _ csr _ cb (& csr _ len , ▁NULL , ▁ctx -> ex _ data ); ▁if ▁(! csr _ data ) ▁{ ▁EST _ LOG _ ERR (" App li cation ▁layer ▁failed ▁to ▁return ▁CSR ▁attributes "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁return ▁( EST _ ERR _ CB _ FAILED ); ▁} ▁} ▁else ▁{ ▁csr _ data ▁= ▁malloc ( ctx -> server _ csrattrs _ len ▁+ ▁1); ▁if ▁(! csr _ data ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failure "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁strncpy _ s ( csr _ data , ▁ctx -> server _ csrattrs _ len ▁+ ▁1, ▁( char ▁* ) ctx -> server _ csrattrs , ▁ctx -> server _ csrattrs _ len ); ▁csr _ data [ ctx -> server _ csrattrs _ len ] ▁= ▁0; ▁csr _ len ▁= ▁ctx -> server _ csrattrs _ len ; ▁} ▁EST _ LOG _ INFO (" Check ing ▁CSR ▁attrs ▁present ▁in ▁CSR : ▁% s ", ▁csr _ data ); ▁/* ▁* ▁We ▁have ▁the ▁CSR ▁configured ▁on ▁the ▁server ▁and ▁it ▁needs ▁base 64 ▁decoding . ▁* ▁Check ▁small est ▁possible ▁base 64 ▁case ▁here ▁for ▁now ▁* ▁and ▁ sanity ▁test ▁will ▁check ▁min / max ▁value ▁for ▁ASN . 1 ▁data ▁*/ ▁if ▁( csr _ len ▁< ▁MIN _ CSRATTRS ) ▁{ ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( csr _ data ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁* ▁gra b ▁some ▁space ▁to ▁hold ▁the ▁decoded ▁CSR ▁data ▁*/ ▁der _ data ▁= ▁malloc ( csr _ len *2 ); ▁if ▁(! der _ data ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( csr _ data ); ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁/* ▁* ▁ Decode ▁the ▁CSR ▁data ▁*/ ▁der _ len ▁= ▁est _ base 64_ decode ( csr _ data , ▁( char ▁* ) der _ data , ▁csr _ len *2 ); ▁free ( csr _ data ); ▁if ▁( der _ len ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁base 64 ▁encoded ▁data "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ BAD _ BASE 64 ); ▁} ▁/* ▁* ▁pointer ▁f un ▁start s ▁here , ▁ joy ▁to ▁OpenSSL ▁*/ ▁out _ len _ save ▁= ▁out _ len ▁= ▁der _ len ; ▁der _ ptr ▁= ▁save _ ptr ▁= ▁der _ data ; ▁if ▁( out _ len _ save ▁> ▁max _ len ) ▁{ ▁EST _ LOG _ ERR (" DER ▁length ▁exceed s ▁max "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁make ▁sure ▁its ▁long ▁enough ▁to ▁be ▁ASN . 1 ▁*/ ▁if ▁( der _ len ▁< ▁MIN _ ASN 1 _ CSRATTRS ) ▁{ ▁EST _ LOG _ ERR (" DER ▁too ▁short "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁* ▁Iterat e ▁through ▁the ▁CSR ▁attributes ▁configured ▁on ▁the ▁server ▁*/ ▁while ▁( out _ len ▁> ▁0) ▁{ ▁/* ▁* ▁Get ▁the ▁next ▁attributes ▁*/ ▁j ▁= ▁ASN 1 _ get _ object ( ( const ▁un signed ▁char **)& der _ ptr , ▁& len , ▁& tag , ▁& xclass , ▁out _ len ); ▁EST _ LOG _ INFO (" Sanity : ▁tag =% d , ▁len =% d , ▁j =% d , ▁out _ len =% d ", ▁tag , ▁len , ▁j , ▁out _ len ); ▁if ▁( j ▁& ▁0 x 80) ▁{ ▁EST _ LOG _ ERR (" Ba d ▁ASN 1 ▁hex "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁switch ▁( tag ) ▁{ ▁case ▁V _ ASN 1 _ OBJECT : ▁a _ object ▁= ▁ c 2 i _ ASN 1 _ OBJECT ( NULL , ▁( const ▁un signed ▁char **)& der _ ptr , ▁len ); ▁if ▁(! a _ object ) ▁{ ▁EST _ LOG _ ERR (" a _ object ▁is ▁null "); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ UNKNOWN ); ▁} ▁/* ▁* ▁If ▁this ▁is ▁the ▁ c hallengePassword , ▁no ▁need ▁to ▁check ▁it . ▁* ▁This ▁is ▁already ▁cover ed ▁when ▁authenticating ▁the ▁client ▁*/ ▁nid ▁= ▁OBJ _ obj 2 nid ( a _ object ); ▁if ▁( nid ▁== ▁NID _ pkcs 9 _ c hallengePassword ) ▁{ ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁break ; ▁} ▁a _ len ▁= ▁i 2 t _ ASN 1 _ OBJECT ( t buf , ▁EST _ MAX _ ATTR _ LEN , ▁a _ object ); ▁EST _ LOG _ INFO (" L o ok ing ▁for ▁attr =% s ▁in ▁the ▁CSR ", ▁tbuf ); ▁ASN 1 _ OBJECT _ free ( a _ object ); ▁/* ▁* ▁If ▁there ▁we re ▁no ▁attr u but es ▁in ▁the ▁CSR , ▁we ▁can ▁* ▁bail ▁now . ▁*/ ▁if ▁( csr _ attr _ oids ▁== ▁NULL ) ▁{ ▁EST _ LOG _ WARN (" CSR ▁did ▁not ▁contain ▁any ▁attributes , ▁CSR ▁will ▁be ▁rejected ", ▁tbuf ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ CSR _ ATTR _ MISSING ); ▁} ▁found _ match ▁= ▁0; ▁ oid _ entry ▁= ▁csr _ attr _ oids ; ▁/* ▁* ▁Iterat e ▁through ▁the ▁attributes ▁that ▁are ▁in ▁the ▁CSR ▁*/ ▁while ▁( oid _ entry ) ▁{ ▁EST _ LOG _ INFO (" Comp ar ing ▁% s ▁to ▁% s ", ▁tbuf , ▁ oid _ entry -> oid ); ▁strcmp _ s ( oid _ entry -> oid , ▁( a _ len ▁< ▁EST _ MAX _ ATTR _ LEN ▁? ▁a _ len ▁: ▁EST _ MAX _ ATTR _ LEN ) , ▁tbuf , ▁& comparator ); ▁if ▁(! comparator ) ▁{ ▁found _ match ▁= ▁1; ▁break ; ▁} ▁ oid _ entry ▁= ▁ oid _ entry -> next ; ▁} ▁if ▁(! found _ match ) ▁{ ▁EST _ LOG _ WARN (" CSR ▁did ▁not ▁contain ▁% s ▁attribute , ▁CSR ▁will ▁be ▁rejected ", ▁tbuf ); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ CSR _ ATTR _ MISSING ); ▁} ▁break ; ▁default : ▁/* ▁have ▁to ▁a d just ▁string ▁pointer ▁here , ▁move ▁on ▁to ▁the ▁next ▁item ▁*/ ▁der _ ptr ▁+= ▁len ; ▁break ; ▁case ▁V _ ASN 1 _ SET : ▁case ▁V _ ASN 1 _ SEQUENCE : ▁break ; ▁} ▁out _ len ▁= ▁out _ len _ save ▁- ▁( der _ ptr ▁- ▁save _ ptr ); ▁} ▁/* ▁* ▁One ▁file ▁check ▁to ▁ensure ▁we ▁did n ' t ▁missing ▁something ▁when ▁parsing ▁* ▁the ▁locally ▁configured ▁CSR ▁attributes . ▁*/ ▁if ▁( out _ len ▁ != ▁0) ▁{ ▁EST _ LOG _ ERR (" DER ▁length ▁not ▁zero ▁(% d )", ▁out _ len ); ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ BAD _ ASN 1 _ HEX ); ▁} ▁/* ▁* ▁If ▁we ' re ▁ lu c ky ▁enough ▁to ▁make ▁it ▁this ▁far , ▁then ▁it ▁means ▁all ▁the ▁* ▁locally ▁configured ▁CSR ▁attributes ▁we re ▁found ▁in ▁the ▁client ' s ▁CSR . ▁*/ ▁est _ server _ free _ csr _ oid _ list ( csr _ attr _ oids ); ▁free ( der _ data ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁by ▁the ▁server ▁to ▁process ▁an ▁incoming ▁* ▁Simple ▁Enroll ▁request ▁from ▁the ▁client . ▁*/ ▁static ▁EST _ ERROR ▁est _ handle _ simple _ enroll ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁SSL ▁* ssl , ▁const ▁char ▁* ct , ▁char ▁* body , ▁int ▁body _ len , ▁char ▁* path _ seg , ▁int ▁reenroll ) ▁{ ▁int ▁rv , ▁cert _ len ; ▁struct ▁mg _ connection ▁* conn ▁= ▁( struct ▁mg _ connection *) http _ ctx ; ▁un signed ▁char ▁* cert ; ▁char ▁http _ hdr [ EST _ HTTP _ HDR _ MAX ] ; ▁int ▁hdrlen ; ▁X 509 ▁* peer _ cert ; ▁X 509_ REQ ▁* csr ▁= ▁NULL ; ▁int ▁client _ is _ ra ▁= ▁0; ▁if ▁(! reenroll ▁&& ▁! ctx -> est _ enroll _ pkcs 10_ cb ) ▁{ ▁EST _ LOG _ ERR (" Null ▁enrollment ▁callback "); ▁return ▁( EST _ ERR _ NULL _ CALLBACK ); ▁} ▁if ▁( reenroll ▁&& ▁! ctx -> est _ reenroll _ pkcs 10_ cb ) ▁{ ▁EST _ LOG _ ERR (" Null ▁reenroll ▁callback "); ▁return ▁( EST _ ERR _ NULL _ CALLBACK ); ▁} ▁/* ▁* ▁Make ▁sure ▁the ▁client ▁has ▁sent ▁us ▁a ▁PKCS 10 ▁CSR ▁request ▁*/ ▁if ▁( strnc mp ( ct , ▁" application / pkcs 10 ", ▁ 18)) ▁{ ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁ Authenticate ▁the ▁client ▁*/ ▁switch ▁( est _ enroll _ auth ( ctx , ▁http _ ctx , ▁ssl , ▁path _ seg , ▁reenroll )) ▁{ ▁case ▁EST _ HTTP _ AUTH : ▁case ▁EST _ SRP _ AUTH : ▁case ▁EST _ CERT _ AUTH : ▁/* ▁* ▁this ▁means ▁the ▁user ▁was ▁authorized , ▁e i ther ▁through ▁* ▁HTTP ▁authoriz tion ▁or ▁certificate ▁authorization ▁*/ ▁break ; ▁case ▁EST _ HTTP _ AUTH _ PENDING : ▁return ▁( EST _ ERR _ AUTH _ PENDING ); ▁break ; ▁case ▁EST _ UNAUTHORIZED : ▁default : ▁return ▁( EST _ ERR _ AUTH _ FAIL ); ▁break ; ▁} ▁/* ▁* ▁Parse ▁the ▁PKCS 10 ▁CSR ▁from ▁the ▁client ▁*/ ▁csr ▁= ▁est _ server _ parse _ csr ( ( un signed ▁char *) body , ▁body _ len ); ▁if ▁(! csr ) ▁{ ▁EST _ LOG _ ERR (" U nable ▁to ▁parse ▁the ▁PKCS 10 ▁CSR ▁sent ▁by ▁the ▁client "); ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁/* ▁* ▁Perform ▁a ▁ sanity ▁check ▁on ▁the ▁CSR ▁*/ ▁if ▁( est _ server _ check _ csr ( csr )) ▁{ ▁EST _ LOG _ ERR (" PKCS 10 ▁CSR ▁sent ▁by ▁the ▁client ▁failed ▁ sanity ▁check "); ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁/* ▁* ▁Get ▁the ▁peer ▁certificate ▁if ▁available . ▁This ▁* ▁identifi es ▁the ▁client . ▁The ▁CA ▁ma y ▁desire ▁* ▁this ▁information . ▁*/ ▁peer _ cert ▁= ▁SSL _ get _ peer _ certificate ( ssl ); ▁if ▁( peer _ cert ) ▁{ ▁client _ is _ ra ▁= ▁est _ check _ cmcRA ▁( peer _ cert ); ▁} ▁EST _ LOG _ INFO (" id - kp - cmcRA ▁present : ▁% d ", ▁client _ is _ ra ); ▁/* ▁* ▁Do ▁the ▁PoP ▁check ▁( Proof ▁of ▁ Pos session ) . ▁The ▁challenge ▁password ▁* ▁in ▁the ▁pkcs 10 ▁request ▁should ▁match ▁the ▁TLS ▁unique ▁ID . ▁* ▁The ▁PoP ▁check ▁is ▁not ▁perform end ▁when ▁the ▁client ▁is ▁an ▁RA . ▁*/ ▁if ▁(! client _ is _ ra ) ▁{ ▁rv ▁= ▁est _ tls _ uid _ auth ( ctx , ▁ssl , ▁csr ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁X 509_ REQ _ free ( csr ); ▁X 509_ free ( peer _ cert ); ▁return ▁( EST _ ERR _ AUTH _ FAIL _ TLSUID ); ▁} ▁} ▁/* ▁* ▁Check ▁if ▁we ▁need ▁to ▁ensure ▁the ▁client ▁included ▁all ▁the ▁* ▁CSR ▁attributes ▁required ▁by ▁the ▁CA . ▁*/ ▁if ▁( ctx -> enforce _ csrattrs ) ▁{ ▁if ▁( EST _ ERR _ NONE ▁ != ▁est _ server _ all _ csrattrs _ present ( ctx , ▁body , ▁body _ len )) ▁{ ▁X 509_ REQ _ free ( csr ); ▁X 509_ free ( peer _ cert ); ▁return ▁( EST _ ERR _ CSR _ ATTR _ MISSING ); ▁} ▁} ▁/* ▁body ▁now ▁point s ▁to ▁the ▁pkcs 10 ▁data , ▁pass ▁* ▁this ▁to ▁the ▁enrollment ▁routine ▁*/ ▁if ▁( reenroll ) ▁{ ▁rv ▁= ▁ctx -> est _ reenroll _ pkcs 10_ cb ( ( un signed ▁char *) body , ▁body _ len , ▁& cert , ▁( int *)& cert _ len , ▁conn -> user _ id , ▁peer _ cert , ▁path _ seg , ▁ctx -> ex _ data ); ▁} ▁else ▁{ ▁rv ▁= ▁ctx -> est _ enroll _ pkcs 10_ cb ( ( un signed ▁char *) body , ▁body _ len , ▁& cert , ▁( int *)& cert _ len , ▁conn -> user _ id , ▁peer _ cert , ▁path _ seg , ▁ctx -> ex _ data ); ▁} ▁/* ▁* ▁P e er ▁cert ▁is ▁no ▁long er ▁needed , ▁delete ▁it ▁if ▁we ▁have ▁one ▁*/ ▁if ▁( peer _ cert ) ▁{ ▁X 509_ free ( peer _ cert ); ▁} ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ▁&& ▁cert _ len ▁> ▁0) ▁{ ▁/* ▁* ▁Send ▁HTTP ▁header ▁*/ ▁ snprintf ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX , ▁"% s % s % s % s ", ▁EST _ HTTP _ HDR _200, ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ STAT _200, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CT , ▁EST _ HTTP _ CT _ PKCS 7_ C O , ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% s % s ", ▁EST _ HTTP _ HDR _ CE , ▁EST _ HTTP _ CE _ BASE 64, ▁EST _ HTTP _ HDR _ EOL ); ▁hdrlen ▁= ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ); ▁ snprintf ( http _ hdr ▁+ ▁hdrlen , ▁EST _ HTTP _ HDR _ MAX , ▁"% s : ▁% d % s % s ", ▁EST _ HTTP _ HDR _ CL , ▁cert _ len , ▁EST _ HTTP _ HDR _ EOL , ▁EST _ HTTP _ HDR _ EOL ); ▁if ▁(! mg _ write ( http _ ctx , ▁http _ hdr , ▁ strnlen _ s ( http _ hdr , ▁EST _ HTTP _ HDR _ MAX ))) ▁{ ▁free ( cert ); ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁/* ▁* ▁Send ▁the ▁signed ▁PKCS 7 ▁certificate ▁in ▁the ▁body ▁*/ ▁if ▁(! mg _ write ( http _ ctx , ▁cert , ▁cert _ len )) ▁{ ▁free ( cert ); ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁free ( cert ); ▁} ▁else ▁if ▁( rv ▁== ▁EST _ ERR _ CA _ ENROLL _ RETRY ) ▁{ ▁/* ▁* ▁The ▁CA ▁did ▁not ▁sign ▁the ▁request ▁and ▁has ▁asked ▁the ▁* ▁client ▁to ▁retry ▁in ▁the ▁future . ▁This ▁ma y ▁occur ▁if ▁* ▁the ▁CA ▁is ▁not ▁configured ▁for ▁automatic ▁enrollment . ▁* ▁Send ▁the ▁HTTP ▁retry ▁response ▁to ▁the ▁client . ▁*/ ▁EST _ LOG _ INFO (" CA ▁server ▁requests ▁retry , ▁ possibly ▁it ' s ▁not ▁set up ▁for ▁auto - enroll "); ▁if ▁( EST _ ERR _ NONE ▁ != ▁est _ server _ send _ http _ retry _ after ( ctx , ▁http _ ctx , ▁ctx -> retry _ period )) ▁{ ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁} ▁} ▁else ▁{ ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ CA _ ENROLL _ FAIL ); ▁} ▁X 509_ REQ _ free ( csr ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁This ▁function ▁is ▁used ▁by ▁the ▁server ▁to ▁process ▁an ▁incoming ▁* ▁csr ▁attributes ▁request ▁from ▁the ▁client . ▁*/ ▁static ▁int ▁est _ handle _ csr _ attrs ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* path _ seg ) ▁{ ▁int ▁rv ▁= ▁EST _ ERR _ NONE ; ▁int ▁pop _ present ; ▁char ▁* csr _ data , ▁* csr _ data _ pop ; ▁int ▁csr _ len , ▁csr _ pop _ len ; ▁if ▁(! ctx -> server _ csrattrs ▁&& ▁! ctx -> est _ get _ csr _ cb ) ▁{ ▁if ▁(! ctx -> server _ enable _ pop ) ▁{ ▁EST _ LOG _ ERR (" Null ▁csr ▁callback "); ▁/* ▁Send ▁a ▁204 ▁response ▁indicat ing ▁the ▁server ▁does n ' t ▁have ▁a ▁CSR ▁*/ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁else ▁{ ▁csr _ data ▁= ▁malloc ( EST _ CSRATTRS _ POP _ LEN ▁+ ▁1); ▁if ▁(! csr _ data ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁strncpy _ s ( csr _ data , ▁EST _ CSRATTRS _ POP _ LEN ▁+ ▁1, ▁EST _ CSRATTRS _ POP , ▁EST _ CSRATTRS _ POP _ LEN ); ▁csr _ data [ EST _ CSRATTRS _ POP _ LEN ] ▁= ▁0; ▁csr _ len ▁= ▁EST _ CSRATTRS _ POP _ LEN ; ▁return ▁( est _ send _ csrattr _ data ( ctx , ▁csr _ data , ▁csr _ len , ▁http _ ctx )); ▁} ▁} ▁/* ▁* ▁I nvoke ▁CA ▁server ▁callback ▁to ▁retrieve ▁the ▁CSR . ▁C allback ▁takes ▁priority ▁* ▁over ▁saved ▁values ▁in ▁the ▁context . ▁* ▁Note : ▁there ▁is ▁no ▁need ▁to ▁authenticate ▁the ▁client ▁( see ▁ se c ▁4.5) ▁*/ ▁if ▁( ctx -> est _ get _ csr _ cb ) ▁{ ▁csr _ data ▁= ▁( char ▁* ) ctx -> est _ get _ csr _ cb (& csr _ len , ▁path _ seg , ▁ctx -> ex _ data ); ▁rv ▁= ▁est _ asn 1 _ parse _ attributes ( csr _ data , ▁csr _ len , ▁& pop _ present ); ▁if ▁( csr _ len ▁&& ▁( rv ▁ != ▁EST _ ERR _ NONE )) ▁{ ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁ctx -> csr _ pop _ present ▁= ▁0; ▁if ▁( ctx -> server _ enable _ pop ) ▁{ ▁rv ▁= ▁est _ is _ c hallengePassword _ present ( csr _ data , ▁csr _ len , ▁& pop _ present ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Error ▁dur ing ▁PoP / sanity ▁check "); ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁ctx -> csr _ pop _ present ▁= ▁pop _ present ; ▁if ▁(! ctx -> csr _ pop _ present ) ▁{ ▁if ▁( csr _ len ▁== ▁0) ▁{ ▁csr _ data ▁= ▁malloc ( EST _ CSRATTRS _ POP _ LEN ▁+ ▁1); ▁if ▁(! csr _ data ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁strncpy _ s ( csr _ data , ▁EST _ CSRATTRS _ POP _ LEN ▁+ ▁1, ▁EST _ CSRATTRS _ POP , ▁EST _ CSRATTRS _ POP _ LEN ); ▁csr _ data [ EST _ CSRATTRS _ POP _ LEN ] ▁= ▁0; ▁csr _ len ▁= ▁EST _ CSRATTRS _ POP _ LEN ; ▁return ▁( est _ send _ csrattr _ data ( ctx , ▁csr _ data , ▁csr _ len , ▁http _ ctx )); ▁} ▁rv ▁= ▁est _ add _ c hallengePassword ( csr _ data , ▁csr _ len , ▁& csr _ data _ pop , ▁& csr _ pop _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁if ▁( csr _ data ) ▁{ ▁free ( csr _ data ); ▁} ▁EST _ LOG _ ERR (" Error ▁dur ing ▁add ▁PoP "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NO _ CONTENT ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁free ( csr _ data ); ▁csr _ data ▁= ▁csr _ data _ pop ; ▁csr _ len ▁= ▁csr _ pop _ len ; ▁} ▁} ▁} ▁else ▁{ ▁csr _ data ▁= ▁malloc ( ctx -> server _ csrattrs _ len ▁+ ▁1); ▁if ▁(! csr _ data ) ▁{ ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁strncpy _ s ( csr _ data , ▁ctx -> server _ csrattrs _ len ▁+ ▁1, ▁( char ▁* ) ctx -> server _ csrattrs , ▁ctx -> server _ csrattrs _ len ); ▁csr _ data [ ctx -> server _ csrattrs _ len ] ▁= ▁0; ▁csr _ len ▁= ▁ctx -> server _ csrattrs _ len ; ▁} ▁return ▁( est _ send _ csrattr _ data ( ctx , ▁csr _ data , ▁csr _ len , ▁http _ ctx )); ▁} ▁/* ▁* ▁This ▁function ▁should ▁be ▁called ▁by ▁the ▁web ▁server ▁layer ▁when ▁* ▁a ▁HTTP ▁request ▁arrive s ▁on ▁the ▁listen ing ▁port ▁of ▁the ▁EST ▁server . ▁* ▁It ▁will ▁determine ▁the ▁EST ▁request ▁type ▁and ▁dis p atch ▁the ▁request ▁* ▁to ▁the ▁appropriate ▁handler . ▁* ▁* ▁P ar am ters : ▁* ▁ctx : ▁ Pointer ▁to ▁EST _ CTX ▁* ▁http _ ctx : ▁Context ▁pointer ▁from ▁web ▁server ▁* ▁method : ▁The ▁ HTML ▁method ▁in ▁the ▁request , ▁should ▁be ▁e i ther ▁" GET " ▁or ▁" POST " ▁* ▁uri : ▁pointer ▁to ▁HTTP ▁URI ▁* ▁body : ▁pointer ▁to ▁full ▁ HTML ▁body ▁content s ▁* ▁body _ len : ▁length ▁of ▁ HTML ▁body ▁* ▁ct : ▁ HTML ▁content ▁type ▁header ▁*/ ▁int ▁est _ http _ request ▁( EST _ CTX ▁* ctx , ▁void ▁* http _ ctx , ▁char ▁* method , ▁char ▁* uri , ▁char ▁* body , ▁int ▁body _ len , ▁const ▁char ▁* ct ) ▁{ ▁SSL ▁* ssl ; ▁int ▁rc ; ▁EST _ OPERATION ▁operation ; ▁char ▁* path _ seg ; ▁EST _ ERROR ▁rv ▁= ▁EST _ ERR _ NONE ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁Verify ▁the ▁context ▁is ▁for ▁a ▁server , ▁not ▁a ▁client ▁*/ ▁if ▁( ctx -> est _ mode ▁ != ▁EST _ SERVER ) ▁{ ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁} ▁rv ▁= ▁est _ parse _ uri ( uri , ▁& operation , ▁( char ▁* *)& path _ seg ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rv ); ▁return ▁( rv ); ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁cacerts ▁request ▁*/ ▁if ▁( operation ▁== ▁EST _ OP _ CACERTS ) ▁{ ▁/* ▁Only ▁GET ▁is ▁allowed ▁*/ ▁if ▁( strnc mp ( method , ▁" GET ", ▁ 3)) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁/* ▁rc ▁= ▁est _ handle _ cacerts ( ctx , ▁ctx -> ca _ certs , ▁ctx -> ca _ certs _ len , ▁*/ ▁/* ▁http _ ctx , ▁path _ seg ); ▁*/ ▁rc ▁= ▁est _ server _ handle _ cacerts ( ctx , ▁http _ ctx , ▁path _ seg ); ▁/* ▁rc ▁= ▁est _ server _ handle _ cacerts ( ctx , ▁http _ ctx , ▁path _ seg ); ▁*/ ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rc ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( rc ); ▁} ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁simple ▁enrollment ▁request ▁*/ ▁else ▁if ▁( operation ▁== ▁EST _ OP _ SIMPLE _ ENROLL ) ▁{ ▁/* ▁Only ▁POST ▁is ▁allowed ▁*/ ▁if ▁( strnc mp ( method , ▁" POST ", ▁ 4)) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁request ▁used ▁w rong ▁method \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁Get ▁the ▁SSL ▁context , ▁which ▁is ▁required ▁for ▁authenticating ▁* ▁the ▁client . ▁*/ ▁ssl ▁= ▁( SSL *) mg _ get _ conn _ ssl ( http _ ctx ); ▁if ▁(! ssl ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ NO _ SSL _ CTX ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁rc ▁= ▁est _ handle _ simple _ enroll ( ctx , ▁http _ ctx , ▁ssl , ▁ct , ▁body , ▁body _ len , ▁path _ seg , ▁0); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ▁&& ▁rc ▁ != ▁EST _ ERR _ AUTH _ PENDING ) ▁{ ▁EST _ LOG _ WARN (" E nrollment ▁failed ▁with ▁rc =% d ▁(% s ) \ n ", ▁rc , ▁EST _ ERR _ NUM _ TO _ STR ( rc )); ▁if ▁( rc ▁== ▁EST _ ERR _ AUTH _ FAIL ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ AUTH _ FAIL ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁rc ; ▁} ▁} ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁re - enrollment ▁request ▁*/ ▁else ▁if ▁( operation ▁== ▁EST _ OP _ SIMPLE _ REENROLL ) ▁{ ▁/* ▁Only ▁POST ▁is ▁allowed ▁*/ ▁if ▁( strnc mp ( method , ▁" POST ", ▁ 4)) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁request ▁used ▁w rong ▁method \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁/* ▁* ▁Get ▁the ▁SSL ▁context , ▁which ▁is ▁required ▁for ▁authenticating ▁* ▁the ▁client . ▁*/ ▁ssl ▁= ▁( SSL *) mg _ get _ conn _ ssl ( http _ ctx ); ▁if ▁(! ssl ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ NO _ SSL _ CTX ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁rc ▁= ▁est _ handle _ simple _ enroll ( ctx , ▁http _ ctx , ▁ssl , ▁ct , ▁body , ▁body _ len , ▁path _ seg , ▁1); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ▁&& ▁rc ▁ != ▁EST _ ERR _ AUTH _ PENDING ) ▁{ ▁EST _ LOG _ WARN (" Re enroll ▁failed ▁with ▁rc =% d ▁(% s ) \ n ", ▁rc , ▁EST _ ERR _ NUM _ TO _ STR ( rc )); ▁if ▁( rc ▁== ▁EST _ ERR _ AUTH _ FAIL ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ AUTH _ FAIL ); ▁} ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ BAD _ PKCS 10); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ BAD _ PKCS 10); ▁} ▁} ▁# if ▁0 ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁ keygen ▁request ▁* ▁ FIX ME : ▁this ▁is ▁currently ▁not ▁implemented ▁*/ ▁else ▁if ▁( strnc mp ( uri , ▁EST _ KEY GE N _ URI , ▁EST _ URI _ MAX _ LEN ) ▁== ▁0) ▁{ ▁/* ▁Only ▁POST ▁is ▁allowed ▁*/ ▁if ▁( strnc mp ( method , ▁" POST ", ▁ 4)) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁request ▁used ▁w rong ▁method \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁if ▁(! ct ) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁header ▁has ▁no ▁Content - Type ▁header \ n "); ▁return ▁( EST _ ERR _ BAD _ CONTENT _ TYPE ); ▁} ▁if ▁( est _ handle _ keygen ( ctx )) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁0); ▁// FIX ME : ▁last ▁ param ▁should ▁not ▁be ▁zero ▁return ▁( EST _ ERR _ HTTP _ WRITE ); ▁// FIX ME : ▁need ▁the ▁appropriate ▁return ▁code ▁} ▁} ▁# endif ▁/* ▁* ▁Se e ▁if ▁this ▁is ▁a ▁CSR ▁attributes ▁request ▁*/ ▁else ▁if ▁( operation ▁== ▁EST _ OP _ CSRATTRS ) ▁{ ▁/* ▁Only ▁GET ▁is ▁allowed ▁*/ ▁if ▁( strnc mp ( method , ▁" GET ", ▁ 4)) ▁{ ▁EST _ LOG _ WARN (" I ncoming ▁HTTP ▁request ▁used ▁w rong ▁method \ n "); ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ WRONG _ METHOD ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ WRONG _ METHOD ); ▁} ▁rc ▁= ▁est _ handle _ csr _ attrs ( ctx , ▁http _ ctx , ▁path _ seg ); ▁if ▁( rc ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁rc ); ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( rc ); ▁} ▁} ▁/* ▁* ▁Send ▁a ▁404 ▁error ▁if ▁the ▁URI ▁did n ' t ▁match ▁*/ ▁else ▁{ ▁est _ send _ http _ error ( ctx , ▁http _ ctx , ▁EST _ ERR _ HTTP _ NOT _ FOUND ); ▁} ▁free ( path _ seg ); ▁path _ seg ▁= ▁NULL ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ start () ▁is ▁used ▁by ▁an ▁application ▁to ▁start ▁the ▁EST ▁server ▁after ▁est _ server _ init () ▁has ▁been ▁called ▁and ▁all ▁the ▁required ▁callback ▁functions ▁have ▁been ▁provided ▁by ▁the ▁application . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁libEST ▁uses ▁HTTP ▁code ▁from ▁the ▁Mon g oose ▁HTTP ▁server . ▁This ▁function ▁allow s ▁the ▁application ▁to ▁start ▁the ▁HTTP ▁services ▁layer , ▁which ▁is ▁required ▁by ▁EST . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ start ▁( EST _ CTX ▁* ctx ) ▁{ ▁EST _ MG _ CONTEXT ▁* mgctx ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁mgctx ▁= ▁mg _ start ( ctx ); ▁if ▁( mgctx ) ▁{ ▁ctx -> mg _ ctx ▁= ▁mgctx ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁else ▁{ ▁return ▁( EST _ ERR _ NO _ SSL _ CTX ); ▁} ▁} ▁/* ! ▁@ br i ef ▁est _ server _ stop () ▁is ▁used ▁by ▁an ▁application ▁to ▁stop ▁the ▁EST ▁server . ▁This ▁should ▁be ▁called ▁prior ▁to ▁est _ destroy (). ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁libEST ▁uses ▁HTTP ▁code ▁from ▁the ▁Mon g oose ▁HTTP ▁server . ▁This ▁function ▁allow s ▁the ▁application ▁to ▁stop ▁the ▁HTTP ▁services ▁layer . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ stop ▁( EST _ CTX ▁* ctx ) ▁{ ▁EST _ MG _ CONTEXT ▁* mgctx ; ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁mgctx ▁= ▁( EST _ MG _ CONTEXT *) ctx -> mg _ ctx ; ▁if ▁( mgctx ) ▁{ ▁mg _ stop ( mgctx ); ▁} ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ init () ▁is ▁used ▁by ▁an ▁application ▁to ▁create ▁a ▁context ▁in ▁the ▁EST ▁library ▁when ▁operat ing ▁as ▁an ▁EST ▁server ▁that ▁front s ▁a ▁CA . ▁This ▁context ▁is ▁used ▁when ▁invoking ▁other ▁functions ▁in ▁the ▁API . ▁@ param ▁ca _ chain ▁Char ▁array ▁containing ▁PEM ▁encoded ▁CA ▁certs ▁& ▁CRL ▁entries ▁@ param ▁ca _ chain _ len ▁Length ▁of ▁ca _ chain ▁char ▁array ▁@ param ▁cacerts _ resp _ chain ▁Char ▁array ▁containing ▁PEM ▁encoded ▁CA ▁certs ▁to ▁include ▁in ▁the ▁/ cacerts ▁response ▁@ param ▁cacerts _ resp _ chain _ len ▁Length ▁of ▁cacerts _ resp _ chain ▁char ▁array ▁@ param ▁cert _ format ▁Specifie s ▁the ▁encoding ▁of ▁the ▁local ▁and ▁external ▁certificate ▁chain s ▁( PEM / DER ) . ▁@ param ▁http _ realm ▁Char ▁array ▁containing ▁HTTP ▁realm ▁name ▁for ▁HTTP ▁auth ▁@ param ▁tls _ id _ cert ▁ Pointer ▁to ▁X 509 ▁that ▁contains ▁the ▁server ' s ▁certificate ▁for ▁the ▁TLS ▁layer . ▁@ param ▁tls _ id _ key ▁ Pointer ▁to ▁E VP _ PKEY ▁that ▁contains ▁the ▁private ▁key ▁associate d ▁with ▁the ▁server ' s ▁certificate . ▁This ▁function ▁allow s ▁an ▁application ▁to ▁initialize ▁an ▁EST ▁server ▁context ▁that ▁is ▁used ▁with ▁a ▁CA ▁( not ▁an ▁RA ) . ▁The ▁application ▁must ▁provide ▁the ▁trusted ▁CA ▁certificates ▁to ▁use ▁for ▁server ▁operation ▁using ▁the ▁ca _ chain ▁parameter . ▁This ▁certificate ▁set ▁should ▁include ▁the ▁explicit ▁trust ▁anchor ▁certificate , ▁any ▁number ▁of ▁implicit ▁trust ▁anchor ▁certificates , ▁and ▁any ▁inter mediate ▁sub - CA ▁certificates ▁required ▁to ▁complete ▁the ▁chain ▁of ▁trust ▁between ▁the ▁identity ▁certificate ▁passed ▁into ▁the ▁tls _ id _ cert ▁parameter ▁and ▁the ▁roo t ▁certificate ▁for ▁that ▁identity ▁certificate . ▁The ▁CA ▁certificates ▁should ▁be ▁encoded ▁using ▁the ▁format ▁specified ▁in ▁the ▁cert _ format ▁parameter ▁( e . g . ▁PEM ) ▁and ▁ma y ▁contain ▁CRL ▁entries ▁that ▁will ▁be ▁used ▁when ▁authenticating ▁EST ▁clients ▁connecting ▁to ▁the ▁server . ▁The ▁application s ▁must ▁also ▁provide ▁the ▁HTTP ▁realm ▁to ▁use ▁for ▁HTTP ▁authentication ▁and ▁the ▁server ▁ c er if i cate / private ▁key ▁to ▁use ▁for ▁the ▁TLS ▁stack ▁to ▁identify ▁the ▁server . ▁ Warning : ▁Inc lu d ing ▁additional ▁inter mediate ▁sub - CA ▁certificates ▁that ▁are ▁not ▁needed ▁to ▁complete ▁the ▁chain ▁of ▁trust ▁ma y ▁result ▁in ▁a ▁potential ▁MI T M ▁attack . ▁@ return ▁EST _ CTX . ▁*/ ▁EST _ CTX ▁* ▁est _ server _ init ▁( un signed ▁char ▁* ca _ chain , ▁int ▁ca _ chain _ len , ▁un signed ▁char ▁* cacerts _ resp _ chain , ▁int ▁cacerts _ resp _ chain _ len , ▁EST _ CERT _ FORMAT ▁cert _ format , ▁char ▁* http _ realm , ▁X 509 ▁* tls _ id _ cert , ▁E VP _ PKEY ▁* tls _ id _ key ) ▁{ ▁EST _ CTX ▁* ctx ; ▁int ▁len ; ▁est _ log _ version (); ▁/* ▁* ▁ Sanity ▁check ▁the ▁input ▁*/ ▁if ▁( ca _ chain ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" Trust ed ▁CA ▁certificate ▁set ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( cert _ format ▁ != ▁EST _ CERT _ FORMAT _ PEM ) ▁{ ▁EST _ LOG _ ERR (" Only ▁PEM ▁encoding ▁of ▁certificate ▁changes ▁is ▁supported . "); ▁return ▁NULL ; ▁} ▁/* ▁* ▁Check ▁the ▁length ▁value , ▁it ▁should ▁match . ▁*/ ▁len ▁= ▁( int ) ▁ strnlen _ s ( ( char ▁* ) ca _ chain , ▁EST _ CA _ MAX ); ▁if ▁( len ▁ != ▁ca _ chain _ len ) ▁{ ▁EST _ LOG _ ERR (" Length ▁of ▁ca _ chain ▁does n ' t ▁match ▁ca _ chain _ len "); ▁return ▁NULL ; ▁} ▁if ▁( cacerts _ resp _ chain ) ▁{ ▁len ▁= ▁( int ) ▁ strnlen _ s ( ( char ▁* ) cacerts _ resp _ chain , ▁EST _ CA _ MAX ); ▁if ▁( len ▁ != ▁cacerts _ resp _ chain _ len ) ▁{ ▁EST _ LOG _ ERR (" A ct ual ▁length ▁of ▁cacerts _ resp _ chain ▁does ▁not ▁match ▁" ▁" pass ed ▁in ▁length ▁value "); ▁return ▁NULL ; ▁} ▁} ▁if ▁( tls _ id _ cert ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" TLS ▁identity ▁cert ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( tls _ id _ key ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" P ri v ate ▁key ▁associate d ▁with ▁TLS ▁identity ▁cert ▁is ▁empty "); ▁return ▁NULL ; ▁} ▁if ▁( http _ realm ▁== ▁NULL ) ▁{ ▁EST _ LOG _ ERR (" EST ▁HTTP ▁realm ▁is ▁NULL "); ▁return ▁NULL ; ▁} ▁ctx ▁= ▁malloc ( sizeof ( EST _ CTX )); ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" malloc ▁failed "); ▁return ▁NULL ; ▁} ▁mem zero _ s ( ctx , ▁sizeof ( EST _ CTX )); ▁ctx -> est _ mode ▁= ▁EST _ SERVER ; ▁ctx -> retry _ period ▁= ▁EST _ RETRY _ PER IO D _ DEF ; ▁ctx -> require _ http _ auth ▁= ▁HTTP _ AUTH _ REQUIRED ; ▁ctx -> server _ read _ timeout ▁= ▁EST _ SSL _ READ _ TIMEOUT _ DEF ; ▁/* ▁* ▁Load ▁the ▁CA ▁certificates ▁into ▁local ▁memory ▁and ▁retain ▁* ▁for ▁future ▁use . ▁This ▁will ▁be ▁used ▁for ▁/ cacerts ▁requests . ▁* ▁The y ▁are ▁optional ▁parameters . ▁The ▁alternative ▁is ▁for ▁the ▁* ▁app ▁layer ▁to ▁provide ▁callback ▁and ▁return ▁them ▁on ▁the ▁fly . ▁*/ ▁if ▁( cacerts _ resp _ chain ) ▁{ ▁if ▁( est _ load _ ca _ certs ( ctx , ▁cacerts _ resp _ chain , ▁cacerts _ resp _ chain _ len )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁load ▁CA ▁certificates ▁response ▁buffer "); ▁free ( ctx ); ▁return ▁NULL ; ▁} ▁} ▁if ▁( est _ load _ trusted _ certs ( ctx , ▁ca _ chain , ▁ca _ chain _ len )) ▁{ ▁EST _ LOG _ ERR (" Failed ▁to ▁load ▁trusted ▁cert f i cate ▁store "); ▁free ( ctx ); ▁return ▁NULL ; ▁} ▁strncpy _ s ( ctx -> realm , ▁ MAX _ REALM , ▁http _ realm , ▁ MAX _ REALM ); ▁ctx -> server _ cert ▁= ▁tls _ id _ cert ; ▁ctx -> server _ priv _ key ▁= ▁tls _ id _ key ; ▁ctx -> auth _ mode ▁= ▁AUTH _ BASIC ; ▁ctx -> server _ enable _ pop ▁= ▁1; ▁ctx -> loc al _ cacerts _ process ing ▁= ▁1; ▁/* ▁* ▁Create ▁a ▁new ▁ASN ▁object ▁for ▁the ▁id - kp - cmcRA ▁OID . ▁* ▁OpenSSL ▁does n ' t ▁ define ▁this , ▁so ▁we ▁need ▁to ▁create ▁it ▁* ▁ourselves . ▁* ▁http :// w ww . openssl . org / do cs / crypto / OBJ _ nid 2 obj . html ▁*/ ▁if ▁(! o _ cmcRA ) ▁{ ▁ o _ cmcRA ▁= ▁OBJ _ txt 2 obj (" 1 . 3 . 6 . 1 . 5 . 5 . 7 . 3 . 2 8 ", ▁1); ▁if ▁(! o _ cmcRA ) ▁{ ▁EST _ LOG _ WARN (" Failed ▁to ▁create ▁OID ▁for ▁id - kp - cmcRA ▁key ▁usage ▁checks "); ▁} ▁} ▁return ▁( ctx ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ set _ auth _ mode () ▁is ▁used ▁by ▁an ▁application ▁to ▁configure ▁the ▁HTTP ▁authentication ▁method ▁to ▁use ▁for ▁validat ing ▁the ▁identity ▁of ▁an ▁EST ▁client . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁amode ▁M ust ▁be ▁one ▁of ▁the ▁following : ▁AUTH _ BASIC , ▁AUTH _ DIGEST , ▁AUTH _ TOKEN ▁This ▁function ▁can ▁optional ly ▁be ▁invoked ▁by ▁the ▁application ▁to ▁change ▁the ▁default ▁HTTP ▁authentication ▁mode . ▁The ▁default ▁mode ▁is ▁HTTP ▁Basic ▁authentication . ▁An ▁application ▁ma y ▁desire ▁to ▁use ▁Digest ▁or ▁Token ▁authentication ▁instead , ▁in ▁which ▁case ▁this ▁function ▁can ▁be ▁used ▁to ▁set ▁that ▁mode . ▁This ▁function ▁must ▁be ▁invoked ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ set _ auth _ mode ▁( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ MODE ▁amode ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁switch ▁( a mode ) ▁{ ▁case ▁AUTH _ DIGEST : ▁/* ▁* ▁S ince ▁HTTP ▁digest ▁auth ▁uses ▁MD 5 , ▁make ▁sure ▁we ' re ▁not ▁in ▁FIPS ▁mode . ▁*/ ▁if ▁( FIPS _ mode ()) ▁{ ▁EST _ LOG _ ERR (" HTTP ▁digest ▁auth ▁not ▁allowed ▁while ▁in ▁FIPS ▁mode "); ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁} ▁/* ▁fall through ▁*/ ▁case ▁AUTH _ BASIC : ▁case ▁AUTH _ TOKEN : ▁ctx -> auth _ mode ▁= ▁amode ; ▁return ▁( EST _ ERR _ NONE ); ▁break ; ▁default : ▁EST _ LOG _ ERR (" Un supported ▁HTTP ▁authentication ▁mode , ▁only ▁Basic , ▁Digest ▁and ▁Token ▁allowed "); ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁break ; ▁} ▁} ▁/* ! ▁@ br i ef ▁est _ set _ ca _ enroll _ cb () ▁is ▁used ▁by ▁an ▁application ▁to ▁install ▁a ▁handler ▁for ▁signing ▁incoming ▁PKCS 10 ▁requests . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁cb ▁Function ▁address ▁of ▁the ▁handler ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁The ▁callback ▁function ▁must ▁match ▁the ▁following ▁prototype : ▁int ▁ func ( un signed ▁char *, ▁int , ▁un signed ▁char ** , ▁int *, ▁char *, ▁X 509 *, ▁char ▁* , ▁void ▁* ); ▁This ▁function ▁is ▁called ▁by ▁libEST ▁when ▁a ▁certificate ▁request ▁needs ▁to ▁be ▁signed ▁by ▁the ▁CA ▁server . ▁The ▁application ▁will ▁need ▁to ▁forward ▁the ▁request ▁to ▁the ▁signing ▁authorit y ▁and ▁return ▁the ▁response . ▁The ▁response ▁should ▁be ▁a ▁PKCS 7 ▁signed ▁certificate . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ set _ ca _ enroll _ cb ▁( EST _ CTX ▁* ctx , ▁int ▁(* cb ) ( un signed ▁char ▁* pkcs 10 , ▁int ▁p 10_ len , ▁un signed ▁char ▁** pkcs 7, ▁int ▁* pkcs 7_ len , ▁char ▁* user _ id , ▁X 509 ▁* peer _ cert , ▁char ▁* path _ seg , ▁void ▁* ex _ data )) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> est _ enroll _ pkcs 10_ cb ▁= ▁cb ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ set _ ca _ reenroll _ cb () ▁is ▁used ▁by ▁an ▁application ▁to ▁install ▁a ▁handler ▁for ▁re - enroll ing ▁certificates . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁cb ▁Function ▁address ▁of ▁the ▁handler ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁The ▁callback ▁function ▁must ▁match ▁the ▁following ▁prototype : ▁int ▁ func ( un signed ▁char *, ▁int , ▁un signed ▁char ** , ▁int *, ▁char *, ▁X 509 *) ▁This ▁function ▁is ▁called ▁by ▁libEST ▁when ▁a ▁certificate ▁needs ▁to ▁be ▁renewed ▁by ▁the ▁CA ▁server . ▁The ▁application ▁will ▁need ▁to ▁forward ▁the ▁request ▁to ▁the ▁signing ▁authorit y ▁and ▁return ▁the ▁response . ▁The ▁response ▁should ▁be ▁a ▁PKCS 7 ▁signed ▁certificate . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ set _ ca _ reenroll _ cb ▁( EST _ CTX ▁* ctx , ▁int ▁(* cb ) ( un signed ▁char ▁* pkcs 10 , ▁int ▁p 10_ len , ▁un signed ▁char ▁** pkcs 7, ▁int ▁* pkcs 7_ len , ▁char ▁* user _ id , ▁X 509 ▁* peer _ cert , ▁char ▁* path _ seg , ▁void ▁* ex _ data )) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> est _ reenroll _ pkcs 10_ cb ▁= ▁cb ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ set _ http _ auth _ cb () ▁is ▁used ▁by ▁an ▁application ▁to ▁install ▁a ▁handler ▁for ▁authenticating ▁EST ▁clients . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁cb ▁Function ▁address ▁of ▁the ▁handler ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁The ▁callback ▁function ▁must ▁match ▁the ▁following ▁prototype : ▁int ▁(* cb ) ( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ HDR ▁* ah , ▁X 509 ▁* peer _ cert , ▁char ▁* path _ seg , ▁void ▁* ex _ data ) ▁This ▁function ▁is ▁called ▁by ▁libEST ▁when ▁perform ing ▁HTTP ▁authentication . ▁libEST ▁will ▁pass ▁the ▁EST _ HTTP _ AUTH _ HDR ▁struct ▁to ▁the ▁application , ▁allowing ▁the ▁application ▁to ▁ h o ok ▁into ▁a ▁Radius , ▁A AA , ▁or ▁some ▁user ▁authentication ▁database . ▁The ▁X 509 ▁certificate ▁from ▁the ▁TLS ▁peer ▁( EST ▁client ) ▁is ▁also ▁provided ▁through ▁this ▁callback ▁facility , ▁allowing ▁the ▁application ▁layer ▁to ▁check ▁for ▁specific ▁attributes ▁in ▁the ▁X 509 ▁certificate ▁suc h ▁as ▁an ▁80 2.1 AR ▁devi ce ▁ID . ▁In ▁addition , ▁the ▁path ▁segment ▁string ▁is ▁passed ▁up ▁if ▁there ▁was ▁one ▁in ▁the ▁request ▁URI . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ set _ http _ auth _ cb ▁( EST _ CTX ▁* ctx , ▁int ▁(* cb ) ( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ HDR ▁* ah , ▁X 509 ▁* peer _ cert , ▁char ▁* path _ seg , ▁void ▁* ex _ data )) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> est _ http _ auth _ cb ▁= ▁cb ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ set _ http _ auth _ required () ▁is ▁used ▁by ▁an ▁application ▁to ▁ define ▁whether ▁HTTP ▁authentication ▁should ▁be ▁required ▁in ▁addition ▁to ▁using ▁client ▁certificates . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁required ▁F la g ▁indicat ing ▁that ▁HTTP ▁authentication ▁is ▁required . ▁Set ▁to ▁HTTP _ AUTH _ REQUIRED ▁value ▁to ▁require ▁HTTP ▁auth . ▁Set ▁to ▁HTTP _ AUTH _ NOT _ REQUIRED ▁if ▁HTTP ▁auth ▁should ▁occur ▁only ▁when ▁TLS ▁client ▁authentication ▁fails . ▁@ return ▁EST _ ERROR . ▁The ▁default ▁mode ▁is ▁HTTP _ AUTH _ REQUIRED . ▁This ▁means ▁that ▁HTTP ▁authentication ▁will ▁be ▁attempted ▁even ▁when ▁TLS ▁client ▁authentication ▁succeed s . ▁If ▁HTTP ▁authentication ▁is ▁only ▁needed ▁when ▁TLS ▁client ▁auth ▁fails , ▁then ▁set ▁this ▁to ▁HTTP _ AUTH _ NOT _ REQUIRED . ▁*/ ▁EST _ ERROR ▁est _ set _ http _ auth _ required ▁( EST _ CTX ▁* ctx , ▁EST _ HTTP _ AUTH _ REQUIRED ▁required ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> require _ http _ auth ▁= ▁required ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ enable _ srp () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁the ▁TLS - SRP ▁authentication . ▁This ▁allow s ▁EST ▁clients ▁that ▁provide ▁SRP ▁credentials ▁at ▁the ▁TLS ▁layer ▁to ▁be ▁authenticated ▁by ▁the ▁EST ▁server . ▁This ▁function ▁must ▁be ▁invoked ▁to ▁enable ▁server - side ▁SRP ▁support . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁cb ▁Function ▁address ▁of ▁the ▁application ▁specific ▁SRP ▁verifie r ▁handler ▁This ▁function ▁should ▁be ▁invoked ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁This ▁is ▁used ▁to ▁specify ▁the ▁handler ▁for ▁SRP ▁authentication ▁at ▁the ▁TLS ▁layer . ▁When ▁a ▁TLS - SRP ▁cipher ▁suite ▁is ▁negotiated ▁at ▁the ▁TLS ▁layer , ▁the ▁handler ▁will ▁be ▁invoked ▁by ▁libEST ▁to ▁retrieve ▁the ▁SRP ▁parameters ▁for ▁user ▁authentication . ▁You r ▁application ▁must ▁provide ▁the ▁SRP ▁parameters ▁for ▁the ▁user . ▁The ▁handler ▁should ▁use ▁the ▁following ▁logic : ▁1 . ▁I nvoke ▁SSL _ get _ srp _ username () ▁to ▁get ▁the ▁SRP ▁user ▁name ▁from ▁the ▁TLS ▁layer . ▁2 . ▁Look up ▁the ▁user ' s ▁SRP ▁parameters ▁in ▁the ▁application ▁specific ▁user ▁database . ▁These ▁parameters ▁include ▁the ▁N , ▁ g , ▁ s , ▁and ▁v ▁parameters . ▁3 . ▁I nvoke ▁SSL _ set _ srp _ server _ param () ▁to ▁forward ▁the ▁SRP ▁parameters ▁to ▁the ▁TLS ▁layer , ▁allowing ▁the ▁TLS ▁handshake ▁to ▁proceed . ▁libEST ▁include s ▁an ▁example ▁server ▁application ▁that ▁uses ▁this ▁handler ▁for ▁SRP ▁support . ▁This ▁example ▁uses ▁the ▁OpenSSL ▁SRP ▁verifie r ▁file ▁ca p ability ▁to ▁manage ▁SRP ▁parameters ▁for ▁individual ▁user s . ▁You r ▁application ▁could ▁use ▁this ▁a pproach , ▁or ▁it ▁ma y ▁ util ize ▁another ▁facility ▁for ▁ managing ▁user ▁specific ▁SRP ▁parameters . ▁P lease ▁ref er ▁to ▁RFC ▁ 29 45 ▁and ▁RFC ▁ 5054 ▁for ▁a ▁full ▁understand ing ▁of ▁SRP . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ enable _ srp ▁( EST _ CTX ▁* ctx , ▁int ▁(* cb ) ( SSL ▁* s , ▁int ▁* ad , ▁void ▁* arg )) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! cb ) ▁{ ▁EST _ LOG _ ERR (" Null ▁callback "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> est _ srp _ username _ cb ▁= ▁cb ; ▁ctx -> enable _ srp ▁= ▁1; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ enable _ pop () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁the ▁p roof - of - possession ▁check ▁on ▁the ▁EST ▁server . ▁This ▁proves ▁the ▁EST ▁client ▁that ▁sent ▁the ▁CSR ▁to ▁the ▁server ▁is ▁in ▁ pos s es ion ▁of ▁the ▁private ▁key ▁that ▁was ▁used ▁to ▁sign ▁the ▁CSR . ▁This ▁bind s ▁the ▁TLS ▁session ▁ID ▁to ▁the ▁CSR . ▁Note , ▁if ▁the ▁CSR ▁attributes ▁configured ▁on ▁the ▁server ▁require ▁PoP ▁checking , ▁then ▁there ▁is ▁no ▁need ▁to ▁call ▁this ▁function ▁to ▁enable ▁PoP . ▁The ▁PoP ▁will ▁be ▁enabled ▁automatically ▁under ▁this ▁scenario . ▁Note , ▁PoP ▁checking ▁is ▁not ▁possible ▁when ▁an ▁EST ▁proxy ▁is ▁used ▁to ▁between ▁the ▁EST ▁client ▁and ▁EST ▁server . ▁S ince ▁the ▁proxy ▁will ▁not ▁be ▁in ▁ possession ▁of ▁the ▁private ▁key , ▁an ▁EST ▁server ▁woul ▁fail ▁the ▁PoP ▁check . ▁How ever , ▁an ▁EST ▁proxy ▁can ▁enable ▁this ▁feature ▁to ▁ensure ▁the ▁EST ▁client ▁has ▁the ▁signing ▁key . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁ma y ▁be ▁called ▁at ▁any ▁time . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ enable _ pop ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> server _ enable _ pop ▁= ▁1; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ disable _ pop () ▁is ▁used ▁by ▁an ▁application ▁to ▁disable ▁the ▁p roof - of - possession ▁check ▁on ▁the ▁EST ▁server . ▁P lease ▁see ▁the ▁do c u me n ation ▁for ▁est _ server _ enable _ pop () ▁for ▁more ▁information ▁on ▁the ▁p roof - of - possession ▁check . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁ma y ▁be ▁called ▁at ▁any ▁time . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ disable _ pop ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> server _ enable _ pop ▁= ▁0; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ set _ retry _ period () ▁is ▁used ▁by ▁an ▁application ▁to ▁change ▁the ▁default ▁retry - after ▁period ▁sent ▁to ▁the ▁EST ▁client ▁when ▁the ▁CA ▁server ▁is ▁not ▁configured ▁for ▁auto - enroll . ▁This ▁retry - after ▁value ▁notifie s ▁the ▁client ▁about ▁how ▁long ▁it ▁should ▁wait ▁before ▁attempt ing ▁the ▁enroll ▁operation ▁again ▁to ▁see ▁if ▁the ▁CA ▁has ▁approved ▁the ▁original ▁CSR . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁seconds ▁Number ▁of ▁seconds ▁the ▁server ▁will ▁use ▁in ▁the ▁retry - after ▁response . ▁This ▁function ▁ma y ▁be ▁called ▁at ▁any ▁time ▁after ▁a ▁context ▁has ▁been ▁created . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ set _ retry _ period ▁( EST _ CTX ▁* ctx , ▁int ▁seconds ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( second s ▁> ▁EST _ RETRY _ PER IO D _ MAX ) ▁{ ▁EST _ LOG _ ERR (" Maximum ▁retry - after ▁period ▁is ▁% d ▁seconds ", ▁EST _ RETRY _ PER IO D _ MAX ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁if ▁( second s ▁< ▁EST _ RETRY _ PER IO D _ MIN ) ▁{ ▁EST _ LOG _ ERR (" Min i mu m ▁retry - after ▁period ▁is ▁% d ▁seconds ", ▁EST _ RETRY _ PER IO D _ MIN ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> retry _ period ▁= ▁seconds ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ set _ ecdhe _ curve () ▁is ▁used ▁by ▁an ▁application ▁to ▁specify ▁the ▁EC C ▁curve ▁that ▁should ▁be ▁used ▁for ▁e phe m eral ▁diff ie - h ell man ▁key s ▁dur ing ▁the ▁TLS ▁handshake . ▁E phe m eral ▁diff ie - h ell man ▁is ▁enabled ▁by ▁libEST ▁and ▁provide s ▁be tter ▁forward ▁ se c re c y . ▁If ▁the ▁curve ▁is ▁not ▁specified ▁by ▁the ▁application ▁using ▁this ▁function , ▁then ▁the ▁prime 256 v 1 ▁curve ▁is ▁used ▁as ▁the ▁default ▁curve . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁nid ▁OpenSSL ▁NID ▁value ▁for ▁the ▁desired ▁curve ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁The ▁NID ▁values ▁are ▁defined ▁in ▁< openssl / obj _ m a c . h > . ▁T y p ical ▁NID ▁values ▁provided ▁to ▁this ▁function ▁woul d ▁include : ▁NID _ X 9 _ 62 _ prime 19 2 v 1 ▁NID _ X 9 _ 62 _ prime 256 v 1 ▁NID _ secp 384 r 1 ▁NID _ secp 5 21 r 1 ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ set _ ecdhe _ curve ▁( EST _ CTX ▁* ctx , ▁int ▁nid ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( nid ▁< = ▁0) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁NID ▁value "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> ecdhe _ nid ▁= ▁nid ; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ set _ dh _ parms () ▁is ▁used ▁by ▁an ▁application ▁to ▁specify ▁the ▁ Diff ie - H ell man ▁parameters ▁to ▁be ▁used ▁for ▁single ▁use ▁DH ▁key ▁generation ▁dur ing ▁the ▁TLS ▁handshake . ▁If ▁these ▁parameters ▁are ▁not ▁used , ▁then ▁single - use ▁DH ▁key ▁generation ▁is ▁not ▁enabled . ▁This ▁should ▁be ▁enabled ▁to ▁improve ▁the ▁forward ▁ se c re c y ▁of ▁the ▁TLS ▁handshake ▁operation . ▁The ▁DH ▁parameters ▁provided ▁through ▁this ▁API ▁should ▁not ▁be ▁hard - code d ▁in ▁the ▁application . ▁The ▁parameters ▁should ▁be ▁generated ▁at ▁the ▁time ▁of ▁product ▁installation . ▁Re us ing ▁the ▁parameters ▁ acros s ▁multiple ▁installation s ▁of ▁the ▁product ▁results ▁in ▁a ▁v ul n er able ▁product . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁ parms ▁ Pointer ▁to ▁OpenSSL ▁DH ▁parameters ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ set _ dh _ parms ▁( EST _ CTX ▁* ctx , ▁DH ▁* parms ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁(! parms ) ▁{ ▁EST _ LOG _ ERR (" Null ▁DH ▁parameters "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> dh _ tmp ▁= ▁DH param s _ dup ( parms ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ init _ csrattrs () ▁is ▁used ▁by ▁an ▁application ▁to ▁initialize ▁a ▁fixed ▁set ▁of ▁CSR ▁attributes . ▁These ▁attributes ▁will ▁be ▁used ▁by ▁libEST ▁in ▁response ▁to ▁a ▁client ▁CSR ▁attributes ▁request . ▁The ▁attributes ▁must ▁be ▁an ▁ASN . 1 ▁base 64 ▁encoded ▁character ▁string . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁csrattrs ▁ Pointer ▁CSR ▁attributes ▁in ▁ASN . 1 ▁base 64 ▁encoded ▁format , ▁a ▁NULL ▁pointer ▁clear s ▁the ▁attributes ▁and ▁length . ▁@ param ▁csrattrs _ len ▁Length ▁of ▁the ▁CSR ▁attributes ▁character ▁string ▁The ▁est _ get _ csr _ cb ▁callback ▁function ▁maintain s ▁pre c end enc e ▁over ▁this ▁method ▁for ▁CSR ▁attributes . ▁If ▁est _ get _ csr _ cb ▁is ▁initialized ▁by ▁the ▁application ▁it ▁will ▁be ▁used . ▁If ▁not , ▁then ▁libEST ▁will ▁use ▁the ▁attributes ▁initialized ▁here . ▁This ▁function ▁should ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁PoP ▁configuration ( est _ server _ enable _ pop ▁or ▁est _ server _ disable _ pop ) ▁should ▁be ▁called ▁prior ▁to ▁this ▁function . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ init _ csrattrs ▁( EST _ CTX ▁* ctx , ▁char ▁* csrattrs , ▁int ▁csrattrs _ len ) ▁{ ▁int ▁csrattrs _ pop _ len , ▁pop _ present , ▁rv ; ▁char ▁* csrattrs _ data _ pop ▁= ▁NULL ; ▁if ▁( ctx ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁/* ▁* ▁Verify ▁the ▁context ▁is ▁for ▁a ▁server , ▁not ▁a ▁client ▁or ▁proxy ▁*/ ▁if ▁( ctx -> est _ mode ▁ != ▁EST _ SERVER ) ▁{ ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁} ▁EST _ LOG _ INFO (" Attribute s ▁pointer ▁is ▁% p , ▁len =% d ", ▁ctx -> server _ csrattrs , ▁ctx -> server _ csrattrs _ len ); ▁/* ▁ Free ▁old ▁version ▁if ▁previous ly ▁initialized ▁*/ ▁if ▁( ctx -> server _ csrattrs ▁ != ▁NULL ) ▁{ ▁free ( ctx -> server _ csrattrs ); ▁ctx -> server _ csrattrs ▁= ▁NULL ; ▁ctx -> server _ csrattrs _ len ▁= ▁0; ▁} ▁/* ▁caller ▁just ▁want ed ▁to ▁clear ▁it , ▁so ▁return ▁*/ ▁if ▁( csrattrs ▁== ▁NULL ) ▁{ ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁In ▁order ▁to ▁run ▁Client ▁negative ▁ unit ▁testing ▁the ▁parameter , ▁* ▁PoP ▁and ▁parse ▁checks ▁all ▁need ▁to ▁be ▁disabled ▁ via ▁# define ▁* ▁in ▁a ▁ co up le ▁of ▁places ▁here . ▁*/ ▁/* ▁* ▁check ▁small est ▁possible ▁base 64 ▁case ▁here ▁for ▁now ▁* ▁and ▁ sanity ▁test ▁will ▁check ▁min / max ▁value ▁for ▁ASN . 1 ▁data ▁*/ ▁if ▁( csrattrs _ len ▁< ▁MIN _ CSRATTRS ) ▁{ ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁/* ▁assume ▁PoP ▁not ▁in ▁CSR ▁attributes ▁*/ ▁ctx -> csr _ pop _ present ▁= ▁0; ▁if ▁( ctx -> server _ enable _ pop ) ▁{ ▁rv ▁= ▁est _ is _ c hallengePassword _ present ( csrattrs , ▁csrattrs _ len , ▁& pop _ present ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Error ▁dur ing ▁PoP / sanity ▁check "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> csr _ pop _ present ▁= ▁pop _ present ; ▁if ▁(! ctx -> csr _ pop _ present ) ▁{ ▁rv ▁= ▁est _ add _ c hallengePassword ( csrattrs , ▁csrattrs _ len , ▁& csrattrs _ data _ pop , ▁& csrattrs _ pop _ len ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Error ▁dur ing ▁add ▁PoP "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁csrattrs ▁= ▁csrattrs _ data _ pop ; ▁csrattrs _ len ▁= ▁csrattrs _ pop _ len ; ▁} ▁} ▁else ▁{ ▁rv ▁= ▁est _ asn 1 _ parse _ attributes ( csrattrs , ▁csrattrs _ len , ▁& pop _ present ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁{ ▁EST _ LOG _ ERR (" Corrupt ▁CSR ▁Attributes "); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁} ▁ctx -> server _ csrattrs ▁= ▁malloc ( csrattrs _ len ▁+ ▁1); ▁if ▁(! ctx -> server _ csrattrs ) ▁{ ▁if ▁( csrattrs _ data _ pop ) ▁{ ▁free ( csrattrs _ data _ pop ); ▁} ▁return ▁( EST _ ERR _ MALLOC ); ▁} ▁ctx -> server _ csrattrs _ len ▁= ▁csrattrs _ len ; ▁strncpy _ s ( ( char ▁* ) ctx -> server _ csrattrs , ▁csrattrs _ len ▁+ ▁1, ▁csrattrs , ▁csrattrs _ len ); ▁ctx -> server _ csrattrs [ csrattrs _ len ] ▁= ▁0; ▁if ▁( csrattrs _ data _ pop ) ▁{ ▁free ( csrattrs _ data _ pop ); ▁} ▁EST _ LOG _ INFO (" Attribute s ▁pointer ▁is ▁% p , ▁len =% d ", ▁ctx -> server _ csrattrs , ▁ctx -> server _ csrattrs _ len ); ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ enable _ tls 10 () ▁is ▁a ▁deprecated ▁function . ▁TLS ▁1.0 ▁is ▁a ▁vi ol ation ▁of ▁RFC 7030 ▁and ▁it ▁is ▁no ▁long er ▁supported ▁by ▁the ▁EST ▁library . ▁This ▁function ▁will ▁log ▁an ▁error ▁message ▁and ▁return ▁EST _ ERR _ BAD _ MODE . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ enable _ tls 10 ▁( EST _ CTX ▁* ctx ) ▁{ ▁EST _ LOG _ ERR (" TLS ▁1.0 ▁is ▁a ▁vi ol ation ▁of ▁RFC 7030 ▁and ▁the refore ▁not ▁supported "); ▁return ▁( EST _ ERR _ BAD _ MODE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ enforce _ csrattrs () ▁is ▁used ▁by ▁an ▁application ▁to ▁enable ▁checking ▁of ▁the ▁CSR ▁attributes ▁on ▁the ▁EST ▁server . ▁When ▁enabled , ▁the ▁EST ▁client ▁must ▁provide ▁all ▁the ▁CSR ▁attributes ▁that ▁we re ▁in ▁the ▁/ csrattrs ▁response ▁sent ▁by ▁the ▁server . ▁The ▁enrollment ▁will ▁fail ▁if ▁the ▁client ▁fails ▁to ▁provide ▁all ▁the ▁CSR ▁attributes . ▁This ▁setting ▁applies ▁to ▁simple ▁enroll ▁and ▁reenroll ▁operations . ▁This ▁setting ▁applies ▁only ▁to ▁server ▁mode ▁and ▁has ▁no ▁be ar ing ▁on ▁proxy ▁mode ▁operation . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁This ▁function ▁must ▁be ▁called ▁prior ▁to ▁start ing ▁the ▁EST ▁server . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ enforce _ csrattr ▁( EST _ CTX ▁* ctx ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁ctx -> enforce _ csrattrs ▁= ▁1; ▁return ▁( EST _ ERR _ NONE ); ▁} ▁/* ! ▁@ br i ef ▁est _ server _ set _ read _ timeout () ▁is ▁used ▁by ▁an ▁application ▁to ▁set ▁timeout ▁value ▁of ▁server ▁read ▁operations . ▁On ce ▁a ▁socket ▁is ▁open ed ▁the ▁EST ▁server ▁begin s ▁attempt ing ▁to ▁read ▁from ▁this ▁socket . ▁This ▁timeout ▁value ▁limit s ▁the ▁amount ▁of ▁time ▁the ▁client ▁will ▁wait ▁for ▁the ▁response . ▁The ▁default ▁value ▁is ▁set ▁to ▁EST _ SSL _ READ _ TIMEOUT _ DEF . ▁@ param ▁ctx ▁ Pointer ▁to ▁the ▁EST ▁context ▁@ param ▁timeout ▁Integer ▁value ▁representing ▁the ▁read ▁timeout ▁in ▁seconds . ▁The ▁minimum ▁value ▁is ▁EST _ SSL _ READ _ TIMEOUT _ MIN ▁and ▁the ▁maximum ▁value ▁is ▁EST _ SSL _ READ _ TIMEOUT _ MAX . ▁@ return ▁EST _ ERROR . ▁*/ ▁EST _ ERROR ▁est _ server _ set _ read _ timeout ▁( EST _ CTX ▁* ctx , ▁int ▁timeout ) ▁{ ▁if ▁(! ctx ) ▁{ ▁EST _ LOG _ ERR (" Null ▁context "); ▁return ▁( EST _ ERR _ NO _ CTX ); ▁} ▁if ▁( timeout ▁< ▁EST _ SSL _ READ _ TIMEOUT _ MIN ▁|| ▁timeout ▁> ▁EST _ SSL _ READ _ TIMEOUT _ MAX ) ▁{ ▁EST _ LOG _ ERR (" I nvalid ▁read ▁timeout ▁value ▁passed : ▁% d ▁" , ▁timeout ); ▁return ▁( EST _ ERR _ INVALID _ PARAMETERS ); ▁} ▁ctx -> server _ read _ timeout ▁= ▁timeout ; ▁return ▁( EST _ ERR _ NONE ); ▁}