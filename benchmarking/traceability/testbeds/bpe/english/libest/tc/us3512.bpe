▁/* ---------------- -- ---------------- ---------------- ---------------- ▁* ▁us 3512 . c ▁- ▁Unit ▁Test s ▁URI ▁path ▁segment ▁support ▁in ▁the ▁Server ▁* ▁* ▁April , ▁2016 ▁* ▁* ▁Copy right ▁( c ) ▁2016 ▁by ▁ cisco ▁System s , ▁Inc . ▁* ▁All ▁rights ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁< s td io . h > ▁# if ndef ▁WI N 32 ▁# include ▁< uni s td . h > ▁# endif ▁# include ▁< est . h > ▁# include ▁< curl / curl . h > ▁# include ▁" curl _ util s . h " ▁# if def ▁HAV E _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁# include ▁"../../ util / test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁" st _ proxy . h " ▁# include ▁"../../ src / est / est _ loc l . h " ▁extern ▁char ▁ tst _ srv r _ path _ seg _ enroll [ ] ; ▁extern ▁char ▁ tst _ srv r _ path _ seg _ cacerts [ ] ; ▁extern ▁char ▁ tst _ srv r _ path _ seg _ csrattrs [ ] ; ▁extern ▁char ▁ tst _ srv r _ path _ seg _ auth [ ] ; ▁extern ▁char ▁ tst _ proxy _ path _ seg _ auth [ ] ; ▁static ▁int ▁path _ segment _ support ; ▁/* ▁* ▁max ▁command ▁line ▁length ▁when ▁generat ing ▁system ▁commands ▁*/ ▁# define ▁EST _ UT _ MAX _ CMD _ LEN ▁256 ▁# define ▁US 3512_ SERVER _ PORT ▁ 29496 ▁# define ▁US 3512_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 3512_ UIDPWD _ GOOD ▁" estuser : estpwd " ▁# define ▁US 3512_ UID ▁" estuser " ▁# define ▁US 3512_ PWD ▁" estpwd " ▁# if ndef ▁WI N 32 ▁# define ▁US 3512_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 3512_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 3512_ SERVER _ CERTKEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 3512_ PROXY _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 3512_ PROXY _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 3512_ CACERT ▁" CA / estCA / cacert . crt " ▁/* ▁* ▁The ▁CA ▁certificate ▁used ▁to ▁verify ▁the ▁EST ▁server . ▁Gra b ▁it ▁from ▁the ▁server ' s ▁directory ▁*/ ▁/* ▁# define ▁CLIENT _ UT _ CACERT ▁"../../ example / server / estCA / cacert . crt " ▁*/ ▁# define ▁CLIENT _ UT _ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁CLIENT _ UT _ PUBKEY ▁" . / est _ client _ ut _ keypair " ▁# else ▁# define ▁US 3512_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 3512_ TRUST _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 3512_ SERVER _ CERTKEY ▁" CA \\ estCA / private / estserver cert and key . pem " ▁# define ▁US 3512_ PROXY _ CERT ▁" CA \\ estCA \\ private / estserver cert and key . pem " ▁# define ▁US 3512_ PROXY _ KEY ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 3512_ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁/* ▁* ▁The ▁CA ▁certificate ▁used ▁to ▁verify ▁the ▁EST ▁server . ▁Gra b ▁it ▁from ▁the ▁server ' s ▁directory ▁*/ ▁/* ▁# define ▁CLIENT _ UT _ CACERT ▁"../../ example / server / estCA / cacert . crt " ▁*/ ▁# define ▁CLIENT _ UT _ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁CLIENT _ UT _ PUBKEY ▁" est _ client _ ut _ keypair " ▁# endif ▁# define ▁US 3512_ ENROLL _ URL _ BA ▁" http s ://127.0.0.1: 29496 / . well - known / est / cacerts - somestring / simpleenroll " ▁# define ▁US 3512_ ENROLL _ URL _ BA _ BA CK S LA S H ▁" http s ://127.0.0.1: 29496 / . well - known / est / cacerts - \\ somestring / simpleenroll " ▁# define ▁US 3512_ ENROLL _ URL _ BA _ NO SEGMENT ▁" http s ://127.0.0.1: 29496 / . well - known / est / simpleenroll " ▁# define ▁US 3512_ PKCS 10_ CT ▁" Content - Type : ▁application / pkcs 10" ▁# define ▁US 3512_ PKCS 10_ RSA 2048 ▁" MIIC v TCCAa U CAQAw e DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE j AQ BgNVBAoMC VJ TQW Nl cn Rj bz EM MA oGA 1 UEC wwD cnN h MR AwDgYDV QQD \ nDA dy c 2 EgZG 9 lMR o wGA YJKoZIhvcNAQkBFg ty c 2 FA ZG 9 lL m Nvb T CCASIwDQYJKoZI \ n hvcNAQEBBQADgg EPADCCAQoCggEBA N 6 pC TB rK 7 T 0 29 Bg a nq 0 QH XH y NL 8 op v xc 7 JY \ n Xa Qz 39 R 3 J 9 BoB E 72 XZ 0 QX sB tU EY GNh HOL a IS ASN zs 2 ZK Wp vM HJ W mP YN t 39 OC i 48 Y \ n FO gL Db An 83 mA OK S fc ML bi bC cs h 4 HO l haa F rWs kRT A sew 16 MU Oz Fu 6 vB kw / A hI 82 J \ nK PY ws 0 dY Ox uW FI gE 1 HL + m / gpl bz q 7 Fr B Id rq k NL + dd gy Xo Dd 5 Nu LM JG DAK 7 vB 1 Ww \ n 9/ B aw /6 Ai 9 V 5 psy e 1 v 8 fW Dr 6 HW 2 gg 9 X n VtM wB 4 pC g 1 rl 1 l SY stum T GY bM 6 c xJ yw e \ nL uM nD jj 1 Zw D sZ 1 wI Xa BA XZa x EIS / rX OX 0 H nZ MT ef xY / gp Fk 1 Kv 0 CAwEAAa AAMA 0 G \ n CS qGS Ib 3 DQEBBQUA A 4 IBAQB 6 r Iw Nj E 8 l 8 jF KR 1 hQ / q eS ve e / bAQ a 58 Ru fZ 4 US Ku K \ nl s ih 7 UC f 8 b kQ vg lj nh sc Qu cz Ibn Jz eq EP qS d no mF W 6 Cv Mc / ah + Qf X 87 F GY xJ gp wF \ nut nU if j Di Zh rW gf / jN Nb tH rke cw / Z ex 4 sZ / HC 127 j tE 3 c yE kD srA 1 oB xYR Cq 93 tC \ nW 2 q 9 PL Vm Ll yjc Z cS 1 KH VD 2 ny a 79 kfS 0 YG Mo cs w 1 G elV L 2 iz / oca yA S 5 GB 9 Y 2 s EB w \ nR kC aY Zw 6 v hj 5 qj pC U zJ 3 E 8 Cl 3 VD 4 Kp i 3 j 3 bZGD JA 9 md md 8 j 5 Zy PY 56 e Au xa rWs sD \ nc i UM / h 6 E 99 w 3 tm r UZ b Ll jk jJ 7 pBX Rn ont gm 5 WZ mQ FH 4 X " ▁# define ▁US 3512_ TCP _ PROXY _ PORT ▁ 16894 ▁# define ▁P ATH _ SEG _ VALID ▁" somestring " ▁# define ▁P ATH _ SEG _ TOO _ MANY _ SEG S ▁" somestring 1 / somestring 2" ▁# define ▁P ATH _ SEG _ IS _ OPERATION ▁" cacerts " ▁# define ▁P ATH _ SEG _ CON TAIN S _ OPERATION ▁" cacerts somestring " ▁# define ▁P ATH _ SEG _ MAX ▁"123456789 01234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 1234567890123456 7 8 " ▁# define ▁P ATH _ SEG _ TOO _ LONG ▁" 1234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 678901234567890 123456789012345 67890123456789" ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ VALID ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ VALID " / simpleenroll " ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ TOO _ LONG ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ TOO _ LONG " / simpleenroll " ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ MAX ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ MAX " / simpleenroll " ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ TOO _ MANY ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ TOO _ MANY _ SEG S " / simpleenroll " ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ IS _ OPERATION ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ IS _ OPERATION " / simpleenroll " ▁# define ▁US 3512_ PROXY _ ENROLL _ URL _ CON TAIN S _ OPERATION ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ CON TAIN S _ OPERATION " / simpleenroll " ▁# define ▁US 3512_ PROXY _ CACERTS _ URL _ VALID ▁" http s ://127.0.0.1: 16894 / . well - known / est / " P ATH _ SEG _ VALID " / cacerts " ▁# define ▁US 3512_ PKCS 10_ REQ ▁" MIICh jCCA W 4 CAQAw QT El MC MGA 1 UEAxM c cmV x IGJ 5 IGN saWV u dCB pbiB kZ W 1 v IHN 0\ n ZXAg Mj EY MBYG A 1 UEB RM P U El E Old pZG dl dCB T T joy MIIBIjANBgkq hk iG 9 w 0 BAQEF \ n AAOCAQ 8 AMIIBCgKCAQEA /6 JU Wp X XD wC kv WP DWO 0 y AND Qz FM x ro LE Ih 6/ vd Nw fR SG \ neN GC 0 ef c L 5 L 4 N xH ZO mO 14 yq MEM Gp Cy Hz 7 Ob 3 hh N Pu 0 K 8 1 g MU z Rq z w mm JH Xw Rq ob A \ ni 5 9 OQ Ek Ha P hI 1 T 4 Rk V nSY Z LO owS q on MZ jW bT 0 i qZ DY / RD 8 l 3 Gj H 3 gE IBMQ Fv 62 NT \ n 1 CS u 9 df HE g 7 6+ Dn JA h d ddU DJ D XO 3 A WI 5 s 7 zs Ll zB oP lg d 4 oK 5 K 1 wqE E 2 pq h nZ xe i \ nc 94 W Fq XQ 1 ky rW 0 P OV lQ + 32 mo W T QT FA 7 SQ E 2 uE F + GB X s RP a EO + FL Qj E 8 J HO ewL f / T \ nq X 0 ng yw nv x KR pK gu SBi c 31 WV ks wP s 8 E 34 pjj ZA vd x QIDAQABo AAwDQYJKoZIhvcN \ n AQEFBQADggEBA A ZX Vo orR xA v QP i MN DpR ZHh iD 5 O 2 Y d 7 APB Bz n V gR ll 1 H ML 5 dp gnu \ n XY 7 ZC Y wQ tx w NG YV tK Ja ZC i W 7 dWr Zh v nF 5 u a 3 wU r 9 R 2 Z No Lw VR 0 Z 9 Y 5 ww n 1 cJ rd SG \ nc Uu BN / 0 XB GI 6 g 6 f Ql DDI mQ oP SF 8 gy gc TC CH ba 7 Uv 0 i 8 oi Ci wf 5 UF + F 3 NY BoB L / PP \ n lO 2 zB EY NQ 65 + W 3 Yg fU yY P 0 C r 0 N yX g kz 3 Q h 2 Xa 2 e RFe W 56 oe jm c EaM jq 6 yx 7 WA C 2 X \ nk 3 w 1 G 6 Le 1 UI nz uen MS c N g nt 8 Fa I 43 e AIL M d LQ / Ek xc 30 f j xA 12 RD h / Yz DY i Ex Fv 0\ ndP d 4 o 5 u PK t 4 jR it vG i AP m / O CdX i YA wq i u 2 w =\ n " ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ); ▁static ▁void ▁us 3512_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 3512_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ; ▁rv ▁= ▁st _ start _ no cacerts ( US 3512_ SERVER _ PORT , ▁US 3512_ SERVER _ CERTKEY , ▁US 3512_ SERVER _ CERTKEY , ▁" US 3512 ▁test ▁realm ", ▁US 3512_ CACERTS , ▁US 3512_ TRUST _ CERTS , ▁" CA / est Example CA . cnf ", ▁manual _ enroll , ▁0, ▁nid ); ▁SL EEP (1); ▁/* ▁* ▁ Next ▁we ▁start ▁an ▁EST ▁proxy ▁ acting ▁as ▁an ▁RA . ▁*/ ▁rv ▁= ▁st _ proxy _ start _ no cacerts ( US 3512_ TCP _ PROXY _ PORT , ▁US 3512_ PROXY _ CERT , ▁US 3512_ PROXY _ KEY , ▁" estrealm ", ▁US 3512_ CACERT , ▁US 3512_ TRUST _ CERTS , ▁" estuser ", ▁" estpwd ", ▁"127.0.0.1", ▁US 3512_ SERVER _ PORT , ▁0, ▁// ▁disable ▁PoP ▁0); ▁// ▁ ecdhe ▁nid ▁info ▁SL EEP (1); ▁return ▁rv ; ▁} ▁static ▁int ▁path _ seg _ supported ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁rc ▁= ▁est _ client _ set _ server ( ectx , ▁US 3512_ SERVER _ IP , ▁US 3512_ SERVER _ PORT , ▁" test _ segment "); ▁if ▁( rc ▁== ▁EST _ ERR _ NONE ) ▁{ ▁return ▁1; ▁} ▁else ▁{ ▁return ▁0; ▁} ▁return ▁0; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁* ▁1 . ▁Generate ▁the ▁ keypair ▁to ▁be ▁used ▁for ▁this ▁EST ▁Client ▁ UT ▁suite ▁*/ ▁static ▁int ▁us 3512_ init _ suite ▁( void ) ▁{ ▁int ▁rv ▁= ▁0; ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁char ▁cmd [ EST _ UT _ MAX _ CMD _ LEN ] ; ▁ printf (" Start ing ▁EST ▁Server ▁path ▁segment ▁ unit ▁tests . \ n "); ▁if ▁(! path _ segment _ support ) ▁{ ▁ printf ( ▁" URI ▁ Path ▁ Segment ▁is ▁not ▁supported ▁in ▁this ▁build ▁of ▁EST . ▁Re build ▁using ▁-- with - uriparser - dir ▁\ n "); ▁return ▁0; ▁} ▁/* ▁* ▁gen ▁the ▁ keypair ▁to ▁be ▁used ▁for ▁EST ▁Client ▁testing ▁*/ ▁ snprintf ( cmd , ▁EST _ UT _ MAX _ CMD _ LEN , ▁" openssl ▁ec param ▁- name ▁prime 256 v 1 ▁- gen key ▁- out ▁% s ", ▁CLIENT _ UT _ PUBKEY ); ▁ printf ("% s \ n ", ▁cmd ); ▁rv ▁= ▁system ( cmd ); ▁/* ▁* ▁start ▁the ▁server ▁for ▁the ▁tests ▁that ▁need ▁to ▁t alk ▁to ▁a ▁server ▁*/ ▁us 3512_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁*/ ▁rv ▁= ▁us 3512_ start _ server (0, ▁0); ▁SL EEP ( 2 ); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁ resources ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 3512_ destroy _ suite ▁( void ) ▁{ ▁st _ stop (); ▁st _ proxy _ stop (); ▁return ▁0; ▁} ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* ▁bio _ err ; ▁bio _ err ▁= ▁BIO _ new _ fp ( stderr , ▁BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁ Print ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ( ▁"% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error )); ▁ printf (" Fail ing ▁Cert :\ n "); ▁X 509_ print _ fp ( stdout , ▁cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁an ticipat ed ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁== ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁ Sanity ▁check ▁of ▁the ▁server ▁side ▁path ▁segment ▁processing . ▁* ▁- ▁simple ▁enroll ▁* ▁- ▁direct ▁to ▁server ▁* ▁- ▁with ▁path ▁segment ▁* ▁ Out come : ▁pass ▁*/ ▁static ▁void ▁us 3512_ test 1 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁rv ▁= ▁curl _ http _ post ( US 3512_ ENROLL _ URL _ BA _ NO SEGMENT , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ RSA 2048, ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁== ▁200 ); ▁} ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf ("\ nError ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁/* ▁* ▁This ▁function ▁perform s ▁a ▁basic ▁simple ▁enroll ▁using ▁* ▁a ▁UID / PWD ▁to ▁identify ▁the ▁client ▁to ▁the ▁server . ▁This ▁* ▁is ▁used ▁for ▁a ▁variet y ▁of ▁test ▁cases ▁in ▁this ▁ module . ▁*/ ▁static ▁void ▁us 3512_ simple _ enroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv , ▁char ▁* path _ segment ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3512_ UID , ▁US 3512_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 3512_ SERVER _ PORT , ▁path _ segment ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁expected _ enroll _ rv ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁expected _ enroll _ rv ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁taken ▁from ▁US 899/ test 1 ▁* ▁Simple ▁enroll ▁- ▁includ ing ▁a ▁path ▁segment ▁in ▁the ▁uri . ▁* ▁* ▁ Path ▁ Segment ▁testing ▁* ▁- ▁This ▁verifie s ▁the ▁client ▁include s ▁a ▁configured ▁* ▁path ▁segment ▁properly ▁and ▁send s ▁it . ▁* ▁- ▁This ▁verifie s ▁that ▁the ▁server ▁correctly ▁parse s ▁out ▁* ▁a ▁valid ▁path ▁segment ▁and ▁passes ▁it ▁up ▁on ▁a ▁simple ▁enroll . ▁* ▁*/ ▁static ▁void ▁us 3512_ test 2 ▁( void ) ▁{ ▁LOG _ FUNC _ NM ▁ ; ▁char ▁* path _ segment ▁= ▁" path _ segment "; ▁memset ( tst _ srv r _ path _ seg _ auth , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁memset ( tst _ srv r _ path _ seg _ enroll , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁us 3512_ simple _ enroll (" TC 3512 - 2 ", ▁US 3512_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁path _ segment ); ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ auth ) ▁== ▁0); ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ enroll ) ▁== ▁0); ▁} ▁/* ▁* ▁taken ▁from ▁US 898/ test 1 ▁* ▁Simple ▁re - enroll ▁- ▁includ ing ▁a ▁path ▁segment ▁in ▁the ▁uri . ▁* ▁* ▁ Path ▁ Segment ▁testing ▁* ▁- ▁Verifi es ▁the ▁client ▁include s ▁a ▁configured ▁* ▁path ▁segment ▁* ▁- ▁Verifi es ▁that ▁the ▁server ▁correctly ▁parse s ▁out ▁* ▁a ▁valid ▁path ▁segment ▁and ▁passes ▁it ▁up ▁on ▁a ▁simple ▁re - enroll ▁* ▁as ▁ well ▁as ▁the ▁auth ▁callback . ▁*/ ▁static ▁void ▁us 3512_ test 3 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 ▁= ▁NULL ; ▁BIO ▁* b 64, ▁* out ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁STA CK _ OF ( X 509 ) ▁* ▁certs ▁= ▁NULL ; ▁int ▁i ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁char ▁* path _ segment ▁= ▁" path _ seg _ us 3512_ test 3 "; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3512_ UID , ▁US 3512_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 3512_ SERVER _ IP , ▁US 3512_ SERVER _ PORT , ▁path _ segment ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Get ▁the ▁la test ▁CSR ▁attributes ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁" TC - US 898-1 ", ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁return ; ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁/* ▁* ▁Convert ▁the ▁cert ▁to ▁an ▁X 509 . ▁Be ▁warn ed ▁this ▁is ▁* ▁pure ▁hack ery . ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁out ▁= ▁BIO _ new _ mem _ buf ( new _ cert , ▁pkcs 7_ len ); ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁p 7 ▁= ▁d 2 i _ PKCS 7_ bio ( out , ▁NULL ); ▁CU _ ASSERT ( p 7 ▁ != ▁NULL ); ▁BIO _ free _ all ( out ); ▁i ▁= ▁OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( i ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁certs ▁= ▁p 7-> d . sign -> cert ; ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁certs ▁= ▁p 7-> d . signed _ and _ e nveloped -> cert ; ▁break ; ▁default : ▁break ; ▁} ▁CU _ ASSERT ( certs ▁ != ▁NULL ); ▁if ▁(! certs ) ▁return ; ▁/* ▁our ▁new ▁cert ▁should ▁be ▁the ▁one ▁and ▁only ▁* ▁cert ▁in ▁the ▁pkcs 7 ▁blob . ▁We ▁should n ' t ▁have ▁to ▁* ▁iterate ▁through ▁the ▁full ▁list ▁to ▁find ▁it . ▁*/ ▁cert ▁= ▁sk _ X 509_ value ( certs , ▁0); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁/* ▁* ▁W ow , ▁that ' s ▁a ▁lo t ▁of ▁work , ▁but ▁we ▁finally ▁have ▁the ▁X 509 . ▁* ▁( d on ' t ▁you ▁just ▁lo ve ▁OpenSSL !!! ) ▁* ▁ Now ▁that ▁we ▁have ▁an ▁X 509 ▁representation ▁of ▁the ▁cert , ▁* ▁let ' s ▁try ▁to ▁re - enroll ▁this ▁cert ▁with ▁the ▁CA ▁*/ ▁memset ( tst _ srv r _ path _ seg _ auth , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁memset ( tst _ srv r _ path _ seg _ enroll , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ auth ) ▁== ▁0); ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ enroll ) ▁== ▁0); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( cert ) ▁X 509_ free ( cert ); ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁taken ▁from ▁US 897/ test 11 ▁* ▁CA certs ▁to ▁the ▁server ▁- ▁includ ing ▁a ▁path ▁segment ▁in ▁the ▁uri . ▁* ▁* ▁ Path ▁ Segment ▁testing ▁* ▁- ▁Verifi es ▁the ▁client ▁include s ▁a ▁configured ▁* ▁path ▁segment ▁* ▁- ▁Verifi es ▁that ▁the ▁server ▁correctly ▁parse s ▁out ▁* ▁a ▁valid ▁path ▁segment ▁and ▁passes ▁it ▁up ▁on ▁the ▁CA ▁certs ▁callback . ▁*/ ▁static ▁void ▁us 3512_ test 4 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁E VP _ PKEY ▁* ▁priv _ key ; ▁char ▁* path _ segment ▁= ▁" path _ seg _ us 3512_ test 4 "; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 3512_ SERVER _ IP , ▁US 3512_ SERVER _ PORT , ▁path _ segment ); ▁/* ▁* ▁clear ▁out ▁the ▁global ▁that ▁proves ▁that ▁the ▁path ▁segment ▁* ▁made ▁it ▁to ▁the ▁application ▁layer ' s ▁cal ▁back ▁function ▁*/ ▁memset ( tst _ srv r _ path _ seg _ cacerts , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁/* ▁* ▁verify ▁that ▁the ▁path ▁segment ▁made ▁it ▁all ▁the ▁way ▁to ▁the ▁callback ▁function ▁* ▁at ▁the ▁application ▁layer ▁*/ ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ cacerts ) ▁== ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁* ▁taken ▁from ▁US 898/ test 1 ▁* ▁CSR Attribute s ▁- ▁includ ing ▁a ▁path ▁segment ▁in ▁the ▁uri . ▁* ▁* ▁ Path ▁ Segment ▁testing ▁* ▁- ▁Verifi es ▁the ▁client ▁include s ▁a ▁configured ▁* ▁path ▁segment ▁* ▁- ▁Verifi es ▁that ▁the ▁server ▁correctly ▁parse s ▁out ▁* ▁a ▁valid ▁path ▁segment ▁and ▁passes ▁it ▁up ▁on ▁a ▁csr ▁attributes ▁callback ▁*/ ▁static ▁void ▁us 3512_ test 5 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁int ▁rv ; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁un signed ▁char ▁* attr _ data ▁= ▁NULL ; ▁int ▁attr _ len ; ▁char ▁* path _ segment ▁= ▁" path _ seg _ us 3512_ test 5 "; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁LOG _ FUNC _ NM ▁ ; ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁Set ▁the ▁authentication ▁mode ▁to ▁use ▁a ▁user ▁id / password ▁*/ ▁rv ▁= ▁est _ client _ set _ auth ( ectx , ▁US 3512_ UID , ▁US 3512_ PWD , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁US 3512_ SERVER _ IP , ▁US 3512_ SERVER _ PORT , ▁path _ segment ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁clear ▁out ▁the ▁global ▁that ▁proves ▁that ▁the ▁path ▁segment ▁* ▁made ▁it ▁to ▁the ▁application ▁layer ' s ▁cal ▁back ▁function ▁*/ ▁memset ( tst _ srv r _ path _ seg _ csrattrs , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rv ▁= ▁est _ client _ get _ csrattrs ( ectx , ▁& attr _ data , ▁& attr _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁verify ▁that ▁the ▁path ▁segment ▁made ▁it ▁all ▁the ▁way ▁to ▁the ▁callback ▁function ▁* ▁at ▁the ▁application ▁layer ▁*/ ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ csrattrs ) ▁== ▁0); ▁/* ▁* ▁Cleanup ▁*/ ▁if ▁( cert ) ▁X 509_ free ( cert ); ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁/* ▁* ▁Test ▁the ▁flow ▁of ▁path ▁segments ▁through ▁proxy ▁mode ▁- ▁valid ▁path ▁segment ▁* ▁ SimpleEnroll ▁*/ ▁static ▁void ▁us 3512_ test 6 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁memset ( tst _ srv r _ path _ seg _ enroll , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ VALID , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( strcmp ( P ATH _ SEG _ VALID , ▁ tst _ srv r _ path _ seg _ enroll ) ▁== ▁0); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁== ▁200 ); ▁} ▁/* ▁* ▁Test ▁the ▁flow ▁of ▁path ▁segments ▁through ▁proxy ▁mode ▁- ▁* ▁path ▁segment ▁is ▁set ▁to ▁the ▁maximum ▁size ▁* ▁*/ ▁static ▁void ▁us 3512_ test 7 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ MAX , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁path ▁segment ▁that ▁is ▁too ▁long , ▁it ▁* ▁should ▁get ▁caught ▁at ▁the ▁proxy ▁and ▁a ▁400 ▁should ▁be ▁returned ▁*/ ▁CU _ ASSERT ( rv ▁== ▁200 ); ▁} ▁/* ▁* ▁Test ▁the ▁flow ▁of ▁path ▁segments ▁through ▁proxy ▁mode ▁- ▁* ▁path ▁segment ▁that ▁is ▁too ▁large ▁* ▁*/ ▁static ▁void ▁us 3512_ test 8 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ TOO _ LONG , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁path ▁segment ▁that ▁is ▁too ▁long , ▁it ▁* ▁should ▁get ▁caught ▁at ▁the ▁proxy ▁and ▁a ▁400 ▁should ▁be ▁returned ▁*/ ▁CU _ ASSERT ( rv ▁== ▁400 ); ▁} ▁/* ▁* ▁Test ▁segment ▁that ▁is ▁an ▁operation ▁path ▁* ▁*/ ▁static ▁void ▁us 3512_ test 9 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ IS _ OPERATION , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁path ▁segment ▁that ▁equals ▁an ▁operation ▁we ▁* ▁should ▁get ▁a ▁400 ▁in ▁return ▁*/ ▁CU _ ASSERT ( rv ▁== ▁400 ); ▁} ▁/* ▁* ▁Test ▁segment ▁that ▁is ▁an ▁operation ▁path ▁* ▁*/ ▁static ▁void ▁us 3512_ test 10 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ TOO _ MANY , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁path ▁segment ▁that ▁equals ▁an ▁operation ▁we ▁* ▁should ▁get ▁a ▁400 ▁in ▁return ▁*/ ▁CU _ ASSERT ( rv ▁== ▁400 ); ▁} ▁/* ▁* ▁Test ▁segment ▁that ▁contains ▁a ▁valid ▁operation ▁string ▁within ▁it , ▁* ▁in ▁this ▁case , ▁at ▁the ▁front . ▁This ▁is ▁a ▁valid ▁path ▁segment , ▁so ▁* ▁the ▁test ▁should ▁pass . ▁* ▁*/ ▁static ▁void ▁us 3512_ test 11 ▁( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ▁ ; ▁SL EEP (1); ▁memset ( tst _ srv r _ path _ seg _ enroll , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁memset ( tst _ proxy _ path _ seg _ auth , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁rv ▁= ▁curl _ http _ post ( US 3512_ PROXY _ ENROLL _ URL _ CON TAIN S _ OPERATION , ▁US 3512_ PKCS 10_ CT , ▁US 3512_ PKCS 10_ REQ , ▁US 3512_ UIDPWD _ GOOD , ▁US 3512_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁CU _ ASSERT ( ▁strcmp ( P ATH _ SEG _ CON TAIN S _ OPERATION , ▁ tst _ srv r _ path _ seg _ enroll ) ▁== ▁0); ▁CU _ ASSERT ( ▁strcmp ( P ATH _ SEG _ CON TAIN S _ OPERATION , ▁ tst _ proxy _ path _ seg _ auth ) ▁== ▁0); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁path ▁segment ▁that ▁equals ▁an ▁operation ▁we ▁* ▁should ▁get ▁a ▁400 ▁in ▁return ▁*/ ▁CU _ ASSERT ( rv ▁== ▁200 ); ▁} ▁/* ▁* ▁taken ▁from ▁US 897/ test 11 ▁* ▁CA certs ▁to ▁the ▁server ▁- ▁includ ing ▁a ▁path ▁segment ▁in ▁the ▁uri . ▁* ▁* ▁ Path ▁ Segment ▁testing ▁* ▁- ▁Verifi es ▁the ▁client ▁include s ▁a ▁configured ▁* ▁path ▁segment ▁* ▁- ▁Verifi es ▁that ▁the ▁server ▁correctly ▁parse s ▁out ▁* ▁a ▁valid ▁path ▁segment ▁and ▁passes ▁it ▁up ▁on ▁the ▁CA ▁certs ▁callback . ▁*/ ▁static ▁void ▁us 3512_ test 12 ▁( void ) ▁{ ▁EST _ CTX ▁* ectx ; ▁un signed ▁char ▁* pkey ▁= ▁NULL ; ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁int ▁cacerts _ len ▁= ▁0; ▁EST _ ERROR ▁rc ▁= ▁EST _ ERR _ NONE ; ▁un signed ▁char ▁* retrieved _ cacerts ▁= ▁NULL ; ▁int ▁retrieved _ cacerts _ len ▁= ▁0; ▁E VP _ PKEY ▁* ▁priv _ key ; ▁char ▁* path _ segment ▁= ▁" path _ seg _ us 3512_ test 4 "; ▁SL EEP (1); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( CLIENT _ UT _ CACERT , ▁& cacerts ); ▁CU _ ASSERT ( cacerts _ len ▁> ▁0); ▁/* ▁* ▁ Read ▁in ▁the ▁private ▁key ▁file ▁*/ ▁priv _ key ▁= ▁read _ private _ key ( CLIENT _ UT _ PUBKEY ); ▁if ▁( priv _ key ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁while ▁reading ▁private ▁key ▁file ▁% s \ n ", ▁CLIENT _ UT _ PUBKEY ); ▁return ; ▁} ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁rc ▁= ▁est _ client _ set _ auth ( ectx , ▁"", ▁"", ▁NULL , ▁priv _ key ); ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁est _ client _ set _ server ( ectx , ▁US 3512_ SERVER _ IP , ▁US 3512_ TCP _ PROXY _ PORT , ▁path _ segment ); ▁/* ▁* ▁clear ▁out ▁the ▁global ▁that ▁proves ▁that ▁the ▁path ▁segment ▁* ▁made ▁it ▁to ▁the ▁application ▁layer ' s ▁cal ▁back ▁function ▁*/ ▁memset ( tst _ srv r _ path _ seg _ cacerts , ▁0, ▁EST _ MAX _ P ATH _ SEGMENT _ LEN ▁+ ▁1); ▁/* ▁* ▁issue ▁the ▁get ▁ca ▁certs ▁request ▁*/ ▁rc ▁= ▁est _ client _ get _ cacerts ( ectx , ▁& retrieved _ cacerts _ len ); ▁/* ▁* ▁should ▁be ▁successful , ▁and ▁should ▁have ▁obtained ▁a ▁valid ▁buffer ▁* ▁containing ▁the ▁CA ▁certs ▁*/ ▁CU _ ASSERT ( rc ▁== ▁EST _ ERR _ NONE ); ▁CU _ ASSERT ( retrieved _ cacerts _ len ▁> ▁0); ▁/* ▁* ▁verify ▁that ▁the ▁path ▁segment ▁made ▁it ▁all ▁the ▁way ▁to ▁the ▁callback ▁function ▁* ▁at ▁the ▁application ▁layer ▁*/ ▁CU _ ASSERT ( strcmp ( path _ segment , ▁ tst _ srv r _ path _ seg _ cacerts ) ▁== ▁0); ▁retrieved _ cacerts ▁= ▁malloc ( retrieved _ cacerts _ len ); ▁rc ▁= ▁est _ client _ copy _ cacerts ( ectx , ▁retrieved _ cacerts ); ▁/* ▁* ▁output ▁the ▁retrieved ▁ca ▁certs ▁and ▁compare ▁to ▁what ▁they ▁should ▁be ▁*/ ▁if ▁( retrieved _ cacerts ) ▁{ ▁ printf ("\ nR etrieved ▁CA ▁Certs ▁buffer :\ n ▁% s \ n ", ▁retrieved _ cacerts ); ▁ printf (" Retrieve d ▁CA ▁certs ▁buffer ▁length : ▁% d \ n ", ▁retrieved _ cacerts _ len ); ▁} ▁free ( retrieved _ cacerts ); ▁if ▁( ectx ) ▁{ ▁est _ destroy ( ectx ); ▁} ▁if ▁( cacerts ) ▁{ ▁free ( cacerts ); ▁} ▁if ▁( pkey ) ▁{ ▁free ( pkey ); ▁} ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 3512_ add _ suite ▁( void ) ▁{ ▁CU _ ErrorCode ▁CU _ error ; ▁# if def ▁HAV E _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 3512_ server _ path _ seg ", ▁us 3512_ init _ suite , ▁us 3512_ destroy _ suite ); ▁if ▁( NULL ▁== ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁* ▁check ▁to ▁see ▁if ▁path ▁segment ▁support ▁has ▁been ▁compile d ▁in ▁*/ ▁if ▁(! path _ seg _ supported ()) ▁{ ▁ printf (" URI ▁ Path ▁ Segment ▁is ▁not ▁supported ▁in ▁this ▁build ▁of ▁EST . ▁Re build ▁using ▁-- with - uriparser - dir = ▁\ n "); ▁path _ segment _ support ▁= ▁0; ▁return ▁0; ▁} ▁path _ segment _ support ▁= ▁1; ▁if ▁( path _ segment _ support ) ▁{ ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁/* ▁NOTE ▁- ▁OR DER ▁IS ▁ IMPORTANT ▁- ▁MUST ▁TEST ▁f read () ▁ AFTER ▁f printf () ▁*/ ▁if ▁( ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Client : ▁Simple ▁enroll ▁with ▁no ▁path ▁segment ", ▁us 3512_ test 1)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁Simple ▁Enroll ▁with ▁path ▁segment ", ▁us 3512_ test 2)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁Simple ▁Re - enroll ▁with ▁path ▁segment ", ▁us 3512_ test 3)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁CACerts ▁with ▁path ▁segment ", ▁us 3512_ test 4)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁CSR At tr s ▁with ▁path ▁segment ", ▁us 3512_ test 5)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ", ▁us 3512_ test 6)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁at ▁the ▁max ", ▁us 3512_ test 7)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁too ▁long ", ▁us 3512_ test 8)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁that ▁is ▁operation ", ▁us 3512_ test 9)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁containing ▁too ▁many ▁segments ", ▁us 3512_ test 10)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁containing ▁an ▁operation ", ▁us 3512_ test 11)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" EST ▁Server : ▁EST ▁ Proxy ▁with ▁path ▁segment ▁valid ▁and ▁cacerts ", ▁us 3512_ test 12)) ▁ ) ▁{ ▁CU _ error ▁= ▁CU _ get _ error (); ▁ printf ("% d \ n ", ▁CU _ error ); ▁CU _ cleanup _ registry (); ▁ printf ("% s \ n ", ▁CU _ get _ error _ msg ()); ▁return ▁CU _ get _ error (); ▁} ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}