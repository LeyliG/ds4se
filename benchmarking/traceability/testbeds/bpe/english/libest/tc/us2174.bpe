▁/* ---------------- -- ---------------- ---------------- ---------------- ▁* ▁us 2174 . c ▁- ▁Unit ▁Test s ▁for ▁User ▁S tory ▁ 2174 ▁- ▁ Proxy ▁simple ▁enroll ▁* ▁* ▁August , ▁2013 ▁* ▁* ▁Copy right ▁( c ) ▁2013 , ▁2016 ▁by ▁ cisco ▁System s , ▁Inc . ▁* ▁All ▁rights ▁ reserved . ▁* -- ---------------- ---------------- ---------------- ---------------- ▁*/ ▁# include ▁< s td io . h > ▁# if ndef ▁WI N 32 ▁# include ▁< uni s td . h > ▁# endif ▁# include ▁< est . h > ▁# include ▁< curl / curl . h > ▁# include ▁" curl _ util s . h " ▁# include ▁" test _ util s . h " ▁# include ▁" st _ server . h " ▁# include ▁" st _ proxy . h " ▁# include ▁< openssl / ssl . h > ▁# if def ▁HAV E _ C UNIT ▁# include ▁" CUnit / Basic . h " ▁# include ▁" CUnit / A utomat ed . h " ▁# endif ▁static ▁un signed ▁char ▁* cacerts ▁= ▁NULL ; ▁static ▁int ▁cacerts _ len ▁= ▁0; ▁# define ▁US 2174_ RETRY _ INTERVAL ▁3600 ▁// # define ▁US 2174_ TCP _ PORT ▁ 29001 ▁# define ▁US 2174_ TCP _ SERVER _ PORT ▁5 2174 ▁# define ▁US 2174_ TCP _ PROXY _ PORT ▁6 2174 ▁# if ndef ▁WI N 32 ▁# define ▁US 2174_ SERVER _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁# define ▁US 2174_ SERVER _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁/* ▁# define ▁US 2174_ PROXY _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁*/ ▁/* ▁# define ▁US 2174_ PROXY _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁*/ ▁# define ▁US 2174_ PROXY _ CERT ▁" US 2174/ cert . pem " ▁# define ▁US 2174_ PROXY _ KEY ▁" US 2174/ key . pem " ▁# define ▁US 2174_ CACERT ▁" CA / estCA / cacert . crt " ▁# define ▁US 2174_ CACERTS ▁" CA / estCA / cacert . crt " ▁# define ▁US 2174_ TRUSTED _ CERTS ▁" CA / trustedcerts . crt " ▁# define ▁US 2174_ EXPLICIT _ CERT ▁" US 2174/ cert - RA . pem " ▁# define ▁US 2174_ EXPLICIT _ KEY ▁" US 2174/ key - RA . pem " ▁# else ▁# define ▁US 2174_ SERVER _ CERT ▁" CA \\ estCA \\ private \\ estserver cert and key . pem " ▁# define ▁US 2174_ SERVER _ KEY ▁" CA \\ estCA \\ private / estserver cert and key . pem " ▁/* ▁# define ▁US 2174_ PROXY _ CERT ▁" CA / estCA / private / estserver cert and key . pem " ▁*/ ▁/* ▁# define ▁US 2174_ PROXY _ KEY ▁" CA / estCA / private / estserver cert and key . pem " ▁*/ ▁# define ▁US 2174_ PROXY _ CERT ▁" US 2174\\ cert . pem " ▁# define ▁US 2174_ PROXY _ KEY ▁" US 2174\\ key . pem " ▁# define ▁US 2174_ CACERT ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 2174_ CACERTS ▁" CA \\ estCA \\ cacert . crt " ▁# define ▁US 2174_ TRUSTED _ CERTS ▁" CA \\ trustedcerts . crt " ▁# define ▁US 2174_ EXPLICIT _ CERT ▁" US 2174\\ cert - RA . pem " ▁# define ▁US 2174_ EXPLICIT _ KEY ▁" US 2174\\ key - RA . pem " ▁# endif ▁# define ▁US 2174_ SERVER _ IP ▁"127.0.0.1" ▁# define ▁US 2174_ TCP _ PORT ▁US 2174_ TCP _ SERVER _ PORT ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁rsa . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁rsa : 2048 ▁- key out ▁rsa key . pem ▁- key form ▁PEM ▁- out ▁rsa . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 2174_ PKCS 10_ RSA 2048 ▁" MIIC v TCCAa U CAQAw e DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE j AQ BgNVBAoMC VJ TQW Nl cn Rj bz EM MA oGA 1 UEC wwD cnN h MR AwDgYDV QQD \ nDA dy c 2 EgZG 9 lMR o wGA YJKoZIhvcNAQkBFg ty c 2 FA ZG 9 lL m Nvb T CCASIwDQYJKoZI \ n hvcNAQEBBQADgg EPADCCAQoCggEBA N 6 pC TB rK 7 T 0 29 Bg a nq 0 QH XH y NL 8 op v xc 7 JY \ n Xa Qz 39 R 3 J 9 BoB E 72 XZ 0 QX sB tU EY GNh HOL a IS ASN zs 2 ZK Wp vM HJ W mP YN t 39 OC i 48 Y \ n FO gL Db An 83 mA OK S fc ML bi bC cs h 4 HO l haa F rWs kRT A sew 16 MU Oz Fu 6 vB kw / A hI 82 J \ nK PY ws 0 dY Ox uW FI gE 1 HL + m / gpl bz q 7 Fr B Id rq k NL + dd gy Xo Dd 5 Nu LM JG DAK 7 vB 1 Ww \ n 9/ B aw /6 Ai 9 V 5 psy e 1 v 8 fW Dr 6 HW 2 gg 9 X n VtM wB 4 pC g 1 rl 1 l SY stum T GY bM 6 c xJ yw e \ nL uM nD jj 1 Zw D sZ 1 wI Xa BA XZa x EIS / rX OX 0 H nZ MT ef xY / gp Fk 1 Kv 0 CAwEAAa AAMA 0 G \ n CS qGS Ib 3 DQEBBQUA A 4 IBAQB 6 r Iw Nj E 8 l 8 jF KR 1 hQ / q eS ve e / bAQ a 58 Ru fZ 4 US Ku K \ nl s ih 7 UC f 8 b kQ vg lj nh sc Qu cz Ibn Jz eq EP qS d no mF W 6 Cv Mc / ah + Qf X 87 F GY xJ gp wF \ nut nU if j Di Zh rW gf / jN Nb tH rke cw / Z ex 4 sZ / HC 127 j tE 3 c yE kD srA 1 oB xYR Cq 93 tC \ nW 2 q 9 PL Vm Ll yjc Z cS 1 KH VD 2 ny a 79 kfS 0 YG Mo cs w 1 G elV L 2 iz / oca yA S 5 GB 9 Y 2 s EB w \ nR kC aY Zw 6 v hj 5 qj pC U zJ 3 E 8 Cl 3 VD 4 Kp i 3 j 3 bZGD JA 9 md md 8 j 5 Zy PY 56 e Au xa rWs sD \ nc i UM / h 6 E 99 w 3 tm r UZ b Ll jk jJ 7 pBX Rn ont gm 5 WZ mQ FH 4 X " ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁ec . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁ec : 256 parms ▁- key out ▁eckey . pem ▁- key form ▁PEM ▁- out ▁ec . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 2174_ PKCS 10_ DSA 1024 ▁" MIIC f jCCA j 0 CAQAw f DEL MAkG A 1 UEB h MCV VM x CzA J BgNVBA g MAk 5 DM Qw wC gYDVQQ H \ nDANSVFAxE zA R BgNVBAoMC kRTQ U Nvb X Bhb nk xD zA N BgNVBA s MB kRTQ W 9 yZzE Q MA 4 G \ nA 1 UEAww H ZHNh IGRv ZT EaM Bg GCS qGS Ib 3 DQEJ ARY L ZHNh Q GRvZ S 5 j b 20 wgg G 2 MIIB \ nK w YHKoZIzjgEA TCCA R 4 CgYEA q If by k 7 r E AaU L IP B 1 G c HH c 0 ctx 6 g 0 dh Bf dU d OP NG \ nB SE + TP 5 UF 5 lw 8 Qm 6 o CX s tU 3 nY EJ al mMv k jF wb g vB ws 8 a JBn j 09 dD Dn 8 s pK EG cG 0 M \ nZ p qd My s 6+ b 4 QJ jq 5 Y AxE a ATV Y / 1 L / rBg GG m 1 EF Dhc /6 E zm 2 T 3 CG e Qk lw o 5 a BZQ C c \ n a I s C FQD C 1 ol BF uE + p h Ohj X AwE E 5 EP Jk RJ w KBgD + vZ + t L CT j Bz VF Nj A O 8 X / SM am wW \ no ra N f dyZ + ZC EA mYI / D 4 838 n C GA jVR Qy Db 1 q 5 a kk L yx o JX 1 YV 7 g Nba BN U y s 3 w a qd u \ nso 1 Ht uE ur 2 cb h U 5 i O eKB Wp j 6 MI Wl P dD 3 uC Ru 4 ui BF 9 XB iAN a R ID 8 CT 2 k c hh w y 4 Ok \ nF f QM uY Oz 4 e BhM Qq mA 4 GE AA KBgD u wR 7 H 3 U 4 C fu Qj We T tr I 50 M 1 T x hlV Z 3 To n RtV Ix \ n EH pu X xA ou x ATV k th J ta CBK c 0 EH i i 1 bE / kg NU g G X / Zd Fj BU b / X fp k Y s RT 3 Q R LF 0 + s \ n PZ GY / 0 T ov O 9 pK jq i w 0 C 10 le N KF bE V dl XY t Ak j X Ub H my No g 31 95/ t 7 oK XH MT 1 A / 5 p \ n hUC R oAAw CQ YHKoZIzjgEA w Mw ADA t Ah U Ah PCq QG 3 gK UU PK d wB NC mZ f z WD qj sCF Ah 0\ nz n 9 H uj lXN a TA 1 Ohj mP m cJ SxT " ▁/* ▁* ▁The ▁following ▁CSR ▁was ▁generated ▁using ▁the ▁following ▁openssl ▁command ▁and ▁then ▁* ▁using ▁cat ▁on ▁the ▁dsa . req ▁file : ▁* ▁* ▁openssl ▁req ▁- new key ▁dsa : dsa parms ▁- key out ▁dsa key . pem ▁- key form ▁PEM ▁- out ▁dsa . req ▁- out form ▁PEM ▁*/ ▁# define ▁US 2174_ PKCS 10_ ECDSA 256 ▁" MIIB MTC B 2 gIBADB 4 MQswCQYDVQQGEwJ VU zE L MAkG A 1 UECAw CT kM xD DAK BgNVBA cM \ nA 1 JU U DES MB AGA 1 UECgw JR UND b 21 wYW 5 5 MQ 4 wDAYDVQQLDAVFQ 29 yZzE P MA 0 GA 1 UE \ n AwwG R UM gZG 9 l MRkwFwY JKoZIhvcNAQkBFg p lY 0 Bkb 2 U uY 29 t MF kwE wYHKoZIzj 0 C \ nAQ YI KoZIzj 0 DAQ c DQ gA EO 1 us z CK dXN Fz yg NL N eS 8 a zQ Ko d 15 16 GT 9 qd D dd t 9 i JN 4 \ nL pBT nv +7 K 7+ t ji 5 kt s 1 kW SY yv qL xv nq 8 Q / TU 1 i QJ 56 AA MAkG By qGS M 49 BA E DR wAw \ nR AIg P 6 qd a +0 TE KZ F Pop gU fwF MRs xc N mu QU e 2 y uz 1 6460 / SQ CI Bf Lv mu Me yY Oq b bD \ nX 0 If de 9 y zk RO VB CE P vK 0 h cU 5 KsT O " ▁# define ▁US 2174_ PKCS 10_ CORRUPT ▁" MIIB MTC B 2 gIBADB 4 MQswCQYDVQQGEwJ VU zE L MAkG A 1 UECAw CT kM xD DAK BgNVBA cM \ nA 1 JU U DES MB AGA 1 UECgw JR UND b 21 wYW 5 5 MQ 4 wDAYDVQQLDAVFQ 39 yZzE P MA 0 GA 1 UE \ n AwwG R UM gZG 9 l MRkwFwY JKoZIhvcNAQkBFg p lY 0 Bkb 2 U uY 29 t MF kwE wYHKoZIzj 0 C \ nAQ YI KoZIzj 0 DAQ c DQ gA EO 1 us z CK dXN Fz yg NL N eS 8 a zQ Ko d 15 16 GT 9 qd D dd t 9 i JN 4 \ nL pBT nv +7 K 7+ t ji 5 kt s 1 kW SY yv qL xv nq 8 Q / TU 1 i QJ 56 AA MAkG By qGS M 49 BA E DR wAw \ nR AIg P 6 qd a +0 TE KZ F Pop gU fwF MRs xc N mu QU e 2 y uz 1 6460 / SQ CI Bf Lv mu Me yY Oq b bD \ nX 0 If de 9 y zk RO VB CE P vK 0 h cU 5 KsT O " ▁/* ▁* ▁The ▁following ▁is ▁a ▁valid ▁CSR ▁that ▁already ▁contains ▁a ▁PoP ▁* ▁ c hallengePassword . ▁This ▁was ▁collect ed ▁using ▁ estserver ▁with ▁* ▁the ▁ dump b in () ▁function . ▁This ▁CSR ▁should ▁n ever ▁work ▁since ▁* ▁the ▁PoP ▁value ▁in ▁it ▁will ▁be ▁st a le . ▁*/ ▁# define ▁US 2174_ PKCS 10_ STA LE _ POP ▁" MIIB c j CB 3 A IBADA R MQ 8 wDQ YDVQQDE wZ URV NU Q 0 4 w g Z 8 wDQYJKoZI hvcNAQEBBQAD \ n gY 0 A MIG JAoGBA P D Hv rk VB 3 + r FH l + Ku I s r ZG i xld RY RD 50 S 2 vF s 8 mW 5 w WV xD S 3 x FR \ nz c K t q g 7 JU yW 8 NY OF NW X 0 oz h Ce 87 XP 2 h 7 t Up Hy H lL /8 N /8 4 zuM tAt KT LU 3 Bjg q 1 x g \ n u u 8 a 1 ht 10 w i y 8 u 2 r / uE K MhQ w pv t 56 U Y 5 p H zu q m ql O 0 ql m E + M 58 WN 49 Ih AgMBAAGg \ n IjA g Bgkq hk iG 9 w 0 BCQcxE xYR Uj dGN 1 ZUN Uw yd 2 Vu eW tM c A ow DQYJKoZIhvcNAQEF \ n BQADgYEA yen rs km fR IX c p eKB v L 3 V nW 5 N 4 Hc LT wI 9 Hc br 74 4 S W FQ aw / R + ru + U X d 2 j \ n 99 AG Br / Gv Tk T g hI NW g 2 C 7 v z GF / z h Iu G 6 Ok 9 F ti M n N r 9 hZ +5 SL Y h f S FJ b u I v 65 r WH \ nv f LR 9 N 9 M 2 Q 9 j l f 7 p 4 AY fW XD 2 qD 2 X OT Zw 2 t 4 tr G ZG K A 2 JR / O iB 40 =" ▁# define ▁US 2174_ ENROLL _ URL _ BA ▁" http s ://127.0.0.1: 62 17 5 / . well - known / est / simpleenroll " ▁# define ▁US 2174_ PKCS 10_ CT ▁" Content - Type : ▁application / pkcs 10" ▁# define ▁US 2174_ UIDPWD _ GOOD ▁" estuser : estpwd " ▁static ▁E VP _ PKEY ▁* ▁generate _ private _ key ▁( void ) ▁{ ▁RSA ▁* rsa ▁= ▁RSA _ new (); ▁B IG NUM ▁* bn ▁= ▁BN _ new (); ▁E VP _ PKEY ▁* pkey ; ▁/* ▁* ▁create ▁an ▁RSA ▁ keypair ▁and ▁assign ▁them ▁to ▁a ▁ PKEY ▁and ▁return ▁it . ▁*/ ▁BN _ set _ word ( bn , ▁0 x 1000 1); ▁RSA _ generate _ key _ ex ( rsa , ▁1024 , ▁bn , ▁NULL ); ▁pkey ▁= ▁E VP _ PKEY _ new (); ▁if ▁( pkey ▁== ▁NULL ) ▁{ ▁ printf ("\ nError ▁allocat ing ▁ PKEY ▁structure ▁for ▁new ▁key ▁pair \ n "); ▁return ▁NULL ; ▁} ▁if ▁(! E VP _ PKEY _ set 1 _ RSA ( pkey , ▁rsa )) ▁{ ▁ printf ("\ nError ▁assign ing ▁RSA ▁key ▁pair ▁to ▁ PKEY ▁structure \ n "); ▁return ▁NULL ; ▁} ▁RSA _ free ( rsa ); ▁BN _ free ( bn ); ▁return ▁( pkey ); ▁} ▁# define ▁GOOD _ TOKEN ▁" WW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 s b GVy IEkg a GVhc iB 5 b 3 U =" ▁# define ▁ DI FFER ENT _ TOKEN ▁" V 2 V s bC w g S S d 2 ZSB nb 3 Q g dG 8 gc nVuIH R v IG tl ZXAg Z nJvbSB o a WRpbicNCkFuZCBJJ 20 gYm 91 b mQ g dG 8 g a 2 Vl c CBvb i By a WRpbicNCkFuZCBJJ 3 Zl IGdv d CBvb mU g b W 9 y ZSB zaW x 2 ZXIgZ G 9 s b GFy DQ p CdX Q gSSdtIG 5 v dCB nb 2 5 u YSB s ZXQg J 2 V t IGN hdG No IG 1 lLCB u b w 0 KT m 90 IGdv bm 5 hIG xld CA n ZW 0 gY 2 F 0 Y 2 g gdGhlIG 1 pZG 5 pZ 2 h 0 IHJpZ GVy " ▁# define ▁NULL _ TOKEN ▁NULL ; ▁# define ▁ LONG _ TOKEN ▁" S S Bj YW 4 n dCB hZ 3 Jl ZSB 0 byB ka X N hZ 3 Jl ZSANCk Zp Z 2 h 0 aW 5 nIG x p a 2 U gSSdtIG Zp Z 2 h 0 aW 5 n IGZvciB s aW ZlI A 0 KV G h le S dyZSB vb mx 5 I H d v cm Rz IGJ 1 dCB 0 aGV 5 IGN 1 dCB sa WtlIG E gYmxh ZG UgDQp T d 2 lu Z 2 lu Zy B 3 aWRlIH dp dG gg YWxs IG 9 m IG 15 IG 1 pZ 2 h 0 IA 0 KDQp B aCB 5 ZWFoLCB J IG d 1 ZXN zIG l 0 J 3 M g YWxs IG 9 m IHRo YXQg Y 29 mZ mVl LCB 0 aGF 0 J 3 M g Z 29 0 IG 15 IG 1 pb mQ g aW 4 g YSB 3 a G ly bC ANCkknbSBzdG l sbCB j dXN zaW 5 nIG Fu ZCB ia X Rj a GluZyB hbmQg d GhlcmUgY Wl uJ 3 Q g bm 9 i b 2 R 5 IGhlcmUg DQ o NC k 9 o I H l lYW g s IHlvdS Bkb 24 n d C BoYX Zl IHRv IG h vb G x l c i BJIGh lY XI geW 91 IA 0 KSSdtI HN 0 YW 5 ka W 5 n IHJpZ 2 h 0 I GhlcmUgY m V zaW Rl IHlvdS A NC k 9 oL CA 5 O SBza GF kZ XMg b 2 Y gY 3 JhenksI Ek nb S A 5 O SBza GF kZ XMg b 2 Y gY 3 JhenkgDQp D c mF 6 eSwg Y 3 JhenksI GN yY Xp 5 LCB jc mF 6 eSANC g 0 K U G 91 c i Bhb m 90 a GVy IGR yaW 5 r LCB t Y WtlIG l 0 IG EgZG 91 Y mx l IGZvciB t ZSANCk 1 h eW Jl IEkg Y 2 Fu IGR yaW 5 r IHRoaXMg YX dh eSANCk l 0 J 3 M g bm V 2 ZXIgZ nVuIH d oZW 4 g dG h l eSB w d W x s IG 91 dCB 0 aGUg Z 3 Vu IA 0 KQ mVh dCB 5 b 3 U gYmxh Y 2 s g YW 5 k IGJ s d W U s IGJ v eSANC ll vd S B nb 3 R 0 YSBwYXk sIHlvdSB nb 3 R 0 YSBwYXk gDQoNCk 9 oLCB 3 aGVyZSB 0 aGUg aGV sbCB h b S B J P y BJIGh v cG U g YXQg b GVhc 3 Q g S S B oYW Q g Z n Vu IA 0 KSSdtI HN 0 d W 1 i b GluZyB 0 a H JvdW do I E 5 ld y BP c mx lYW 5 zIG 9 oLCB 0 byB 0 aGUgc ml zaW 5 n IHN 1 b iAN Cg 0 KT 2 g geW V h aCwg eW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 s b GVy IEkg a GVhc iB 5 b 3 UgDQp JJ 20 gc 3 Rhb m R pbmcg cm ln aHQ g aGVyZSB i ZXN pZG U geW 91 IA 0 KT 2 g s ID k 5 IHN oYW Rl cyB vZ iB jc mF 6 eSwg S S d t ID k 5 IHN oYW Rl cyB vZ iB jc mF 6 eSANCk N yY Xp 5 LCB jc mF 6 eSwg Y 3 JhenksI GN yY Xp 5 IA 0 KDQp Mb 3 Jk IGhhdmUg b WV yY 3 kgb 24 g b W UgDQp Ob 3 Zl b nR hIG 5 1 ZXZ h IHRv bm 9 zIG R lIG xv Y 2 8 gDQoNCk kgb mVl ZCB z b 21 l I HB lY WNlLCB q dXN 0 IHN vb W U g cmV saWV m IA 0 KR nJvbSB 0 aGlzIH Z va WNlLCB ra W x s aW 5 nIG 1 l IA 0 K WW 91 IHN 0 YXJ l IGF 0 IG 1 lLCB hbmQg eW 91 IG d s YXJ l IGF 0 IG 1 l IA 0 KQ W x s IHRoaXMg c GF pbiB pdC d z IGF sbCB 0 aGUgc 2 F tZS w g a XQ nc y BhbGwg aW 5 zYW 5 l IA 0 K KH lv d S Bz ZW Up IA 0 KDQp J cyB 0 aGlzIH Jl YWxs eS BoYX Bw ZW 5 pbmcg b 3 I gZG lkIEkg b W Fr ZSB pdC BhbGwg d X A / IA 0 KSSdtI G JvdW 5 k IGZvciB D aGF 0 d GF ob 29 j aGV lIG 9 u IG E g d HV y b ml wI H R yd WN r IA 0 KDQp P aCB 5 ZWFoLCB 5 b 3 U gZG 9 uJ 3 Q g aGF 2 ZSB 0 byB ob 2 x s ZX Ig S S B oZW F y IHlvdS ANCkknbSBzdG Fu Z GluZyB yaW do dCB o Z XJlIG Jl c 2 lkZSB 5 b 3 UgDQp P aCwg OTk gc 2 hh ZGV zIG 9 m IGN yY Xp 5 LCB JJ 20 g OTk gc 2 hh ZGV zIG 9 m IGN yY Xp 5 IA 0 KQ 3 JhenksI GN yY Xp 5 LCB jc mF 6 eSwg Y 3 J h e nk gDQoNCk F o IHlvdS dyZSB jc mF 6 eSB 5 b 3 U nc mU gY 3 JhenkgDQp Ib 2 x k IG 15 IGZlZXQ s IGZlZXQ g dG 8 gdGhlIG Zp cm UgDQp Z b 3 U gaG 9 s ZCB t eSB mZ WV 0 IHRv IHRo ZSB m a X Jl IA 0 K S S Bu ZXZ l c iB zYW lkIEkg d 2 Fz IGRv d 24 g d 2 l 0 aCB 5 b 3 U =" ▁static ▁char ▁* test _ token ▁= ▁" WW 91 IGRv bid 0 IGhhdmUg dG 8 gaG 9 s b GVy IEkg a GVhc iB 5 b 3 U =" ; ▁static ▁int ▁auth _ cred _ callback _ called ▁= ▁0; ▁static ▁int ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁auth _ credentials _ token _ cb () ▁is ▁the ▁application ▁layer ▁callback ▁function ▁that ▁will ▁* ▁return ▁a ▁token ▁based ▁authentication ▁credential ▁when ▁called . ▁It ' s ▁registered ▁* ▁with ▁the ▁EST ▁Client ▁using ▁the ▁est _ client _ set _ auth _ cred _ cb (). ▁* ▁The ▁test ▁function ▁is ▁required ▁to ▁set ▁some ▁global ▁values ▁in ▁order ▁to ▁make ▁this ▁* ▁callback ▁operate ▁the ▁way ▁that ▁the ▁test ▁case ▁wants . ▁* ▁- ▁auth _ cred _ force _ error ▁= ▁tell ▁this ▁function ▁to ▁force ▁a ▁response ▁code ▁error ▁* ▁- ▁test _ token ▁= ▁pointer ▁to ▁a ▁hard ▁code d ▁string ▁that ▁is ▁the ▁token ▁string ▁to ▁return ▁* ▁* ▁This ▁callback ▁must ▁provide ▁the ▁token ▁credentials ▁in ▁a ▁heap ▁based ▁buffer , ▁and ▁* ▁own ers h ip ▁of ▁that ▁buffer ▁is ▁implicitly ▁transferred ▁to ▁the ▁E T ▁client ▁library ▁upon ▁* ▁return . ▁*/ ▁static ▁EST _ HTTP _ AUTH _ CRE D _ RC ▁auth _ credentials _ token _ cb ▁( ▁EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁char ▁* token _ ptr ▁= ▁NULL ; ▁int ▁token _ len ▁= ▁0; ▁CU _ ASSERT ( auth _ credentials -> mode ▁== ▁AUTH _ TOKEN ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁== ▁AUTH _ TOKEN ) ▁{ ▁/* ▁* ▁If ▁the ▁test _ token ▁is ▁set ▁to ▁anything , ▁then ▁we ▁need ▁to ▁allocate ▁* ▁space ▁from ▁the ▁heap ▁and ▁copy ▁in ▁the ▁value . ▁*/ ▁if ▁( test _ token ▁ != ▁NULL ) ▁{ ▁token _ len ▁= ▁str len ( test _ token ); ▁/* ▁use ▁str len () ▁so ▁that ▁the ▁string ▁can ▁be ▁as ▁large ▁as ▁needed ▁to ▁test ▁the ▁EST ▁client ▁*/ ▁if ▁( token _ len ▁== ▁0) ▁{ ▁ printf ( ▁"\ nError ▁de ter min ing ▁length ▁of ▁token ▁string ▁used ▁for ▁credentials \ n "); ▁return ▁EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ; ▁} ▁token _ ptr ▁= ▁malloc ( token _ len ▁+ ▁1); ▁if ▁( token _ ptr ▁== ▁NULL ) ▁{ ▁ printf ( ▁"\ nError ▁allocat ing ▁token ▁string ▁used ▁for ▁credentials \ n "); ▁return ▁EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ; ▁} ▁strncpy ( token _ ptr , ▁test _ token , ▁str len ( test _ token )); ▁token _ ptr [ token _ len ] ▁= ▁'\0'; ▁} ▁/* ▁* ▁If ▁we ▁made ▁it ▁this ▁far , ▁token _ ptr ▁is ▁point ing ▁to ▁a ▁string ▁* ▁containing ▁the ▁token ▁to ▁be ▁returned . ▁Assign ▁it ▁and ▁return ▁success ▁*/ ▁auth _ credentials -> auth _ token ▁= ▁token _ ptr ; ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁/* ▁* ▁auth _ credentials _ basic _ cb () ▁is ▁the ▁same ▁as ▁the ▁token ▁based ▁one ▁above , ▁but ▁* ▁instead ▁return s ▁the ▁basic ▁credentials ▁of ▁userid ▁and ▁password ▁*/ ▁static ▁EST _ HTTP _ AUTH _ CRE D _ RC ▁auth _ credentials _ basic _ cb ▁( ▁EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁CU _ ASSERT ( auth _ credentials -> mode ▁== ▁AUTH _ BASIC ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁== ▁AUTH _ BASIC ) ▁{ ▁auth _ credentials -> user ▁= ▁malloc ( sizeof (" estuser ")); ▁strncpy ( auth _ credentials -> user , ▁" estuser ", ▁sizeof (" estuser ")); ▁auth _ credentials -> pwd ▁= ▁malloc ( sizeof (" estpwd ")); ▁strncpy ( auth _ credentials -> pwd , ▁" estpwd ", ▁sizeof (" estpwd ")); ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁# if ▁0 ▁/* ▁* ▁auth _ credentials _ digest _ cb () ▁is ▁the ▁same ▁as ▁the ▁basic ▁based ▁one ▁above , ▁but ▁* ▁instead ▁ ver f ies ▁that ▁the ▁auth _ mode ▁passed ▁is ▁digest ▁*/ ▁static ▁EST _ HTTP _ AUTH _ CRE D _ RC ▁auth _ credentials _ digest _ cb ( EST _ HTTP _ AUTH _ HDR ▁* auth _ credentials ) ▁{ ▁CU _ ASSERT ( auth _ credentials -> mode ▁== ▁AUTH _ DIGEST ); ▁/* ▁* ▁report ▁that ▁the ▁callback ▁has ▁been ▁called . ▁*/ ▁auth _ cred _ callback _ called ▁= ▁1; ▁/* ▁* ▁Se e ▁if ▁the ▁test ▁is ▁requesting ▁to ▁force ▁an ▁error ▁response ▁code ▁from ▁the ▁* ▁callback ▁*/ ▁if ▁( auth _ cred _ force _ error ) ▁{ ▁return ( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁if ▁( auth _ credentials -> mode ▁== ▁AUTH _ DIGEST ) ▁{ ▁auth _ credentials -> user ▁= ▁malloc ( sizeof (" estuser ")); ▁strncpy ( auth _ credentials -> user , ▁" estuser ", ▁sizeof (" estuser ")); ▁auth _ credentials -> pwd ▁= ▁malloc ( sizeof (" estpwd ")); ▁strncpy ( auth _ credentials -> pwd , ▁" estpwd ", ▁sizeof (" estpwd ")); ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ SUCCESS ); ▁} ▁return ▁( EST _ HTTP _ AUTH _ CRE D _ NOT _ AVAILABLE ); ▁} ▁# endif ▁/* ▁* ▁C allback ▁function ▁passed ▁to ▁est _ client _ init () ▁*/ ▁static ▁int ▁client _ manual _ cert _ verify ▁( X 509 ▁* cur _ cert , ▁int ▁openssl _ cert _ error ) ▁{ ▁BIO ▁* ▁bio _ err ; ▁bio _ err ▁= ▁BIO _ new _ fp ( stderr , ▁BIO _ NO CLOSE ); ▁int ▁approve ▁= ▁0; ▁/* ▁* ▁ Print ▁out ▁the ▁specific s ▁of ▁this ▁cert ▁*/ ▁ printf ( ▁"% s : ▁OpenSSL / EST ▁server ▁cert ▁verification ▁failed ▁with ▁the ▁following ▁error : ▁openssl _ cert _ error ▁= ▁% d ▁(% s ) \ n ", ▁ _ _ FUNCTION _ _ , ▁openssl _ cert _ error , ▁X 509_ verify _ cert _ error _ string ( openssl _ cert _ error )); ▁ printf (" Fail ing ▁Cert :\ n "); ▁X 509_ print _ fp ( stdout , ▁cur _ cert ); ▁/* ▁* ▁ Next ▁call ▁print s ▁out ▁the ▁signature ▁which ▁can ▁be ▁used ▁as ▁the ▁fingerprint ▁* ▁This ▁fingerprint ▁can ▁be ▁checked ▁against ▁the ▁an ticipat ed ▁value ▁to ▁determine ▁* ▁whether ▁or ▁not ▁the ▁server ' s ▁cert ▁should ▁be ▁approved . ▁*/ ▁X 509_ signature _ print ( bio _ err , ▁cur _ cert -> sig _ alg , ▁cur _ cert -> signature ); ▁if ▁( openssl _ cert _ error ▁== ▁X 509_ V _ ERR _ U NABLE _ TO _ GET _ CRL ) ▁{ ▁approve ▁= ▁1; ▁} ▁BIO _ free ( bio _ err ); ▁return ▁approve ; ▁} ▁/* ▁* ▁us 2174_ simple _ enroll () ▁is ▁used ▁by ▁test ▁cases ▁to ▁perform ▁a ▁simple ▁enroll . ▁*/ ▁static ▁void ▁us 2174_ simple _ enroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁EST _ ERROR ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁EST _ ERROR ▁e _ rc ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁callback ); ▁CU _ ASSERT ( e _ rc ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 2174_ TCP _ PROXY _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁expected _ enroll _ rv ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁static ▁void ▁us 2174_ simple _ reenroll ▁( char ▁* cn , ▁char ▁* server , ▁EST _ ERROR ▁expected _ enroll _ rv , ▁auth _ credentials _ cb ▁callback ) ▁{ ▁EST _ CTX ▁* ectx ; ▁E VP _ PKEY ▁* key ; ▁EST _ ERROR ▁rv ; ▁int ▁pkcs 7_ len ▁= ▁0; ▁un signed ▁char ▁* new _ cert ▁= ▁NULL ; ▁PKCS 7 ▁* p 7 ▁= ▁NULL ; ▁BIO ▁* b 64, ▁* out ; ▁X 509 ▁* cert ▁= ▁NULL ; ▁STA CK _ OF ( X 509 ) ▁* ▁certs ▁= ▁NULL ; ▁int ▁i ; ▁EST _ ERROR ▁e _ rc ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁callback ); ▁CU _ ASSERT ( e _ rc ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 2174_ TCP _ PROXY _ PORT , ▁NULL ); ▁/* ▁* ▁generate ▁a ▁private ▁key ▁*/ ▁key ▁= ▁generate _ private _ key (); ▁CU _ ASSERT ( key ▁ != ▁NULL ); ▁/* ▁* ▁Use ▁the ▁simplifie d ▁API ▁to ▁enroll ▁a ▁CSR ▁*/ ▁rv ▁= ▁est _ client _ enroll ( ectx , ▁cn , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Retrieve ▁the ▁cert ▁that ▁was ▁given ▁to ▁us ▁by ▁the ▁EST ▁server ▁*/ ▁if ▁( rv ▁== ▁EST _ ERR _ NONE ) ▁{ ▁new _ cert ▁= ▁malloc ( pkcs 7_ len ); ▁CU _ ASSERT ( new _ cert ▁ != ▁NULL ); ▁rv ▁= ▁est _ client _ copy _ enrolled _ cert ( ectx , ▁new _ cert ); ▁CU _ ASSERT ( rv ▁== ▁EST _ ERR _ NONE ); ▁} ▁est _ destroy ( ectx ); ▁ectx ▁= ▁NULL ; ▁/* ▁* ▁Create ▁a ▁client ▁context ▁*/ ▁ectx ▁= ▁est _ client _ init ( cacerts , ▁cacerts _ len , ▁EST _ CERT _ FORMAT _ PEM , ▁client _ manual _ cert _ verify ); ▁CU _ ASSERT ( ectx ▁ != ▁NULL ); ▁/* ▁* ▁ Now ▁that ▁we ▁have ▁the ▁cert , ▁switch ▁the ▁server ▁over ▁to ▁token ▁mode ▁*/ ▁st _ enable _ http _ token _ auth (); ▁e _ rc ▁= ▁est _ client _ set _ auth _ cred _ cb ( ectx , ▁callback ); ▁CU _ ASSERT ( e _ rc ▁== ▁EST _ ERR _ NONE ); ▁/* ▁* ▁Set ▁the ▁EST ▁server ▁address / port ▁*/ ▁est _ client _ set _ server ( ectx , ▁server , ▁US 2174_ TCP _ PORT , ▁NULL ); ▁/* ▁* ▁ And ▁attempt ▁a ▁reenroll ▁while ▁in ▁token ▁mode ▁* ▁* ▁Convert ▁the ▁cert ▁to ▁an ▁X 509 . ▁Be ▁warn ed ▁this ▁is ▁* ▁pure ▁hack ery . ▁* ▁PDB : ▁This ▁conversion ▁code ▁come s ▁from ▁other ▁test ▁cases . ▁*/ ▁b 64 ▁= ▁BIO _ new ( BIO _ f _ base 64 ()); ▁out ▁= ▁BIO _ new _ mem _ buf ( new _ cert , ▁pkcs 7_ len ); ▁out ▁= ▁BIO _ push ( b 64, ▁out ); ▁p 7 ▁= ▁d 2 i _ PKCS 7_ bio ( out , ▁NULL ); ▁CU _ ASSERT ( p 7 ▁ != ▁NULL ); ▁BIO _ free _ all ( out ); ▁i ▁= ▁OBJ _ obj 2 nid ( p 7-> type ); ▁switch ▁( i ) ▁{ ▁case ▁NID _ pkcs 7_ signed : ▁certs ▁= ▁p 7-> d . sign -> cert ; ▁break ; ▁case ▁NID _ pkcs 7_ signed And Enveloped : ▁certs ▁= ▁p 7-> d . signed _ and _ e nveloped -> cert ; ▁break ; ▁default : ▁break ; ▁} ▁CU _ ASSERT ( certs ▁ != ▁NULL ); ▁if ▁(! certs ) ▁return ; ▁/* ▁our ▁new ▁cert ▁should ▁be ▁the ▁one ▁and ▁only ▁* ▁cert ▁in ▁the ▁pkcs 7 ▁blob . ▁We ▁should n ' t ▁have ▁to ▁* ▁iterate ▁through ▁the ▁full ▁list ▁to ▁find ▁it . ▁*/ ▁cert ▁= ▁sk _ X 509_ value ( certs , ▁0); ▁CU _ ASSERT ( cert ▁ != ▁NULL ); ▁/* ▁* ▁PDB ▁NOTE : ▁At ▁the ▁moment , ▁this ▁is ▁expected ▁to ▁fail ▁since ▁* ▁the ▁server ▁does ▁not ▁yet ▁understand ▁requests ▁with ▁token ▁authentication . ▁* ▁On ce ▁188 4 ▁is ▁complete , ▁the ▁below ▁ ASSERT ▁will ▁begin ▁to ▁fail ▁and ▁will ▁need ▁* ▁to ▁be ▁changed ▁to ▁a ▁pass ing ▁response . ▁*/ ▁rv ▁= ▁est _ client _ reenroll ( ectx , ▁cert , ▁& pkcs 7_ len , ▁key ); ▁CU _ ASSERT ( rv ▁== ▁expected _ enroll _ rv ); ▁/* ▁* ▁Cleanup ▁*/ ▁E VP _ PKEY _ free ( key ); ▁if ▁( new _ cert ) ▁free ( new _ cert ); ▁est _ destroy ( ectx ); ▁} ▁static ▁void ▁us 2174_ clean ▁( void ) ▁{ ▁} ▁static ▁int ▁us 2174_ start _ server ▁( int ▁manual _ enroll , ▁int ▁nid ) ▁{ ▁int ▁rv ▁= ▁0; ▁/* ▁* ▁First ▁we ▁start ▁an ▁EST ▁server ▁ acting ▁as ▁the ▁CA ▁*/ ▁rv ▁= ▁st _ start ( US 2174_ TCP _ SERVER _ PORT , ▁US 2174_ SERVER _ CERT , ▁US 2174_ SERVER _ KEY , ▁" estrealm ", ▁US 2174_ CACERT , ▁US 2174_ TRUSTED _ CERTS , ▁" US 2174/ est Example CA . cnf ", ▁manual _ enroll , ▁// ▁manual ▁enroll ▁0, ▁// ▁disable ▁PoP ▁nid ); ▁// ▁ ecdhe ▁nid ▁info ▁SL EEP (1); ▁if ▁( rv ▁ != ▁EST _ ERR _ NONE ) ▁return ▁rv ; ▁/* ▁* ▁ Next ▁we ▁start ▁an ▁EST ▁proxy ▁ acting ▁as ▁an ▁RA ▁with ▁the ▁server ▁side ▁* ▁operat ing ▁in ▁token ▁auth ▁mode . ▁*/ ▁rv ▁= ▁st _ proxy _ start _ token ( US 2174_ TCP _ PROXY _ PORT , ▁US 2174_ PROXY _ CERT , ▁US 2174_ PROXY _ KEY , ▁" estrealm ", ▁US 2174_ CACERT , ▁US 2174_ TRUSTED _ CERTS , ▁" estuser ", ▁" estpwd ", ▁"127.0.0.1", ▁US 2174_ TCP _ SERVER _ PORT , ▁0); ▁// ▁disable ▁PoP ▁SL EEP (1); ▁return ▁rv ; ▁} ▁void ▁us 2174_ stop _ server ▁( ) ▁{ ▁st _ stop (); ▁st _ proxy _ stop (); ▁SL EEP ( 2 ); ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁initialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁allocate ▁data ▁or ▁open ▁any ▁* ▁ resources ▁required ▁for ▁all ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 2174_ init _ suite ▁( void ) ▁{ ▁int ▁rv ; ▁est _ init _ logger ( EST _ LOG _ L VL _ INFO , ▁NULL ); ▁/* ▁* ▁ Read ▁in ▁the ▁CA ▁certificates ▁*/ ▁cacerts _ len ▁= ▁read _ binary _ file ( US 2174_ CACERTS , ▁& cacerts ); ▁if ▁( cacerts _ len ▁< = ▁0) ▁{ ▁return ▁1; ▁} ▁us 2174_ clean (); ▁/* ▁* ▁Start ▁an ▁instance ▁of ▁the ▁EST ▁server ▁with ▁* ▁automatic ▁enrollment ▁enabled . ▁*/ ▁rv ▁= ▁us 2174_ start _ server (0, ▁0); ▁return ▁rv ; ▁} ▁/* ▁* ▁This ▁routine ▁is ▁called ▁when ▁ CUnit ▁uninitialize s ▁this ▁test ▁* ▁suite . ▁This ▁can ▁be ▁used ▁to ▁de allocate ▁data ▁or ▁close ▁any ▁* ▁ resources ▁that ▁we re ▁used ▁for ▁the ▁test ▁cases . ▁*/ ▁static ▁int ▁us 2174_ destroy _ suite ▁( void ) ▁{ ▁us 2174_ stop _ server (); ▁free ( cacerts ); ▁return ▁0; ▁} ▁# if ▁0 ▁/* ▁* ▁Simple ▁enroll ▁- ▁* ▁proxy ▁- ▁BASIC ▁* ▁server ▁- ▁BASIC ▁* ▁* ▁Make ▁sure ▁token ▁auth ▁mode ▁did ▁not ▁break ▁anything . ▁* ▁*/ ▁static ▁void ▁us 2174_ test 1 ( void ) ▁{ ▁long ▁rv ; ▁LOG _ FUNC _ NM ; ▁rv ▁= ▁curl _ http _ post ( US 2174_ ENROLL _ URL _ BA , ▁US 2174_ PKCS 10_ CT , ▁US 2174_ PKCS 10_ RSA 2048, ▁US 2174_ UIDPWD _ GOOD , ▁US 2174_ CACERTS , ▁CURL AUTH _ BASIC , ▁NULL , ▁NULL , ▁NULL ); ▁/* ▁* ▁S ince ▁we ▁passed ▁in ▁a ▁valid ▁user ID / password , ▁* ▁we ▁expect ▁the ▁server ▁to ▁respond ▁with ▁200 ▁*/ ▁CU _ ASSERT ( rv ▁== ▁200 ); ▁} ▁# endif ▁/* ▁* ▁Simple ▁enroll ▁- ▁* ▁proxy ▁- ▁TOKEN ▁* ▁server ▁- ▁TOKEN ▁* ▁*/ ▁static ▁void ▁us 2174_ test 2 ▁( void ) ▁{ ▁LOG _ FUNC _ NM ▁ ; ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁set ▁server ▁to ▁do ▁token ▁auth ▁challenges ▁* ▁tell ▁the ▁server ▁which ▁token s ▁to ▁accept ▁*/ ▁st _ enable _ http _ token _ auth (); ▁st _ set _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁set ▁the ▁proxy ▁to ▁do ▁token ▁auth ▁challenges ▁and ▁* ▁tell ▁it ▁what ▁token s ▁to ▁accept . ▁*/ ▁st _ proxy _ enable _ http _ token _ auth (); ▁st _ proxy _ set _ srv _ valid _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁tell ▁the ▁client ▁side ▁of ▁proxy ▁which ▁token ▁credential ▁to ▁* ▁use ▁*/ ▁st _ proxy _ set _ cl nt _ token _ cred ( GOOD _ TOKEN ); ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Enroll ▁should ▁succeed . ▁*/ ▁us 2174_ simple _ enroll (" TC 2174 - 4", ▁US 2174_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁== ▁1); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁* ▁proxy ▁- ▁TOKEN ▁* ▁server ▁- ▁BASIC ▁*/ ▁static ▁void ▁us 2174_ test 3 ▁( void ) ▁{ ▁LOG _ FUNC _ NM ▁ ; ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁set ▁server ▁to ▁do ▁BASIC ▁auth ▁challenges ▁*/ ▁st _ enable _ http _ basic _ auth (); ▁/* ▁* ▁set ▁the ▁proxy ▁to ▁do ▁token ▁auth ▁challenges ▁and ▁* ▁tell ▁it ▁what ▁token s ▁to ▁accept . ▁*/ ▁st _ proxy _ enable _ http _ token _ auth (); ▁st _ proxy _ set _ srv _ valid _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁tell ▁the ▁client ▁side ▁of ▁proxy ▁which ▁token ▁credential ▁to ▁* ▁use ▁*/ ▁st _ proxy _ set _ cl nt _ token _ cred ( GOOD _ TOKEN ); ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Enroll ▁should ▁succeed . ▁*/ ▁us 2174_ simple _ enroll (" TC 2174 - 4", ▁US 2174_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁== ▁1); ▁} ▁/* ▁* ▁Simple ▁enroll ▁- ▁* ▁proxy ▁- ▁BASIC ▁* ▁server ▁- ▁TOKEN ▁*/ ▁static ▁void ▁us 2174_ test 4 ▁( void ) ▁{ ▁LOG _ FUNC _ NM ▁ ; ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁set ▁server ▁to ▁do ▁token ▁auth ▁challenges ▁* ▁tell ▁the ▁server ▁which ▁token s ▁to ▁accept ▁*/ ▁st _ enable _ http _ token _ auth (); ▁st _ set _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁set ▁the ▁proxy ▁to ▁do ▁BASIC ▁auth ▁challenges ▁and ▁* ▁tell ▁it ▁what ▁token s ▁to ▁accept . ▁*/ ▁st _ proxy _ enable _ http _ basic _ auth (); ▁/* ▁st _ proxy _ set _ srv _ valid _ token ( GOOD _ TOKEN ); ▁*/ ▁/* ▁* ▁tell ▁the ▁client ▁side ▁of ▁proxy ▁which ▁token ▁credential ▁to ▁* ▁use ▁*/ ▁st _ proxy _ set _ cl nt _ token _ cred ( GOOD _ TOKEN ); ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁enroll . ▁* ▁* ▁Enroll ▁should ▁succeed . ▁*/ ▁us 2174_ simple _ enroll (" TC 2174 - 4", ▁US 2174_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ basic _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁== ▁1); ▁} ▁/* ▁* ▁Simple ▁RE - enroll ▁- ▁* ▁proxy ▁- ▁TOKEN ▁* ▁server ▁- ▁TOKEN ▁* ▁*/ ▁static ▁void ▁us 2174_ test 5 ▁( void ) ▁{ ▁LOG _ FUNC _ NM ▁ ; ▁auth _ cred _ callback _ called ▁= ▁0; ▁auth _ cred _ force _ error ▁= ▁0; ▁/* ▁* ▁set ▁server ▁to ▁do ▁token ▁auth ▁challenges ▁* ▁tell ▁the ▁server ▁which ▁token s ▁to ▁accept ▁*/ ▁st _ enable _ http _ token _ auth (); ▁st _ set _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁set ▁the ▁proxy ▁to ▁do ▁token ▁auth ▁challenges ▁and ▁* ▁tell ▁it ▁what ▁token s ▁to ▁accept . ▁*/ ▁st _ proxy _ enable _ http _ token _ auth (); ▁st _ proxy _ set _ srv _ valid _ token ( GOOD _ TOKEN ); ▁/* ▁* ▁tell ▁the ▁client ▁side ▁of ▁proxy ▁which ▁token ▁credential ▁to ▁* ▁use ▁*/ ▁st _ proxy _ set _ cl nt _ token _ cred ( GOOD _ TOKEN ); ▁/* ▁* ▁Set ▁up ▁the ▁EST ▁Client ▁and ▁have ▁it ▁perform ▁a ▁simple ▁RE - enroll . ▁* ▁* ▁RE - enroll ▁should ▁succeed . ▁*/ ▁us 2174_ simple _ reenroll (" TC 2174 - 4", ▁US 2174_ SERVER _ IP , ▁EST _ ERR _ NONE , ▁auth _ credentials _ token _ cb ); ▁/* ▁* ▁callback ▁should ▁have ▁been ▁called ▁*/ ▁CU _ ASSERT ( auth _ cred _ callback _ called ▁== ▁1); ▁} ▁/* ▁The ▁main () ▁function ▁for ▁setting ▁up ▁and ▁running ▁the ▁tests . ▁* ▁Returns ▁a ▁CU E _ SUCCESS ▁on ▁successful ▁running , ▁another ▁* ▁ CUnit ▁error ▁code ▁on ▁failure . ▁*/ ▁int ▁us 2174_ add _ suite ▁( void ) ▁{ ▁# if def ▁HAV E _ C UNIT ▁CU _ pSuite ▁pSuite ▁= ▁NULL ; ▁/* ▁add ▁a ▁suite ▁to ▁the ▁ registry ▁*/ ▁pSuite ▁= ▁CU _ add _ suite (" us 2174_ token _ proxy ", ▁us 2174_ init _ suite , ▁us 2174_ destroy _ suite ); ▁if ▁( NULL ▁== ▁pSuite ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁/* ▁add ▁the ▁tests ▁to ▁the ▁suite ▁*/ ▁if ▁( / * ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Proxy ▁Enroll ▁basic ▁ sanity ▁test ", ▁us 2174_ test 1)) ▁|| ▁*/ ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Proxy ▁Enroll ▁token ▁auth , ▁both ▁proxy ▁and ▁server ", ▁us 2174_ test 2)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Proxy ▁Enroll ▁token ▁auth , ▁proxy ▁token / server ▁basic ", ▁us 2174_ test 3)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Proxy ▁Enroll ▁token ▁auth , ▁proxy ▁basic / server ▁token ", ▁us 2174_ test 4)) ▁|| ▁( NULL ▁== ▁CU _ add _ test ( pSuite , ▁" Proxy ▁RE - Enroll ▁token ▁auth , ▁proxy ▁basic / server ▁token ", ▁us 2174_ test 5)) ▁ ) ▁{ ▁CU _ cleanup _ registry (); ▁return ▁CU _ get _ error (); ▁} ▁return ▁CU E _ SUCCESS ; ▁# endif ▁}