code,docstring
"public void writeHeader(HollowBlobHeader header, DataOutputStream dos) throws IOException {
        /// save 4 bytes to indicate FastBlob version header.  This will be changed to indicate backwards incompatibility.
        dos.writeInt(HollowBlobHeader.HOLLOW_BLOB_VERSION_HEADER);

        /// Write randomized tag data -- every state gets a random 64-bit tag.
        /// When attempting to apply a delta, the originating state's random 64-bit tag is compared against the current 64-bit tag.
        /// This prevents deltas from being applied to incorrect states.
        dos.writeLong(header.getOriginRandomizedTag());
        dos.writeLong(header.getDestinationRandomizedTag());

        /// write the schemas contained in this blob to the stream in the pre v2.2.0 backwards compatibility envelope
        ByteArrayOutputStream schemasStream = new ByteArrayOutputStream();
        VarInt.writeVInt(schemasStream, header.getSchemas().size());
        for(HollowSchema schema : header.getSchemas())
            schema.writeTo(schemasStream);
        byte[] schemasData = schemasStream.toByteArray();
        
        VarInt.writeVInt(dos, schemasData.length + 1); // plus one byte for new backwards compatibility envelope.
        dos.write(schemasData);
        
        ///backwards compatibility -- new data can be added here by first indicating number of bytes used, will be skipped by existing readers.
        VarInt.writeVInt(dos, 0);

        /// write the header tags -- intended to include input source data versions
        dos.writeShort(header.getHeaderTags().size());

        for (Map.Entry<String, String> headerTag : header.getHeaderTags().entrySet()) {
            dos.writeUTF(headerTag.getKey());
            dos.writeUTF(headerTag.getValue());
        }
    }","Write the header to the data output stream
@param header the blob header
@param dos the data output stream to write the blov header
@throws IOException if the blob header could not be written"
"@Override
	public Map<K, V> get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
	{
		if (this.pending != null)
		{
			this.loaded.putAll(this.pending.get(timeout, unit));
			this.pending = null;
		}
		
		return this.loaded;
	}","/* (non-Javadoc)
@see java.util.concurrent.Future#get(long, java.util.concurrent.TimeUnit)"
"public void sourceLoadProgressNotification(int statusCode, int percentage) {
    Enumeration e = scalablePictureStatusListeners.elements();
    while (e.hasMoreElements()) {
      ((ScalablePictureListener) e.nextElement())
          .sourceLoadProgressNotification(statusCode, percentage);
    }

  }",pass on the update on the loading Progress to the listening objects
"public final List<File> getModelDirs() {
        if ((modelDirs == null) && (modelPath != null)) {
            modelDirs = paths().stream().filter(XtextParserConfig::isFile).map(XtextParserConfig::asFile).collect(Collectors.toList());
        }
        return modelDirs;
    }","Returns a list of model directories to parse.

@return Directory list or NULL."
"public static String encode(byte[] data) {
        Assert.isNotNull(data);

        StringBuffer buf = new StringBuffer();

        byte b = 0;
        int bits = 2;

        for (int i = 0; i < data.length; ++i) {
            b = (byte) ((b | (data[i] >> bits)) & 0x003f);
            buf.append(encode(b));
            b = (byte) ((data[i] << 6 - bits) & 0x003f);
            bits += 2;
            if (bits == 8) {
                buf.append(encode((byte) (b & 0x003f)));
                b = 0;
                bits = 2;
            }
        }

        if (bits == 4) {
            buf.append(encode(b));
            buf.append(""==""); //$NON-NLS-1$
        } else if (bits == 6) {
            buf.append(encode(b));
            buf.append('=');
        }

        return buf.toString();
    }","Returns the BASE64 encoded <code>String</code> of the given data.

@param data the bytes to be BASE64 encoded
@return     the BASE64 encoded <code>String</code> of the given data"
"void
    updateGroups(List<DapGroup> groups)
    {
        // Verify that the incoming groups are all and only in the list of groups.
        assert (groups.size() == this.groups.size()) : ""Update groups: not same size"";
        for(DapGroup g : groups) {
            if(!this.groups.contains(g))
                assert (false) : ""Update groups: attempt to add new group"";
        }
    }",We will need to re-order the groups
"public static void initXSSFAnchorsMap(final XSSFWorkbook wb,
            final ChartsData charsData) {

        Map<String, ClientAnchor> anchortMap = charsData
                .getChartAnchorsMap();
        Map<String, String> positionMap = charsData.getChartPositionMap();
        anchortMap.clear();
        positionMap.clear();
        for (int i = 0; i < wb.getNumberOfSheets(); i++) {
            initXSSFAnchorsMapForSheet(anchortMap, positionMap,
                    wb.getSheetAt(i));
        }
    }","retrieve anchor information from draw.xml for all the charts in the
workbook. then save them to anchors map.

@param wb
workbook.
@param charsData
the chars data"
"protected String getTableName() {
    if (!Strings.isNullOrEmpty(schema)) {
      if (caseSensitive) {
        return ""\"""" + schema + ""\""."" + ""\"""" + tableName + ""\"""";
      } else {
        return schema + ""."" + tableName;
      }
    }

    if (caseSensitive) {
      return ""\"""" + tableName + ""\"""";
    }

    return tableName;
  }","Table this writer will write to.
@return table name"
"public static Object callStaticMethod(Method method, Object[] params)
    {
        try
        {
            return method.invoke(null, params);
        }
        catch (IllegalAccessException e)
        {
            throw new IllegalStateException(e);
        }
        catch (InvocationTargetException e)
        {
            throw new IllegalStateException(e);
        }
    }","Calls a named static method on a class with a specified set of parameters.

@param  method The method name to call.
@param  params The parameters to pass.

@return The return value from the method call."
"public final void addAlias(final String alias, final String name)
			throws NoSuchUnitException, UnitExistsException {
		addAlias(alias, name, null);
	}","Adds an alias for a unit already in the database.

@param alias
An alias for the unit.
@param name
The name of the unit already in the database.
@throws UnitExistsException
Another unit with the same name or symbol already exists in
the database.
@throws NoSuchUnitException
The unit isn't in the database."
"@Override
    public void downgradeToPreviousVersion(OpenImmoDocument doc) {
        doc.setDocumentVersion(OpenImmoVersion.V1_2_5);

        if (doc instanceof OpenImmoTransferDocument) {
            try {
                this.removePreiseChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <preise> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeKaufpreisElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <kaufpreis> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeZwangsversteigerungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <zwangsversteigerung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeFlaechenChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <flaechen> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeBauzoneElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <bauzone> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeBodenElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <boden> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeEnergietypElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <energietyp> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeAusblickElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <ausblick> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeBueroPraxenElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <buero_praxen> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }
        }
    }","Downgrade an OpenImmo document from version 1.2.6 to 1.2.5.

@param doc OpenImmo document in version 1.2.6"
"public void create() throws java.io.IOException {
    if (!defineMode)
      throw new UnsupportedOperationException(""not in define mode"");
    if (!isNewFile)
      throw new UnsupportedOperationException(""can only call create on a new file"");

    ncfile.finish(); // ??
    spiw.setFill(fill); // ??
    spiw.create(location, ncfile, extraHeader, preallocateSize, isLargeFile);

    defineMode = false;
  }","After you have added all of the Dimensions, Variables, and Attributes,
call create() to actually create the file. You must be in define mode.
After this call, you are no longer in define mode.

@throws java.io.IOException if I/O error"
"public static String map(String url, RandomAccessFile file)
  {
    return map(url, file, file, DEFAULT_UNMAP_URL_ON_OPEN,
        DEFAULT_CLOSE_STREAM_ON_CLOSE);
  }","Maps a {@link RandomAccessFile} object to a URL for use by Humble.

@param url the URL to use.
@param file the {@link RandomAccessFile}
@return a string that can be passed to {@link Container}'s open methods."
"@Override
	public void stop() {
		if (log != null) {
			log.info(""PETITE stop"");
		}
		if (petiteContainer != null) {
			petiteContainer.shutdown();
		}
		petiteContainer = null;
	}",Stops Petite container.
"private EnsCoord getEnsCoordinate(int ens_id) {
    if (ens_id < 0) return null;
    for (EnsCoord ec : eaxes) {
      if ((ec.getId() == ens_id))
        return ec;
    }
    return null;
  }",////////////////////////////////////////////////////
"static public VariableDS makeDummyTransformVariable(NetcdfDataset ds, CoordinateTransform ct) {
    VariableDS v = new VariableDS( ds, null, null, ct.getName(), DataType.CHAR, """", null, null);
    List<Parameter> params = ct.getParameters();
    for (Parameter p : params) {
      if (p.isString())
        v.addAttribute(new Attribute(p.getName(), p.getStringValue()));
      else {
        double[] data = p.getNumericValues();
        Array dataA = Array.factory(DataType.DOUBLE, new int[]{data.length}, data);
        v.addAttribute(new Attribute(p.getName(), dataA));
      }
    }
    v.addAttribute( new Attribute(_Coordinate.TransformType, ct.getTransformType().toString()));

    // fake data
    Array data = Array.factory(DataType.CHAR, new int[] {}, new char[] {' '});
    v.setCachedData(data, true);

    return v;
  }","Create a ""dummy"" Coordinate Transform Variable based on the given CoordinateTransform.
This creates a scalar Variable with dummy data, and adds the Parameters of the CoordinateTransform
as attributes.
@param ds for this dataset
@param ct based on the CoordinateTransform
@return the Coordinate Transform Variable. You must add it to the dataset."
"protected SynchRecordImpl<E> extract(boolean unblock, boolean signal)
    {
        SynchRecordImpl<E> result = buffer.remove();
        count--;

        if (signal)
        {
            notFull.signal();
        }

        if (unblock)
        {
            result.releaseImmediately();
        }

        return result;
    }","Removes an element from the buffer, and optionally unblocks the producer of the element, if it is waiting, and
optionally signals that the {@link #notFull} condition may now be true.

<p/>Warning: This method must only be called when holding the main {@link #lock}.

@param  unblock <tt>true</tt> if the elements producer should be released.
@param  signal  <tt>trye</tt> if the {@link #notFull} condition should be signalled.

@return The synch record for the extracted item."
"@Override
	public void serialize(HttpServletResponse httpResponse) throws IOException {
		httpResponse.setHeader(HttpHeader.CACHE_CONTROL, HttpHeader.NO_CACHE);
		httpResponse.addHeader(HttpHeader.CACHE_CONTROL, HttpHeader.NO_STORE);
		httpResponse.setHeader(HttpHeader.PRAGMA, HttpHeader.NO_CACHE);
		httpResponse.setDateHeader(HttpHeader.EXPIRES, 0);
		httpResponse.setContentType(contentType);
		httpResponse.setHeader(HttpHeader.CONTENT_LENGTH, Long.toString(file.length()));
		Files.copy(file, httpResponse.getOutputStream());
	}","Serialize this file resource to HTTP response. Disable cache and set content type and content length.

@param httpResponse HTTP response.
@throws IOException if writing to underlying stream fails."
"public final void addParamTemplate(final ParameterizedTemplateModel paramTemplate) {
        if (paramTemplates == null) {
            paramTemplates = new ArrayList<ParameterizedTemplateModel>();
        }
        paramTemplates.add(paramTemplate);
    }","Adds another template to the list. If the list does not exist,it will be created.

@param paramTemplate
Template to add - Cannot be NULL."
"public boolean extendRecording(
        final String channel,
        final int streamId,
        final SourceLocation sourceLocation,
        final long recordingId,
        final long correlationId,
        final long controlSessionId)
    {
        extendRecordingRequestEncoder
            .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)
            .controlSessionId(controlSessionId)
            .correlationId(correlationId)
            .recordingId(recordingId)
            .streamId(streamId)
            .sourceLocation(sourceLocation)
            .channel(channel);

        return offer(extendRecordingRequestEncoder.encodedLength());
    }","Extend an existing, non-active, recorded stream for a the same channel and stream id.

The channel must be configured for the initial position from which it will be extended. This can be done
with {@link ChannelUriStringBuilder#initialPosition(long, int, int)}. The details required to initialise can
be found by calling {@link #listRecording(long, long, long)}.

@param channel          to be recorded.
@param streamId         to be recorded.
@param sourceLocation   of the publication to be recorded.
@param recordingId      to be extended.
@param correlationId    for this request.
@param controlSessionId for this request.
@return true if successfully offered otherwise false."
"private List<Comparator> childComparators( Map<String, FieldAccess> fields ) {
        if ( this.comparators == null ) {
            this.comparators = new ArrayList<>( this.sorts.size() + 1 );

            for ( Sort sort : sorts ) {
                Comparator comparator = universalComparator(
                        sort.getName(),
                        fields,
                        sort.getType(),
                        sort.childComparators(fields)
                );
                this.comparators.add( comparator );
            }
        }
        return this.comparators;
    }","This creates a list of children comparators based on the child list.
@param fields
@return"
"public static LongCounter makeSynchronized(final LongCounter counter)
   {
      return new Wrapper(counter) {
         /** The serialVersionUID */
         private static final long serialVersionUID = 8903330696503363758L;
            public synchronized long increment() {
               return this.counter.increment();
            }

            public synchronized long decrement() {
               return this.counter.decrement();
            }

            public synchronized long getCount() {
               return this.counter.getCount();
            }

            public synchronized void reset() {
               this.counter.reset();
            }

            public synchronized int hashCode() {
               return this.counter.hashCode();
            }

            public synchronized boolean equals(final Object obj) {
               return this.counter.equals(obj);
            }

            public synchronized String toString() {
               return this.counter.toString();
            }

            public synchronized Object clone() {
               return this.counter.clone();
            }
         };
   }","Return a synchronized counter.

@param counter    LongCounter to synchronize.
@return           Synchronized counter."
"public String getValueAtLevel(String level)
    {
        /*log.fine(""public String getValueAtLevel(String level): called"");*/
        /*log.fine(""level = "" + level);*/

        int index = attributeClass.levels.indexOf(level);

        /*log.fine(""index = "" + index);*/

        if (index == -1)
        {
            throw new IllegalArgumentException(""Level name "" + level +
                "" is not known to this hierarchy attribute type."");
        }

        return getValueAtLevel(index);
    }","Gets the label value at the named level of the hierarchy.

@param  level The level to get the label at.

@return The label value at the specified level of the hierarchy."
"@Override
    protected Unit myDivideBy(final Unit that) throws OperationException {
        return that instanceof OffsetUnit
                ? getUnit().divideBy(((OffsetUnit) that).getUnit())
                : getUnit().divideBy(that);
    }","Divide this unit by another unit.

@param that
The unit to divide this unit by.
@return The quotient of this unit and <code>that</code>. The offset of
this unit will be ignored; thus, for example
""celsius.myDivideBy(day)"" is equivalent to
""kelvin.myDivideBy(day)"".
@throws OperationException
Can't divide these units."
"public static <T> T[] copyOf(T[] original)
	{
		return Arrays.copyOf(original, original.length);
	}","Returns a copy of the given array. The original array and the
returned copy will have identical length and content.

@param <T> the type of the elements in the array to copy.
@param original the array to be copied.

@return a copy of the original array.

@throws NullPointerException if {@code original} is {@code null}."
"@CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Observable<T> doOnEach(final Observer<? super T> observer) {
        ObjectHelper.requireNonNull(observer, ""observer is null"");
        return doOnEach(
                ObservableInternalHelper.observerOnNext(observer),
                ObservableInternalHelper.observerOnError(observer),
                ObservableInternalHelper.observerOnComplete(observer),
                Functions.EMPTY_ACTION);
    }","Modifies the source ObservableSource so that it notifies an Observer for each item and terminal event it emits.
<p>
In case the {@code onError} of the supplied observer throws, the downstream will receive a composite
exception containing the original exception and the exception thrown by {@code onError}. If either the
{@code onNext} or the {@code onComplete} method of the supplied observer throws, the downstream will be
terminated and will receive this thrown exception.
<p>
<img width=""640"" height=""310"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.o.png"" alt="""">
<dl>
<dt><b>Scheduler:</b></dt>
<dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>

@param observer
the observer to be notified about onNext, onError and onComplete events on its
respective methods before the actual downstream Observer gets notified.
@return the source ObservableSource with the side-effecting behavior applied
@see <a href=""http://reactivex.io/documentation/operators/do.html"">ReactiveX operators documentation: Do</a>"
"public static MockMvcAuthenticationScheme principal(final Object principal) {
        return new MockMvcAuthenticationScheme() {
            public void authenticate(MockMvcRequestSpecification mockMvcRequestSpecification) {
                mockMvcRequestSpecification.auth().principal(principal);
            }
        };
    }","Authenticate using the given principal. Used as:
<pre>
RestAssured.authentication = principal(myPrincipal);
</pre>
or in a {@link MockMvcRequestSpecBuilder}:
<pre>
MockMvcRequestSpecification req = new MockMvcRequestSpecBuilder().setAuth(principal(myPrincipal)). ..
</pre>

@param principal The principal to use.
@return A {@link MockMvcAuthenticationScheme} instance.
@see MockMvcAuthenticationSpecification#principal(Object)"
"@CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {
        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());
    }","Signals a range of long values, the first after some initial delay and the rest periodically after.
<p>
The sequence completes immediately after the last value (start + count - 1) has been reached.
<dl>
<dt><b>Backpressure:</b></dt>
<dd>The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.</dd>
<dt><b>Scheduler:</b></dt>
<dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.</dd>
</dl>
@param start that start value of the range
@param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.
@param initialDelay the initial delay before signaling the first value (the start)
@param period the period between subsequent values
@param unit the unit of measure of the initialDelay and period amounts
@return the new Flowable instance"
"public static String[]  split( final String string,
                                  final char split, final int limit ) {


        char[][] comps = CharScanner.split( FastStringUtils.toCharArray( string ), split, limit );

        return Str.fromCharArrayOfArrayToStringArray( comps );


    }","Splits a string into many parts
@param string input string
@param split char to split by
@param limit the limit of the times you want it split up
@return the split string"
"@XmlElementDecl(namespace = ""http://www.immobilienscout24.de/immobilientransfer"", name = ""KeineAngabe"", scope = BefeuerungsArtTyp.class)
    public JAXBElement<Object> createBefeuerungsArtTypKeineAngabe(Object value) {
        return new JAXBElement<Object>(_BefeuerungsArtTypKeineAngabe_QNAME, Object.class, BefeuerungsArtTyp.class, value);
    }",Create an instance of {@link JAXBElement }{@code <}{@link Object }{@code >}}
"public static String labelName(final int typeId)
    {
        switch (typeId)
        {
            case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID:
                return PublisherLimit.NAME;

            case SenderPos.SENDER_POSITION_TYPE_ID:
                return SenderPos.NAME;

            case ReceiverHwm.RECEIVER_HWM_TYPE_ID:
                return ReceiverHwm.NAME;

            case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID:
                return SubscriberPos.NAME;

            case ReceiverPos.RECEIVER_POS_TYPE_ID:
                return ReceiverPos.NAME;

            case SenderLimit.SENDER_LIMIT_TYPE_ID:
                return SenderLimit.NAME;

            case PublisherPos.PUBLISHER_POS_TYPE_ID:
                return PublisherPos.NAME;

            case SenderBpe.SENDER_BPE_TYPE_ID:
                return SenderBpe.NAME;

            default:
                return ""<unknown>"";
        }
    }","Return the label name for a counter type identifier.

@param typeId of the counter.
@return the label name as a String."
"public static String getLastShardId(
      ClientConfiguration awsClientConfig,
      KinesisConfigBean conf,
      String streamName
  ) throws StageException {
    AmazonKinesis kinesisClient = getKinesisClient(awsClientConfig, conf);

    String lastShardId = null;
    try {
      StreamDescription description;
      do {
        if (lastShardId == null) {
          description = kinesisClient.describeStream(streamName).getStreamDescription();
        } else {
          description = kinesisClient.describeStream(streamName, lastShardId).getStreamDescription();
        }

        int pageSize = description.getShards().size();
        lastShardId = description.getShards().get(pageSize - 1).getShardId();

      } while (description.getHasMoreShards());

      return lastShardId;

    } finally {
      kinesisClient.shutdown();
    }
  }","Get the last shard Id in the given stream
In preview mode, kinesis source uses the last Shard Id to get records from kinesis
@param awsClientConfig generic AWS client configuration
@param conf
@param streamName"
"static public long makeSizeEstimate(ucar.nc2.dt.GridDataset gds, List<String> gridList,
                                       LatLonRect llbb, ProjectionRect projRect, int horizStride, Range zRange,
                                       CalendarDateRange dateRange, int stride_time, boolean addLatLon) throws IOException, InvalidRangeException {

    CFGridWriter2 writer2 = new CFGridWriter2();
    return writer2.writeOrTestSize(gds, gridList, llbb, projRect, horizStride, zRange, dateRange, stride_time, addLatLon, true, null);
  }","Compute the size of the file without writing

@param gds              the GridDataset
@param gridList         the list of variables to be written, or null for all
@param llbb             the lat/lon bounding box, or null for all
@param projRect         the projection bounding box, or null for all
@param horizStride      the x and y stride
@param zRange           the z stride
@param dateRange        date range, or null for all
@param stride_time      the time stride
@param addLatLon        add 2D lat/lon coordinates if needed
@return total bytes written
@throws IOException
@throws InvalidRangeException"
"public static boolean sendMail(MailItem item) {
        LOGGER.debug(""Mail : "" + item.toString());
        boolean result = queue.add(item);
        LOGGER.info(""Adding mail to queue. Queue size: "" + queue.size());

        // If thread is alive leave the job to it
        // Else create new thread and start.
        if (!consumerThread.isAlive()) {
            consumerThread = new Thread(consumer);
            consumerThread.start();
        }
        return result;
    }","Takes the mail item into the queue and manages the mail sender thread.
If thread is alive it will send the mail at the end of current thread queue.
Else a new thread will be created and started.

@param item MailItem to send.
@return true if item added to the queue successfully."
"String
    extractname(Object o)
            throws ParseException
    {
        if(o instanceof BaseType)
            return ((BaseType) o).getClearName();
        if(o instanceof Attribute)
            return ((Attribute) o).getClearName();
        if(o instanceof AttributeTable)
            return ((AttributeTable) o).getClearName();
        throw new ParseException(""extractname: illegal object class: "" + o);
    }","/* Since there is no common parent class for BaseType, Attribute,
and AttributeTable, provide a type specific name getter."
"public void empty(final Iterable<Key> keys) {
		final Map<Key, Object> updates = new HashMap<>();

		for (final Key key: keys)
			if (cacheControl.isCacheable(key))
				updates.put(key, null);

		this.memcacheWithRetry.putAll(updates);
	}","Revert a set of keys to the empty state.  Will loop on this several times just in case
the memcache write fails - we don't want to leave the cache in a nasty state."
"public ResultSet getTableAndViewMetadata(
      Connection connection,
      String schema,
      String tableName
  ) throws SQLException {
    return connection.getMetaData().getTables(
        getCatalog(connection, schema),
        schema,
        tableName,
        METADATA_TABLE_VIEW_TYPE
    );
  }","Wrapper for {@link java.sql.DatabaseMetaData#getTables(String, String, String, String[])}

@param connection open JDBC connection
@param schema schema name, can be null
@param tableName table name or pattern, optionally fully qualified in the form schema.tableName
@return ResultSet containing the table and view metadata

@throws SQLException"
"@Override
	public QueryImpl<T> filter(final String condition, final Object value) {
		final QueryImpl<T> q = createQuery();
		q.addFilter(condition, value);
		return q;
	}","/* (non-Javadoc)
@see com.googlecode.objectify.cmd.Query#filter(java.lang.String, java.lang.Object)"
"public static String substVars(String input, PropertyContainer pc0, PropertyContainer pc1) {
    try {
      return NodeToStringTransformer.substituteVariable(input, pc0, pc1);
    } catch (ScanException e) {
      throw new IllegalArgumentException(""Failed to parse input ["" + input + ""]"", e);
    }
  }","See  http://logback.qos.ch/manual/configuration.html#variableSubstitution
@param input string to be evaluated
@param pc0 primary property container
@param pc1 secondary property container
@return the substituted string"
"public void serialize(String dataset,DataOutputStream sink,CEEvaluator ce,Object specialO)
                                    throws NoSuchVariableException, DAP2ServerSideException, IOException {

    if (org == null) {
      super.serialize(dataset, sink, ce, specialO);
      return;
    }

    // use the projection info in the original
    java.util.Enumeration vars = org.getVariables();

    // run through each structure member
    StructureMembers sm = sdata.getStructureMembers();

    int count = 0;
    while (vars.hasMoreElements()) {
      HasNetcdfVariable sm_org = (HasNetcdfVariable) vars.nextElement();
      boolean isProjected = ((ServerMethods) sm_org).isProject();
      if (isProjected) {
        StructureMembers.Member m = sm.getMember(count);
        sm_org.serialize( sink, sdata, m);
      }
      count++;
    }

  }",overrride for array of Structures
"public Grib1Parameter getLocalParameter(int id) {
    if (parameters == null) {
      parameters = readParameterTable();
    }
    return parameters.get(id);
  }","Get the parameter with id, but dont look in default table.

@param id the parameter number
@return the Grib1Parameter, or null if not found"
"public static byte[] toRawByteArray(final char[] carr) {
		byte[] barr = new byte[carr.length << 1];
		for (int i = 0, bpos = 0; i < carr.length; i++) {
			char c = carr[i];
			barr[bpos++] = (byte) ((c & 0xFF00) >> 8);
			barr[bpos++] = (byte) (c & 0x00FF);
		}
		return barr;
	}",Converts char array into byte array by replacing each character with two bytes.
"public Iterator<Operator<Term>> traverse(Functor functor, boolean reverse)
    {
        /*log.fine(""Traversing functor "" + functor.toString(interner, true, false));*/

        Queue<Operator<Term>> queue = (!reverse) ? new StackQueue<Operator<Term>>() : new LinkedList<Operator<Term>>();

        Term[] arguments = functor.getArguments();

        // For a top-level functor clear top-level flag, so that child functors are not taken as top-level.
        if (arguments != null)
        {
            for (int i = 0; i < arguments.length; i++)
            {
                Term argument = arguments[i];

                // When navigating onto a variable, the variable is scoped within a clause, and may appear many times
                // within it. Therefore it always uses its unique id relative to the root symbol table for the
                // clause as its contextual position. Other terms use their position path and are relative to the
                // the current positions symbol table.
                SymbolTable<Integer, String, Object> contextSymbolTable;

                if (argument.isVar())
                {
                    contextSymbolTable = clauseScopedSymbolTable.enterScope(CLAUSE_FREEVAR_INDEX);
                    /*log.fine(""Enter freevar scope"");*/

                    argument.setReversable(new ContextOperator(contextSymbolTable,
                            createTermOperator(argument, i, functor)));
                    argument.setTermTraverser(this);
                    queue.offer(argument);

                    /*log.fine(""Created: "" +
                        (""var argument operator on "" + argument.toString(interner, true, false)));*/
                }
                else
                {
                    contextSymbolTable = null;

                    argument.setReversable(new ContextOperator(contextSymbolTable, i,
                            createTermOperator(argument, i, functor)));
                    argument.setTermTraverser(this);
                    queue.offer(argument);

                    /*log.fine(""Created: "" +
                        (""argument operator "" + i + "" on "" + argument.toString(interner, true, false)));*/
                }

            }
        }

        return queue.iterator();
    }",{@inheritDoc}
"protected boolean validate( StringBuffer buff) {
    if (!_validate(buff)) return false;
    Object editValue = getEditValue();
    if (editValue == null)
      return false;

    for (FieldValidator v : validators) {
      if (!v.validate(this, editValue, buff)) return false;
    }

    if (acceptIfDifferent( editValue)) {
      setEditValue( validValue);
      sendEvent();
    }
    return true;
  }","See if edit value is valid, put error message in buff."
"@Override
	public void end() {
		if (parentNode != rootNode) {

			Node thisNode = parentNode;

			while (thisNode != rootNode) {
				if (domBuilder.config.isImpliedEndTags()) {
					if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) {
						thisNode = thisNode.getParentNode();
						continue;
					}
				}

				error(""Unclosed tag closed: <"" + thisNode.getNodeName() + "">"");

				thisNode = thisNode.getParentNode();
			}
		}

		// remove whitespaces
		if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {
			removeLastChildNodeIfEmptyText(parentNode, true);
		}

		// foster
		if (domBuilder.config.isUseFosterRules()) {
			HtmlFosterRules fosterRules = new HtmlFosterRules();
			fosterRules.fixFosterElements(rootNode);
		}

		// elapsed
		rootNode.end();

		if (log.isDebugEnabled()) {
			log.debug(""LagartoDom tree created in "" + rootNode.getElapsedTime() + "" ms"");
		}
	}",Finishes the tree building. Closes unclosed tags.
"private String assembleNewValue(final Object value,
			final FacesCell facesCell) {
		String newValue;
		if (value instanceof java.util.Date) {
			String datePattern = facesCell.getDatePattern();
			if (datePattern == null || datePattern.isEmpty()) {
			    datePattern = parent.getDefaultDatePattern();
			}
			Format formatter = new SimpleDateFormat(datePattern);
			newValue = formatter.format(value);
		} else {
			newValue = (String) value;
		}
		if (""textarea"".equalsIgnoreCase(facesCell.getInputType())
				&& (newValue != null)) {
			// remove ""\r"" because excel issue
			newValue = newValue.replace(""\r\n"", ""\n"");
		}
		return newValue;
	}","Assemble new value.

@param value
the value
@param facesCell
the faces cell
@return the string"
"private void removeSbbEntityWithCurrentClassLoader(
			final SbbEntity sbbEntity) {		
		// remove entity
		sbbEntity.remove();
		// remove from tx data
		final TransactionContext txContext = sleeContainer.getTransactionManager().getTransactionContext();
		final SbbEntityID sbbEntityID = sbbEntity.getSbbEntityId();
		txContext.getData().remove(sbbEntityID);	
		// if sbb entity is root add a tx action to ensure lock is removed
		if (sbbEntityID.isRootSbbEntity()) {
			TransactionalAction txAction = new TransactionalAction() {
				@Override
				public void execute() {
					lockFacility.remove(sbbEntityID);
				}
			};
			txContext.getAfterCommitActions().add(txAction);
		}
	}","Removes the specified sbb entity but without changing to sbb's class
loader first.

@param sbbEntity
the sbb entity to remove"
"public static Long[] toObject(long... a)
	{
		if (a != null) {
			Long[] w = new Long[a.length];
			for (int i = 0; i < a.length; i++) {
				w[i] = a[i];
			}
			return w;
		}
		return null;
	}","Converts an array of {@code long}s to an array of {@code Long}s.
Returns {@code null} if the given array is {@code null}. Does not
modify the input array.

@param a the {@code long} array to convert.

@return the corresponding {@code Long} array."
"public final boolean isDimensionless() {
        for (int i = _factors.length; --i >= 0;) {
            if (!_factors[i].isDimensionless()) {
                return false;
            }
        }
        return true;
    }","Indicates if this dimension is dimensionless. A dimension is
dimensionless if it has no Factor-s or if all Factor-s are, themselves,
dimensionless.

@return <code>true</code> if and only if this dimension is dimensionless."
"public static SchedulerHelper create(final LazyInitializer<Runnable> runnableFactory, final String name) {
    return new SchedulerHelper(runnableFactory, name);
  }","Factory method. Creates a {@link SchedulerHelper} which consumes a factory providing a runnable. This approach
allows lazy runnable initialization.

@param runnableFactory
a factory creating the runnable to schedule.
@param name
the name associated with this {@link SchedulerHelper} (useful to detect if this class is causing a memory
leak."
"public static void startEmbeddedCassandra(File file, String tmpDir, long timeout) throws IOException, ConfigurationException {
        if (cassandraDaemon != null) {
            /* nothing to do Cassandra is already started */
            return;
        }

        checkConfigNameForRestart(file.getAbsolutePath());

        log.debug(""Starting cassandra..."");
        log.debug(""Initialization needed"");

        System.setProperty(""cassandra.config"", ""file:"" + file.getAbsolutePath());
        System.setProperty(""cassandra-foreground"", ""true"");
        System.setProperty(""cassandra.native.epoll.enabled"", ""false""); // JNA doesnt cope with relocated netty
        System.setProperty(""cassandra.unsafesystem"", ""true""); // disable fsync for a massive speedup on old platters

        // If there is no log4j config set already, set the default config
        if (System.getProperty(""log4j.configuration"") == null) {
            copy(DEFAULT_LOG4J_CONFIG_FILE, tmpDir);
            System.setProperty(""log4j.configuration"", ""file:"" + tmpDir + DEFAULT_LOG4J_CONFIG_FILE);
        }

        DatabaseDescriptor.daemonInitialization();

        cleanupAndLeaveDirs();
        final CountDownLatch startupLatch = new CountDownLatch(1);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            cassandraDaemon = new CassandraDaemon();
            cassandraDaemon.activate();
            startupLatch.countDown();
        });
        try {
            if (!startupLatch.await(timeout, MILLISECONDS)) {
                log.error(""Cassandra daemon did not start after "" + timeout + "" ms. Consider increasing the timeout"");
                throw new AssertionError(""Cassandra daemon did not start within timeout"");
            }
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                if (session != null) session.close();
                if (cluster != null) cluster.close();
            }));
        } catch (InterruptedException e) {
            log.error(""Interrupted waiting for Cassandra daemon to start:"", e);
            throw new AssertionError(e);
        } finally {
            executor.shutdown();
        }
    }","Set embedded cassandra up and spawn it in a new thread.

@throws TTransportException
@throws IOException
@throws ConfigurationException"
"public UserCustomCursor queryByIds(long baseId, long relatedId) {
        return query(buildWhereIds(baseId, relatedId),
                buildWhereIdsArgs(baseId, relatedId));
    }","Query by both base id and related id

@param baseId    base id
@param relatedId related id
@return cursor"
"public boolean addLogger(String name, Level level) throws NullPointerException, ManagementConsoleException {
    try {
      return ((Boolean) this.mbeanServer.invoke(logMgmtMBeanName, ""addLogger"", new Object[] { name, level }, new String[] { ""java.lang.String"",
          ""java.util.logging.Level"" })).booleanValue();
    }
    catch (Exception e) {
      e.printStackTrace();
      throw new ManagementConsoleException(SleeManagementMBeanUtils.doMessage(e));
    }
  }","Tries to add logger if it doesnt exist

@param name
- name of logger
@param level
- level for this logger, if <b>null</b> than default level for logger is used
@return <ul>
<li><b>true</b> - if logger didnt exist and it was created</li>
<li><b>false</b> - if logger did exist and it was not created</li>
</ul>
@throws NullPointerException
- when arg is null{}"
"public RpcResponseFuture invokeWithFuture(final Url url, final Object request,
                                              final int timeoutMillis) throws RemotingException,
                                                                      InterruptedException {
        check();
        return this.rpcRemoting.invokeWithFuture(url, request, null, timeoutMillis);
    }","Future invocation using a parsed {@link Url} <br>
You can get result use the returned {@link RpcResponseFuture}.
<p>
Notice:<br>
<ol>
<li><b>DO NOT modify the request object concurrently when this method is called.</b></li>
<li>When do invocation, use the parsed {@link Url} to find a available client connection, if none then throw exception</li>
</ol>

@param url
@param request
@param timeoutMillis
@return RpcResponseFuture
@throws RemotingException
@throws InterruptedException"
"public static List<String> listZip(final File zipFile) throws IOException {
		List<String> entries = new ArrayList<>();

		ZipFile zip = new ZipFile(zipFile);
		Enumeration zipEntries = zip.entries();

		while (zipEntries.hasMoreElements()) {
			ZipEntry entry = (ZipEntry) zipEntries.nextElement();
			String entryName = entry.getName();

			entries.add(entryName);
		}

		return Collections.unmodifiableList(entries);
	}",Lists zip content.
"@Deprecated
  public synchronized OServerAdmin connect(final String iUserName, final String iUserPassword) throws IOException {
    final String username;
    final String password;

    OCredentialInterceptor ci = OSecurityManager.instance().newCredentialInterceptor();

    if (ci != null) {
      ci.intercept(storage.getURL(), iUserName, iUserPassword);
      username = ci.getUsername();
      password = ci.getPassword();
    } else {
      username = iUserName;
      password = iUserPassword;
    }
    OConnect37Request request = new OConnect37Request(username, password);

    networkAdminOperation((network, session) -> {
      OStorageRemoteNodeSession nodeSession = session.getOrCreateServerSession(network.getServerURL());
      try {
        network.beginRequest(request.getCommand(), session);
        request.write(network, session);
      } finally {
        network.endRequest();
      }
      OConnectResponse response = request.createResponse();
      try {
        network.beginResponse(nodeSession.getSessionId(), true);
        response.read(network, session);
      } finally {
        storage.endResponse(network);
      }
      return null;
    }, ""Cannot connect to the remote server/database '"" + storage.getURL() + ""'"");

    return this;
  }","Connects to a remote server.

@param iUserName     Server's user name
@param iUserPassword Server's password for the user name used

@return The instance itself. Useful to execute method in chain

@throws IOException"
"public AbstractUsageParameterSet getInstalledUsageParameterSet(
			SbbID sbbID, String name)
			throws UnrecognizedUsageParameterSetNameException {
		if (name == null) {
			throw new NullPointerException(""null name"");
		}
		AbstractUsageParameterSet installedUsageParameterSet = _getInstalledUsageParameterSet(
				sbbID, name);
		if (installedUsageParameterSet == null) {
			throw new UnrecognizedUsageParameterSetNameException(name);
		}
		return installedUsageParameterSet;
	}","Convenience method to retrieve the {@link AbstractUsageParameterSet} for
the specified sbb and name

@param sbbID
@param name
@return
@throws UnrecognizedUsageParameterSetNameException"
"@Override
    public JSONObject toJsonObject() throws JSONException
    {
        JSONObject returnVal = super.toJsonObject();

        //Sum Decimals...
        if(this.getSumDecimals() != null)
        {
            returnVal.put(JSONMapping.SUM_DECIMALS, this.getSumDecimals());
        }

        //Table Field Records...
        if(this.getTableRecords() != null && !this.getTableRecords().isEmpty())
        {
            JSONArray assoFormsArr = new JSONArray();
            for(Form toAdd :this.getTableRecords())
            {
                assoFormsArr.put(toAdd.toJsonObject());
            }

            returnVal.put(JSONMapping.TABLE_RECORDS, assoFormsArr);
        }

        return returnVal;
    }","Conversion to {@code JSONObject} from Java Object.

@return {@code JSONObject} representation of {@code TableField}
@throws JSONException If there is a problem with the JSON Body.

@see ABaseFluidJSONObject#toJsonObject()"
"public GuiceApplicationBuilder withModuleLoader(
      BiFunction<Environment, Config, List<GuiceableModule>> loader) {
    return newBuilder(
        delegate.load(
            func(
                (play.api.Environment env, play.api.Configuration conf) ->
                    Scala.toSeq(loader.apply(new Environment(env), conf.underlying())))));
  }","Set the module loader. Overrides the default or any previously configured values.

@param loader the configuration
@return the configured application builder"
"protected String checkForClassInSchema(final String className) {
    if (className == null)
      return null;

    OrientBaseGraph graph = getGraph();
    if (graph == null)
      return className;

    final OSchema schema = graph.getRawGraph().getMetadata().getSchema();

    if (!schema.existsClass(className)) {
      // CREATE A NEW CLASS AT THE FLY
      try {
        graph.executeOutsideTx(new OCallable<OClass, OrientBaseGraph>() {

                                 @Override public OClass call(final OrientBaseGraph g) {
                                   return schema.createClass(className, schema.getClass(getBaseClassName()));

                                 }
                               }, ""Committing the active transaction to create the new type '"", className, ""' as subclass of '"", getBaseClassName(),
            ""'. The transaction will be reopen right after that. To avoid this behavior create the classes outside the transaction"");

      } catch (OSchemaException e) {
        if (!schema.existsClass(className))
          throw e;
      }
    } else {
      // CHECK THE CLASS INHERITANCE
      final OClass cls = schema.getClass(className);
      if (!cls.isSubClassOf(getBaseClassName()))
        throw new IllegalArgumentException(""Class '"" + className + ""' is not an instance of "" + getBaseClassName());
    }

    return className;
  }","Check if a class already exists, otherwise create it at the fly. If a transaction is running commit changes, create the class
and begin a new transaction.

@param className Class's name"
"public static void cublasDsyrk(char uplo, char trans, int n, int k, double alpha, Pointer A, int lda, double beta, Pointer C, int ldc)
    {
        cublasDsyrkNative(uplo, trans, n, k, alpha, A, lda, beta, C, ldc);
        checkResultBLAS();
    }","<pre>
void
cublasDsyrk (char uplo, char trans, int n, int k, double alpha,
const double *A, int lda, double beta, double *C, int ldc)

performs one of the symmetric rank k operations

C = alpha * A * transpose(A) + beta * C, or
C = alpha * transpose(A) * A + beta * C.

Alpha and beta are double precision scalars. C is an n x n symmetric matrix
consisting of double precision elements and stored in either lower or
upper storage mode. A is a matrix consisting of double precision elements
with dimension of n x k in the first case, and k x n in the second case.

Input
-----
uplo   specifies whether the symmetric matrix C is stored in upper or lower
storage mode as follows. If uplo == 'U' or 'u', only the upper
triangular part of the symmetric matrix is to be referenced, and the
elements of the strictly lower triangular part are to be infered from
those in the upper triangular part. If uplo == 'L' or 'l', only the
lower triangular part of the symmetric matrix is to be referenced,
and the elements of the strictly upper triangular part are to be
infered from those in the lower triangular part.
trans  specifies the operation to be performed. If trans == 'N' or 'n', C =
alpha * transpose(A) + beta * C. If trans == 'T', 't', 'C', or 'c',
C = transpose(A) * A + beta * C.
n      specifies the number of rows and the number columns of matrix C. If
trans == 'N' or 'n', n specifies the number of rows of matrix A. If
trans == 'T', 't', 'C', or 'c', n specifies the columns of matrix A.
n must be at least zero.
k      If trans == 'N' or 'n', k specifies the number of rows of matrix A.
If trans == 'T', 't', 'C', or 'c', k specifies the number of rows of
matrix A. k must be at least zero.
alpha  double precision scalar multiplier applied to A * transpose(A) or
transpose(A) * A.
A      double precision array of dimensions (lda, ka), where ka is k when
trans == 'N' or 'n', and is n otherwise. When trans == 'N' or 'n',
the leading n x k part of array A must contain the matrix A,
otherwise the leading k x n part of the array must contains the
matrix A.
lda    leading dimension of A. When trans == 'N' or 'n' then lda must be at
least max(1, n). Otherwise lda must be at least max(1, k).
beta   double precision scalar multiplier applied to C. If beta izs zero, C
does not have to be a valid input
C      double precision array of dimensions (ldc, n). If uplo = 'U' or 'u',
the leading n x n triangular part of the array C must contain the
upper triangular part of the symmetric matrix C and the strictly
lower triangular part of C is not referenced. On exit, the upper
triangular part of C is overwritten by the upper triangular part of
the updated matrix. If uplo = 'L' or 'l', the leading n x n
triangular part of the array C must contain the lower triangular part
of the symmetric matrix C and the strictly upper triangular part of C
is not referenced. On exit, the lower triangular part of C is
overwritten by the lower triangular part of the updated matrix.
ldc    leading dimension of C. It must be at least max(1, n).

Output
------
C      updated according to C = alpha * A * transpose(A) + beta * C, or C =
alpha * transpose(A) * A + beta * C

Reference: http://www.netlib.org/blas/dsyrk.f

Error status for this function can be retrieved via cublasGetError().

Error Status
------------
CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has not been initialized
CUBLAS_STATUS_INVALID_VALUE    if n < 0 or k < 0
CUBLAS_STATUS_ARCH_MISMATCH    if invoked on device without DP support
CUBLAS_STATUS_EXECUTION_FAILED if function failed to launch on GPU
</pre>"
"protected void assignCoordinateSystemsExplicit(NetcdfDataset ncDataset) {

    // look for explicit references to coord sys variables
    for (VarProcess vp : varList) {
      if (vp.coordSys != null && !vp.isCoordinateTransform) {
        StringTokenizer stoker = new StringTokenizer(vp.coordSys);
        while (stoker.hasMoreTokens()) {
          String vname = stoker.nextToken();
          VarProcess ap = findVarProcess(vname, vp);
          if (ap == null) {
            parseInfo.format(""***Cant find Coordinate System variable %s referenced from var= %s%n"", vname, vp.v.getFullName());
            userAdvice.format(""***Cant find Coordinate System variable %s referenced from var= %s%n"", vname, vp.v.getFullName());
            continue;
          }
          if (ap.cs == null) {
            parseInfo.format(""***Not a Coordinate System variable %s referenced from var= %s%n"", vname, vp.v.getFullName());
            userAdvice.format(""***Not a Coordinate System variable %s referenced from var= %s%n"", vname, vp.v.getFullName());
            continue;
          }

          VariableEnhanced ve = (VariableEnhanced) vp.v;
          ve.addCoordinateSystem(ap.cs);
        }
      }
    }

    // look for explicit references from coord sys variables to data variables
    for (VarProcess csVar : varList) {
      if (!csVar.isCoordinateSystem || (csVar.coordSysFor == null))
        continue;

      // get list of dimensions from '_CoordinateSystemFor' attribute
      List<Dimension> dimList = new ArrayList<>(6);
      StringTokenizer stoker = new StringTokenizer(csVar.coordSysFor);
      while (stoker.hasMoreTokens()) {
        String dname = stoker.nextToken();
        Dimension dim = ncDataset.getRootGroup().findDimension(dname);
        if (dim == null) {
          parseInfo.format(""***Cant find Dimension %s referenced from CoordSys var= %s%n"", dname, csVar.v.getFullName());
          userAdvice.format(""***Cant find Dimension %s referenced from CoordSys var= %s%n"", dname, csVar.v.getFullName());
        } else
          dimList.add(dim);
      }

      // look for vars with those dimensions
      for (VarProcess vp : varList) {
        if (!vp.hasCoordinateSystem() && vp.isData() && (csVar.cs != null)) {
          VariableEnhanced ve = (VariableEnhanced) vp.v;
          if (CoordinateSystem.isSubset(dimList, vp.v.getDimensionsAll()) && CoordinateSystem.isSubset(vp.v.getDimensionsAll(), dimList))
            ve.addCoordinateSystem(csVar.cs);
        }
      }
    }

    // look for explicit listings of coordinate axes
    for (VarProcess vp : varList) {
      VariableEnhanced ve = (VariableEnhanced) vp.v;

      if (!vp.hasCoordinateSystem() && (vp.coordAxes != null) && vp.isData()) {
        List<CoordinateAxis> dataAxesList = getAxes(vp, vp.coordAxes, vp.v.getFullName());
        if (dataAxesList.size() > 1) {
          String coordSysName = CoordinateSystem.makeName(dataAxesList);
          CoordinateSystem cs = ncDataset.findCoordinateSystem(coordSysName);
          if (cs != null) {
            ve.addCoordinateSystem(cs);
            parseInfo.format("" assigned explicit CoordSystem '%s' for var= %s%n"", cs.getName(), vp.v.getFullName());
          } else {
            CoordinateSystem csnew = new CoordinateSystem(ncDataset, dataAxesList, null);
            ve.addCoordinateSystem(csnew);
            ncDataset.addCoordinateSystem(csnew);
            parseInfo.format("" created explicit CoordSystem '%s' for var= %s%n"", csnew.getName(), vp.v.getFullName());
          }
        }
      }
    }
  }","Assign explicit CoordinateSystem objects to variables.

@param ncDataset why"
"public void nameBound(String name) {
		final Node node = getNamesBoundNode(true);
		if (!node.hasChild(name)) {
			node.addChild(Fqn.fromElements(name));
		}
	}","Adds the specified name to the set of names bound to the ac

@param name"
"private boolean processMixLetter(AnalyzeContext context){
		boolean needLock = false;
		
		if(this.start == -1){//当前的分词器尚未开始处理字符
			if(CharacterUtil.CHAR_ARABIC == context.getCurrentCharType()
					|| CharacterUtil.CHAR_ENGLISH == context.getCurrentCharType()){
				//记录起始指针的位置,标明分词器进入处理状态
				this.start = context.getCursor();
				this.end = start;
			}
			
		}else{//当前的分词器正在处理字符			
			if(CharacterUtil.CHAR_ARABIC == context.getCurrentCharType()
					|| CharacterUtil.CHAR_ENGLISH == context.getCurrentCharType()){
				//记录下可能的结束位置
				this.end = context.getCursor();
				
			}else if(CharacterUtil.CHAR_USELESS == context.getCurrentCharType()
						&& this.isLetterConnector(context.getCurrentChar())){
				//记录下可能的结束位置
				this.end = context.getCursor();
			}else{
				//遇到非Letter字符，输出词元
				Lexeme newLexeme = new Lexeme(context.getBufferOffset() , this.start , this.end - this.start + 1 , Lexeme.TYPE_LETTER);
				context.addLexeme(newLexeme);
				this.start = -1;
				this.end = -1;
			}			
		}
		
		//判断缓冲区是否已经读完
		if(context.isBufferConsumed() && (this.start != -1 && this.end != -1)){
            //缓冲以读完，输出词元
            Lexeme newLexeme = new Lexeme(context.getBufferOffset() , this.start , this.end - this.start + 1 , Lexeme.TYPE_LETTER);
            context.addLexeme(newLexeme);
            this.start = -1;
            this.end = -1;
		}
		
		//判断是否锁定缓冲区
		if(this.start == -1 && this.end == -1){
			//对缓冲区解锁
			needLock = false;
		}else{
			needLock = true;
		}
		return needLock;
	}","处理数字字母混合输出
如：windos2000 | linliangyi2005@gmail.com
* @param input
@param context
@return"
"protected JSONObject executeForm(
			HttpMethod httpMethodParam,
			List<HeaderNameValue> headerNameValuesParam,
			boolean checkConnectionValidParam,
			List<FormNameValue> formNameValuesParam,
			ContentType contentTypeParam,
			String postfixUrlParam
	) {
		//Validate Form Field and values...
		if(formNameValuesParam == null || formNameValuesParam.isEmpty()) {
			throw new FluidClientException(""No 'Name and Value' body to post."",
					FluidClientException.ErrorCode.FIELD_VALIDATE);
		}

		StringBuilder strBuilder = new StringBuilder();

		for(FormNameValue nameValue : formNameValuesParam) {
			if(nameValue.getName() == null || nameValue.getName().trim().isEmpty()) {
				continue;
			}

			if(nameValue.getValue() == null) {
				continue;
			}

			strBuilder.append(nameValue.getName());
			strBuilder.append(EQUALS);
			strBuilder.append(nameValue.getValue());
			strBuilder.append(AMP);
		}

		String bodyJsonString = strBuilder.toString();
		bodyJsonString = bodyJsonString.substring(0, bodyJsonString.length() - 1);

		return this.executeString(
				httpMethodParam,
				headerNameValuesParam,
				checkConnectionValidParam,
				bodyJsonString, contentTypeParam, postfixUrlParam);
	}","Submit a HTML Form based HTTP request body with JSON as a response.

@param httpMethodParam The HTTP method to use.
@param headerNameValuesParam The additional HTTP headers.
@param checkConnectionValidParam Check if connection to base endpoint is valid.
@param formNameValuesParam The Form name and value pairs.
@param contentTypeParam The Mime / Content type to submit as.
@param postfixUrlParam URL mapping after the Base endpoint.

@return Return body as JSON.

@see HttpMethod
@see JSONObject
@see ContentType
@see ABaseFluidJSONObject"
"@Test
	public void submitWhenSubmitInputSubmitsRequest() throws InterruptedException
	{
		server().enqueue(new MockResponse().setBody(""<html><body>""
			+ ""<form name='f' action='/x'>""
			+ ""<input type='submit'/>""
			+ ""</form>""
			+ ""</body></html>""));
		server().enqueue(new MockResponse());
		
		newBrowser().get(url(server()))
			.getForm(""f"")
			.submit();
		
		server().takeRequest();
		assertThat(""request"", takeRequest(server()).getPath(), is(""/x""));
	}",----------------------------------------------------------------------------------------------------------------
"public InputStream getVersionInputStream(String path, String versionId, String streamId) throws AccessDeniedException,
            StorageClientException, IOException {
        long t = System.currentTimeMillis();
        try {
            accessControlManager.check(Security.ZONE_CONTENT, path, Permissions.CAN_READ);
            checkOpen();
            Map<String, Object> structure = getCached(keySpace, contentColumnFamily, path);
            if (exists(structure)) {
                String contentId = (String) structure.get(STRUCTURE_UUID_FIELD);
                Map<String, Object> content = getCached(keySpace, contentColumnFamily, contentId);
                if (exists(content)) {
                    String versionHistoryId = (String) content.get(VERSION_HISTORY_ID_FIELD);
                    if (versionHistoryId != null) {
                        Map<String, Object> versionHistory = getCached(keySpace, contentColumnFamily, versionHistoryId);
                        if (versionHistory != null && versionHistory.containsKey(versionId)) {
                            return internalGetInputStream(versionId, streamId);
                        }
                    }
                }
            }
            return null;
        } finally {
            statsService.apiCall(ContentManagerImpl.class.getName(), ""egtVersionInputStream"", System.currentTimeMillis() - t);
        }
    }",TODO: Unit test
"public static <D> SipAssembler<D> forPdiAndContent(PackagingInformationFactory factory,
      Assembler<HashedContents<D>> pdiAssembler, DigitalObjectsExtraction<D> contentsExtraction) {
    HashAssembler noHashAssembler = new NoHashAssembler();
    return forPdiAndContentWithHashing(factory, pdiAssembler, noHashAssembler,
        ContentAssembler.noDedup(contentsExtraction, noHashAssembler));
  }","Assemble a SIP that contains only structured data and is the only SIP in its DSS.
@param <D> The type of domain objects to assemble the SIP from
@param factory Factory for creating the Packaging Information
@param pdiAssembler Assembler that builds up the PDI
@param contentsExtraction Extraction of content from domain objects added to the SIP
@return The newly created SIP assembler"
"protected Object session(Type type, String name) {
		return parameter(type, name, new Function<String, Object>() {

			public Object apply(String name) {
				return context.session().getAttribute(name);
			}
			
		}, new Function<String, Collection<Object>>() {

			@SuppressWarnings(""unchecked"")
			public Collection<Object> apply(String name) {
				HttpSession session = context.session();
				Object attribute = session.getAttribute(name);
				
				if (attribute instanceof Collection<?>) {
					return (Collection<Object>) attribute;
				}
				
				Map<String, Object> map = new TreeMap<String, Object>();
				
				for (Object object : Collections.list(session.getAttributeNames())) {
					String key = (String) object;
					
					if (key.startsWith(name + ""["")) {
						map.put(key, session.getAttribute(key));
					}
				}
				
				return (map.isEmpty()) ? null : map.values();
			}
			
		});
	}","Returns the Web endpoint method parameter from HTTP session.

@param type The parameter type.
@param name The parameter name.
@return The Web endpoint method parameter from HTTP session."
"public static String getPublicId(String otp) {
		if ((otp == null) || (otp.length() < OTP_MIN_LEN)){
			//not a valid OTP format, throw an exception
			throw new IllegalArgumentException(""The OTP is too short to be valid"");
		}
		
		Integer len = otp.length();

		/* The OTP part is always the last 32 bytes of otp. Whatever is before that
		 * (if anything) is the public ID of the YubiKey. The ID can be set to ''
		 * through personalization.
		 */
		return otp.substring(0, len - 32).toLowerCase();
	}","Extract the public ID of a YubiKey from an OTP it generated.

@param otp	The OTP to extract ID from, in modhex format.

@return string	Public ID of YubiKey that generated otp. Between 0 and 12 lower-case characters.

@throws IllegalArgumentException for arguments that are null or too short to be valid OTP strings."
"private void genPreambleStaticInitializers() throws JasperException {
        out.printil(""private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();"");
        out.println();

        // Static data for getDependants()
        out.printil(""private static java.util.List<String> _jspx_dependants;"");
        out.println();
        List<String> dependants = pageInfo.getDependants();
        Iterator<String> iter = dependants.iterator();
        if (!dependants.isEmpty()) {
            out.printil(""static {"");
            out.pushIndent();
            out.printin(""_jspx_dependants = new java.util.ArrayList<String>("");
            out.print("""" + dependants.size());
            out.println("");"");
            while (iter.hasNext()) {
                out.printin(""_jspx_dependants.add(\"""");
                out.print(iter.next());
                out.println(""\"");"");
            }
            out.popIndent();
            out.printil(""}"");
            out.println();
        }

        // Codes to support genStringAsByteArray option
        // Generate a static variable for the initial response encoding
        if (genBytes) {
            // first get the respons encoding
            String contentType = pageInfo.getContentType();
            String encoding = ""ISO-8859-1"";
            int i = contentType.indexOf(""charset="");
            if (i > 0)
                encoding = contentType.substring(i+8);

            // Make sure the encoding is supported
            // Assume that this can be determined at compile time
            try {
                ""testing"".getBytes(encoding);
                out.printin(""private static final String _jspx_encoding = "");
                out.print(quote(encoding));
                out.println("";"");
                out.printil(""private boolean _jspx_gen_bytes = true;"");
                out.printil(""private boolean _jspx_encoding_tested;"");
            } catch (java.io.UnsupportedEncodingException ex) {
                genBytes = false;
            }
        }
    }","Generation of static initializers in preamble.
For example, dependant list, el function map, prefix map.
(shared by servlet and tag handler preamble generation)"
"private List<Integer> buildFormWatchList(
			final XSSFEvaluationWorkbook wbWrapper, final Sheet sheet) {

		List<Integer> watchList = new ArrayList<>();

		ConfigRange cRange = this.getConfigRange();
		List<ConfigCommand> commandList = cRange.getCommandList();
		if (commandList.isEmpty()) {
			// if no command then no dynamic changes. then no need formula
			// shifts.
			return watchList;
		}
		int lastStaticRow = commandList.get(0).getTopRow() - 1;
		if (lastStaticRow < 0) {
			lastStaticRow = this.getTopRow();
		}

		int sheetIndex = sheet.getWorkbook().getSheetIndex(sheet);

		for (int i = this.getTopRow(); i <= this.getLastRow(); i++) {
			Row row = sheet.getRow(i);
			for (Cell cell : row) {
				if (cell.getCellTypeEnum() == CellType.FORMULA) {

					buildWatchListForCell(wbWrapper, sheetIndex, cell,
							watchList, lastStaticRow);

				}
			}
		}

		return watchList;

	}","Watch list serve for formula changes. Basically all the rows appeared in
the formula in the current sheet will be watched. Note if the cell
reference is from other sheet or workbooks, it will be ignored.

@param wbWrapper
XSSFEvaluationWorkbook used for formula parse.
@param sheet
current sheet.
@return List row number for monitoring."
"public static boolean isPrimitiveWrapper(final Class type)
   {
      for (int i = 0; i < PRIMITIVE_WRAPPER_MAP.length; i += 2)
      {
         if (type.equals(PRIMITIVE_WRAPPER_MAP[i + 1]))
         {
            return true;
         }
      }

      return false;
   }","Check if the given class is a primitive wrapper class.

@param type    Class to check.
@return        True if the class is a primitive wrapper."
"public static void parse(Object target, Properties arguments) {
        Class clazz;
        if (target instanceof Class) {
            clazz = (Class) target;
        } else {
            clazz = target.getClass();
        }
        for (Field field : clazz.getDeclaredFields()) {
            processField(target, field, arguments);
        }
        try {
            BeanInfo info = Introspector.getBeanInfo(clazz);
            for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
                processProperty(target, pd, arguments);
            }
        } catch (IntrospectionException e) {
            // If its not a JavaBean we ignore it
        }
    }","Parse properties instead of String arguments.  Any additional arguments need to be passed some other way.
This is often used in a second pass when the property filename is passed on the command line.  Because of
required properties you must be careful to set them all in the property file.

@param target    Either an instance or a class
@param arguments The properties that contain the arguments"
"@Override
	public void init() throws ServletException {
		super.init();
		String casServiceHost = System.getProperty(""cas.service.host"", ""localhost:8443"");
		targetUrl = ""https://"" + casServiceHost + ""/cas-sample/secure/"";
	}","Initialize the target URL. It allows for the host to change based upon the
""cas.service.host"" system property. If the property is not set, the default is
""localhost:8443""."
"@Override
  public synchronized int read() throws IOException {
    // Use local refs since buf and in may be invalidated by an
    // unsynchronized close()
    byte[] localBuf = buf;
    final InputStream localIn = in;
    if (localBuf == null || localIn == null) { throw new IOException(""Stream is closed""); }

    /* Are there buffered bytes available? */
    if (pos >= count && fillbuf(localIn, localBuf) == -1) {
      return -1; /* no, fill buffer */
    }
    // localBuf may have been invalidated by fillbuf
    if (localBuf != buf) {
      localBuf = buf;
      if (localBuf == null) { throw new IOException(""Stream is closed""); }
    }

    /* Did filling the buffer fail with -1 (EOF)? */
    final int mask = 0xFF;
    if (count - pos > 0) {
      return localBuf[pos++] & mask;
    }
    return -1;
  }","Reads a single byte from this stream and returns it as an integer in the
range from 0 to 255. Returns -1 if the end of the source string has been
reached. If the internal buffer does not contain any available bytes then
it is filled from the source stream and the first byte is returned.

@return the byte read or -1 if the end of the source stream has been
reached.
@throws IOException
if this stream is closed or another IOException occurs."
"public static Class findEnum(Class target) {
		if (target.isPrimitive()) {
			return null;
		}
		while (target != Object.class) {
			if (target.isEnum()) {
				return target;
			}

			target = target.getSuperclass();
		}

		return null;
	}",Returns <code>enum</code> class or <code>null</code> if class is not an enum.
"@SuppressWarnings(""UnusedDeclaration"")
    public DecoderConfig defaultContentCharset(Charset charset) {
        String charsetAsString = notNull(charset, Charset.class).toString();
        return new DecoderConfig(charsetAsString, useNoWrapForInflateDecoding, true, contentDecoders, contentTypeToDefaultCharset);
    }","Specify the default charset of the content in the response that's assumed if no charset is explicitly specified in the response.

@param charset The expected charset
@return A new instance of the DecoderConfig."
"public static URL getParent(URL url) {
        String file = url.getFile();
        int len = file.length();

        if (len == 0 || len == 1 && file.charAt(0) == '/')
            return null;

        int lastSlashIndex = -1;
        for (int i = len - 2; lastSlashIndex == -1 && i >= 0; --i) {
            if (file.charAt(i) == '/')
                lastSlashIndex = i;
        }

        if (lastSlashIndex == -1)
            file = """"; //$NON-NLS-1$
        else
            file = file.substring(0, lastSlashIndex + 1);

        try {
            url = new URL(url.getProtocol(), url.getHost(), url.getPort(), file);
        } catch (MalformedURLException e) {
            Assert.isTrue(false, e.getMessage());
        }

        return url;
    }","Returns the parent URL of the given URL, or <code>null</code> if the
given URL is the root.
<table>
<caption>Example</caption>
<tr>
<th>Given URL</th>
<th>Parent URL</th>
<tr>
<td>""http://hostname/""</td>
<td>null</td>
<tr>
<td>""http://hostname/folder/file</td>
<td>""http://hostname/folder/</td>
</table>

@param url a URL
@return    the parent of the given URL"
"private static void initialize() {
		String driver = ConfigHelper.getProperty(""jdbc.driver"");
		String url = ConfigHelper.getProperty(""jdbc.url"");
		String username = ConfigHelper.getProperty(""jdbc.username"");
		String password = ConfigHelper.getProperty(""jdbc.password"");
		String dialect = ConfigHelper.getProperty(""hibernate.dialect"");
		AssertHelper.notNull(driver);
		AssertHelper.notNull(url);
		AssertHelper.notNull(username);
		AssertHelper.notNull(password);
		AssertHelper.notNull(dialect);
		String formatSql = ConfigHelper.getProperty(""hibernate.format_sql"");
		String showSql = ConfigHelper.getProperty(""hibernate.show_sql"");
		Configuration configuration = new Configuration();
		
		if(StringHelper.isNotEmpty(driver)) {
			configuration.setProperty(""hibernate.connection.driver_class"", driver);
		}
		if(StringHelper.isNotEmpty(url)) {
			configuration.setProperty(""hibernate.connection.url"", url);
		}
		if(StringHelper.isNotEmpty(username)) {
			configuration.setProperty(""hibernate.connection.username"", username);
		}
		if(StringHelper.isNotEmpty(password)) {
			configuration.setProperty(""hibernate.connection.password"", password);
		}
		if(StringHelper.isNotEmpty(dialect)) {
			configuration.setProperty(""hibernate.dialect"", dialect);
		}
		if(StringHelper.isNotEmpty(formatSql)) {
			configuration.setProperty(""hibernate.format_sql"", formatSql);
		}
		if(StringHelper.isNotEmpty(showSql)) {
			configuration.setProperty(""hibernate.show_sql"", showSql);
		}
		sessionFactory = configuration.configure().buildSessionFactory();
	}","在没有任何SessionFactory注入的情况下，默认加载hibernate.cfg.xml初始化sessionFactory
这里只设置了常用的属性，建议调用Configuration.initAccessDBObject方法注入sessionfactory
或者使用ioc容器注入"
"public void optimize() {
        final int numRows = this.rows.size();

        for ( int i = 0; i < numRows; ++i ) {
            get( i ).optimize();
        }
    }",Optimizes all rows for optimal presentation
"public void setZoomManager(ZoomManager newManager) {

        if ( zoomManager != null ) {
            zoomManager.removeZoomListener( this );
        }

        zoomManager = newManager;

        if ( zoomManager != null ) {
            zoomManager.addZoomListener( this );
        }

    }","Replaces existing zoomManager with the new one.

Implementation is null-safe.

@param newManager new zoom manager"
"public int getSize() {
    switch (sort) {
      case VOID:
        return 0;
      case BOOLEAN:
      case CHAR:
      case BYTE:
      case SHORT:
      case INT:
      case FLOAT:
      case ARRAY:
      case OBJECT:
      case INTERNAL:
        return 1;
      case LONG:
      case DOUBLE:
        return 2;
      default:
        throw new AssertionError();
    }
  }","Returns the size of values of this type. This method must not be used for method types.

@return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for
{@code void} and 1 otherwise."
"public static <T> String arrayString(T[] items) {
        StringBuilder sB = new StringBuilder(""A["");
        boolean isFirst = true;
        for (T item : items) {
            if (isFirst) {
                isFirst = false;
            } else {
                sB.append("" "");
            }
            if (item instanceof String) {
                sB.append(""\"""").append(item).append(""\"""");
            } else {
                sB.append(item);
            }
        }
        return sB.append(""]"").toString();
    }","There is Arrays.toString, but this is intended to produce Cymling code some day."
"@Override
    public void downgradeToPreviousVersion(OpenImmoDocument doc) {
        doc.setDocumentVersion(OpenImmoVersion.V1_1);

        if (doc instanceof OpenImmoTransferDocument) {
            try {
                this.downgradeUebertragungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <uebertragung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeUserDefinedExtendElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove <user_defined_extend> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeAnbieterChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <anbieter> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeBieterverfahrenElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove <bieterverfahren> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeBewertungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove <bewertung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeGeoChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <geo> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeHeizkostenEnthaltenElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove <heizkosten_enthalten> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeAusstattungChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <ausstattung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeEnergiepassElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove <energiepass> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeMieteinnahmenElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <mieteinnahmen_ist> and <mieteinnahmen_soll> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeBefeuerungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <befeuerung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeHausElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <haus> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }
        }
    }","Downgrade an OpenImmo document from version 1.2.0 to 1.1.

@param doc OpenImmo document in version 1.2.0"
"public Resource<T> setResource(T resource) {
        return new Resource<>(resourceID, provider, resource, consumer);
    }","sets the Resource data.
<p>
Note! this Object is immutable!
</p>
@param resource the data to set
@return the Resource"
"public static int getBufferSizeNeeded(int width, int height, PixelFormat.Type pix_fmt) {
    return VideoJNI.PixelFormat_getBufferSizeNeeded(width, height, pix_fmt.swigValue());
  }","Find the buffer size that would be necessary to store an image<br>
with the given qualities."
"@CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final <U extends Collection<? super T>> Observable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable<U> bufferSupplier) {
        ObjectHelper.requireNonNull(unit, ""unit is null"");
        ObjectHelper.requireNonNull(scheduler, ""scheduler is null"");
        ObjectHelper.requireNonNull(bufferSupplier, ""bufferSupplier is null"");
        return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));
    }","Returns an Observable that emits buffers of items it collects from the source ObservableSource. The resulting
ObservableSource starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the
specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
{@code timespan} argument. When the source ObservableSource completes, the resulting ObservableSource emits the
current buffer and propagates the notification from the source ObservableSource. Note that if the source
ObservableSource issues an onError notification the event is passed on immediately without first emitting the
buffer it is in the process of assembling.
<p>
<img width=""640"" height=""320"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.png"" alt="""">
<dl>
<dt><b>Scheduler:</b></dt>
<dd>You specify which {@link Scheduler} this operator will use.</dd>
</dl>

@param <U> the collection subclass type to buffer into
@param timespan
the period of time each buffer collects items before it is emitted
@param timeskip
the period of time after which a new buffer will be created
@param unit
the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
@param scheduler
the {@link Scheduler} to use when determining the end and start of a buffer
@param bufferSupplier
a factory function that returns an instance of the collection subclass to be used and returned
as the buffer
@return an Observable that emits new buffers of items emitted by the source ObservableSource periodically after
a fixed timespan has elapsed
@see <a href=""http://reactivex.io/documentation/operators/buffer.html"">ReactiveX operators documentation: Buffer</a>"
"private void createInitialContext(Term term)
    {
        if (!initialContextCreated)
        {
            PositionalContextOperator initialContext =
                new PositionalContextOperator(term, -1, false, false, false, null, contextStack.peek());
            contextStack.offer(initialContext);
            term.setReversable(initialContext);
            initialContextCreated = true;
        }
    }","Sets up the initial context once, at the start of a traversal.

@param term The term to establish the initial positional traversal context for."
"public static float float4(int a, int b, int c, int d) {
    int sgn, mant, exp;

    mant = b << 16 | c << 8 | d;
    if (mant == 0) {
      return 0.0f;
    }

    sgn = -(((a & 128) >> 6) - 1);
    exp = (a & 127) - 64;

    return (float) (sgn * Math.pow(16.0, exp - 6) * mant);
  }","Convert 4 bytes to a float.

@param a first byte
@param b second byte
@param c third byte
@param d fourth byte
@return float"
"public static <O> RuleVisitor<O> getTimedVisitor(RuleVisitor<O> visitor,
			RuleApplicationTimer timer) {
		return new RuleApplicationTimerVisitor<O>(visitor, timer);
	}","@param visitor
the {@link SubsumerDecompositionVisitor} used to execute the
methods
@param timer
the {@link RuleApplicationTimer} used to mesure the time spent
within the methods

@return a new {@link SubsumerDecompositionVisitor} that executes the
corresponding methods of the given
{@link SubsumerDecompositionVisitor} and measures the time spent
within the corresponding methods using the given
{@link RuleApplicationTimer}."
"@CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Maybe<T> create(MaybeOnSubscribe<T> onSubscribe) {
        ObjectHelper.requireNonNull(onSubscribe, ""onSubscribe is null"");
        return RxJavaPlugins.onAssembly(new MaybeCreate<T>(onSubscribe));
    }","Provides an API (via a cold Maybe) that bridges the reactive world with the callback-style world.
<p>
Example:
<pre><code>
Maybe.&lt;Event&gt;create(emitter -&gt; {
Callback listener = new Callback() {
&#64;Override
public void onEvent(Event e) {
if (e.isNothing()) {
emitter.onComplete();
} else {
emitter.onSuccess(e);
}
}

&#64;Override
public void onFailure(Exception e) {
emitter.onError(e);
}
};

AutoCloseable c = api.someMethod(listener);

emitter.setCancellable(c::close);

});
</code></pre>
<dl>
<dt><b>Scheduler:</b></dt>
<dd>{@code create} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>
@param <T> the value type
@param onSubscribe the emitter that is called when a MaybeObserver subscribes to the returned {@code Maybe}
@return the new Maybe instance
@see MaybeOnSubscribe
@see Cancellable"
"public boolean proofStep(ResolutionState state)
    {
        Clause query = state.getCurrentClause();

        // The query goals are placed onto the goal stack backwards so that their insertion order is reversed for an
        // intuitive left-to-right evaluation order.
        for (int i = query.getBody().length - 1; i >= 0; i--)
        {
            BuiltInFunctor newGoal = state.getBuiltInTransform().apply(query.getBody()[i]);
            state.getGoalStack().offer(newGoal);
        }

        return true;
    }",{@inheritDoc}
"public WebApp registerComponent(final Class<?> madvocComponent) {
		Objects.requireNonNull(madvocComponent);
		madvocComponents.add(ClassConsumer.of(madvocComponent));
		return this;
	}",Registers additional Madvoc components after the registration of default components.
"private SearchNode<O, T> joinBothPaths(SearchNode<O, T> forwardPath, SearchNode<O, T> reversePath)
        throws SearchNotExhaustiveException
    {
        // Check if an alternative path join algorithm has been set and delegate to it if so
        if (pathJoiner != null)
        {
            return pathJoiner.joinBothPaths(forwardPath, reversePath);
        }

        // No alternative path join algorithm has been supplied so use this default one
        else
        {
            // Used to hold the current position along the reverse path of search nodes
            SearchNode<O, T> currentReverseNode = reversePath;

            // Used to hold the current position along the forward path of search nodes
            SearchNode<O, T> currentForwardNode = forwardPath;

            // Loop over all nodes in the reverse path checking if the current reverse node is the
            // goal state to terminate on.
            while (!goalPredicate.evaluate(currentReverseNode.getState()))
            {
                // Create a new forward node from the parent state of the current reverse node, the current reverse
                // nodes applied operation and cost, and an increment of one to the path depth
                SearchNode<O, T> reverseParentNode = currentReverseNode.getParent();
                T state = currentReverseNode.getParent().getState();
                Operator<O> operation = currentReverseNode.getAppliedOp();
                float cost = currentReverseNode.getPathCost() - reverseParentNode.getPathCost();

                currentForwardNode = currentForwardNode.makeNode(new Successor<O>(state, operation, cost));

                // Move one step up the reverse path
                currentReverseNode = reverseParentNode;
            }

            // Return the last forward search node found
            return currentForwardNode;
        }
    }","Once a match has been found between the forward and reverse fringes of the search a path is known to exist from
the start to the goal. The path is not complete at this stage because it remains to reverse all of the steps in
the backward half of the path and add them to the forward half of the path to produce the complete forward path
from start to the goal.

<p>This method implements a standard algorithm for doing this. It assumes that the state space being searched by
both halfs of the search is over the same states. It also assumes that the applied operations in the reverse
search node have already been reverse. For example, if the search space was the eight tiles game then the moves
stored in the reverse half of the search would have to be stored in the reverse direction to that in which they
are applied when really playing the game backwards. This means that two implementations of
{@link com.thesett.aima.search.TraversableState} are needed, one that gives its operators reversed.

<p>It is possible to supply an alternative path joining algorithm that does know how to reverse the operators.
Set this in this search algorithm by calling the {@link #setPathJoinAlgorithm} method. This is an alternative to
writing two implementatios of {@link com.thesett.aima.search.TraversableState}

@param  forwardPath a search node for the forward portion of the goal path
@param  reversePath a search node for the reverse portion of the goal path

@return a search node corresponding to the path right from start to goal

@throws SearchNotExhaustiveException If the node implementation does not allow new nodes to be created from old.
See the {@link SearchNode#makeNode} method for more information."
"protected void onApplyError(String message, Exception e) {
        log.error(message, e);
        throw new RuntimeException(message, e);
    }",Logs an error applying some JSON to Kubernetes and optionally throws an exception
"private String getColumnWidthStyle(final Sheet sheet1, final Map<String, CellRangeAddress> cellRangeMap,
			final String cellindex, final int cindex, final double totalWidth) {

		CellRangeAddress caddress = cellRangeMap.get(cellindex);
		double colWidth;
		// check whether the cell has rowspan or colspan
		if (caddress != null) {
			colWidth = CellStyleUtility.calcTotalWidth(sheet1, caddress.getFirstColumn(), caddress.getLastColumn(), 0);
		} else {
			colWidth = sheet1.getColumnWidth(cindex);
		}

		return getWidthStyle(colWidth, totalWidth);

	}","Gets the column width style.

@param sheet1
the sheet 1
@param cellRangeMap
the cell range map
@param cellindex
the cellindex
@param cindex
the cindex
@param totalWidth
the total width
@return the column width style"
"public static int getMethodCountForName(Class<?> clazz, String methodName) {
        Preconditions.checkNotNull(clazz, ""Class must not be null"");
        Preconditions.checkNotNull(methodName, ""Method name must not be null"");
        int count = 0;
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method method : declaredMethods) {
            if (methodName.equals(method.getName())) {
                count++;
            }
        }
        Class<?>[] ifcs = clazz.getInterfaces();
        for (Class<?> ifc : ifcs) {
            count += getMethodCountForName(ifc, methodName);
        }
        if (clazz.getSuperclass() != null) {
            count += getMethodCountForName(clazz.getSuperclass(), methodName);
        }
        return count;
    }","Return the number of methods with a given name (with any argument types),
for the given class and/or its superclasses. Includes non-public methods.

@param clazz      the clazz to check
@param methodName the name of the method
@return the number of methods with the given name"
"private void processSQLExceptions(ConnHolder connHolder, SQLException[] exceptions) {
        int connVersion = connHolder.version();
        SQLException criticalException = getCriticalSQLException(exceptions);
        if (criticalException != null && connectionFactory.compareAndSetVersion(connVersion, connVersion + 1)) {
            int destroyed = poolService.drainCreated(); // destroys all connections in the pool
            logger.error(""Critical SQLState {} occurred, destroyed {} connections from pool {}, current connection version is {}."",
                    criticalException.getSQLState(), destroyed, getPoolName(dataSource), connectionFactory.version(), criticalException);
        }
    }","Processes SQL exceptions that have occurred on the given JDBC Connection (wrapped in a {@code ConnHolder}).

@param connHolder the given connection
@param exceptions the list of SQL exceptions that have occurred on the connection; might be an empty list but not a {@code null}"
"public Variable addStringVariable(Group g, Variable stringVar, List<Dimension> dims) {
    if (!defineMode)
      throw new UnsupportedOperationException(""not in define mode"");

    if (!N3iosp.isValidNetcdfObjectName(stringVar.getShortName()))
      throw new IllegalArgumentException(""illegal netCDF-3 variable name: "" + stringVar.getShortName());

    // convert STRING to CHAR
    int max_strlen = 0;
    Array data;

    try {
      data = stringVar.read();
      IndexIterator ii = data.getIndexIterator();
      while (ii.hasNext()) {
        String s = (String) ii.getObjectNext();
        max_strlen = Math.max(max_strlen, s.length());
      }
    } catch (IOException e) {
      e.printStackTrace();
      String err = ""No data found for Variable "" + stringVar.getShortName() +
              "". Cannot determine the lentgh of the new CHAR variable."";
      log.error(err);
      System.out.println(err);
    }

    return addStringVariable(g, stringVar.getShortName(), dims, max_strlen);
  }","Add a variable with DataType = String to a netCDF-3 file. Must be in define mode.
The variable will be stored in the file as a CHAR variable.
A new dimension with name ""stringVar.getShortName()_strlen"" is automatically
added, with length max_strlen, as determined from the data contained in the
stringVar.

@param g         add to this group in the new file
@param stringVar string variable.
@param dims      list of Dimensions for the string variable.
@return the CHAR variable generated from stringVar"
"public CallAdapter<?, ?> callAdapter(Type returnType, Annotation[] annotations) {
    return nextCallAdapter(null, returnType, annotations);
  }","Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
#callAdapterFactories() factories}.

@throws IllegalArgumentException if no call adapter available for {@code type}."
"private void adjustBounds(BoundingBox boundingBox,
                              int zoom) {
        // Google Tile Format
        if (googleTiles) {
            adjustGoogleBounds();
        } else if (projection.isUnit(Units.DEGREES)) {
            adjustGeoPackageBoundsWGS84(boundingBox, zoom);
        } else {
            adjustGeoPackageBounds(boundingBox, zoom);
        }
    }","Adjust the tile matrix set and bounds

@param boundingBox bounding box
@param zoom        zoom"
"@SuppressWarnings(""unchecked"")
    public <E> Expression<E> pickExpression() {
        Preconditions.checkState(this.expression != null, ""No expression has been set"");
        Expression<E> result = (Expression<E>) this.expression;
        expression = null;
        return result;
    }","Returns the expression currently active in the building context.

@param <E> the type of the expression.
@return the JPA expression."
"public static ProtectedFunctionMapper getInstance() {
        ProtectedFunctionMapper funcMapper;
	if (SecurityUtil.isPackageProtectionEnabled()) {
	    funcMapper = AccessController.doPrivileged(
		new PrivilegedAction<ProtectedFunctionMapper>() {
		public ProtectedFunctionMapper run() {
		    return new ProtectedFunctionMapper();
		}
	    } );
	} else {
	    funcMapper = new ProtectedFunctionMapper();
	}
	funcMapper.fnmap = new java.util.HashMap<String, Method>();
	return funcMapper;
    }","Generated Servlet and Tag Handler implementations call this
method to retrieve an instance of the ProtectedFunctionMapper.
This is necessary since generated code does not have access to
create instances of classes in this package.

@return A new protected function mapper."
"protected void putJobImpl(Executable task) 
   {
      m_heap.insert(task);
      ((TimerTask)task).setState(TimerTask.SCHEDULED);
      notifyAll();
   }",WorkerQueue overrides ---------------------------------------------------
"private void assignDefaultAliases(List<OMatchExpression> matchExpressions) {
    int counter = 0;
    for (OMatchExpression expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (OMatchPathItem item : expression.items) {
        if (item.filter == null) {
          item.filter = new OMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
  }","assigns default aliases to pattern nodes that do not have an explicit alias

@param matchExpressions"
"public SizeableLinkedList<WAMInstruction> compileBodyCall(Functor expression, boolean isFirstBody,
        boolean isLastBody, boolean chainRule, int permVarsRemaining)
    {
        return new SizeableLinkedList<WAMInstruction>();
    }",{@inheritDoc}
"public void writeBidRequest(BidRequest req, OutputStream os) throws IOException {
    JsonGenerator gen = factory().getJsonFactory().createGenerator(os);
    writeBidRequest(req, gen);
  }","Serializes a {@link BidRequest} to JSON, streamed into an {@link OutputStream}.

@see JsonFactory#createGenerator(OutputStream)"
"String getGeoLocation(String remoteAddr) {
		try {
			CityResponse city = this.reader.city(InetAddress.getByName(remoteAddr));
			String cityName = city.getCity().getName();
			String countryName = city.getCountry().getName();
			if (cityName == null && countryName == null) {
				return null;
			}
			else if (cityName == null) {
				return countryName;
			}
			else if (countryName == null) {
				return cityName;
			}
			return cityName + "", "" + countryName;
		}
		catch (Exception ex) {
			return UNKNOWN;

		}
	}",end::dofilterinternal[]
"@SuppressWarnings(""unchecked"")
    private static <K, V> Node<K,V> append(Node<? extends K,? extends V> left,
                                   Node<? extends K,? extends V> right) {
        if (left == null)
            return (Node<K,V>) right;
        else if (right == null)
            return (Node<K,V>) left;
        else if (left instanceof PersistentTreeMap.Red) {
            if (right instanceof PersistentTreeMap.Red) {
                Node<K,V> app = append(left.right(), right.left());
                if (app instanceof PersistentTreeMap.Red)
                    return red(app.getKey(), app.getValue(),
                               red(left.getKey(), left.getValue(), left.left(), app.left()),
                               red(right.getKey(), right.getValue(), app.right(), right.right()));
                else
                    return red(left.getKey(), left.getValue(), left.left(),
                               red(right.getKey(), right.getValue(), app, right.right()));
            } else
                return red(left.getKey(), left.getValue(), left.left(), append(left.right(), right));
        } else if (right instanceof PersistentTreeMap.Red)
            return red(right.getKey(), right.getValue(), append(left, right.left()), right.right());
        else //black/black
        {
            Node<K,V> app = append(left.right(), right.left());
            if (app instanceof PersistentTreeMap.Red)
                return red(app.getKey(), app.getValue(),
                           black(left.getKey(), left.getValue(), left.left(), app.left()),
                           black(right.getKey(), right.getValue(), app.right(), right.right()));
            else
                return balanceLeftDel(left.getKey(), left.getValue(), left.left(),
                                      black(right.getKey(), right.getValue(), app, right.right()));
        }
    }","Node<K,V> concat(Node<K1,V1> left, Node<K2,V2> right){"
"public Response save() {
		assertNotEmpty(replicatorDoc.getSource(), ""Source"");
		assertNotEmpty(replicatorDoc.getTarget(), ""Target"");
		if(userCtxName != null) {
			UserCtx ctx = replicatorDoc.new UserCtx();
			ctx.setName(userCtxName);
			ctx.setRoles(userCtxRoles);
			replicatorDoc.setUserCtx(ctx);
		}
		return dbc.put(dbURI, replicatorDoc, true);
	}","Adds a new document to the replicator database.
@return {@link Response}"
"public static String getVersion(String groupId, String artifactId) throws IOException {
        String path = ""META-INF/maven/"" + groupId + ""/"" + artifactId + ""/pom.properties"";
        InputStream in = MavenUtil.class.getClassLoader().getResourceAsStream(path);
        if (in == null) {
            throw new IOException(""Could not find "" + path + "" on classath!"");
        }
        Properties properties = new Properties();
        try {
            properties.load(in);
        } catch (IOException e) {
            throw new IOException(""Failed to load "" + path + "". "" + e, e);
        }
        String version = properties.getProperty(""version"");
        if (StringUtils.isBlank(version)) {
            throw new IOException(""No version property in "" + path);

        }
        return version;
    }",Returns the version from the list of pre-configured versions of common groupId/artifact pairs
"public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) {
		return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword);
	}",Creates SOCKS5 proxy.
"public void compile(Sentence<Clause> sentence) throws SourceCodeException
    {
        /*log.fine(""public WAMCompiledClause compile(Sentence<Term> sentence = "" + sentence + ""): called"");*/

        // Extract the clause to compile from the parsed sentence.
        Clause clause = sentence.getT();

        // Classify the sentence to compile by the different sentence types in the language.
        if (clause.isQuery())
        {
            compileQuery(clause);
        }
        else
        {
            // Initialise a nested symbol table for the current compilation scope, if it has not already been.
            if (scopeTable == null)
            {
                scopeTable = symbolTable.enterScope(scope);
            }

            // Check in the symbol table, if a compiled predicate with name matching the program clause exists, and if
            // not create it.
            SymbolKey predicateKey = scopeTable.getSymbolKey(clause.getHead().getName());
            Collection<Clause> clauseList = (List<Clause>) scopeTable.get(predicateKey, SymbolTableKeys.SYMKEY_PREDICATES);

            if (clauseList == null)
            {
                clauseList = new LinkedList<Clause>();
                scopeTable.put(predicateKey, SymbolTableKeys.SYMKEY_PREDICATES, clauseList);
                predicatesInScope.offer(predicateKey);
            }

            // Add the clause to compile to its parent predicate for compilation at the end of the current scope.
            clauseList.add(clause);
        }
    }","{@inheritDoc}

<p/>Compiles a sentence into a binary form, that provides a Java interface into the compiled structure.

<p/>The clausal sentence may be a query, or a program statement. If it is a query, it is compiled immediately. If
it is a clause, it is retained against the predicate which it forms part of, and compiled on the
{@link #endScope()} method is invoked."
"public void setMemberData(StructureMembers.Member m, Array data) {
    if (data == null)
      throw new IllegalArgumentException(""data cant be null"");

    memberData.put(m, data);
  }","/* Copy constructor.
This makes a local copy of all the data in the from StrucureData.
@param from copy from here

public StructureDataW (StructureData from) {
this(from.getStructureMembers());
List<StructureMembers.Member> members = getMembers();
for (StructureMembers.Member m : members) {
Array data = from.getArray(m);
setMemberData(m, data.copy());  // LOOK wont work for StructureData
}
}"
"public Field createFieldDateTimeDateAndTime(Field routeFieldParam) {
		if(routeFieldParam != null && this.serviceTicket != null) {
			routeFieldParam.setServiceTicket(this.serviceTicket);
		}

		if(routeFieldParam != null) {
			routeFieldParam.setTypeAsEnum(Field.Type.DateTime);
			routeFieldParam.setTypeMetaData(FieldMetaData.DateTime.DATE_AND_TIME);
		}

		return new Field(this.putJson(
				routeFieldParam, Version1.routeFieldCreate()));
	}","Create a new Date and time field.

@param routeFieldParam Field to Create.
@return Created Field."
"public Node.Nodes parseTagFileDirectives(String inFileName)
	        throws FileNotFoundException, JasperException, IOException {
        boolean isTagFileSave = isTagFile;
        boolean directiveOnlySave = directiveOnly;
        isTagFile = true;
        directiveOnly = true;
        Node.Nodes page = doParse(inFileName, null,
                             (URL) ctxt.getTagFileJarUrls().get(inFileName));
        directiveOnly = directiveOnlySave;
        isTagFile = isTagFileSave;
        return page;
    }","Extracts tag file directive information from the tag file with the
given name.

This is invoked by the compiler

@param inFileName The name of the tag file to be parsed."
"private static void addGroupByExpressionsToProjections(QueryPlanningInfo info) {
    if (info.groupBy == null || info.groupBy.getItems() == null || info.groupBy.getItems().size() == 0) {
      return;
    }
    OGroupBy newGroupBy = new OGroupBy(-1);
    int i = 0;
    for (OExpression exp : info.groupBy.getItems()) {
      if (exp.isAggregate()) {
        throw new OCommandExecutionException(""Cannot group by an aggregate function"");
      }
      boolean found = false;
      if (info.preAggregateProjection != null) {
        for (String alias : info.preAggregateProjection.getAllAliases()) {
          //if it's a simple identifier and it's the same as one of the projections in the query,
          //then the projection itself is used for GROUP BY without recalculating; in all the other cases, it is evaluated separately
          if (alias.equals(exp.getDefaultAlias().getStringValue()) && exp.isBaseIdentifier()) {
            found = true;
            newGroupBy.getItems().add(exp);
            break;
          }
        }
      }
      if (!found) {
        OProjectionItem newItem = new OProjectionItem(-1);
        newItem.setExpression(exp);
        OIdentifier groupByAlias = new OIdentifier(""_$$$GROUP_BY_ALIAS$$$_"" + (i++));
        newItem.setAlias(groupByAlias);
        if (info.preAggregateProjection == null) {
          info.preAggregateProjection = new OProjection(-1);
        }
        if (info.preAggregateProjection.getItems() == null) {
          info.preAggregateProjection.setItems(new ArrayList<>());
        }
        info.preAggregateProjection.getItems().add(newItem);
        newGroupBy.getItems().add(new OExpression(groupByAlias));
      }

      info.groupBy = newGroupBy;
    }

  }","if GROUP BY is performed on an expression that is not explicitly in the pre-aggregate projections, then that expression has to
be put in the pre-aggregate (only here, in subsequent steps it's removed)"
"public static void main(String[] args) {

        if (java.util.logging.LogManager.getLogManager().getClass().getName().equals(""org.jboss.logmanager.LogManager"")) {
            // Make sure our original stdio is properly captured.
            try {
                Class.forName(org.jboss.logmanager.handlers.ConsoleHandler.class.getName(), true, org.jboss.logmanager.handlers.ConsoleHandler.class.getClassLoader());
            } catch (Throwable ignored) {
            }
            // Install JBoss Stdio to avoid any nasty crosstalk, after command line arguments are processed.
            StdioContext.install();
            final StdioContext context = StdioContext.create(
                    new NullInputStream(),
                    new LoggingOutputStream(org.jboss.logmanager.Logger.getLogger(""stdout""), org.jboss.logmanager.Level.INFO),
                    new LoggingOutputStream(org.jboss.logmanager.Logger.getLogger(""stderr""), org.jboss.logmanager.Level.ERROR)
            );
            StdioContext.setStdioContextSelector(new SimpleStdioContextSelector(context));
        }

        try {
            Module.registerURLStreamHandlerFactoryModule(Module.getBootModuleLoader().loadModule(ModuleIdentifier.create(""org.jboss.vfs"")));

            final ParsedOptions options = determineEnvironment(args, new Properties(WildFlySecurityManager.getSystemPropertiesPrivileged()), WildFlySecurityManager.getSystemEnvironmentPrivileged(), ServerEnvironment.LaunchType.APPCLIENT);
            if(options == null) {
                //this happens if --version was specified
                return;
            }
            ServerEnvironment serverEnvironment = options.environment;
            final List<String> clientArgs = options.clientArguments;

            if (clientArgs.isEmpty()) {
                STDERR.println(AppClientLogger.ROOT_LOGGER.appClientNotSpecified());
                usage();
                abort(null);
            } else {

                final QName rootElement = new QName(Namespace.CURRENT.getUriString(), ""server"");
                final String file = clientArgs.get(0);
                final List<String> params = clientArgs.subList(1, clientArgs.size());
                final String deploymentName;
                final String earPath;

                int pos = file.lastIndexOf(""#"");
                if (pos == -1) {
                    earPath = file;
                    deploymentName = null;
                } else {
                    deploymentName = file.substring(pos + 1);
                    earPath = file.substring(0, pos);
                }

                File realFile = new File(earPath);

                if (!realFile.exists()) {
                    throw AppClientLogger.ROOT_LOGGER.cannotFindAppClientFile(realFile.getAbsoluteFile());
                }

                final Bootstrap bootstrap = Bootstrap.Factory.newInstance();
                final Bootstrap.Configuration configuration = new Bootstrap.Configuration(serverEnvironment);
                configuration.setModuleLoader(Module.getBootModuleLoader());
                final ExtensionRegistry extensionRegistry = configuration.getExtensionRegistry();
                final AppClientXml parser = new AppClientXml(Module.getBootModuleLoader(), extensionRegistry);
                final Bootstrap.ConfigurationPersisterFactory configurationPersisterFactory = new Bootstrap.ConfigurationPersisterFactory() {

                    @Override
                    public ExtensibleConfigurationPersister createConfigurationPersister(ServerEnvironment serverEnvironment, ExecutorService executorService) {
                        ApplicationClientConfigurationPersister persister = new ApplicationClientConfigurationPersister(earPath, deploymentName, options.hostUrl,options.propertiesFile, params,
                                serverEnvironment.getServerConfigurationFile().getBootFile(), rootElement, parser);
                        for (Namespace namespace : Namespace.domainValues()) {
                            if (!namespace.equals(Namespace.CURRENT)) {
                                persister.registerAdditionalRootElement(new QName(namespace.getUriString(), ""server""), parser);
                            }
                        }
                        extensionRegistry.setWriterRegistry(persister);
                        return persister;
                    }
                };
                configuration.setConfigurationPersisterFactory(configurationPersisterFactory);
                bootstrap.bootstrap(configuration, Collections.<ServiceActivator>emptyList()).get();
            }
        } catch (Throwable t) {
            abort(t);
        }
    }","The main method.

@param args the command-line arguments"
"public static long gcd(long a, long b)
	{
		if (a < 0L || b < 0L) {
			try {
				return gcd(safeAbs(a), safeAbs(b));
			} catch (ArithmeticException e) {
				throw new ArithmeticException(
					""Long overflow: gcd("" + a + "", "" + b + "")"");
			}
		}
		if (a == 0L) {
			return b;
		}
		if (b == 0L) {
			return a;
		}
		int shift = 0;
		while (((a | b) & 1L) == 0) {
			a >>= 1;
			b >>= 1;
			shift++;
		}
		while ((a & 1L) == 0L) {
			a >>= 1;
		}
		do {
			while ((b & 1L) == 0L) {
				b >>= 1;
			}
			if (a > b) {
				long tmp = b;
				b = a;
				a = tmp;
			}
			b -= a;
		} while (b != 0L);
		return a << shift;
	}","Returns the greatest common divisor of the absolute value of the
given two numbers. This method first computes the absolute values of
the given numbers, thus it doesn't accept {@code Long.MIN_VALUE}.
Also, note that if one of the given values is {@code 0}, this method
will return the absolute value of the second argument.
This method implements the binary GCD algorithm (also known as
Stein's algorithm). For further information on this algorithm, please
refer to <a href=""http://en.wikipedia.org/wiki/Binary_GCD_algorithm"">
Wikipedia</a>.

@param a the first number.
@param b the second number.

@return the greatest common divisor of {@code a} and {@code b}.

@throws ArithmeticException if {@code a} or {@code b} is equal to
{@code Long.MIN_VALUE}."
"public DeclarationFilter and(DeclarationFilter f) {
		final DeclarationFilter f1 = this;
		final DeclarationFilter f2 = f;
		return new DeclarationFilter() {
			public boolean matches(Declaration d) {
				return f1.matches(d) && f2.matches(d);
			}
		};
	}","Returns a filter that selects those declarations selected
by both this filter and another.

@param f filter to be composed with this one
@return a filter that selects those declarations selected by
both this filter and another"
"public InvCatalog getParentCatalog() {
    if (catalog != null) return catalog;
    return (parent != null) ? parent.getParentCatalog() : null;
  }","Get containing catalog.

@return containing catalog."
"public static void retainMatching(Collection<String> values,
      String... patterns) {
    retainMatching(values, Arrays.asList(patterns));
  }","Retains all values in the subject collection that are matched by
at least one of a collection of regular expressions.
<p>
This method is a convenience overload for
{@link #retainMatching(Collection, Collection)}.

@param values subject value collection
@param patterns patterns to match"
"private void updateMinimum(Node node)
    {
        // Check if a comparator was set.
        if (entryComparator != null)
        {
            // Use the comparator to compare the candidate new minimum with the current one and check if the new one
            // should be set.
            if (entryComparator.compare(node.element, minNode.element) < 0)
            {
                // Update the minimum node.
                minNode = node;
            }
        }

        // No comparator was set so use the natural ordering.
        else
        {
            // Cast the candidate new minimum element into a Comparable and compare it with the existing minimum
            // to check if the new one should be set.
            if (((Comparable) node.element).compareTo(minNode.element) < 0)
            {
                // Update the minimum node.
                minNode = node;
            }
        }
    }","Compares the specified node with the minimum and updates the minimum if neccessary. If a comparator was used to
create this heap then this comparator is used to perform the comparison. If no comparator was set then the
natural ordering of the element type is used. The element must implement the Comparable interface to support a
natural ordering. If it does not there will be a class cast exception thrown.

@param  node the node to compare with the current minimum.

@throws ClassCastException if the element in the specified node cannot be compared with elements currently in the
heap according to the heap's ordering.

@todo   Use the compare method."
"public void run() {
        try {
            readStream();
        } catch (EOFException eof) {
            // Normal disconnect
        } catch (SocketException se) {
            // Do nothing if the exception occured while shutting down the
            // component otherwise
            // log the error and try to establish a new connection
            if (!shutdown) {
                component.getManager().getLog().error(se);
                component.connectionLost();
            }
        } catch (XmlPullParserException ie) {
            component.getManager().getLog().error(ie);
        } catch (Exception e) {
            component.getManager().getLog().warn(e);
        }
    }","A dedicated thread loop for reading the stream and sending incoming
packets to the appropriate router."
"public InvService findService(String name) {
    if (name == null) return null;

    for (InvService s : services) {
      if (name.equals(s.getName())) return s;

      // look for nested servers
      if (s.getServiceType() == ServiceType.COMPOUND) {
        InvService result = s.findNestedService(name);
        if (result != null) return result;
      }
    }

    return null;
  }","Find the named service declared in the top level of this catalog.

@param name match this name
@return service that matches the given name, or null if none found."
"protected void onUpgrade(final SQLiteDatabase db, final int oldVersion,
			final int newVersion) {
		db.execSQL(upgradeSql(oldVersion, newVersion));
	}","Upgrades the table that represents the associated entity. This will
typically be an ALTER TABLE statement.

@param db
@param oldVersion
@param newVersion"
"public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel()
			throws Exception {
		ApplicationContext context = getContext();
		return getOrApply(new ChannelSecurityConfigurer<>(context))
				.getRegistry();
	}","Configures channel security. In order for this configuration to be useful at least
one mapping to a required channel must be provided.

<h2>Example Configuration</h2>

The example below demonstrates how to require HTTPs for every request. Only
requiring HTTPS for some requests is supported, but not recommended since an
application that allows for HTTP introduces many security vulnerabilities. For one
such example, read about <a
href=""https://en.wikipedia.org/wiki/Firesheep"">Firesheep</a>.

<pre>
&#064;Configuration
&#064;EnableWebSecurity
public class ChannelSecurityConfig extends WebSecurityConfigurerAdapter {

&#064;Override
protected void configure(HttpSecurity http) throws Exception {
http.authorizeRequests().antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;).and().formLogin()
.and().requiresChannel().anyRequest().requiresSecure();
}

&#064;Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
auth.inMemoryAuthentication().withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;);
}
}
</pre>


@return the {@link ChannelSecurityConfigurer} for further customizations
@throws Exception"
"private static void checkParametersWithinBound(ParameterizedType type) {
		Type[] arguments = type.getActualTypeArguments();
		TypeVariable<?>[] typeParameters = ((Class<?>)type.getRawType()).getTypeParameters();
		
		// a map of type arguments in the type, to fill in variables in the bounds 
		VarMap varMap = new VarMap(type);
		
		// for every bound on every parameter
		for (int i = 0; i < arguments.length; i++) {
			for (Type bound : typeParameters[i].getBounds()) {
				// replace type variables in the bound by their value
				Type replacedBound = varMap.map(bound);
				
				
				if (arguments[i] instanceof WildcardType) {
					WildcardType wildcardTypeParameter = (WildcardType) arguments[i];
					
					// Check if a type satisfying both the bounds of the variable and of the wildcard could exist
					
					// upper bounds must not be mutually exclusive
					for (Type wildcardUpperBound : wildcardTypeParameter.getUpperBounds()) {
						if (!couldHaveCommonSubtype(replacedBound, wildcardUpperBound)) {
							throw new TypeArgumentNotInBoundException(arguments[i], typeParameters[i], bound);
						}
					}
					// a lowerbound in the wildcard must satisfy every upperbound 
					for (Type wildcardLowerBound : wildcardTypeParameter.getLowerBounds()) {
						if (!GenericTypeReflector.isSuperType(replacedBound, wildcardLowerBound)) {
							throw new TypeArgumentNotInBoundException(arguments[i], typeParameters[i], bound);
						}
					}
				} else {
					if (! GenericTypeReflector.isSuperType(replacedBound, arguments[i])) {
						throw new TypeArgumentNotInBoundException(arguments[i], typeParameters[i], bound);
					}
				}
			}
		}
	}","Check if the type arguments of the given type are within the bounds declared on the type parameters.
Only the type arguments of the type itself are checked, the possible owner type is assumed to be valid.
<p>
It does not follow the checks defined in the
<a href=""http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.5"">JLS</a> because there are
several problems with those (see http://stackoverflow.com/questions/7003009 for one).
Instead, this applies some intuition and follows what Java compilers seem to do.

@param type possibly inconsistent type to check.
@throws IllegalArgumentException if the type arguments are not within the bounds"
"public OQueryAbstract setFetchPlan(final String fetchPlan) {
    OFetchHelper.checkFetchPlanValid(fetchPlan);
    if (fetchPlan != null && fetchPlan.length() == 0)
      this.fetchPlan = null;
    else
      this.fetchPlan = fetchPlan;
    return this;
  }",Sets the fetch plan to use.
"private int hash32shift(int key)
    {
        key += hash2seed;
        key = ~key + (key << 15);
        key = key ^ (key >>> 12);
        key = key + (key << 2);
        key = key ^ (key >>> 4);
        key = key * 2057;
        key = key ^ (key >>> 16);

        return key;
    }","Thomas Wang's 32-bit shift hash function. <a href=""http://www.concentric.net/~Ttwang/tech/inthash.htm""/>
http://www.concentric.net/~Ttwang/tech/inthash.htm</a>

@param  key The integer to compute a hash of.

@return A hash of the integer."
"@XmlElementDecl(namespace = ""http://www.immoxml.de"", name = ""abdatum"")
    @XmlJavaTypeAdapter(Adapter4 .class)
    public JAXBElement<Calendar> createAbdatum(Calendar value) {
        return new JAXBElement<Calendar>(_Abdatum_QNAME, Calendar.class, null, value);
    }",Create an instance of {@link JAXBElement }{@code <}{@link Calendar }{@code >}}
"private final void addByName(final String name, final Unit newUnit)
			throws UnitExistsException {
		if (name != null) {
			addUnique(nameMap, canonicalize(name), newUnit);
		}
	}","Adds a unit to the database by name.

@param name
The name of the unit. If <code>null</code> then the unit is
not added.
@param newUnit
The unit to be added.
@throws UnitExistsException
Attempt to redefine an existing unit."
"public static boolean isValid(Rect rect) {
        return rect.left < rect.right && rect.top < rect.bottom;
    }","Check if the rectangle is valid

@param rect rectangle
@return true if valid
@since 1.3.1"
"public String toRegexForFixedDate(Date date) {
    StringBuilder buf = new StringBuilder();
    Converter<Object> p = headTokenConverter;
    while (p != null) {
      if (p instanceof LiteralConverter) {
        buf.append(p.convert(null));
      } else if (p instanceof IntegerTokenConverter) {
        buf.append(FileFinder.regexEscapePath(""(\\d+)""));
      } else if (p instanceof DateTokenConverter) {
        DateTokenConverter<Object> dtc = (DateTokenConverter<Object>) p;
        if (dtc.isPrimary()) {
          buf.append(p.convert(date));
        } else {
          buf.append(FileFinder.regexEscapePath(dtc.toRegex()));
        }
      }
      p = p.getNext();
    }
    return buf.toString();
  }","Given date, convert this instance to a regular expression.

Used to compute sub-regex when the pattern has both %d and %i, and the
date is known.

@param date - date to be converted"
"public static void equalsOrDie(String a, String b) {
        if (a == null && b == null) {
            return;
        }
        if (a == null || b == null) {
            die(""Values not equal value a="", a, ""value b="", b);
        }

        char[] ac = FastStringUtils.toCharArray(a);
        char[] bc = FastStringUtils.toCharArray(b);
        Chr.equalsOrDie(ac, bc);
    }","See if they are equal or die
@param a a
@param b b"
"private String getExposedPropertyOrParamName(ActionInputParameter inputParameter) {
        final Expose expose = inputParameter.getAnnotation(Expose.class);
        String property;
        if (expose != null) {
            property = expose.value();
        } else {
            property = inputParameter.getParameterName();
        }
        return property;
    }","Gets exposed property or parameter name.

@param inputParameter for exposure
@return property name"
"public static ByteBuffer putTimeOnlyAsString(ByteBuffer buffer, long value)
    {
        buffer = putTimeOnlyAsString(buffer, value, true);

        return buffer;
    }","Writes a time of day with milliseconds in the format HH:MM:SS[.sss], into a byte buffer. The specified buffer
will be enlarged if necessary using the specified byte buffer pool.

@param  buffer The initial buffer to write to.
@param  value  The time of day since midnight, in milliseconds.

@return The buffer written to."
"public Integer getLineNumber(Member member) {
    Preconditions.checkArgument(
        type == member.getDeclaringClass(),
        ""Member %s belongs to %s, not %s"",
        member,
        member.getDeclaringClass(),
        type);
    return lines.get(memberKey(member));
  }","Get the line number associated with the given member.

@param member a field, constructor, or method belonging to the class used during construction
@return the wrapped line number, or null if not available
@throws IllegalArgumentException if the member does not belong to the class used during
construction"
"@CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnDispose(Action onDispose) {
        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION, onDispose);
    }","Calls the shared {@code Action} if a CompletableObserver subscribed to the current
Completable disposes the common Disposable it received via onSubscribe.
<p>
<img width=""640"" height=""589"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png"" alt="""">
<dl>
<dt><b>Scheduler:</b></dt>
<dd>{@code doOnDispose} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>
@param onDispose the action to call when the child subscriber disposes the subscription
@return the new Completable instance
@throws NullPointerException if onDispose is null"
"@Override
    public String readableSize(String database) {
        long size = size(database);
        return GeoPackageIOUtils.formatBytes(size);
    }",{@inheritDoc}
"public static double acuteAngle( LineSegment2D_I32 line0 , LineSegment2D_I32 line1 ) {
		int dx0 = line0.b.x - line0.a.x;
		int dy0 = line0.b.y - line0.a.y;
		int dx1 = line1.b.x - line1.a.x;
		int dy1 = line1.b.y - line1.a.y;

		double bottom = Math.sqrt(dx0*dx0 + dy0*dy0) * Math.sqrt(dx1*dx1 + dy1*dy1);
		return Math.acos((dx0*dx1 + dy0*dy1)/bottom);
	}","Computes the acute angle between the two lines.  Does not check for intersection

@param line0 First line
@param line1 Second line
@return Acute angle in radians"
"@SuppressWarnings(""unchecked"")
  public void begin(InterpretationContext ec, String localName,
      Attributes attributes) throws ActionException {
    // We are just beginning, reset variables
    appender = null;
    inError = false;

    String className = attributes.getValue(CLASS_ATTRIBUTE);
    if (OptionHelper.isEmpty(className)) {
      addError(""Missing class name for appender. Near ["" + localName
          + ""] line "" + getLineNumber(ec));
      inError = true;
      return;
    }

    try {
      addInfo(""About to instantiate appender of type ["" + className + ""]"");
      warnDeprecated(className);

      appender = (Appender<E>) OptionHelper.instantiateByClassName(className,
          ch.qos.logback.core.Appender.class, context);

      appender.setContext(context);

      String appenderName = ec.subst(attributes.getValue(NAME_ATTRIBUTE));

      if (OptionHelper.isEmpty(appenderName)) {
        addWarn(""No appender name given for appender of type "" + className
            + ""]."");
      } else {
        appender.setName(appenderName);
        addInfo(""Naming appender as ["" + appenderName + ""]"");
      }

      // The execution context contains a bag which contains the appenders
      // created thus far.
      HashMap<String, Appender<E>> appenderBag = (HashMap<String, Appender<E>>) ec.getObjectMap().get(
          ActionConst.APPENDER_BAG);

      // add the appender just created to the appender bag.
      appenderBag.put(appenderName, appender);

      ec.pushObject(appender);
    } catch (Exception oops) {
      inError = true;
      addError(""Could not create an Appender of type ["" + className + ""]."",
          oops);
      throw new ActionException(oops);
    }
  }","Instantiates an appender of the given class and sets its name.

The appender thus generated is placed in the {@link InterpretationContext}'s
appender bag."
"protected String createRedirectUrl(final String serviceUrl) {
		return CommonUtils.constructRedirectUrl(this.loginUrl,
				this.serviceProperties.getServiceParameter(), serviceUrl,
				this.serviceProperties.isSendRenew(), false);
	}","Constructs the Url for Redirection to the CAS server. Default implementation relies
on the CAS client to do the bulk of the work.

@param serviceUrl the service url that should be included.
@return the redirect url. CANNOT be NULL."
"public LongProperty field(LongGetter<M> getter, LongSetter<M> setter) {
		return add(new BeanPropertyField<>(
				this::propertyWasChanged,
				getter::apply, (m, number) -> setter.accept(m, number.longValue()),
				SimpleLongProperty::new));
	}",/* Field type Long
"public static String clientFacingEndpoints(final ClusterMember[] members)
    {
        final StringBuilder builder = new StringBuilder(100);

        for (int i = 0, length = members.length; i < length; i++)
        {
            if (0 != i)
            {
                builder.append(',');
            }

            final ClusterMember member = members[i];
            builder.append(member.id()).append('=').append(member.clientFacingEndpoint());
        }

        return builder.toString();
    }","Create a string of member facing endpoints by id in format {@code id=endpoint,id=endpoint, ...}.

@param members for which the endpoints string will be generated.
@return  a string of member facing endpoints by id."
"@Override
  public CalendarDateRange makeCalendarDateRange(ucar.nc2.time.Calendar cal) {
    CalendarDateUnit cdu = CalendarDateUnit.of(cal, timeUnit.getField(), refDate);
    CalendarDate start = cdu.makeCalendarDate( timeUnit.getValue() * timeIntervals.get(0).getBounds2());
    CalendarDate end = cdu.makeCalendarDate(timeUnit.getValue() * timeIntervals.get(getSize()-1).getBounds2());
    return CalendarDateRange.of(start, end);
  }","Make calendar date range, using the first and last ending bounds
@param cal  optional calendar, may be null
@return  calendar date range"
"@XmlTransient
	public Integer getFieldValueAsInt(String fieldNameParam) {
		Field fieldWithName = this.getField(fieldNameParam);
		return (fieldWithName == null) ? null : fieldWithName.getFieldValueAsInteger();
	}","<p>
Returns the value of the {@code fieldNameParam} requested.

<p>
The {@code fieldNameParam} <b>is not</b> case sensitive.

<p>
A {@code null} will be returned if;
<ul>
<li>{@code fieldNameParam} is {@code null} or empty.</li>
<li>{@code getFormFields()} is {@code null} or empty.</li>
<li>Field is not found by {@code fieldNameParam}.</li>
<li>Field Value is not of type {@code Number}.</li>
</ul>

@param fieldNameParam The name of the Form Field as in Fluid.
@return The value for the Form Field as {@code Integer}.

@see Field.Type#Decimal"
"@Override
  public T get(Object iKey) {
    final Object lastIndexResult = lastIndex.get(iKey);

    final Set<OIdentifiable> result = new HashSet<OIdentifiable>();

    if (lastIndexResult != null)
      result.addAll(applyTailIndexes(lastIndexResult));

    return (T) result;
  }",{@inheritDoc}
"public static byte[] decodeGssExportedName(byte[] encodedName) {
        if (encodedName[0] != 0x04 || encodedName[1] != 0x01)
            return null;

        int mechOidLength = (encodedName[2] & 0xFF) << 8; //MECH_OID_LEN
        mechOidLength += (encodedName[3] & 0xFF);      // MECH_OID_LEN

        byte[] oidArray = new byte[mechOidLength];
        System.arraycopy(encodedName, 4, oidArray, 0, mechOidLength);

        for (int i = 0; i < mechOidLength; i++) {
            if (gssUpMechOidArray[i] != oidArray[i]) {
                return null;
            }
        }

        int offset = 4 + mechOidLength;
        int nameLength = (encodedName[offset] & 0xFF) << 24;
        nameLength += (encodedName[++offset] & 0xFF) << 16;
        nameLength += (encodedName[++offset] & 0xFF) << 8;
        nameLength += (encodedName[++offset] & 0xFF);

        byte[] name = new byte[nameLength];
        System.arraycopy(encodedName, ++offset, name, 0, nameLength);

        return name;
    }","<p>
Decodes a GSS exported name that has been encoded with the GSSUP mechanism OID. See {@code createGSSExportedName}
for a description of the encoding format.
</p>

@param encodedName the encoded exported name.
@return a {@code byte[]} representing the decoded exported name.
@see #createGSSExportedName(byte[], byte[])"
"@Override
    public Blob convert(IComplexNDArray toConvert) throws IOException, SQLException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(bos);

        Nd4j.writeComplex(toConvert, dos);

        byte[] bytes = bos.toByteArray();
        Connection c = dataSource.getConnection();
        Blob b = c.createBlob();
        b.setBytes(1, bytes);
        return b;
    }","Convert an ndarray to a blob

@param toConvert the complex ndarray to convert
@return the converted complex ndarray"
"public Set getAttachedTimers() {
		final Node node = getAttachedTimersNode(false);
		return node != null ? node.getChildrenNames() : Collections.emptySet();								
	}","Returns the set of timers attached to the ac

@return"
"public void cascadeRemove(String id) {
		Process entity = access().getProcess(id);
		List<HistoryOrder> historyOrders = access().getHistoryOrders(null, new QueryFilter().setProcessId(id));

		for(HistoryOrder historyOrder : historyOrders) {
			ServiceContext.getEngine().order().cascadeRemove(historyOrder.getId());
		}
		access().deleteProcess(entity);
		clear(entity);
	}",级联删除指定流程定义的所有数据
"public String getString(final String key) {
		CharSequence cs = (CharSequence) map.get(key);
		return cs == null ? null : cs.toString();
	}",Returns the string value with the specified key.
"private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) {
    final List<String> columnNames = typeInfo.getAllStructFieldNames();
    final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos();
    return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes));

  }",An optional group containing multiple elements
"public static Rollup.Type getRollupComputer(RollupType srcType, Granularity srcGran) {
        switch (srcType) {
            case COUNTER:
                return Rollup.CounterFromCounter;
            case TIMER:
                return Rollup.TimerFromTimer;
            case GAUGE:
                return Rollup.GaugeFromGauge;
            case BF_BASIC:
                return srcGran == Granularity.FULL ? Rollup.BasicFromRaw : Rollup.BasicFromBasic;
            case SET:
                return Rollup.SetFromSet;
            default:
                break;
        }
        throw new IllegalArgumentException(String.format(""Cannot compute rollups for %s from %s"", srcType.name(), srcGran.shortName()));
    }",determine which DataType to use for serialization.
"public static SrcGen4JConfig createAndInit(final SrcGen4JContext context, final File configFile) throws UnmarshalObjectException {
        try {
            final JaxbHelper helper = new JaxbHelper();
            final SrcGen4JConfig config = helper.create(configFile, JAXBContext.newInstance(SrcGen4JConfig.class,
                    VelocityGeneratorConfig.class, ParameterizedTemplateParserConfig.class, ParameterizedTemplateGeneratorConfig.class));
            config.init(context, Utils4J.getCanonicalFile(configFile.getParentFile()));
            return config;
        } catch (final JAXBException ex) {
            throw new UnmarshalObjectException(""Error reading the configuration: "" + configFile, ex);
        }
    }","Creates and initializes a SrcGen4J configuration from a configuration file that contains ONLY generators/parsers of type
{@link ParameterizedTemplateParser} and {@link ParameterizedTemplateGenerator}.

@param context
Current context - Cannot be NULL.
@param configFile
XML configuration file to read - Cannot be NULL.

@return New configuration instance.

@throws UnmarshalObjectException
Error reading the configuration."
"public void setIcon(long featureId, GeometryType geometryType, IconRow icon) {
        featureStyleExtension.setIcon(tableName, featureId, geometryType, icon);
    }","Get the icon of the feature, searching in order: feature geometry type
icon, feature default icon, table geometry type icon, table default icon

@param featureId    feature id
@param geometryType geometry type
@param icon         icon row"
"public static void useRelaxedHTTPSValidation(String protocol) {
        config = RestAssured.config().sslConfig(SSLConfig.sslConfig().relaxedHTTPSValidation(protocol));
    }","Use relaxed HTTP validation with a specific protocol. This means that you'll trust all hosts regardless if the SSL certificate is invalid. By using this
method you don't need to specify a keystore (see {@link #keyStore(String, String)} or trust store (see {@link #trustStore(java.security.KeyStore)}.
<p>
This is just a shortcut for:
</p>
<pre>
RestAssured.config = RestAssured.config().sslConfig(sslConfig().relaxedHTTPSValidation(&lt;protocol&gt;));
</pre>

@param protocol The standard name of the requested protocol. See the SSLContext section in the <a href=""https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext"">Java Cryptography Architecture Standard Algorithm Name Documentation</a> for information about standard protocol names."
"public static boolean isInfiniteH(Point4D_F64 p , double tol ) {
		double n = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
		return Math.abs(p.w) <= n*tol;
	}","Checks to see if the homogenous 3D point lies on the plane at infinity

@param p (Input) Homogenous point
@param tol (Input) tolerance. Try EPS
@return true if on plane at infinity"
"public List<InterceptorBean> createInterceptors(
    StageLibraryTask stageLib,
    StageConfiguration stageConfiguration,
    StageDefinition stageDefinition,
    InterceptorCreatorContextBuilder contextBuilder,
    InterceptorCreator.InterceptorType interceptorType,
    List<Issue> issues
  ) {
    List<InterceptorBean> beans = new ArrayList<>();
    if(contextBuilder == null) {
      return beans;
    }

    for(InterceptorDefinition definition : stageLib.getInterceptorDefinitions()) {
      InterceptorBean bean = createInterceptor(stageLib, definition, stageConfiguration, stageDefinition, contextBuilder, interceptorType, issues);
      if (bean != null) {
        beans.add(bean);
      }
    }

    return beans;
  }",Create interceptors for given stage.
"public static long getEditedDuration(TrakBox track) {
        List<Edit> edits = track.getEdits();
        if (edits == null)
            return track.getDuration();

        long duration = 0;
        for (Edit edit : edits) {
            duration += edit.getDuration();
        }
        return duration;
    }","Calculates track duration considering edits

@param track
@return"
"public void stopPageWriteInCacheTimer() {
    final long endTs = nanoTimer.getNano();
    final long timeDiff = (endTs - timeStamps.pop());

    performanceCountersHolder.pageWriteToCacheTime += timeDiff;
    performanceCountersHolder.pageWriteToCacheCount++;

    for (Component component : componentsStack) {
      final String componentName = component.name;
      PerformanceCountersHolder cHolder = countersByComponent
          .computeIfAbsent(componentName, k -> component.type.newCountersHolder());

      cHolder.pageWriteToCacheTime += timeDiff;
      cHolder.pageWriteToCacheCount++;
    }

    makeSnapshotIfNeeded(endTs);
  }","Stops and records results of timer which counts how much time was spent to write page to disk cache.
<p>
If you wish to gather statistic for current durable component please call
{@link #startComponentOperation(String, ComponentType)} method before the call and {@link #completeComponentOperation()} after
the call."
"public static Locale getLocale(final String language, final String country) {
        return getLocale(language, country, null);
    }",Returns Locale from cache.
"public static MediaAudioConverter createConverter(String description,
      int sampleRate, Layout layout, Type format) {
    if (description != DEFAULT_JAVA_AUDIO)
      throw new RuntimeException(""Unsupported converter type"");
    return new StereoS16AudioConverter(sampleRate, layout, format);
  }","Create a converter.
@param description A descriptor string for the converter.
@param sampleRate Sample rate of MediaAudio objects that will be converted to/from.
@param layout Channel layout of MediaAudio objects that will be converted to/from.
@param format Sample format of MediaAudio objets that will be converted to/from.
@return A converter to use"
"private RhinoScriptBuilder initScriptBuilder() {
    try {
      RhinoScriptBuilder builder = null;
      if (scope == null) {
        builder = RhinoScriptBuilder.newChain().evaluateChain(getScriptAsStream(), DEFAULT_CSSLINT_JS);
        scope = builder.getScope();
      } else {
        builder = RhinoScriptBuilder.newChain(scope);
      }
      return builder;
    } catch (final IOException ex) {
      throw new IllegalStateException(""Failed reading init script"", ex);
    }
  }",Initialize script builder for evaluation.
"private void computeHashCode()
    {
        hashCode = 0;

        for (int i = 0; i < length; i++)
        {
            hashCode = (31 * hashCode) + data.get(i + offset);
        }
    }","Computes and caches in the {@link #hashCode} field, a hash code for this string."
"public static RuntimeException propagate(Throwable t)
	{
		Parameters.checkNotNull(t);
		if (t instanceof RuntimeException) {
			throw (RuntimeException) t;
		} else if (t instanceof Error) {
			throw (Error) t;
		}
		throw new RuntimeException(t);
	}","Re-throws the given {@code Throwable} if it is already an instance of
{@code RuntimeException} or {@link Error}, and, if not, wraps it in a
{@code RuntimeException} before throwing it.

@param t the {@code Throwable} to propagate.

@return nothing (this method always throws a {@code Throwable}).

@throws NullPointerException if {@code t} is {@code null}.
@throws RuntimeException if {@code t} is already an instance of
{@code RuntimeException} or if {@code t} is neither an instance
of {@code RuntimeException} nor an instance of {@code Error}.
@throws Error if {@code t} is an instance of {@code Error}."
"public void
    outputBytes(byte[] bytes, int start, int count)
            throws IOException
    {
        if(DUMPDATA) {
            System.err.printf(""output %d/%d:"", start, count);
            for(int i = 0; i < count; i++) {
                System.err.printf("" %02x"", bytes[i]);
            }
            System.err.println("""");
            System.err.flush();
        }
        output.write(bytes, start, count);
    }","Deliberate choke point for debugging

@param bytes
@param start
@param count
@throws IOException"
"public int read(char ch[], int offset, int length) throws IOException {
        if (length > fBuffer.length) {
            length = fBuffer.length;
        }
        int count = fInputStream.read(fBuffer, 0, length);
        for (int i = 0; i < count; i++) {
            int b0 = fBuffer[i];
            if (b0 < 0) {
                throw new IOException(Localizer.getMessage(""jsp.error.xml.invalidASCII"",
							   Integer.toString(b0)));
            }
            ch[offset + i] = (char)b0;
        }
        return count;
    }","Read characters into a portion of an array.  This method will block
until some input is available, an I/O error occurs, or the end of the
stream is reached.

@param      ch     Destination buffer
@param      offset Offset at which to start storing characters
@param      length Maximum number of characters to read

@return     The number of characters read, or -1 if the end of the
stream has been reached

@exception  IOException  If an I/O error occurs"
"public Field createFieldTrueFalse(Field formFieldParam)
    {
        if(formFieldParam != null && this.serviceTicket != null) {
            formFieldParam.setServiceTicket(this.serviceTicket);
        }

        if(formFieldParam != null) {
            formFieldParam.setTypeAsEnum(Field.Type.TrueFalse);
            formFieldParam.setTypeMetaData(FieldMetaData.TrueFalse.TRUE_FALSE);
        }

        return new Field(this.putJson(
                formFieldParam, WS.Path.UserField.Version1.userFieldCreate()));
    }","Create a new True False field.

@param formFieldParam Field to Create.
@return Created Field."
"public static <U, R> Flowable<R> multicastSelector(
            final Callable<? extends ConnectableFlowable<U>> connectableFactory,
            final Function<? super Flowable<U>, ? extends Publisher<R>> selector) {
        return new MulticastFlowable<R, U>(connectableFactory, selector);
    }","Given a connectable observable factory, it multicasts over the generated
ConnectableObservable via a selector function.
@param <U> the connectable observable type
@param <R> the result type
@param connectableFactory the factory that returns a ConnectableFlowable for each individual subscriber
@param selector the function that receives a Flowable and should return another Flowable that will be subscribed to
@return the new Observable instance"
"public void applyServiceAccount(ServiceAccount serviceAccount, String sourceName) throws Exception {
        String namespace = getNamespace();
        String id = getName(serviceAccount);
        Objects.requireNonNull(id, ""No name for "" + serviceAccount + "" "" + sourceName);
        if (isServicesOnlyMode()) {
            log.debug(""Only processing Services right now so ignoring ServiceAccount: "" + id);
            return;
        }
        ServiceAccount old = kubernetesClient.serviceAccounts().inNamespace(namespace).withName(id).get();
        if (isRunning(old)) {
            if (UserConfigurationCompare.configEqual(serviceAccount, old)) {
                log.info(""ServiceAccount has not changed so not doing anything"");
            } else {
                if (isRecreateMode()) {
                    kubernetesClient.serviceAccounts().inNamespace(namespace).withName(id).delete();
                    doCreateServiceAccount(serviceAccount, namespace, sourceName);
                } else {
                    log.info(""Updating a ServiceAccount from "" + sourceName);
                    try {
                        Object answer = kubernetesClient.serviceAccounts().inNamespace(namespace).withName(id).replace(serviceAccount);
                        logGeneratedEntity(""Updated ServiceAccount: "", namespace, serviceAccount, answer);
                    } catch (Exception e) {
                        onApplyError(""Failed to update ServiceAccount from "" + sourceName + "". "" + e + "". "" + serviceAccount, e);
                    }
                }
            }
        } else {
            if (!isAllowCreate()) {
                log.warn(""Creation disabled so not creating a ServiceAccount from "" + sourceName + "" namespace "" + namespace + "" name "" + getName(serviceAccount));
            } else {
                doCreateServiceAccount(serviceAccount, namespace, sourceName);
            }
        }
    }",Creates/updates a service account and processes it returning the processed DTOs
"private void makeMyUI() {

    AbstractAction incrFontAction = new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        stnRender.incrFontSize();
        redraw();
      }
    };
    BAMutil.setActionProperties(incrFontAction, ""FontIncr"", ""increase font size"", false, 'I', -1);

    AbstractAction decrFontAction = new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        stnRender.decrFontSize();
        redraw();
      }
    };
    BAMutil.setActionProperties(decrFontAction, ""FontDecr"", ""decrease font size"", false, 'D', -1);

    JCheckBox declutCB = new JCheckBox(""Declutter"", true);
    declutCB.addActionListener(e -> {
        setDeclutter(((JCheckBox) e.getSource()).isSelected());
    });

    AbstractAction bbAction = new AbstractAction() {
      public void actionPerformed(ActionEvent e) {
        geoSelectionMode = !geoSelectionMode;
        np.setGeoSelectionMode(geoSelectionMode);
        redraw();
      }
    };
    BAMutil.setActionProperties(bbAction, ""geoselect"", ""select geo region"", true, 'B', -1);
    bbAction.putValue(BAMutil.STATE, geoSelectionMode ? Boolean.TRUE : Boolean.FALSE);

    // the fields use a PrefPanel
    if (regionSelect) {
      minmaxPP = new PrefPanel(null, null);
      minLonField = minmaxPP.addDoubleField(""minLon"", ""minLon"", geoSelection.getMinX(), nfracDig, 0, 0, null);
      maxLonField = minmaxPP.addDoubleField(""maxLon"", ""maxLon"", geoSelection.getMaxX(), nfracDig, 2, 0, null);
      minLatField = minmaxPP.addDoubleField(""minLat"", ""minLat"", geoSelection.getMinY(), nfracDig, 4, 0, null);
      maxLatField = minmaxPP.addDoubleField(""maxLat"", ""maxLat"", geoSelection.getMaxY(), nfracDig, 6, 0, null);

      minmaxPP.finish(true, BorderLayout.EAST);
      minmaxPP.addActionListener(e -> {
          // ""Apply"" was called
          double minLon = minLonField.getDouble();
          double minLat = minLatField.getDouble();
          double maxLon = maxLonField.getDouble();
          double maxLat = maxLatField.getDouble();
          LatLonRect llbb = new LatLonRect(new LatLonPointImpl(minLat, minLon),
                  new LatLonPointImpl(maxLat, maxLon));
          setGeoSelection(llbb);
          redraw();
      });


    }

    // assemble
    setLayout(new BorderLayout());

    if (stationSelect) {
      BAMutil.addActionToContainer(toolPanel, incrFontAction);
      BAMutil.addActionToContainer(toolPanel, decrFontAction);
      toolPanel.add(declutCB);
    }

    if (regionSelect) BAMutil.addActionToContainer(toolPanel, bbAction);
    if (dateSelect) BAMutil.addActionToContainer(toolPanel, dateAction);

    JPanel upperPanel = new JPanel(new BorderLayout());
    if (regionSelect) upperPanel.add(minmaxPP, BorderLayout.NORTH);
    upperPanel.add(toolPanel, BorderLayout.SOUTH);

    JPanel statusPanel = new JPanel(new BorderLayout());
    statusPanel.setBorder(new EtchedBorder());
    JLabel positionLabel = new JLabel(""position"");
    statusPanel.add(positionLabel, BorderLayout.CENTER);

    np.setPositionLabel(positionLabel);
    add(upperPanel, BorderLayout.NORTH);
    add(np, BorderLayout.CENTER);
    add(statusPanel, BorderLayout.SOUTH);
  }",override superclass
"public static <T> T[] reverse(T[] a)
	{
		int len = a.length;
		T[] copy = newArray(a.getClass().getComponentType(), len);
		for (int i = 0; i < len; i++) {
			copy[i] = a[len - i - 1];
		}
		return copy;
	}","Returns a new array containing the same elements as the given one,
but in reverse order.

@param <T> the type of the elements in the array to reverse.
@param a the array to reverse.

@return the reversed array.

@throws NullPointerException if {@code a} is {@code null}."
"public boolean offer(T t) {
        if (once.get()) {
            return false;
        }
        ObjectHelper.requireNonNull(t, ""offer called with null. Null values are generally not allowed in 2.x operators and sources."");
        if (fusionMode == QueueSubscription.NONE) {
            if (queue.offer(t)) {
                drain();
                return true;
            }
        }
        return false;
    }","Tries to offer an item into the internal queue and returns false
if the queue is full.
@param t the item to offer, not null
@return true if successful, false if the queue is full"
"protected void endPrefixMapping(String prefix) throws SAXException {
        if (getContentHandler() != null) {
            if (namespaces.containsKey(prefix)) {
                getContentHandler().endPrefixMapping(prefix);
                namespaces.remove(prefix);
            }
        }
    }","Ends the prefix mapping for the given prefix.

@see org.xml.sax.ContentHandler#endPrefixMapping(String)"
"public FilterableCollection<V> valuesByValue() {

        if (collectionOfValuesByValue == null) {
            collectionOfValuesByValue = new AbstractFilterableCollection<V>() {

                @Override
                public Iterator<V> iterator() {

                    return new TransactionalBidiTreeMapIterator<V>(VALUE) {

                        @Override
                        protected V doGetNext() {
                            return (V)lastReturnedNode.getData(VALUE);
                        }
                    };
                }

                @Override
                public int size() {
                    return TransactionalBidiTreeMap.this.size();
                }

                @Override
                public boolean contains(Object o) {
                    return containsValue(o);
                }

                @Override
                public boolean remove(Object o) {

                    int oldnodeCount = nodeCount;

                    removeValue(o);

                    return nodeCount != oldnodeCount;
                }

                @Override
                public boolean removeAll(Collection<?> c) {

                    boolean     modified = false;
                    Iterator<?> iter     = c.iterator();

                    while (iter.hasNext()) {
                        if (removeValue(iter.next()) != null) {
                            modified = true;
                        }
                    }

                    return modified;
                }

                @Override
                public void clear() {
                    TransactionalBidiTreeMap.this.clear();
                }
            };
        }

        return collectionOfValuesByValue;
    }","Returns a collection view of the values contained in this
map. The collection is backed by the map, so changes to the map
are reflected in the collection, and vice-versa. If the map is
modified while an iteration over the collection is in progress,
the results of the iteration are undefined. The collection
supports element removal, which removes the corresponding
mapping from the map, via the Iterator.remove,
Collection.remove, removeAll, retainAll and clear operations.
It does not support the add or addAll operations.<p>

The difference between this method and values is that values's
iterator() method returns an iterator that iterates over the
values in ascending order by key. This method's iterator method
iterates over the values in ascending order by value.

@return a collection view of the values contained in this map."
"public static String format(String messageFormat, Object... arguments) {
    return Messages.format(messageFormat, arguments);
  }",TODO(lukes): inline into callers
"public <T> T getValue(final String key, final T def) {
		T val = getValue(key);

		if (val == null) {
			if (map.containsKey(key)) {
				return null;
			}
			return def;
		}

		return val;
	}",Like {@link #getValue(String)} but specifies a default value to return if there is no entry.
"@Override
    public boolean createFile(File file) {

        // Get the database name
        String database = GeoPackageIOUtils.getFileNameWithoutExtension(file);

        // Create the GeoPackage
        boolean created = createFile(database, file);

        return created;
    }",{@inheritDoc}
"public Key<?> fixAnnotations(Key<?> key) {
    return key.getAnnotation() == null
        ? key
        : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType());
  }","Replace annotation instances with annotation types, this is only appropriate for testing if a
key is bound and not for injecting.

<p>See Guice bug 125, https://github.com/google/guice/issues/125"
"public static boolean isSolvable(EightPuzzleState state)
    {
        // Take a copy of the puzzle to check. This is done because this puzzle will be updated in-place and the
        // original is to be preserved.
        EightPuzzleState checkState;

        try
        {
            checkState = (EightPuzzleState) state.clone();
        }
        catch (CloneNotSupportedException e)
        {
            throw new IllegalStateException(""Puzzle state could not be cloned."", e);
        }

        // Create the goal state to check against when swapping tiles into position.
        EightPuzzleState goalState = getGoalState();

        // Count the number of illegal swaps needed to put the puzzle in order.
        int illegalSwaps = 0;

        // Loop over the whole board, left to right, to to bottom
        for (int j = 0; j < 3; j++)
        {
            for (int i = 0; i < 3; i++)
            {
                // Find out from the goal state what tile should be at this position.
                char t = goalState.getTileAt(i, j);

                // Swap the tile into its goal position keeping count of the total number of illegal swaps.
                illegalSwaps += checkState.swapTileToLocationCountingIllegal(t, i, j);
            }
        }

        // Check if the number of illegal swaps is even in which case the puzzle is solvable, or odd in which case it
        // is not solvable.
        return (illegalSwaps % 2) == 0;
    }","To check for solvability the empty tile is moved to its goal position and then the number of swaps needed to put
the other tiles in position is counted. For an odd number of rows on a square puzzle there must be an even number
of swaps, for an even number of rows an odd number of swaps.

@param  state A puzzle state to test for solvability.

@return True if the puzzle is solvable, false if it is not."
"public static <A,B,C,D,E,F,G> Tuple7<A,B,C,D,E,F,G> of(A a, B b, C c, D d, E e, F f, G g) {
        return new Tuple7<>(a, b, c, d, e, f, g);
    }",Public static factory method
"public void stopCommitTimer() {
    final long endTs = nanoTimer.getNano();
    final long timeDiff = (endTs - timeStamps.pop());

    performanceCountersHolder.commitTime += timeDiff;
    performanceCountersHolder.commitCount++;

    makeSnapshotIfNeeded(endTs);
  }",Stops and records results of timer which counts how much time was spent on atomic operation commit.
"public void copy(String from, String to, boolean withStreams) throws StorageClientException, AccessDeniedException, IOException {
        long ts = System.currentTimeMillis();
        try {
            checkOpen();
            // To Copy, get the to object out and copy everything over.
            Content f = get(from);
            if (f == null) {
                throw new StorageClientException("" Source content "" + from + "" does not exist"");
            }
            if (f.getProperty(UUID_FIELD) == null) {
                LOGGER.warn(""Bad Content item with no ID cant be copied {} "", f);
                throw new StorageClientException("" Source content "" + from + ""  Has no "" + UUID_FIELD);
            }
            Content t = get(to);
            if (t != null) {
                LOGGER.debug(""Deleting {} "", to);
                delete(to);
            }
            Set<String> streams = Sets.newHashSet();
            Map<String, Object> copyProperties = Maps.newHashMap();
            if (withStreams) {
                for (Entry<String, Object> p : f.getProperties().entrySet()) {
                    // Protected fields (such as ID and path) will differ
                    // between
                    // the source and destination, so don't copy them.
                    if (!PROTECTED_FIELDS.contains(p.getKey())) {
                        if (p.getKey().startsWith(BLOCKID_FIELD)) {
                            streams.add(p.getKey());
                        } else {
                            copyProperties.put(p.getKey(), p.getValue());
                        }
                    }
                }
            } else {
                copyProperties.putAll(f.getProperties());
            }
            copyProperties.put(COPIED_FROM_PATH_FIELD, from);
            copyProperties.put(COPIED_FROM_ID_FIELD, f.getProperty(UUID_FIELD));
            copyProperties.put(COPIED_DEEP_FIELD, withStreams);
            t = new Content(to, copyProperties);
            update(t);
            LOGGER.debug(""Copy Updated {} {} "", to, t);

            for (String stream : streams) {
                String streamId = null;
                if (stream.length() > BLOCKID_FIELD.length()) {
                    streamId = stream.substring(BLOCKID_FIELD.length() + 1);
                }
                InputStream fromStream = getInputStream(from, streamId);
                writeBody(to, fromStream);
                fromStream.close();
            }
            eventListener.onUpdate(Security.ZONE_CONTENT, to, accessControlManager.getCurrentUserId(), getResourceType(f), true,
                    null, ""op:copy"");
        } finally {
            statsService.apiCall(ContentManagerImpl.class.getName(), ""copy"", System.currentTimeMillis() - ts);
        }

    }","{@inheritDoc}

@see org.sakaiproject.nakamura.api.lite.content.ContentManager#copy(java.lang.String,
java.lang.String, boolean)"
"private static WebApplicationContext _findWebApplicationContext(ServletContext sc) {
		WebApplicationContext wac = getWebApplicationContext(sc);
		if (wac == null) {
			Enumeration<String> attrNames = sc.getAttributeNames();
			while (attrNames.hasMoreElements()) {
				String attrName = attrNames.nextElement();
				Object attrValue = sc.getAttribute(attrName);
				if (attrValue instanceof WebApplicationContext) {
					if (wac != null) {
						throw new IllegalStateException(""No unique WebApplicationContext found: more than one "" +
								""DispatcherServlet registered with publishContext=true?"");
					}
					wac = (WebApplicationContext) attrValue;
				}
			}
		}
		return wac;
	}","Copy of {@link #findWebApplicationContext(ServletContext)} for compatibility with spring framework 4.1.x.
@see #findWebApplicationContext(ServletContext)"
"private static List<String> asStrings(Class... classes) {
    List<String> strings = Lists.newArrayList();
    for (Class c : classes) {
      strings.add(c.getName());
    }
    return strings;
  }",Returns the class names as Strings
"public static <T> T checkNotNull(T ref, String msg, Object... args)
	{
		if (ref == null) {
			throw new NullPointerException(format(msg, args));
		}
		return ref;
	}","Checks that the given reference is not {@code null} and returns it
in case of success.

@param <T> the type of the given reference.
@param ref the reference to test.
@param msg the error message format string.
@param args the error message arguments.

@return the validated (non-{@code null}) reference.

@throws NullPointerException if the given reference is {@code null}."
"public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) {
		if (!StringUtil.endsWithChar(prefix, '.')) {
			prefix += StringPool.DOT;
		}

		for (Map.Entry<?, ?> entry : map.entrySet()) {
			String key = entry.getKey().toString();

			key = prefix + key;

			setValue(key, entry.getValue().toString(), profile);
		}
	}",Adds child map to the props on given prefix.
"public static boolean equalsIgnoreCase(String s1, String s2) {
        Preconditions.checkNotNull(s1);
        // don't check non-null against s2 to make the semantics same as
        // s1.equals(s2)
        return s1.equalsIgnoreCase(s2);
    }","Compare strings locale-freely by using String#equalsIgnoreCase.

@param s1  Non-null string to be converted
@param s2  string to be converted
@return     the str, converted to uppercase."
"public void createPartControl(Composite parent) {
        viewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);
        drillDownAdapter = new DrillDownAdapter(viewer);
        viewer.setContentProvider(new RepositoryContentProvider());
        viewer.setLabelProvider(new RepositoryLabelProvider());
        viewer.setSorter(new NameSorter());
        viewer.setInput(viewer);
        makeActions();
        hookContextMenu();
        hookDoubleClickAction();
        contributeToActionBars();

        Activator.getLocationManager().addRepositorySetListener(new IRepositorySetListener() {
            public void repositorySetChanged(int type, List<GuvnorRepository> repList) {
                // TODO: Just creating an entirely new content provider.
                //       Someday might update this to have incremental changes
                //       to existing content provider.
                viewer.setContentProvider(new RepositoryContentProvider());
            }
        });

        super.getSite().setSelectionProvider(viewer);

        addDragDropSupport();
    }","/*
(non-Javadoc)
@see org.eclipse.ui.part.WorkbenchPart#createPartControl(org.eclipse.swt.widgets.Composite)"
"public static byte[] concatenate(byte[]... arrays) {
		int length = 0;
		for (byte[] array : arrays) {
			length += array.length;
		}
		byte[] newArray = new byte[length];
		int destPos = 0;
		for (byte[] array : arrays) {
			System.arraycopy(array, 0, newArray, destPos, array.length);
			destPos += array.length;
		}
		return newArray;
	}",Combine the individual byte arrays into one array.
"public static void resize(File originalImage, File to, int w, int h, boolean keepRatio) {
        try {
            BufferedImage source = ImageIO.read(originalImage);
            int owidth = source.getWidth();
            int oheight = source.getHeight();
            double ratio = (double) owidth / oheight;

            int maxWidth = w;
            int maxHeight = h;

            if (w < 0 && h < 0) {
                w = owidth;
                h = oheight;
            }
            if (w < 0 && h > 0) {
                w = (int) (h * ratio);
            }
            if (w > 0 && h < 0) {
                h = (int) (w / ratio);
            }

            if (keepRatio) {
                h = (int) (w / ratio);
                if (h > maxHeight) {
                    h = maxHeight;
                    w = (int) (h * ratio);
                }
                if (w > maxWidth) {
                    w = maxWidth;
                    h = (int) (w / ratio);
                }
            }

            String mimeType = ""image/jpeg"";
            if (to.getName().endsWith("".png"")) {
                mimeType = ""image/png"";
            }
            if (to.getName().endsWith("".gif"")) {
                mimeType = ""image/gif"";
            }

            // out
            BufferedImage dest = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
            Image srcSized = source.getScaledInstance(w, h, Image.SCALE_SMOOTH);
            Graphics graphics = dest.getGraphics();
            graphics.setColor(Color.WHITE);
            graphics.fillRect(0, 0, w, h);
            graphics.drawImage(srcSized, 0, 0, null);
            ImageWriter writer = ImageIO.getImageWritersByMIMEType(mimeType).next();
            ImageWriteParam params = writer.getDefaultWriteParam();
            FileImageOutputStream toFs = new FileImageOutputStream(to);
            writer.setOutput(toFs);
            IIOImage image = new IIOImage(dest, null, null);
            writer.write(null, image, params);
            toFs.flush();
            toFs.close();
            writer.dispose();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }","Resize an image

@param originalImage The image file
@param to            The destination file
@param w             The new width (or -1 to proportionally resize) or the maxWidth if keepRatio is true
@param h             The new height (or -1 to proportionally resize) or the maxHeight if keepRatio is true
@param keepRatio     : if true, resize will keep the original image ratio and use w and h as max
dimensions"
"public static cuComplex cublasCdotc(int n, Pointer x, int incx, Pointer y, int incy)
    {
        cuComplex result = cublasCdotcNative(n, x, incx, y, incy);
        checkResultBLAS();
        return result;
    }","<pre>
cuComplex
cublasCdotc (int n, const cuComplex *x, int incx, const cuComplex *y,
int incy)

computes the dot product of two single-complex vectors. It returns the
dot product of the single-complex vectors x and y if successful, and complex
zero otherwise. It computes the sum for i = 0 to n - 1 of x[lx + i * incx] *
y[ly + i * incy], where lx = 1 if incx >= 0, else lx = 1 + (1 - n) * incx;
ly is defined in a similar way using incy.

Input
-----
n      number of elements in input vectors
x      single-complex vector with n elements
incx   storage spacing between elements of x
y      single-complex vector with n elements
incy   storage spacing between elements of y

Output
------
returns single-complex dot product (zero if n <= 0)

Reference: http://www.netlib.org/blas/cdotc.f

Error status for this function can be retrieved via cublasGetError().

Error Status
------------
CUBLAS_STATUS_NOT_INITIALIZED  if CUBLAS library has nor been initialized
CUBLAS_STATUS_EXECUTION_FAILED if function failed to execute on GPU
</pre>"
"@XmlTransient
	public void setFieldValue(String fieldNameParam, Object fieldValueParam, Field.Type typeParam) {
		if (fieldNameParam == null) {
			return;
		}

		if (this.getFormFields() == null || this.getFormFields().isEmpty()) {
			this.setFormFields(new ArrayList());
		}

		String paramLower = fieldNameParam.toLowerCase().trim();

		boolean valueFound = false;

		//Iterate the Form Fields...
		int fieldIndex = 0;
		for (Iterator<Field> fieldIter = this.getFormFields().iterator();
			 fieldIter.hasNext();fieldIndex++) {

			Field field = fieldIter.next();

			String toCheckNameLower = field.getFieldName();
			if (toCheckNameLower == null || toCheckNameLower.trim().isEmpty()) {
				continue;
			}

			toCheckNameLower = toCheckNameLower.trim().toLowerCase();

			if (paramLower.equals(toCheckNameLower)) {
				valueFound = true;
				this.getFormFields().get(fieldIndex).setFieldValue(fieldValueParam);
				this.getFormFields().get(fieldIndex).setTypeAsEnum(typeParam);
				break;
			}
		}

		//Add the value if it wasn't found by name...
		if (!valueFound) {
			this.getFormFields().add(new Field(fieldNameParam, fieldValueParam, typeParam));
		}
	}","<p>
Sets the value of the {@code fieldNameParam} requested.

<p>
If there is an existing value, the value will be override with
the value of {@code fieldValueParam}.

<p>
The {@code fieldNameParam} <b>is not</b> case sensitive.

<br>

<p>
The value won't be set if;
<ul>
<li>{@code fieldNameParam} is {@code null} or empty.</li>
<li>{@code getFormFields()} is {@code null} or empty.</li>
<li>Field is not found by {@code fieldNameParam}.</li>
</ul>

@param fieldNameParam The name of the Form Field as in Fluid.
@param fieldValueParam The value of the {@code Field}.
@param typeParam The {@code Field.Type} of {@code Field}.

@see Field.Type"
"final boolean addReference(final JNIReference ref)
  {
    /* Implementation note: This method is extremely
     * hot, and so I've unrolled the lock and unlock
     * methods from above.  Take care if you change
     * them to change the unrolled versions here.
     * 
     */
    // First try to grab the non blocking lock
    boolean gotNonblockingLock = false;
    gotNonblockingLock = mSpinLock.compareAndSet(false, true);
    if (gotNonblockingLock)
    {
      final int slot = mNextAvailableReferenceSlot++;
      if (slot < mMaxValidReference)
      {
        mValidReferences[slot] = ref;
        // unlock the non-blocking lock, and progress to a full lock.
        final boolean result = mSpinLock.compareAndSet(true, false);
        assert result : ""Should never be unlocked here"";
        return true;
      }
      // try the big lock without blocking
      if (!mLock.tryLock()) {
        // we couldn't get the big lock, so release the spin lock
        // and try getting the bit lock while blocking
        gotNonblockingLock = false;
        mSpinLock.compareAndSet(true, false);
      }
    }
    // The above code needs to make sure that we never
    // have gotNonblockingLock set, unless we have both
    // the spin lock and the big lock.
    if (!gotNonblockingLock){
      mLock.lock();
      while(!mSpinLock.compareAndSet(false, true))
        ; // grab the spin lock
    }
    try {
      int slot = mNextAvailableReferenceSlot++;
      if (slot >= mMaxValidReference)
      {
        sweepAndCollect();
        slot = mNextAvailableReferenceSlot++;
      }
      mValidReferences[slot] = ref;
    } finally {
      final boolean result = mSpinLock.compareAndSet(true, false);
      assert result : ""Should never ever be unlocked here"";
      mLock.unlock();
    }
    return true;
  }","Add a reference to the set of references we'll collect.

@param ref The reference to collect.
@return true if already in list; false otherwise."
"private void registerConfigMapping(String endpointClassName, EndpointConfig config, DeploymentUnit unit) {
        WSEndpointConfigMapping mapping = unit.getAttachment(WSAttachmentKeys.WS_ENDPOINT_CONFIG_MAPPING_KEY);
        if (mapping == null) {
            mapping = new WSEndpointConfigMapping();
            unit.putAttachment(WSAttachmentKeys.WS_ENDPOINT_CONFIG_MAPPING_KEY, mapping);
        }
        mapping.registerEndpointConfig(endpointClassName, config);
    }",TODO this could be moved to a separate DeploymentUnitProcessor operating on endpoints (together with the rest of the config resolution mechanism)
"public FeatureCache getCache(String tableName) {
        FeatureCache cache = tableCache.get(tableName);
        if (cache == null) {
            cache = new FeatureCache(maxCacheSize);
            tableCache.put(tableName, cache);
        }
        return cache;
    }","Get or create a feature row cache for the table name

@param tableName feature table name
@return feature row cache"
"public static AjaxMessage failure(String message, Exception exception) {
        return failure(message, null, exception);
    }","返回处理失败的消息内容

@param message   Toast
@param exception exception
@return message content"
"public Map<String, String> getCopyOfContextMap() {
    Map<String, String> hashMap = copyOnThreadLocal.get();
    if (hashMap == null) {
      return null;
    } else {
      return new HashMap<String, String>(hashMap);
    }
  }","Return a copy of the current thread's context map. Returned value may be
null."
"private void scanForChildren() {
    if (debug) System.out.printf(""DirectoryBuilder.scanForChildren on %s "", dir);

    int count = 0;
    try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {
      for (Path p : ds) {
        BasicFileAttributes attr = Files.readAttributes(p, BasicFileAttributes.class);
        if (attr.isDirectory()) {
          children.add(new DirectoryBuilder(topCollectionName, p, attr, suffix));
          if (debug && (++count % 10 == 0)) System.out.printf(""%d "", count);
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    if (debug) System.out.printf(""done=%d%n"", count);
    childrenConstructed = true;
  }","Scan for subdirectories, make each into a DirectoryBuilder and add as a child"
"public void startComponentOperation(String componentName, ComponentType type) {
    final Component currentComponent = componentsStack.peek();

    if (currentComponent != null && componentName.equals(currentComponent.name)) {
      currentComponent.operationCount++;
      return;
    }

    componentsStack.push(new Component(componentName, type));
  }","Called inside of {@link com.orientechnologies.orient.core.storage.impl.local.paginated.base.ODurableComponent} to notify that
component started to perform operation on data. After that all performance characteristic started to be gathered for this
component till method {@link #completeComponentOperation()} will be called.
<p>
Components can be stacked, so if components <code>c1</code> and then <code>c2</code> call this method than performance data for
both components at once started to be gathered.

@param componentName Name of component which started to perform operation on data. Name is case sensitive."
"public String calculateAKSN(String ak, String sk, String url, List<NameValuePair> nameValuePairs, String method) {
        String params = """";
        if (method.equals(""POST"")) {
            Collections.sort(nameValuePairs, new Comparator<NameValuePair>() {
                @Override
                public int compare(NameValuePair o1, NameValuePair o2) {
                    StringComparator comparator = new StringComparator();
                    return comparator.compare(o1.getName(), o2.getName());
                }
            });

            StringBuilder stringBuilder = new StringBuilder();
            for (Iterator<NameValuePair> iterator = nameValuePairs.iterator(); iterator.hasNext(); ) {
                NameValuePair nameValuePair = iterator.next();
                String name = nameValuePair.getName();
                String value = nameValuePair.getValue();
                stringBuilder.append(name);
                stringBuilder.append(""="");
                stringBuilder.append(value);
                if (iterator.hasNext()) {
                    stringBuilder.append(""&"");
                }
            }
            params = stringBuilder.toString();
        }

        String basicString = url + ""? "" + params;
        String sn = null;
        try {
            sn = MD5Helper.encrypt(URLEncoder.encode(basicString + sk, ""UTF-8""));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return sn;
    }","sn = MD5(urlencode(basicString + sk))
<p>
其中 basicString 的算法如下：
<p>
(1) get 请求
<p>
url 中 http://域名{uri}
<p>
basicString = uri
<p>
(2) post 请求
<p>
url 中 http://域名{uri} POST 参数按照key进行从小大到字母排序
<p>
然后拼装成：k1=v1&amp;k2=v2&amp;k3=v3&amp;...&amp;kn=vn的格式=&gt; {params}
<p>
basicString = uri +?+ params

@param ak             access key
@param sk             secret key
@param url            url值，例如: /geosearch/nearby 不能带hostname和querstring，也不能带？
@param nameValuePairs $querystring_arrays 参数数组，key=&gt;value形式。在计算签名后不能重新排序，也不能添加或者删除数据元素
@param method         method 只能为'POST'或者'GET'
@return 计算SN签名算法"
"private void writeResponseHeaderToRecordHeader(Response response, Record.Header header) {
    for (Map.Entry<String, List<String>> entry : response.getStringHeaders().entrySet()) {
      if (!entry.getValue().isEmpty()) {
        String firstValue = entry.getValue().get(0);
        header.setAttribute(conf.headerAttributePrefix + entry.getKey(), firstValue);
      }
    }
  }","Writes HTTP response headers to the SDC Record header with the configured optional prefix.

@param response HTTP response
@param header SDC Record header"
"public void parse(String test) throws ExceptionState {

    parser = new StateMachineParser();
    test = test.trim();
    if (test.substring(test.length() - 4).matches(""V2\\.0"") || test.substring(test.length() - 4).matches(""v2\\.0"")) {

      for (int i = 0; i < test.length() - 4; i++) {
        parser.doAction(test.charAt(i));
      }

      if (!(parser.getState() instanceof FinalState)) {
        LOG.error(""Invalid input: Final State was not reached:"");
        throw new FinalStateException(""Invalid input: Final State was not reached"");
      }
    } else {
      LOG.error(""Invalid input: HELM2 standard is missing:"");
      throw new NotValidHELM2Exception(""Invalid input: HELM2 standard is missing"");
    }
  }","method to parse the given HELM2 string in the case of an invalid HELM2 notation exception is thrown

@param test HELM2 Notation
@throws ExceptionState if error occurs in state"
"@Override
    public boolean validateIntegrity(String database) {
        boolean valid = isValid(database, false, true);
        return valid;
    }",{@inheritDoc}
"public UserCustomCursor query(double minX, double minY, double maxX,
                                  double maxY) {
        String where = buildWhere(minX, minY, maxX, maxY);
        String[] whereArgs = buildWhereArgs(minX, minY, maxX, maxY);
        return query(where, whereArgs);
    }","Query for rows within the bounds

@param minX min x
@param minY min y
@param maxX max x
@param maxY max y
@return cursor results"
"public final Self overrides(play.api.inject.Module... modules) {
    return overrides(Guiceable.modules(modules));
  }","Override bindings using Play modules.

@param modules the set of Play modules whose bindings override some previously configured ones
@return a copy of this builder re-configured with the provided bindings"
"@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:52:47+02:00"", comments = ""JAXB RI v2.2.11"")
    public void setApiSuchfelder(JAXBElement<ApiSuchfelderTyp> value) {
        this.apiSuchfelder = value;
    }","Sets the value of the apiSuchfelder property.

@param value
allowed object is
{@link JAXBElement }{@code <}{@link ApiSuchfelderTyp }{@code >}"
"public synchronized T get() {
		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();

		if (contextClassLoader != null) {
			T value = weakMap.get(contextClassLoader);

			if ((value == null) && !weakMap.containsKey(contextClassLoader)) {
				value = initialValue();
				weakMap.put(contextClassLoader, value);
			}

			return value;
		}

		if (!initialized) {
			value = initialValue();
			initialized = true;
		}

		return value;
	}","Returns the value in the current classloader copy of this variable.
If the variable has no value for the current classloader, it is first initialized to the value returned
by an invocation of the initialValue() method."
"@Override
	protected Boolean defaultVisit(ClassConclusion conclusion) {
		Context context = get();
		boolean result = context.addConclusion(conclusion);
		if (LOGGER_.isTraceEnabled()) {
			LOGGER_.trace(""{}: inserting {}: {}"", context, conclusion,
					result ? ""success"" : ""failure"");
		}
		return result;
	}",logging is switched off
"public FilterReply getFilterChainDecision(E event) {
    final Filter<E>[] filterArrray = filterList.asTypedArray();
    final int len = filterArrray.length;

    for (int i = 0; i < len; i++) {
      final FilterReply r = filterArrray[i].decide(event);
      if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {
        return r;
      }
    }

    // no decision
    return FilterReply.NEUTRAL;
  }","Loop through the filters in the list. As soon as a filter decides on
ACCEPT or DENY, then that value is returned. If all of the filters return
NEUTRAL, then NEUTRAL is returned."
"private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException {
        if( curop != Opcode.CONTINUOUS ) {
            processFrameIsNotFin(frame);
        } else if( frame.isFin() ) {
            processFrameIsFin(webSocketImpl, frame);
        } else if( currentContinuousFrame == null ) {
            log.error( ""Protocol error: Continuous frame sequence was not started."" );
            throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, ""Continuous frame sequence was not started."" );
        }
        //Check if the whole payload is valid utf8, when the opcode indicates a text
        if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) {
            log.error( ""Protocol error: Payload is not UTF8"" );
            throw new InvalidDataException( CloseFrame.NO_UTF8 );
        }
        //Checking if the current continuous frame contains a correct payload with the other frames combined
        if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) {
            addToBufferList(frame.getPayloadData());
        }
    }","Process the frame if it is a continuous frame or the fin bit is not set
@param webSocketImpl the websocket implementation to use
@param frame the current frame
@param curop the current Opcode
@throws InvalidDataException if there is a protocol error"
"public int reduce(long num, long den, long max) {
    return VideoJNI.Rational_reduce(swigCPtr, this, num, den, max);
  }","Reduce a fraction to it's lowest common denominators.<br>
This is useful for framerate calculations.<br>
@param num       the src numerator.<br>
@param den       the src denominator.<br>
@param max the maximum allowed for nom &amp; den in the reduced fraction.<br>
@return 1 if exact, 0 otherwise"
"public static Optional<PlaybackState> getPlaybackStateFromResource(ResourceModel x) {
        if (!x.getResourceID().equals(ID))
            return Optional.empty();
        Object resource = x.getResource();
        if (resource instanceof String) {
            String state = (String) resource;
            try {
                return Optional.of(PlaybackState.valueOf(state));
            } catch (IllegalArgumentException e) {
                return Optional.empty();
            }
        } else {
            return Optional.empty();
        }
    }","returns the PlaybackState from the resource
@param x the resourceModel
@return the optional Playbackstate (empty if illegal resource)"
"@CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable<T> replay() {
        return FlowableReplay.createFrom(this);
    }","Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher
that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable
Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is
subscribed to, but only when its {@code connect} method is called.
<p>
<img width=""640"" height=""515"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.png"" alt="""">
<dl>
<dt><b>Backpressure:</b></dt>
<dd>This operator supports backpressure. Note that the upstream requests are determined by the child
Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
request 100 elements from the underlying Publisher sequence.</dd>
<dt><b>Scheduler:</b></dt>
<dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>

@return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its
items to its {@link Subscriber}s
@see <a href=""http://reactivex.io/documentation/operators/replay.html"">ReactiveX operators documentation: Replay</a>"
"@Override
    public IComplexNDArray addiRowVector(INDArray rowVector) {
        for (int i = 0; i < rows(); i++) {
            getRow(i).addi(rowVector.getScalar(i));
        }
        return this;
    }","In place addition of a column vector

@param rowVector the column vector to add
@return the result of the addition"
"public Variable addStringVariable(Group g, String shortName, String dims, int strlen) {
    if (immutable) throw new IllegalStateException(""Cant modify"");
    if (g == null) g = rootGroup;
    String dimName = shortName + ""_strlen"";
    addDimension(g, new Dimension(dimName, strlen));
    Variable v = new Variable(this, g, null, shortName);
    v.setDataType(DataType.CHAR);
    v.setDimensions(dims + "" "" + dimName);
    g.addVariable(v);
    return v;
  }","Create a new Variable of type Datatype.CHAR, and add to the given group.

@param g         add to this group. If group is null, use root group
@param shortName short name of the Variable
@param dims      list of dimension names
@param strlen    dimension length of the inner (fastest changing) dimension
@return the new Variable"
"public Iterable<Map<String, Variable>> expandResultSetToMap(Iterator<Set<Variable>> solutions)
    {
        return new Filterator<Set<Variable>, Map<String, Variable>>(solutions,
            new Function<Set<Variable>, Map<String, Variable>>()
            {
                public Map<String, Variable> apply(Set<Variable> variables)
                {
                    Map<String, Variable> results = new HashMap<String, Variable>();

                    for (Variable var : variables)
                    {
                        String varName = getInterner().getVariableName(var.getName());
                        results.put(varName, var);
                    }

                    return results;
                }
            });
    }","Transforms an iterator over sets of variable bindings, resulting from a query, to an iterator over a map from the
string name of variables to their bindings, for the same sequence of query solutions.

@param  solutions The resolution solutions to convert to map form.

@return An iterator over a map from the string name of variables to their bindings, for the solutions."
"public URLTable getProperties(Collection propertyNames, String depth) throws DAVException {
        // Set up the request context.
        IContext context = newContext();
        context.setDepth(depth);

        // Set up the request body.
        Document document = newDocument();
        PropFind propfind = PropFind.create(document);

        // null is a special value meaning 'all properties'.
        if (propertyNames == null)
            propfind.setIsAllProp(true);
        else {
            // Add all the property names to the request body.
            Prop prop = propfind.setProp();
            Iterator namesItr = propertyNames.iterator();
            while (namesItr.hasNext())
                prop.addPropertyName((QualifiedName) namesItr.next());
        }

        // Were ready to make the server call.
        IResponse response = null;
        try {
            // This contacts the server.
            response = davClient.propfind(locator, context, document);
            examineResponse(response);

            // Create a multi-status element editor on the response.
            if (!response.hasDocumentBody())
                throw new DAVException(Policy.bind(""exception.respMustShareXMLDoc"")); //$NON-NLS-1$
            Element documentElement = response.getDocumentBody().getDocumentElement();
            if (documentElement == null)
                throw new DAVException(Policy.bind(""exception.respHasInvalidDoc"")); //$NON-NLS-1$
            MultiStatus multiStatus = new MultiStatus(documentElement);

            // Construct a URLTable of results to return to the user.
            return extractPropStats(multiStatus);

        } catch (IOException e) {
            throw new SystemException(e);
        } catch (MalformedElementException e) {
            throw new SystemException(e);
        } finally {
            closeResponse(response);
        }
    }","Fetches and returns the specified properties for this resource and its
children to the given depth. The returned table is a URLTable of
hashtables. The keys in the first table are the <code>URL</code>s of
the resources. The nested table is a table where the keys are the names
(<code>QualifiedName</code>) of the properties and the values are the
properties' values (<code>PropertyStatus</code>).

@param propertyNames collection of property names to search for
(<code>QualifiedName</code>), or <code>null</code> to retrieve
all properties.
@param depth the depth of the search (eg. <code>Context.DEPTH_INFINITY</code>)
@return URLTable of hashtables keyed by resource <code>URLKey</code>
then by property name.
@exception DAVException if there was a problem fetching the properties.
@see IServer#propfind(Locator, Context, Document)"
"public static Restriction lt(String name, Object Object){
        return new Restriction(Operator.LESS_THAN, name, Object);
    }",'<' less than operator
"public static long[] values(Long[] array) {
		long[] dest = new long[array.length];
		for (int i = 0; i < array.length; i++) {
			Long v = array[i];
			if (v != null) {
				dest[i] = v.longValue();
			}
		}
		return dest;
	}",Converts to primitive array.
"@XmlElementDecl(namespace = """", name = ""objektart_zusatz"")
    public JAXBElement<String> createObjektartZusatz(String value) {
        return new JAXBElement<String>(_ObjektartZusatz_QNAME, String.class, null, value);
    }",Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}
"public boolean isCaching() {
    if (!permitCaching) {
      return false;
    }

    if (!this.cache.cachingSet) {
      cache.isCaching = !isVariableLength && (getSize() * getElementSize() < getSizeToCache());
      if (debugCaching) System.out.printf(""  cache %s %s %d < %d%n"", getFullName(), cache.isCaching, getSize() * getElementSize(), getSizeToCache());
      this.cache.cachingSet = true;
    }
    return cache.isCaching;
  }","Will this Variable be cached when read.
Set externally, or calculated based on total size < sizeToCache.
<p>
This will always return {@code false} if {@link #permitCaching caching isn't permitted}.

@return true is caching"
"public javax.slee.management.DeployableUnitDescriptor getSpecsDeployableUnitDescriptor() {
		Set<ComponentID> componentIDs = new HashSet<ComponentID>();
		for (SleeComponent component : getDeployableUnitComponents()) {
			componentIDs.add(component.getComponentID());
		}
		return new DeployableUnitDescriptor(getDeployableUnitID(), date,
				componentIDs.toArray(new ComponentID[0]));
	}","Returns the {@link DeployableUnitDescriptor} for this deployable unit.

@return"
"@CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable<T> doOnCancel(Action onCancel) {
        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);
    }","Calls the cancel {@code Action} if the downstream cancels the sequence.
<p>
The action is shared between subscriptions and thus may be called concurrently from multiple
threads; the action must be thread-safe.
<p>
If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,
sometimes as a {@code CompositeException} if there were multiple exceptions along the way.
<p>
Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.
<p>
<img width=""640"" height=""310"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.png"" alt="""">
<dl>
<dt><b>Backpressure:</b></dt>
<dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure
behavior is preserved between its upstream and its downstream.</dd>
<dt><b>Scheduler:</b></dt>
<dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>

@param onCancel
the action that gets called when the source {@code Publisher}'s Subscription is canceled
@return the source {@code Publisher} modified so as to call this Action when appropriate
@see <a href=""http://reactivex.io/documentation/operators/do.html"">ReactiveX operators documentation: Do</a>"
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static <T> Flowable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {
        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);
    }","Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the
most recently emitted of those Publishers.
<p>
<img width=""640"" height=""370"" src=""https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png"" alt="""">
<p>
{@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of
these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items
emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items
from the earlier-emitted Publisher and begins emitting items from the new one.
<p>
The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.
If the outer Publisher signals an onError, the inner Publisher is canceled and the error delivered in-sequence.
<dl>
<dt><b>Backpressure:</b></dt>
<dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
but the violation <em>may</em> lead to {@code OutOfMemoryError} due to internal buffer bloat.</dd>
<dt><b>Scheduler:</b></dt>
<dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.</dd>
</dl>

@param <T> the item type
@param sources
the source Publisher that emits Publishers
@param bufferSize
the number of items to prefetch from the inner Publishers
@return a Flowable that emits the items emitted by the Publisher most recently emitted by the source
Publisher
@see <a href=""http://reactivex.io/documentation/operators/switch.html"">ReactiveX operators documentation: Switch</a>"
"private String getJBossAppSecurityDomain(final DeploymentUnit deploymentUnit) {
        String securityDomain = null;
        DeploymentUnit parent = deploymentUnit.getParent();
        if (parent != null) {
            final EarMetaData jbossAppMetaData = parent.getAttachment(org.jboss.as.ee.structure.Attachments.EAR_METADATA);
            if (jbossAppMetaData instanceof JBossAppMetaData) {
                securityDomain = ((JBossAppMetaData) jbossAppMetaData).getSecurityDomain();
            }
        }
        return securityDomain != null ? securityDomain.trim() : null;
    }",Try to obtain the security domain configured in jboss-app.xml at the ear level if available
"public void warning(String message, Throwable t)
			throws NullPointerException, FacilityException {
		sendNotification(TraceLevel.WARNING, message, t);
		logger.warn(message,t);		
	}","/* (non-Javadoc)
@see javax.slee.facilities.Tracer#warning(java.lang.String, java.lang.Throwable)"
"public V remove(Object key) {
        int hashCode = hash((key == null) ? NULL : key);
        int index = hashIndex(hashCode, data.length);
        HashEntry<K, V> entry = data[index];
        HashEntry<K, V> previous = null;
        while (entry != null) {
            if (entry.hashCode == hashCode && isEqualKey(key, entry.getKey())) {
                V oldValue = entry.getValue();
                removeMapping(entry, index, previous);
                return oldValue;
            }
            previous = entry;
            entry = entry.next;
        }
        return null;
    }","Removes the specified mapping from this map.

@param key
the mapping to remove
@return the value mapped to the removed key, null if key not in map"
"public void config(String message) throws NullPointerException,
			FacilityException {
		sendNotification(TraceLevel.CONFIG, message, null);
		logger.info(message);		
	}","/* (non-Javadoc)
@see javax.slee.facilities.Tracer#config(java.lang.String)"
"public static void main(String[] args)
	{
        try {
			JBackup applet = new JBackup(""JBackup"");
			if (!Boolean.TRUE.toString().equalsIgnoreCase(System.getProperty(PROPERTY_QUIET_PARAM)))
			{
				JFrame frame = applet.addAppToFrame();
				frame.setVisible(true);
			}
			else
			{
				Scanner scanner = new Scanner(applet.m_properties);
				scanner.run();
				
				AppUtilities.writeProperties(applet.m_strFileName, applet.m_properties);				
				System.exit(0);
			}
		} catch (Throwable t) {
			System.out.println(""uncaught exception: "" + t);
			t.printStackTrace();
		}
//+		System.exit(0);
    }","/*
Main method."
"private void setData(String objectKey, Recorder recorder) {
        if (recorder == null) return;
        String upload = new Gson().toJson(uploadModel);
        recorder.set(objectKey, upload.getBytes());
    }","Set data in the upload with a recorder.
@param objectKey key
@param recorder recorder"
"long analyze() {
        Arc a;
        Arc aa;

        if (pre.outs == null) {
            return Flags.REG_UIMPOSSIBLE;
        }
        for (a = pre.outs; a != null; a = a.outchain) {
            for (aa = a.to.outs; aa != null; aa = aa.outchain) {
                if (aa.to == post) {
                    return Flags.REG_UEMPTYMATCH;
                }
            }
        }
        return 0;
    }","analyze - ascertain potentially-useful facts about an optimized NFA

@return re_info bits."
"@Override
    public void predictPlane(byte[] ref, int refX, int refY, int refW, int refH, int refVertStep, int refVertOff,
            int[] tgt, int tgtY, int tgtW, int tgtH, int tgtVertStep) {
        super.predictPlane(ref, refX << 1, refY << 1, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW << 2, tgtH << 2,
                tgtVertStep);
    }",this may be a result of color greening out in long GOPs.
"public static void closeQuietly(Socket socket) {
    if (socket == null) return;
    try {
      socket.close();
    }
    catch (IOException ex) {
      assert true;  // avoid an empty catch
    }
  }","Closes a socket while suppressing any {@code IOException} that occurs.
@param socket the socket to close"
"private void ensureSameDomains(final String oldSecurityDomain, final String newSecurityDomain) {
        final boolean domainsDiffer = !oldSecurityDomain.equals(newSecurityDomain);
        if (domainsDiffer)
            throw WSLogger.ROOT_LOGGER.multipleSecurityDomainsDetected(oldSecurityDomain, newSecurityDomain);
    }","This method ensures both passed domains contain the same value.

@param oldSecurityDomain our security domain
@param newSecurityDomain next security domain
@throws IllegalStateException if domains have different values"
"public Future<GoodwillSchema> getSchema(final String schemaName)
    {
        try {
            return client.prepareGet(String.format(""%s/%s"", url, schemaName)).addHeader(""Accept"", ""application/json"").execute(new AsyncCompletionHandler<GoodwillSchema>()
            {
                @Override
                public GoodwillSchema onCompleted(final Response response) throws Exception
                {
                    if (response.getStatusCode() != 200) {
                        return null;
                    }

                    final InputStream in = response.getResponseBodyAsStream();
                    try {
                        return mapper.readValue(in, GoodwillSchema.class);
                    }
                    finally {
                        closeStream(in);
                    }
                }

                @Override
                public void onThrowable(final Throwable t)
                {
                    log.warn(""Got exception looking up the schema"", t);
                }
            });
        }
        catch (IOException e) {
            log.warn(""Got exception looking up the schema"", e);
            return null;
        }
    }","Get the Goodwill schema associated to a schema name.
</p>
Typical invocation:
<pre>
try {
GoodwillSchema type = accessor.getSchema(""test"").get();
...
}
catch (Exception e) {
// Connection exception? Goodwill server down?
}
</pre>

@param schemaName schema name to lookup
@return a future on the Schema"
"public java.util.Collection<Long> getSupportedTags()
   {
     final java.util.List<Long> retval =
       new java.util.LinkedList<Long>();
     final java.util.Set<Long> uniqueSet =
       new java.util.HashSet<Long>();
     
     int numCodecs = getNumSupportedCodecs();
     for(int i = 0; i < numCodecs; i++)
     {
       long tag = getSupportedCodecTag(i);
       Codec.ID id = getSupportedCodecId(i);
       // remove duplicate tags
       if (id != Codec.ID.CODEC_ID_NONE && !uniqueSet.contains(tag))
         retval.add(tag);
       uniqueSet.add(tag);
     }    
     return retval;
   }","Returns a list of all codec tags supported for this container.

<p>

If this object hasn't been set up for output, then
we return null.

</p>

@return A list of supported codec tags, in decreasing preferred order."
"@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")
    public List<Interessent.Bevorzugt> getBevorzugt() {
        if (bevorzugt == null) {
            bevorzugt = new ArrayList<Interessent.Bevorzugt>();
        }
        return this.bevorzugt;
    }","Gets the value of the bevorzugt property.

<p>
This accessor method returns a reference to the live list,
not a snapshot. Therefore any modification you make to the
returned list will be present inside the JAXB object.
This is why there is not a <CODE>set</CODE> method for the bevorzugt property.

<p>
For example, to add a new item, do as follows:
<pre>
getBevorzugt().add(newItem);
</pre>


<p>
Objects of the following type(s) are allowed in the list
{@link Interessent.Bevorzugt }"
"@Override
    public void downgradeToPreviousVersion(OpenImmoDocument doc) {
        doc.setDocumentVersion(OpenImmoVersion.V1_2_4);

        // downgrade a feedback document
        if (doc instanceof OpenImmoFeedbackDocument) {
            try {
                this.removeFeedbackObjektChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <objekt> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }
        }

        // downgrade a transfer document
        else if (doc instanceof OpenImmoTransferDocument) {
            try {
                this.removeKontaktpersonChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <kontaktperson> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeMwstGesamtElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <mwst_gesamt> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeVerkehrswertElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <verkehrswert> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeAnzahlLogiaElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <anzahl_logia> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeErschliessungUmfangElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported <erschliessung_umfang> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.removeVerwaltungTechnChildElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't remove unsupported children of <verwaltung_techn> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeZustandElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <zustand> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeBebaubarNachElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <bebaubar_nach> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeErschliessungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <erschliessung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeWohnungElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <wohnung> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeHausElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <haus> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }

            try {
                this.downgradeEnergiepassElements(doc.getDocument());
            } catch (Exception ex) {
                LOGGER.error(""Can't downgrade <energiepass> elements!"");
                LOGGER.error(""> "" + ex.getLocalizedMessage(), ex);
            }
        }
    }","Downgrade an OpenImmo document from version 1.2.5 to 1.2.4.

@param doc OpenImmo document in version 1.2.5"
"public BeliefSetField getFieldByName(String name) {
    BeliefSetField field = null;
    for (int i = 0; i < fields.length; i++) {
      if (name.equals(fields[i].getName())) {
        field = fields[i];
        break;
      }
    }
    return field;
  }","Gets the field of this belief set that has the given name.

@param name the name of the field to retrieve
@return the belief set field matching that name, or null if not found
@since 0.3.4"
"public void copyValuesTo(M model) {
		Objects.requireNonNull(model);
		fields.forEach(field -> field.commit(model));
	}","This method can be used to copy all values of this {@link ModelWrapper} instance
to the model instance provided as argument.
Existing values in the provided model instance will be overwritten.
<p>
This method doesn't change the state of this modelWrapper or the wrapped model instance.

@param model a non-null instance of a model."
"public static Pattern filterPattern(String inputRegexp) {
        if (inputRegexp.equals(""*"")) {
            inputRegexp = "".*"";
        } else if (inputRegexp.startsWith(""!"")) {
            inputRegexp = inputRegexp.substring(1);
        }
        return Pattern.compile(inputRegexp); // Catch incorrect patterns..
    }","Allow special cases to Pattern matching, such as ""*"" -> "".*"" and ! indicating the match shouldn't
happen. The first ! indicates the rest of the pattern should not match.

@param inputRegexp Regexp given by the user
@return Pattern modified to allow special cases in the query language"
"@Override
    public IComplexNDArray div(INDArray other, INDArray result) {
        return dup().divi(other, result);
    }","copy (element wise) division of two matrices

@param other  the second ndarray to divide
@param result the result ndarray
@return the result of the divide"
"public IconRow getIcon(String featureTable, long featureId,
                           GeometryType geometryType) {
        return getIcon(featureTable, featureId, geometryType, true);
    }","Get the icon of the feature, searching in order: feature geometry type
icon, feature default icon, table geometry type icon, table default icon

@param featureTable feature table
@param featureId    feature id
@param geometryType geometry type
@return icon row"
"public static Collection<URL> getClasspathURLs(ClassLoader classLoader, String packageName) {
        if (packageName == null) {
            throw new IllegalArgumentException(""PackageName must be not null."");
        }
        Collection<URL> urls = new ArrayList<URL>();
        String dirname = packageName.replace('.', '/');
        try {
            Enumeration<URL> dirs = classLoader.getResources(dirname);
            while (dirs.hasMoreElements()) {
                urls.add(dirs.nextElement());
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return urls;
    }",根据 classLoader 获取指定 package 对应的 URLs.
"public void configure(Map<String, ?> configs, final String loginContextName) {
    super.configure(configs, loginContextName);
    this.loginContextName = loginContextName;
    this.ticketRenewWindowFactor = (Double) configs.get(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);
    this.ticketRenewJitter = (Double) configs.get(SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);
    this.minTimeBeforeRelogin = (Long) configs.get(SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);
    this.kinitCmd = (String) configs.get(SaslConfigs.SASL_KERBEROS_KINIT_CMD);
    this.serviceName = getServiceName(configs, loginContextName);
  }","Login constructor. The constructor starts the thread used
to periodically re-login to the Kerberos Ticket Granting Server.
@param loginContextName
name of section in JAAS file that will be use to login.
Passed as first param to javax.security.auth.login.LoginContext().
@param configs configure Login with the given key-value pairs.
@throws javax.security.auth.login.LoginException
Thrown if authentication fails."
"public double togreenw(double rectt, double utco, double gmst) {

    double pi = Math.acos(-1.00);
    //
    // For each occultation ID, its TU and GMST are the same.  However, every
    // occultation event takes place at gmst+uts, uts is progressively increasing
    // with every occultation event.
    double utc = (utco + rectt) * 1.0027379093;
    gmst = gmst + utc;  //in seconds, without eoe correction.
    //  gmst may be a positive number or may be a negative number.
    while (gmst < 0.0) {
      gmst = gmst + 86400.00;
    }


    while (gmst > 86400.00) {
      gmst = gmst - 86400.00;
    }

    // gmst = the Greenwich mean sidereal time.
    // This gmst is without the corrections from the equation of equinoxes.  For
    // GPS/MET applications, the corrections from equation of equinoxes is not
    // necessary because of the accurary needed.
    return gmst * 2.0 * pi / 86400.0;  //!*** This is the THETA in radian.
  }","This subroutine is to transform the locations and velocities of the GPS and
LEO satellites from the celestial inertial reference frame to the Earth
centered Greenwich reference frame.
The dummy arguments iyear, month and iday are the calender year, month and
day of the occultation event.  The dummy arguments ihour, minute and sec
are the UTC time.
Reference: Astronomical Alamanus, 1993
<p/>
Modified subroutine from Dasheng's code.

@param rectt _more_
@param utco  _more_
@param gmst  _more_
@return _more_"
"static Set<IndexedObjectProperty> getSubProperties(
			IndexedPropertyChain input,
			Producer<? super SubPropertyChainInference> inferenceProducer,
			final PropertyHierarchyCompositionState.Dispatcher dispatcher) {
		return computeSubProperties(input, inferenceProducer, dispatcher)
				.getSubProperties();
	}","Computes all sub-{@link IndexedObjectProperty}s of the given
{@link IndexedPropertyChain}, if not computing before, recording all
{@link ObjectPropertyInference}s using the provided {@link Producer}. It
is ensured that all {@link ObjectPropertyInference}s are applied only
once even if the method is called multiple times.

@param input
the {@link IndexedPropertyChain} for which to find the sub-
{@link IndexedObjectProperty}s.
@param inferenceProducer
the {@link Producer} using which all applied
{@link ObjectPropertyInference}s are recorded.
@return the sub-{@link IndexedObjectProperty} of the given
{@link IndexedPropertyChain}"
"public void eventProcessingFailed(FailureReason failureReason) {
		raEntity.getResourceAdaptorObject().eventProcessingFailed(activityHandle, fireableEventType,
				failureReason, address, receivableService, eventFlags,
				failureReason);
	}","/*
(non-Javadoc)

@seeorg.mobicents.slee.core.event.SleeEventProcessingFailedCallback#
eventProcessingFailed(javax.slee.resource.FailureReason)"
"public static String getInverseConnectionFieldName(final String iFieldName, final boolean useVertexFieldsForEdgeLabels) {
    if (useVertexFieldsForEdgeLabels) {
      if (iFieldName.startsWith(CONNECTION_OUT_PREFIX)) {
        if (iFieldName.length() == CONNECTION_OUT_PREFIX.length())
          // ""OUT"" CASE
          return CONNECTION_IN_PREFIX;

        return CONNECTION_IN_PREFIX + iFieldName.substring(CONNECTION_OUT_PREFIX.length());

      } else if (iFieldName.startsWith(CONNECTION_IN_PREFIX)) {
        if (iFieldName.length() == CONNECTION_IN_PREFIX.length())
          // ""IN"" CASE
          return CONNECTION_OUT_PREFIX;

        return CONNECTION_OUT_PREFIX + iFieldName.substring(CONNECTION_IN_PREFIX.length());

      } else
        throw new IllegalArgumentException(""Cannot find reverse connection name for field "" + iFieldName);
    }

    if (iFieldName.equals(OrientBaseGraph.CONNECTION_OUT))
      return OrientBaseGraph.CONNECTION_IN;
    else if (iFieldName.equals(OrientBaseGraph.CONNECTION_IN))
      return OrientBaseGraph.CONNECTION_OUT;

    throw new IllegalArgumentException(""Cannot find reverse connection name for field "" + iFieldName);
  }",(Internal only)
"public Props loadEnvironment(final String prefix) {
		final Map<String, String> environmentMap = System.getenv();
		load(environmentMap, prefix);
		return this;
	}","Loads environment properties with given prefix.
If prefix is <code>null</code> it will not be used."
"public static void showSoftInput(final View textView) {
    try {
      final InputMethodManager imm = (InputMethodManager)textView.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.showSoftInput(textView, InputMethodManager.SHOW_FORCED);
    } catch (final Exception e) {
      Log.w(TAG, ""Ignore exception"", e);
    }
  }","Show soft keyboard.
@param textView text view containing current window token"
"@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest httpRequest = (HttpServletRequest) request;
		String requestURI = httpRequest.getRequestURI();
		String contextPath = httpRequest.getContextPath();
		String requestPath = requestURI.substring(contextPath.length());

		// request-uri = context-path request-path
		// context-path = ""/"" path-component
		// request-path = 1*(""/"" path-component)

		File file = new File(request.getServletContext().getRealPath(requestPath));
		if (file.exists()) {
			chain.doFilter(request, response);
			return;
		}

		// request-path = [""/"" locale] [""/"" security-domain] 1*(""/"" path-component)

		RequestContext context = container.getInstance(RequestContext.class);

		String queryString = httpRequest.getQueryString();
		context.setRequestURL(queryString != null ? Strings.concat(requestURI, '?', queryString) : requestURI);

		if (!locales.isEmpty()) {
			for (String locale : locales) {
				if (startsWith(requestPath, locale)) {
					requestPath = requestPath.substring(locale.length() + 1);
					context.setLocale(new Locale(locale));
					break;
				}
			}
		}

		for (String securityDomain : securityDomains) {
			if (startsWith(requestPath, securityDomain)) {
				requestPath = requestPath.substring(securityDomain.length() + 1);
				context.setSecurityDomain(securityDomain);
				break;
			}
		}

		context.setRequestPath(requestPath);
		request.getRequestDispatcher(requestPath).forward(request, response);
	}","Search request URI for locale and security domain, by comparing with internal lists, and remove found values. Update
locale, security domain and request path on context request from current thread, see
{@link RequestContext#setLocale(Locale)}, {@link RequestContext#setSecurityDomain(String)} and
{@link RequestContext#setRequestPath(String)}.
<p>
Remove locale and security context from current request URI and forward it. If current request URI is for a static
resource, that is, an existing file this filter does nothing.
<p>
It is considered a resource not found and rejected with 404 if a request URI contains a locale code that is not listed
into filter parameter. If <code>locale</code> filter parameter is not declared all locale code that may be present into
request URI are passed unprocessed. If request URI contains a security domain that is not listed into
<code>security-domain</code> filter parameter, it is forwarded unprocessed.

@param request servlet request,
@param response servlet response,
@param chain filter chain.
@throws IOException for failure on underlying request and response streams.
@throws ServletException if filter chaining or request forwarding fails."
"@Nonnull
  public static GenericodeReader <com.helger.genericode.v10.ColumnSetDocument> gc10ColumnSet ()
  {
    return new GenericodeReader<> (EGenericodeDocumentType.GC10_COLUMN_SET,
                                   com.helger.genericode.v10.ColumnSetDocument.class);
  }","Create a reader builder for com.helger.genericode.v10.ColumnSetDocument.

@return The builder and never <code>null</code>"
"public FileGenerationMetrics generate(Iterator<C> components) throws IOException {
    File result = fileSupplier.get();
    return new FileGenerationMetrics(result, generate(components, new FileBuffer(result)));
  }","Generate a file by assembling components.
@param components The components to assemble
@return The generated file and metrics about the generation process
@throws IOException When an I/O error occurs"
"protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) {
		List<Node> selectedNodes = select(rootNode, selectors);

		for (Node selectedNode : selectedNodes) {
			if (!results.contains(selectedNode)) {
				results.add(selectedNode);
			}
		}
	}",Process selectors and keep adding results.
"public static void rotate( double theta, GeoTuple2D_F64 pt, GeoTuple2D_F64 solution ) {
		double c = Math.cos( theta );
		double s = Math.sin( theta );

		double x = pt.x;
		double y = pt.y;

		solution.x = c * x - s * y;
		solution.y = s * x + c * y;
	}","Rotates a 2D point by the specified angle.

@param theta
@param pt
@param solution where the solution is written to.  Can be the same point as 'pt'."
"public final boolean parse(InputStream stream)
    {
        Dap2Parser parser = new Dap2Parser(new DefaultFactory());
        String text;
        try {
            text = DConnect2.captureStream(stream);
            if(parser.errparse(text, this) != Dap2Parser.DapERR) return false;
        } catch (ParseException pe) {
            this.initCause(pe);
        } catch (IOException pe) {
            this.initCause(pe);
        }
        return true;
    }","Reads an Error description from the named InputStream.  This
method calls a generated parser to interpret an ASCII representation of an
<code>Error</code>, and regenerate it as a <code>DAP2Exception</code>.

@param stream the text containing the <code>Error</code> to parse."
"public static Type parameterizedInnerClass(Type owner, Class<?> clazz, Type... arguments) {
		// never allow an owner on a class that doesn't have one
		if (clazz.getDeclaringClass() == null && owner != null) {
			throw new IllegalArgumentException(""Cannot specify an owner type for a top level class"");
		}
		
		Type realOwner = transformOwner(owner, clazz);
		
		if (arguments == null) {
			if (clazz.getTypeParameters().length == 0) {
				// no arguments known, but no needed so just use an empty argument list.
				// (we can still end up with a generic type if the owner is generic)
				arguments = new Type[0];
			} else {
				// missing type arguments, return the raw type
				return clazz;
			}
		} else {
			if (arguments.length != clazz.getTypeParameters().length) {
				throw new IllegalArgumentException(""Incorrect number of type arguments for ["" + clazz + ""]: "" +
						""expected "" + clazz.getTypeParameters().length + "", but got "" + arguments.length);
			}
		}
		
		// if the class and its owner simply have no parameters at all, this is not a parameterized type
		if (!GenericTypeReflector.isMissingTypeParameters(clazz)) {
			return clazz;
		}
		
		// if the owner type is missing type parameters and clazz is non-static, this is a raw type
		if (realOwner != null && !Modifier.isStatic(clazz.getModifiers())
				&& GenericTypeReflector.isMissingTypeParameters(realOwner)) {
			return clazz;
		}
		
		ParameterizedType result = new ParameterizedTypeImpl(clazz, arguments, realOwner);
		checkParametersWithinBound(result);
		return result;
	}","Creates a type of <tt>clazz</tt> with <tt>arguments</tt> as type arguments, nested in <tt>owner</tt>.
<p>
In the ideal case, this returns a {@link ParameterizedType} with all generic information in it.
If some type arguments are missing or if the resulting type simply doesn't need any type parameters,
it returns the raw <tt>clazz</tt>.
Note that types with some parameters specified and others not, don't exist in Java.
<p>
If the caller does not know the exact <tt>owner</tt> type or <tt>arguments</tt>, <tt>null</tt> should be given
(or {@link #parameterizedClass(Class, Type...)} or {@link #innerClass(Type, Class)} could be used).
If they are not needed (non-generic owner and/or <tt>clazz</tt> has no type parameters), they will be filled in
automatically. If they are needed but are not given, the raw <tt>clazz</tt> is returned.
<p>
The specified <tt>owner</tt> may be any subtype of <tt>clazz.getDeclaringClass()</tt>. It is automatically
converted into the right parameterized version of the declaring class.
If <tt>clazz</tt> is a <tt>static</tt> (nested) class, the owner is not used.

@param owner The owner type. This should be a subtype of <tt>clazz.getDeclaringClass()</tt>,
or <tt>null</tt> if no owner is known.
@param clazz Type class of the type to create
@param arguments Type arguments for the variables of <tt>clazz</tt>, or null if these are not known.
@return A {@link ParameterizedType} if <tt>clazz</tt> or the class declaring <tt>clazz</tt> is generic,
and all the needed type arguments are specified in <tt>owner</tt> and <tt>arguments</tt>.
Otherwise, just returns <tt>clazz</tt>.
@throws IllegalArgumentException if <tt>arguments</tt> (is non-null and) has an incorrect length,
or if one of the <tt>arguments</tt> is not within the bounds declared on the matching type variable,
or if owner is non-null but <tt>clazz</tt> has no declaring class (e.g. is a top-level class),
or if owner is not a a subtype of <tt>clazz.getDeclaringClass()</tt>.
@throws NullPointerException if <tt>clazz</tt> or one of the elements in <tt>arguments</tt> is null."
"public Session getSession(String hostsAndPorts, String username, String password,
            String keyspace) {
        return getSession(hostsAndPorts, username, password, keyspace, false);
    }","Obtain a Cassandra session instance.

<p>
The existing session instance will be returned if such existed.
</p>

@param hostsAndPorts
@param username
@param password
@param keyspace
@return
@throws NoHostAvailableException
@throws AuthenticationException"
"private static byte[] readStream(final InputStream inputStream, final boolean close)
      throws IOException {
    if (inputStream == null) {
      throw new IOException(""Class not found"");
    }
    try {
      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
      byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
      int bytesRead;
      while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
        outputStream.write(data, 0, bytesRead);
      }
      outputStream.flush();
      return outputStream.toByteArray();
    } finally {
      if (close) {
        inputStream.close();
      }
    }
  }","Reads the given input stream and returns its content as a byte array.

@param inputStream an input stream.
@param close true to close the input stream after reading.
@return the content of the given input stream.
@throws IOException if a problem occurs during reading."
"public boolean match(String[] urlSegments, PathVariables pathVariables) {
        Validate.isTrue(urlSegments.length == matchers.length);

        for (int i = 1; i < matchers.length; i++) {
            if (!matchers[i].match(urlSegments[i], pathVariables)) {
                pathVariables.clear(); // 注意：不匹配的情况下，需要清除此次匹配的内容
                return false;
            }
        }
        return true;
    }",和实际的 URL 进行匹配，并返回成功匹配的参数(pathVariables)
"@Override
    public BaseRobotRules getRobotRulesSet(Protocol http, URL url) {

        String cacheKey = getCacheKey(url);

        // check in the error cache first
        BaseRobotRules robotRules = ERRORCACHE.getIfPresent(cacheKey);
        if (robotRules != null) {
            return robotRules;
        }

        // now try the proper cache
        robotRules = CACHE.getIfPresent(cacheKey);
        if (robotRules != null) {
            return robotRules;
        }

        boolean cacheRule = true;
        URL redir = null;

        String keyredir = null;

        LOG.debug(""Cache miss {} for {}"", cacheKey, url);
        List<Integer> bytesFetched = new LinkedList<>();
        try {
            ProtocolResponse response = http.getProtocolOutput(new URL(url,
                    ""/robots.txt"").toString(), Metadata.empty);
            int code = response.getStatusCode();
            bytesFetched.add(response.getContent() != null ? response
                    .getContent().length : 0);
            // try one level of redirection ?
            if (code == 301 || code == 302 || code == 307 || code == 308) {
                String redirection = response.getMetadata().getFirstValue(
                        HttpHeaders.LOCATION);
                if (StringUtils.isNotBlank(redirection)) {
                    if (!redirection.startsWith(""http"")) {
                        // RFC says it should be absolute, but apparently it
                        // isn't
                        redir = new URL(url, redirection);
                    } else {
                        redir = new URL(redirection);
                    }
                    // try from the cache
                    keyredir = getCacheKey(redir);
                    if (cacheKey.equalsIgnoreCase(keyredir)) {
                        keyredir = null;
                    } else {
                        RobotRules cachedRediRobotRules = CACHE
                                .getIfPresent(keyredir);
                        if (cachedRediRobotRules != null) {
                            // cache also for the redirected host
                            // but only if the robots.txt file is at the root
                            if (redir.getPath().equals(""/robots.txt"")) {
                                LOG.debug(
                                        ""Caching robots for {} under key {} in cache"",
                                        redir, keyredir);
                                CACHE.put(keyredir, cachedRediRobotRules);
                            }
                            return cachedRediRobotRules;
                        }
                    }

                    response = http.getProtocolOutput(redir.toString(),
                            Metadata.empty);
                    code = response.getStatusCode();
                    bytesFetched.add(response.getContent() != null ? response
                            .getContent().length : 0);
                }
            }
            if (code == 200) // found rules: parse them
            {
                String ct = response.getMetadata().getFirstValue(
                        HttpHeaders.CONTENT_TYPE);
                robotRules = parseRules(url.toString(), response.getContent(),
                        ct, agentNames);
            } else if ((code == 403) && (!allowForbidden)) {
                robotRules = FORBID_ALL_RULES; // use forbid all
            } else if (code >= 500) {
                cacheRule = false;
                robotRules = EMPTY_RULES;
            } else
                robotRules = EMPTY_RULES; // use default rules
        } catch (Throwable t) {
            LOG.info(""Couldn't get robots.txt for {} : {}"", url, t.toString());
            cacheRule = false;
            robotRules = EMPTY_RULES;
        }

        Cache<String, RobotRules> cacheToUse = CACHE;
        String cacheName = ""success"";
        if (!cacheRule) {
            cacheToUse = ERRORCACHE;
            cacheName = ""error"";
        }

        RobotRules cached = new RobotRules(robotRules);

        LOG.debug(""Caching robots for {} under key {} in cache {}"", url,
                cacheKey, cacheName);
        cacheToUse.put(cacheKey, cached);

        // cache robot for redirections
        // get here only if the target has not been found in the cache
        if (keyredir != null) {
            // cache also for the redirected host
            // but only if the robots.txt file is at the root
            if (redir.getPath().equals(""/robots.txt"")) {
                LOG.debug(""Caching robots for {} under key {} in cache {}"",
                        redir, keyredir, cacheName);
                cacheToUse.put(keyredir, cached);
            }
        }

        RobotRules live = new RobotRules(robotRules);
        live.setContentLengthFetched(Ints.toArray(bytesFetched));
        return live;
    }","Get the rules from robots.txt which applies for the given {@code url}.
Robot rules are cached for a unique combination of host, protocol, and
port. If no rules are found in the cache, a HTTP request is send to fetch
{{protocol://host:port/robots.txt}}. The robots.txt is then parsed and
the rules are cached to avoid re-fetching and re-parsing it again.

@param http
The {@link Protocol} object
@param url
URL robots.txt applies to

@return {@link BaseRobotRules} holding the rules from robots.txt"
"public PositionalContext getParentContext()
    {
        PositionalTermTraverserImpl.PositionalContextOperator position = contextStack.peek();

        return (position != null) ? position.getParentContext() : null;
    }",{@inheritDoc}
"private boolean isDelimiter() throws JasperException {
	if (! isSpace()) {
	    int ch = peekChar();
	    // Look for a single-char work delimiter:
	    if (ch == '=' || ch == '>' || ch == '""' || ch == '\''
		    || ch == '/') {
		return true;
	    }
	    // Look for an end-of-comment or end-of-tag:		
	    if (ch == '-') {
		Mark mark = mark();
		if (((ch = nextChar()) == '>')
		        || ((ch == '-') && (nextChar() == '>'))) {
		    reset(mark);
		    return true;
		} else {
		    reset(mark);
		    return false;
		}
	    }
	    return false;
	} else {
	    return true;
	}
    }","Parse utils - Is current character a token delimiter ?
Delimiters are currently defined to be =, &gt;, &lt;, "", and ' or any
any space character as defined by <code>isSpace</code>.

@return A boolean."
"public static String relativize(URL base, URL full)
	{
		try {
			return base.toURI().relativize(full.toURI())
				.normalize().toString();
		} catch (URISyntaxException ex) {
			throw new IllegalArgumentException(ex);
		}
	}","Relativizes the specified full {@code URL} against the given base.
Behaves as {@link java.net.URI#relativize(java.net.URI)}.

@param base the base {@code URL}.
@param full the full {@code URL}.

@return the relativized path.

@throws NullPointerException if one of the arguments is {@code null}.
@throws IllegalArgumentException if the relativization fails."
