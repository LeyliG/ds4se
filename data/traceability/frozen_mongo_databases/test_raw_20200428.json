{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc1"},"name":"us895.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us895.c - Unit Tests for User Story 895 - Proxy CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US895_SERVER_PORT   29895\n#define US895_PROXY_PORT   29095\n\n#ifndef WIN32\n#define US895_CACERT        \"CA/estCA/cacert.crt\"\n#define US895_TRUSTED_CERT  \"CA/trustedcerts.crt\"\n#define SERVER_UT_CACERT    \"CA/estCA/cacert.crt\"\n#define SERVER_UT_PUBKEY    \"./est_client_ut_keypair\"\n\n#define US895_SERVER_IP     \"127.0.0.1\" \n#define US895_CACERTS       \"CA/estCA/cacert.crt\"\n#define US895_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US895_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define US895_CACERT        \"CA\\\\estCA\\\\cacert.crt\"\n#define US895_TRUSTED_CERT  \"CA\\\\trustedcerts.crt\"\n#define SERVER_UT_CACERT     \"CA\\\\estCA\\\\cacert.crt\"\n#define SERVER_UT_PUBKEY    \"est_client_ut_keypair\"\n\n#define US895_SERVER_IP     \"127.0.0.1\" \n#define US895_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US895_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US895_SERVER_CERTKEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif\n\n#define TEST_ATTR_POP \"MAsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR_NOPOP \"MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR_NOPOPPOP \"MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n#define TEST_ATTR_POPADDED \"MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n#define TEST_ATTR1 \"MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\\0\"\n#define TEST_ATTR2 \"MAA=\\0\"\n#define TEST_ATTR7 \"MA==\\0\"\n#define TEST_ATTR2_POP \"MAsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR8 \"MAthisis badsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR3 \"MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\\0\"\n#define TEST_ATTR4_122 \"MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR4_122POP \"MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR5_117 \"MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR5_117POP \"MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0\"\n#define TEST_ATTR6_116 \"MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR_244 \"MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR_245 \"MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0\"\n#define TEST_ATTR_250 \"MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR_250POP \"MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0\"\n#define TEST_ALL_ATTR \"MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0\"\n#define TEST_1024_NOPOP \"MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n\n#define TEST_1025_NOPOP \"MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_1024_POP \"MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n\n#define TEST_LONG_ATTR \"MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0\"\n\n#define EST_UT_MAX_CMD_LEN 255\nextern EST_CTX *ectx;\n\nstatic void us895_clean (void)\n{\n}\n\nstatic int us895_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US895_SERVER_PORT,\n                  US895_SERVER_CERTKEY,\n                  US895_SERVER_CERTKEY,\n                  \"US895 test realm\",\n                  US895_CACERT,\n                  US895_TRUSTED_CERT,\n                  \"CA/estExampleCA.cnf\",\n                  manual_enroll,\n                  0,\n                  nid);\n\n    if (rv) {\n        return (rv);\n    }\n\n    /*\n     * Next we start an EST proxy acting as an RA\n     */\n    rv = st_proxy_start(US895_PROXY_PORT,\n                        US895_SERVER_CERTKEY,\n                        US895_SERVER_CERTKEY,\n                        \"US895 test realm\",\n                        US895_CACERT,\n                        US895_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US895_SERVER_PORT,\n                        0,\n                        nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us895_init_suite (void)\n{\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(\"Starting EST Server CSR attributes unit tests.\\n\");\n\n    /*\n     * gen the keypair to be used for EST Proxy testing\n     */\n    snprintf(\n        cmd,\n        EST_UT_MAX_CMD_LEN,\n        \"openssl ecparam -name prime256v1 -genkey -out %s\",\n        SERVER_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n\n    rv = system(cmd);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US895_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us895_clean();\n\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us895_start_server(0, 0);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us895_destroy_suite (void)\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n    return 0;\n}\n\nstatic unsigned char * handle_short_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR7);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_corrupt_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR8);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_long_csrattrs_request (int *csr_len,\n                                                     char *path_seg,\n                                                     void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_LONG_ATTR);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_correct_csrattrs_request (int *csr_len,\n                                                        char * path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR1);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_nopop_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR_NOPOP);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_empty_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = 0;\n    csr_data = NULL;\n    return (csr_data);\n}\n\n/*\n * Callback function passed to est_proxy_init()\n */\nstatic int proxy_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the server side variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us895_test1 (void)\n{\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY * priv_key;\n    int csr_len;\n    unsigned char *csr_data = NULL;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(SERVER_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(SERVER_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(\"\\nError while reading private key file %s\\n\", SERVER_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        proxy_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US895_SERVER_IP, US895_PROXY_PORT, NULL);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    /* should get 204 with no data */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* Setting the smallest base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2));\n    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR3));\n    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));\n    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Enable PoP and test responses with PoP added */\n    st_enable_pop();\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_data != NULL);\n    CU_ASSERT(csr_len = 20);\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_POP));\n    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));\n    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));\n    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us895_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us895_proxy_csrattrs\",\n            us895_init_suite,\n            us895_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"CSR Proxy Attributes API1\", us895_test1)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc2"},"name":"us748.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us748.c - Unit Tests for User Story 748 - Proxy simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US748_RETRY_INTERVAL    3600\n//#define US748_TCP_PORT        29001\n\n#define US748_TCP_SERVER_PORT       15748\n#define US748_TCP_PROXY_PORT        16748\n\n#ifndef WIN32\nstatic char test5_outfile[FILENAME_MAX] = \"US748/test5.hdr\";\n#define US748_SERVER_CERT \"CA/estCA/private/estservercertandkey.pem\"\n#define US748_SERVER_KEY \"CA/estCA/private/estservercertandkey.pem\"\n/* #define US748_PROXY_CERT \"CA/estCA/private/estservercertandkey.pem\"   */\n/* #define US748_PROXY_KEY \"CA/estCA/private/estservercertandkey.pem\" */\n#define US748_PROXY_CERT \"US748/cert.pem\"  \n#define US748_PROXY_KEY \"US748/key.pem\"\n#define US748_CACERT \"CA/estCA/cacert.crt\"\n#define US748_TRUSTED_CERT \"CA/trustedcerts.crt\"\n#else\nstatic char test5_outfile[FILENAME_MAX] = \"US748\\\\test5.hdr\";\n#define US748_SERVER_CERT \"CA\\\\estCA/private\\\\estservercertandkey.pem\"\n#define US748_SERVER_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n/* #define US748_PROXY_CERT \"CA/estCA/private/estservercertandkey.pem\"   */\n/* #define US748_PROXY_KEY \"CA/estCA/private/estservercertandkey.pem\" */\n#define US748_PROXY_CERT \"US748\\\\cert.pem\"  \n#define US748_PROXY_KEY \"US748\\\\key.pem\"\n#define US748_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define US748_TRUSTED_CERT \"CA\\\\trustedcerts.crt\"\n#endif\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US748_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US748_PKCS10_DSA1024 \"MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US748_PKCS10_ECDSA256 \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n#define US748_PKCS10_CORRUPT \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US748_PKCS10_STALE_POP \"MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=\"\n\n#define US748_ENROLL_URL_BA \"https://127.0.0.1:15748/.well-known/est/simpleenroll\"\n\n#define US748_PKCS10_CT     \"Content-Type: application/pkcs10\" \n#define US748_UIDPWD_GOOD   \"estuser:estpwd\"\n#define US748_CACERTS       \"CA/estCA/cacert.crt\"\n#define US748_EXPLICIT_CERT \"US748/cert-RA.pem\" \n#define US748_EXPLICIT_KEY  \"US748/key-RA.pem\"\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\nstatic void us748_clean (void)\n{\n}\n\nstatic int us748_start_server (int manual_enroll, int nid)\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US748_TCP_SERVER_PORT,\n                  US748_SERVER_CERT,\n                  US748_SERVER_KEY,\n                  \"estrealm\",\n                  US748_CACERT,\n                  US748_TRUSTED_CERT,\n                  \"US748/estExampleCA.cnf\",\n                  manual_enroll, // manual enroll\n                  0,  // disable PoP\n                  nid); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start(US748_TCP_PROXY_PORT,\n                        US748_PROXY_CERT,\n                        US748_PROXY_KEY,\n                        \"estrealm\",\n                        US748_CACERT,\n                        US748_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US748_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        nid);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\nvoid us748_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us748_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US748_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us748_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us748_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us748_destroy_suite (void)\n{\n    us748_stop_server();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple enroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * enrollment of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - EC prime 256\n *\n * This test case uses libcurl to test simple\n * enrollment of a 256 bit EC CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_ECDSA256,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - DSA prime 1024\n *\n * This test case uses libcurl to test simple\n * enrollment of a 1024 bit DSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_DSA1024,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - Corrupted PKCS10\n *\n * This test case uses libcurl to test simple\n * enrollment usinga corrupted CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_CORRUPT,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since the CSR is not valid, the server should\n     * respond with a 400.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - manual enrollment\n *\n * This test case verifies the server is\n * sending the appropriate retry-after response.\n */\nstatic void us748_test5 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    us748_stop_server();\n\n    /* Restart the server with manual enrollment enabled */\n    us748_start_server(1, 0);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, &write_func);\n    fclose(outfile);\n\n    /*\n     * Since the server hasn't seen this CSR in the past,\n     * it should respond with a retry-after 202 response.\n     */\n    CU_ASSERT(rv == 202);\n\n    /*\n     * Verify the retry-after value\n     \n     sprintf(cmd, \"grep Retry-After %s | grep %d\", test5_outfile,\n     US748_RETRY_INTERVAL);\n     rv = system(cmd);\n     */\n    rv = grep(test5_outfile, \"Retry-After: 3600\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We will avoid waiting the full retry period since we're\n     * only simulating manual enrollment.  Wait a second and then\n     * try to enroll the cert again.\n     */\n    SLEEP(1);\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * This enrollment request should succeed this time\n     * Our simulated manual enrollment will automatically\n     * enroll on the second attempt.\n     */\n    CU_ASSERT(rv == 200);\n\n    /* Stop the EST server */\n    us748_stop_server();\n\n    /* Restart the server with manual enrollment disabled */\n    us748_start_server(0, 0);\n}\n\n/*\n * Simple enroll - PoP check fails with curl\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  Since curl does not\n * set the PoP, the EST enrollment should fail.\n */\nstatic void us748_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Send a valid enroll request using curl.  Curl does not\n     * include the PoP\n     */\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * The server should respond with a failure code\n     */\n    CU_ASSERT(rv == 400);\n\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP check succeeds with estclient\n *\n * This test case verifies the proxy is\n * verifying the PoP from the client CSR.  We use\n * estclient since it supports the PoP.\n */\nstatic void us748_test7 (void)\n{\n    long rv;\n    EST_CTX *c_ctx;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This test case requires PoP to be enabled\n     */\n    st_enable_pop();\n\n    /*\n     * Create a client context\n     */\n    c_ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(c_ctx != NULL);\n    if (!c_ctx) {\n        return;\n    }\n\n    /*\n     * Specify user ID and password since the server is running\n     * in Basic Authentication mode.\n     */\n    rv = est_client_set_auth(c_ctx, \"estuser\", \"estpwd\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    est_client_set_server(c_ctx, \"127.0.0.1\", US748_TCP_PROXY_PORT, NULL);\n\n    /*\n     * get a keypair to be used in the enroll.\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll a CSR\n     */\n    rv = est_client_enroll(c_ctx, \"US748-test7 CN\", &pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Client library has obtained the new client certificate.\n     * Now retrieve it from the library.\n     */\n    pkcs7 = malloc(pkcs7_len);\n    if (!pkcs7) {\n        return;\n    }\n    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Clean up\n     */\n    est_destroy(c_ctx);\n    EVP_PKEY_free(new_pkey);\n    free(pkcs7);\n\n    /*\n     * Disable PoP for future test cases\n     */\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 valid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes a valid PoP even when\n * the server didn't request it.  We have to use\n * CiscoEST as the client to generate a CSR containing\n * a valid PoP.  There's no way to include a valid PoP\n * using Curl since the TLS channel binding information\n * is not known in advance.\n */\n//The following include should never be used by an application\n//but we use it here to hack the EST_CTX values mid-way\n//through this test\n#include \"../../src/est/est_locl.h\"\nstatic void us748_test9 (void)\n{\n    EST_CTX *ctx;\n    int rv;\n    unsigned char *cacerts;\n    int caclen = 0;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len = 0;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    /*\n     * Read in the CA certs\n     */\n    caclen = read_binary_file(US748_CACERTS, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Init the client context\n     */\n    ctx = est_client_init(cacerts, caclen, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    /*\n     * We'll use simple HTTP auth to identify ourselves\n     */\n    rv = est_client_set_auth(ctx, \"estuser\", \"estpwd\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_client_set_server(ctx, \"127.0.0.1\", US748_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Create some space to hold the cert and generate\n     * a private key\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll\n     */\n    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR    \n    rv = est_client_enroll(ctx, \"TestCase9\", &pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    pkcs7 = malloc(pkcs7_len);\n    rv = est_client_copy_enrolled_cert(ctx, pkcs7);\n\n    free(pkcs7);\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 invalid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes an invalid PoP even when\n * the server didn't request it.\n */\nstatic void us748_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_STALE_POP,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The enroll request should fail since the PoP was invalid\n     * We expect a 400 response.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us748_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us748_srv_simpenroll\",\n            us748_init_suite,\n            us748_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"Enroll RSA cert\", us748_test1)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll ECDSA cert\", us748_test2)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll DSA cert\", us748_test3)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll corrupted ECDSA cert\", us748_test4)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll retry-after manual approval \", us748_test5)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll PoP fail with Curl\", us748_test6)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll PoP succeed with estclient\", us748_test7)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll w/PoP disabled, CSR includes valid PoP\", us748_test9)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll w/PoP disabled, CSR includes invalid PoP\", us748_test10)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc3"},"name":"us3512.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}]],"contents":"/*------------------------------------------------------------------\n * us3512.c - Unit Tests URI path segment support in the Server\n *\n * April, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include \"../../util/test_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n\n#include \"../../src/est/est_locl.h\"\n\nextern char tst_srvr_path_seg_enroll[];\nextern char tst_srvr_path_seg_cacerts[];\nextern char tst_srvr_path_seg_csrattrs[];\nextern char tst_srvr_path_seg_auth[];\nextern char tst_proxy_path_seg_auth[];\n\nstatic int path_segment_support;\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n\n#define US3512_SERVER_PORT      29496\n#define US3512_SERVER_IP        \"127.0.0.1\"\n#define US3512_UIDPWD_GOOD      \"estuser:estpwd\"\n#define US3512_UID              \"estuser\"\n#define US3512_PWD              \"estpwd\"\n#ifndef WIN32\n#define US3512_CACERTS          \"CA/estCA/cacert.crt\"\n#define US3512_TRUST_CERTS      \"CA/trustedcerts.crt\"\n#define US3512_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n#define US3512_PROXY_CERT       \"CA/estCA/private/estservercertandkey.pem\"\n#define US3512_PROXY_KEY        \"CA/estCA/private/estservercertandkey.pem\"\n#define US3512_CACERT           \"CA/estCA/cacert.crt\"\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server's directory\n */\n/* #define CLIENT_UT_CACERT \"../../example/server/estCA/cacert.crt\" */\n#define CLIENT_UT_CACERT        \"CA/estCA/cacert.crt\"\n#define CLIENT_UT_PUBKEY        \"./est_client_ut_keypair\"\n#else\n#define US3512_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US3512_TRUST_CERTS      \"CA/trustedcerts.crt\"\n#define US3512_SERVER_CERTKEY   \"CA\\\\estCA/private/estservercertandkey.pem\"\n#define US3512_PROXY_CERT       \"CA\\\\estCA\\\\private/estservercertandkey.pem\"\n#define US3512_PROXY_KEY        \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US3512_CACERT           \"CA\\\\estCA\\\\cacert.crt\"\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server's directory\n */\n/* #define CLIENT_UT_CACERT \"../../example/server/estCA/cacert.crt\" */\n#define CLIENT_UT_CACERT        \"CA\\\\estCA\\\\cacert.crt\"\n#define CLIENT_UT_PUBKEY        \"est_client_ut_keypair\"\n#endif\n\n#define US3512_ENROLL_URL_BA \"https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll\"\n#define US3512_ENROLL_URL_BA_BACKSLASH \"https://127.0.0.1:29496/.well-known/est/cacerts-\\\\somestring/simpleenroll\"\n#define US3512_ENROLL_URL_BA_NOSEGMENT \"https://127.0.0.1:29496/.well-known/est/simpleenroll\"\n#define US3512_PKCS10_CT        \"Content-Type: application/pkcs10\" \n\n#define US3512_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n#define US3512_TCP_PROXY_PORT       16894\n#define PATH_SEG_VALID    \"somestring\"\n#define PATH_SEG_TOO_MANY_SEGS    \"somestring1/somestring2\"\n#define PATH_SEG_IS_OPERATION    \"cacerts\"\n#define PATH_SEG_CONTAINS_OPERATION    \"cacertssomestring\"\n#define PATH_SEG_MAX \"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\"\n#define PATH_SEG_TOO_LONG \"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"\n\n#define US3512_PROXY_ENROLL_URL_VALID \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_VALID\"/simpleenroll\"\n#define US3512_PROXY_ENROLL_URL_TOO_LONG \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_TOO_LONG\"/simpleenroll\"\n#define US3512_PROXY_ENROLL_URL_MAX \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_MAX\"/simpleenroll\"\n#define US3512_PROXY_ENROLL_URL_TOO_MANY \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_TOO_MANY_SEGS\"/simpleenroll\"\n#define US3512_PROXY_ENROLL_URL_IS_OPERATION \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_IS_OPERATION\"/simpleenroll\"\n#define US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_CONTAINS_OPERATION\"/simpleenroll\"\n#define US3512_PROXY_CACERTS_URL_VALID \"https://127.0.0.1:16894/.well-known/est/\"PATH_SEG_VALID\"/cacerts\"\n\n#define US3512_PKCS10_REQ    \"MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n\"\n\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);\n\nstatic void us3512_clean (void)\n{\n}\n\nstatic int us3512_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start_nocacerts(US3512_SERVER_PORT,\n                            US3512_SERVER_CERTKEY,\n                            US3512_SERVER_CERTKEY,\n                            \"US3512 test realm\",\n                            US3512_CACERTS,\n                            US3512_TRUST_CERTS,\n                            \"CA/estExampleCA.cnf\",\n                            manual_enroll,\n                            0,\n                            nid);\n\n    SLEEP(1);\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start_nocacerts(US3512_TCP_PROXY_PORT,\n                                  US3512_PROXY_CERT,\n                                  US3512_PROXY_KEY,\n                                  \"estrealm\",\n                                  US3512_CACERT,\n                                  US3512_TRUST_CERTS,\n                                  \"estuser\",\n                                  \"estpwd\",\n                                  \"127.0.0.1\",\n                                  US3512_SERVER_PORT,\n                                  0,  // disable PoP\n                                  0);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\nstatic int path_seg_supported (void)\n{\n\n    EST_CTX *ectx;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    rc = est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        \"test_segment\");\n    if (rc == EST_ERR_NONE) {\n        return 1;\n    } else {\n        return 0;\n    }\n\n    return 0;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.\n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us3512_init_suite (void)\n{\n    int rv = 0;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    char cmd[EST_UT_MAX_CMD_LEN];\n    printf(\"Starting EST Server path segment unit tests.\\n\");\n\n    if (!path_segment_support) {\n        printf(\n            \"URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \\n\");\n        return 0;\n    }\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n        \"openssl ecparam -name prime256v1 -genkey -out %s\",\n        CLIENT_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us3512_clean();\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us3512_start_server(0, 0);\n    SLEEP(2);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3512_destroy_suite (void)\n{\n\n    st_stop();\n    st_proxy_stop();\n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Sanity check of the server side path segment processing.\n * - simple enroll\n * - direct to server\n * - with path segment\n * Outcome: pass\n */\nstatic void us3512_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US3512_ENROLL_URL_BA_NOSEGMENT, US3512_PKCS10_CT,\n    US3512_PKCS10_RSA2048,\n    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us3512_simple_enroll (char *cn, char *server,\n                                  EST_ERROR expected_enroll_rv,\n                                  char *path_segment)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US3512_SERVER_PORT, path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * taken from US899/test1\n * Simple enroll -  including a path segment in the uri.\n *\n * Path Segment testing\n * - This verifies the client includes a configured\n *   path segment properly and sends it.\n * - This verifies that the server correctly parses out\n *   a valid path segment and passes it up on a simple enroll.\n *\n */\nstatic void us3512_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n    char *path_segment = \"path_segment\";\n\n    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    us3512_simple_enroll(\"TC3512-2\", US3512_SERVER_IP, EST_ERR_NONE,\n        path_segment);\n\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);\n}\n\n/*\n * taken from US898/test1\n * Simple re-enroll -  including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on a simple re-enroll\n *   as well as the auth callback.\n */\nstatic void us3512_test3 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) * certs = NULL;\n    int i;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    char *path_segment = \"path_seg_us3512_test3\";\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TC-US898-1\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    if (rv != EST_ERR_NONE)\n        return;\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out, NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i = OBJ_obj2nid(p7->type);\n    switch (i) {\n    case NID_pkcs7_signed:\n        certs = p7->d.sign->cert;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        certs = p7->d.signed_and_enveloped->cert;\n        break;\n    default:\n        break;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs)\n        return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn't have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * Wow, that's a lot of work, but we finally have the X509.\n     * (don't you just love OpenSSL!!!)\n     * Now that we have an X509 representation of the cert,\n     * let's try to re-enroll this cert with the CA\n     */\n    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);\n\n    /*\n     * Cleanup\n     */\n    if (cert)\n        X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * taken from US897/test11\n * CAcerts to the server - including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on the CA certs callback.\n */\nstatic void us3512_test4 (void)\n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n\n    char *path_segment = \"path_seg_us3512_test4\";\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer's cal back function\n     */\n    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/*\n * taken from US898/test1\n * CSRAttributes -  including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on a csr attributes callback\n */\nstatic void us3512_test5 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    char *path_segment = \"path_seg_us3512_test5\";\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer's cal back function\n     */\n    memset(tst_srvr_path_seg_csrattrs, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rv == EST_ERR_NONE);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_csrattrs) == 0);\n\n    /*\n     * Cleanup\n     */\n    if (cert)\n        X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Test the flow of path segments through proxy mode - valid path segment\n * SimpleEnroll\n */\nstatic void us3512_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_VALID, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD,\n    US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    CU_ASSERT(strcmp(PATH_SEG_VALID, tst_srvr_path_seg_enroll) == 0);\n\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Test the flow of path segments through proxy mode -\n *  path segment is set to the maximum size\n *\n */\nstatic void us3512_test7 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_MAX, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that is too long, it\n     * should get caught at the proxy and a 400 should be returned\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Test the flow of path segments through proxy mode -\n *  path segment that is too large\n *\n */\nstatic void us3512_test8 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_LONG, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that is too long, it\n     * should get caught at the proxy and a 400 should be returned\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that is an operation path\n *\n */\nstatic void us3512_test9 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_IS_OPERATION, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that is an operation path\n *\n */\nstatic void us3512_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_MANY, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that contains a valid operation string within it,\n * in this case, at the front.  This is a valid path segment, so\n * the test should pass.\n *\n */\nstatic void us3512_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_proxy_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION,\n    US3512_PKCS10_CT, US3512_PKCS10_REQ,\n    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    CU_ASSERT(\n        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_srvr_path_seg_enroll) == 0);\n    CU_ASSERT(\n        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_proxy_path_seg_auth) == 0);\n\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * taken from US897/test11\n * CAcerts to the server - including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on the CA certs callback.\n */\nstatic void us3512_test12 (void)\n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n\n    char *path_segment = \"path_seg_us3512_test4\";\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_TCP_PROXY_PORT,\n        path_segment);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer's cal back function\n     */\n    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us3512_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us3512_server_path_seg\",\n            us3512_init_suite,\n            us3512_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * check to see if path segment support has been compiled in\n     */\n    if (!path_seg_supported()) {\n        printf(\"URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \\n\");\n        path_segment_support = 0;\n        return 0;\n    }\n    path_segment_support = 1;\n\n    if (path_segment_support) {\n\n        /* add the tests to the suite */\n        /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n        if (\n            (NULL == CU_add_test(pSuite, \"EST Client: Simple enroll with no path segment\", us3512_test1)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: Simple Enroll with path segment\", us3512_test2)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: Simple Re-enroll with path segment\", us3512_test3)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: CACerts with path segment\", us3512_test4)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: CSRAttrs with path segment\", us3512_test5)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment\", us3512_test6)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment at the max\", us3512_test7)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment too long\", us3512_test8)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment that is operation\", us3512_test9)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment containing too many segments\", us3512_test10)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment containing an operation\", us3512_test11)) ||\n            (NULL == CU_add_test(pSuite, \"EST Server: EST Proxy with path segment valid and cacerts\", us3512_test12))\n            )\n            {\n                CU_error = CU_get_error();\n                printf(\"%d\\n\", CU_error);\n\n                CU_cleanup_registry();\n                printf(\"%s\\n\", CU_get_error_msg());\n                return CU_get_error();\n            }\n        }\n        return CUE_SUCCESS;\n     #endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc4"},"name":"us3612.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}]],"contents":"/*------------------------------------------------------------------\n * us3612.c - Unit Tests for User Story US3612 - Encrypted Private Key Support\n *\n *\n *\n * July, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n*/\n\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic char *key_password = NULL;\nstatic int cacerts_len = 0;\n\n#define US3612_SERVER_PORT   29899\n#define US3612_SERVER_IP     \"127.0.0.1\"\n#define US3612_UID           \"estuser\"\n#define US3612_PWD           \"estpwd\"\n#define US3612_GOOD_PWD \"us3612\"\n#define US3612_BAD_PWD  \"thiscantpossiblywork\"\n#define RSA_KEYSIZE 4096\n\n/*\n * Key wrap algorithm optionally used to protect private keys\n */\n#define EST_PRIVATE_KEY_ENC EVP_aes_128_cbc()\n\n/*\n * The following certs are used for FQDN testing\n */\n#ifndef WIN32\n#define US3612_CACERTS       \"CA/estCA/cacert.crt\"\n#define US3612_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US3612_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n#define US3612_PRIVATE_KEY_FILE \"US3612/us3612_key.pem\"\n\n#else\n#define US3612_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US3612_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US3612_SERVER_CERTKEY   \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US3612_PRIVATE_KEY_FILE \"US3612\\\\us3612_key.pem\"\n\nstatic CRITICAL_SECTION logger_critical_section;\nstatic void us3612_logger_stderr (char *format, va_list l)\n{\n    EnterCriticalSection(&logger_critical_section);\n    vfprintf(stderr, format, l);\n    fflush(stderr);\n    LeaveCriticalSection(&logger_critical_section);\n}\n#endif\n\nunsigned char *BIO_copy_data(BIO *out, int *data_lenp) {\n    unsigned char *data, *tdata;\n    int data_len;\n\n    data_len = BIO_get_mem_data(out, &tdata);\n    data = malloc(data_len+1);\n    if (data) {\n        memcpy(data, tdata, data_len);\n\tdata[data_len]='\\0';  // Make sure it's \\0 terminated, in case used as string\n\tif (data_lenp) {\n\t    *data_lenp = data_len;\n\t}\n    } else {\n        printf(\"malloc failed\");\n    }\n    return data;\n}\n\nchar *generate_private_RSA_key (int key_size, pem_password_cb *cb)\n{\n    char *key_data = NULL;\n\n    RSA *rsa = RSA_new();\n    if (!rsa) {\n        return NULL;\n    }\n    BIGNUM *bn = BN_new();\n    if (!bn) {\n        RSA_free(rsa);\n        return NULL;\n    }\n\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, key_size, bn, NULL);\n\n    do {\n        BIO *out = BIO_new(BIO_s_mem());\n        if (!out) {\n            break;\n        }\n        PEM_write_bio_RSAPrivateKey(out, rsa, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);\n        key_data = (char *)BIO_copy_data(out, NULL);\n        BIO_free(out);\n        if (key_data && !key_data[0]) {\n            // happens if passphrase entered via STDIN does not verify or has less than 4 characters\n            free(key_data);\n            key_data = NULL;\n        }\n    } while (cb && !key_data);\n\n    RSA_free(rsa);\n    BN_free(bn);\n    return (key_data);\n}\n\nchar *generate_private_EC_key (int curve_nid, pem_password_cb *cb)\n{\n    EC_KEY *eckey;\n    EC_GROUP *group = NULL;\n    char *key_data = NULL;\n    int asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\n\n    /*\n     * Generate an EC key\n     */\n\n    eckey = EC_KEY_new();\n    if (!eckey) {\n        return NULL;\n    }\n\n    group = EC_GROUP_new_by_curve_name(curve_nid);\n    EC_GROUP_set_asn1_flag(group, asn1_flag);\n    EC_GROUP_set_point_conversion_form(group, form);\n    EC_KEY_set_group(eckey, group);\n    if (!EC_KEY_generate_key(eckey)) {\n        return (NULL);\n    }\n\n    do {\n        BIO *out = BIO_new(BIO_s_mem());\n        if (!out) {\n            break;\n        }\n        PEM_write_bio_ECPKParameters(out, group);\n        PEM_write_bio_ECPrivateKey(out, eckey, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);\n        key_data = (char *)BIO_copy_data(out, NULL);\n        BIO_free(out);\n        if (key_data && !strstr(key_data, \"-----BEGIN EC PRIVATE KEY-----\")) {\n            // happens if passphrase entered via STDIN does not verify or has less than 4 characters\n            free(key_data);\n            key_data = NULL;\n        }\n    } while (cb && !key_data);\n\n    EC_KEY_free(eckey);\n    return (key_data);\n}\n\nstatic int string_password_cb (char *buf, int size, int wflag, void *data)\n{\n    /*\n     * Hard code a password for this suite\n     */\n    strncpy(buf, key_password, size);\n    return(strnlen(buf, size));\n}\n\n\nstatic void us3612_clean (void)\n{\n}\n\nstatic int us3612_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US3612_SERVER_PORT,\n              US3612_SERVER_CERTKEY,\n              US3612_SERVER_CERTKEY,\n              \"US3612 test realm\",\n              US3612_CACERTS,\n              US3612_TRUST_CERTS,\n              \"CA/estExampleCA.cnf\",\n          manual_enroll,\n          0,\n          nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us3612_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us3612_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US3612_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n    return 1;\n    }\n\n    us3612_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us3612_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3612_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Simple Enroll b- client\n * Load in a password prortected private key with\n * the correct passphrase and attempt to enroll for a certificate\n */\nstatic void us3612_test1 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len,\n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n    /*\n     * Read in our test private key\n     * generated via the command below:\n     *\n     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TCUS3612-1\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n    new_cert = malloc(pkcs7_len);\n    CU_ASSERT(new_cert != NULL);\n    rv = est_client_copy_enrolled_cert(ectx, new_cert);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll CSR\n *\n * Load in a password protected private key with the incorrect password\n * and attempt to enroll for a certificate. This will fail.\n */\nstatic void us3612_test2 (void)\n{\n     EST_CTX *ectx;\n     EVP_PKEY *key;\n     int rv;\n     int pkcs7_len = 0;\n     unsigned char *new_cert = NULL;\n     unsigned char *attr_data = NULL;\n     int attr_len;\n\n     /*\n      * Create a client context\n      */\n     ectx = est_client_init(cacerts, cacerts_len,\n                            EST_CERT_FORMAT_PEM,\n                            client_manual_cert_verify);\n     CU_ASSERT(ectx != NULL);\n\n     /*\n      * Set the authentication mode to use a user id/password\n      */\n     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n     CU_ASSERT(rv == EST_ERR_NONE);\n\n     /*\n      * Set the EST server address/port\n      */\n     est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n     /*\n      * Read in our test private key\n      * generated via the command below:\n      *\n      * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n      */\n\n     key_password = US3612_BAD_PWD;\n\n     key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n     CU_ASSERT(key == NULL);\n\n     /*\n      * Get the latest CSR attributes\n      */\n     rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n     CU_ASSERT(rv == EST_ERR_NONE);\n\n     /*\n      * Use the simplified API to enroll a CSR\n      */\n     rv = est_client_enroll(ectx, \"TC3612-2\", &pkcs7_len, key);\n     CU_ASSERT(rv != EST_ERR_NONE);\n\n     /*\n      * Cleanup\n      */\n     EVP_PKEY_free(key);\n     if (new_cert) free(new_cert);\n     est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll CSR\n *\n * Change the password used by the callback after reading\n * in the protected private key file.\n */\nstatic void us3612_test3 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len,\n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n    /*\n     * Read in our test private key\n     * generated via the command below:\n     *\n     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Change out the password, EVP_PKEY should remain unaffected\n     */\n\n    key_password = US3612_BAD_PWD;\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TCUS3612-3\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n    new_cert = malloc(pkcs7_len);\n    CU_ASSERT(new_cert != NULL);\n    rv = est_client_copy_enrolled_cert(ectx, new_cert);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Test key generation utility functions\n * and associated password callbacks\n */\nstatic void us3612_test4 (void)\n{\n    char * new_pkey = NULL;\n\n    /*\n     * Generate an RSA key without a password\n     */\n\n    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, NULL);\n    CU_ASSERT(new_pkey != NULL);\n    printf(\"\\n%s\\n\", new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n    /*\n     * Generate an RSA key with password\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, string_password_cb);\n    CU_ASSERT(new_pkey != NULL);\n    printf(\"\\n%s\\n\", new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n    /*\n     * Generate an EC key without a password\n     */\n\n    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) \"prime256v1\"), NULL);\n    CU_ASSERT(new_pkey != NULL);\n    printf(\"\\n%s\\n\", new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n\n    /*\n     * Generate an EC key with a password\n     */\n    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) \"prime256v1\"), string_password_cb);\n    CU_ASSERT(new_pkey != NULL);\n    printf(\"\\n%s\\n\", new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n}\n\nint us3612_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us3612_encrypted_private_keys\",\n                      us3612_init_suite,\n              us3612_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /*\n    * Add the tests to the suite\n    */\n   if ((NULL == CU_add_test(pSuite, \"Client simple enroll w/ correct pwd\", us3612_test1)) ||\n       (NULL == CU_add_test(pSuite, \"Client simple enroll w/ incorrect pwd\", us3612_test2)) ||\n       (NULL == CU_add_test(pSuite, \"Client simple enroll w/ incorrect pwd\", us3612_test3)) ||\n       (NULL == CU_add_test(pSuite, \"Keygen Test\", us3612_test4)))\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc5"},"name":"us1159.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc83"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca5"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us1159.c - Unit Tests for User Story 1159 - CSR Attributes enforce\n *\n * October, 2014\n *\n * Copyright (c) 2014, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include \"test_utils.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n#include \"st_server.h\"\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#ifndef WIN32\n#define US1159_CACERTS          \"CA/estCA/cacert.crt\"\n#define US1159_CACERT           \"CA/estCA/cacert.crt\"\n#define US1159_SERVER_CERT      \"CA/estCA/private/estservercertandkey.pem\"\n#define US1159_SERVER_KEY       \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define US1159_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US1159_CACERT           \"CA\\\\estCA\\\\cacert.crt\"\n#define US1159_SERVER_CERT      \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1159_SERVER_KEY       \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif\n#define US1159_UID              \"estuser\"\n#define US1159_PWD              \"estpwd\"\n\n#define US1159_SERVER_PORT      15897\n#define US1159_SERVER_IP        \"127.0.0.1\"\n\n#define US1159_ATTR_POP_ONLY    \"MAsGCSqGSIb3DQEJBw==\\0\"\n#define US1159_ATTR_CN_ONLY     \"MAUGA1UEAw==\\0\"\n#define US1159_ATTR_TEST        \"MHEGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBgUrgQQAIgYDVQQDBggqhkjOPQQDAg==\\0\"\n\nextern EST_CTX *ectx;\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\nstatic char *attrs;\n\nstatic unsigned char * handle_csrattrs_request (int *csr_len, char *path_seg,\n                                                void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(attrs);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, attrs, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic void us1159_clean (void)\n{\n}\n\nint us1159_start_server ()\n{\n    int rv = 0;\n\n    /*\n     * Start an EST server acting as the CA\n     */\n    rv = st_start(US1159_SERVER_PORT,\n                  US1159_SERVER_CERT,\n                  US1159_SERVER_KEY,\n                  \"estrealm\",\n                  US1159_CACERT,\n                  \"CA/trustedcerts.crt\",\n                  \"CA/estExampleCA.cnf\",\n                  0, // manual enroll\n                  0,  // disable PoP\n                  0); // ecdhe nid info\n    if (rv != EST_ERR_NONE) {\n        printf(\"\\nUnable to start EST server for US1159.\\n\");\n        return rv;\n    }\n\n    st_enable_csrattr_enforce();\n\n    rv = est_set_csr_cb(ectx, &handle_csrattrs_request);\n    if (rv != EST_ERR_NONE) {\n        printf(\"\\nUnable to set EST CSR Attributes callback for US1159.\\n\");\n        return (rv);\n    }\n\n    SLEEP(1);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1159_init_suite (void)\n{\n    int rv;\n\n    us1159_clean();\n\n    printf(\n        \"\\nStarting server for CSR attributes enforcement unit tests (US1159).\\n\");\n\n    attrs = US1159_ATTR_POP_ONLY;\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1159_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1159_start_server();\n\n    return rv;\n}\n\nvoid us1159_stop_server ()\n{\n    st_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1159_destroy_suite (void)\n{\n    us1159_stop_server();\n    free(cacerts);\n    printf(\"Completed CSR attributes enforcement unit tests.\\n\");\n    return 0;\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function generates an EC public/private key\n * pair that will be used with the certificate\n * we provision.\n */\nstatic EVP_PKEY * generate_ec_private_key (int nid)\n{\n    EC_KEY *eckey;\n    EC_GROUP *group = NULL;\n    BIO *out;\n    unsigned char *tdata;\n    unsigned char *key_data;\n    int key_len;\n    BIO *keyin;\n    EVP_PKEY *new_priv_key;\n    int asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\n\n    /*\n     * Generate an EC key\n     */\n    group = EC_GROUP_new_by_curve_name(nid /*NID_X9_62_prime256v1*/);\n    EC_GROUP_set_asn1_flag(group, asn1_flag);\n    EC_GROUP_set_point_conversion_form(group, form);\n    eckey = EC_KEY_new();\n    EC_KEY_set_group(eckey, group);\n    if (!EC_KEY_generate_key(eckey)) {\n        printf(\"Failed to generate EC key\\n\");\n        return NULL;\n    }\n    out = BIO_new(BIO_s_mem());\n    PEM_write_bio_ECPKParameters(out, group);\n    PEM_write_bio_ECPrivateKey(out, eckey, NULL, NULL, 0, NULL, NULL);\n    key_len = BIO_get_mem_data(out, &tdata);\n    key_data = malloc(key_len + 1);\n    memcpy(key_data, tdata, key_len);\n    EC_KEY_free(eckey);\n    BIO_free(out);\n\n    /*\n     * read it back in to an EVP_PKEY struct\n     */\n    keyin = BIO_new(BIO_s_mem());\n    keyin = BIO_new_mem_buf(key_data, key_len);\n\n    /*\n     * This reads in the private key file, which is expected to be a PEM\n     * encoded private key.  If using DER encoding, you would invoke\n     * d2i_PrivateKey_bio() instead.\n     */\n    new_priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    if (new_priv_key == NULL) {\n        printf(\"\\nError while reading PEM encoded private key\\n\");\n        ERR_print_errors_fp(stderr);\n        return NULL;\n    }\n    BIO_free(keyin);\n    free(key_data);\n\n    return (new_priv_key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing no CSR attributes other than\n * challengePassword. The enroll should succeed.\n */\nstatic void us1159_test1 (void)\n{\n    EST_CTX *ctx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ctx, \"Test 1\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ctx);\n}\n\n/*\n * This routine builds a PKCS10 CSR.\n */\nstatic EST_ERROR populate_x509_request (X509_REQ *req, EVP_PKEY *pkey, char *cn)\n{\n    X509_NAME *subj;\n    int rv;\n\n    /* setup version number */\n    rv = X509_REQ_set_version(req, 0L);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_VER);\n    }\n\n    /*\n     * Add Common Name entry\n     */\n    subj = X509_REQ_get_subject_name(req);\n    rv = X509_NAME_add_entry_by_txt(subj, \"CN\", MBSTRING_ASC,\n        (const unsigned char*) cn, -1, -1, 0);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_CN);\n    }\n\n    /*\n     * Add serial number Name entry\n     */\n    rv = X509_NAME_add_entry_by_NID(subj, NID_serialNumber, MBSTRING_ASC,\n        (unsigned char*) \"12349999B\", -1, -1, 0);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_CN);\n    }\n\n    /*\n     * Add all the other attributes that the server will be expecting\n     */\n    rv = X509_REQ_add1_attr_by_txt(req, \"1.3.6.1.1.1.1.22\", MBSTRING_ASC,\n        (const unsigned char*) \"dummymac\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"2.999.1\", MBSTRING_ASC,\n        (const unsigned char*) \"dummy\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"2.999.2\", MBSTRING_ASC,\n        (const unsigned char*) \"dummy\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"2.999.3\", MBSTRING_ASC,\n        (const unsigned char*) \"dummy\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"2.999.4\", MBSTRING_ASC,\n        (const unsigned char*) \"dummy\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"1.2.840.10045.2.1\", MBSTRING_ASC,\n        (const unsigned char*) \"1.3.132.0.34\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, \"1.2.840.10045.4.3.3\", MBSTRING_ASC,\n        (const unsigned char*) \"\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_NID(req, NID_serialNumber, MBSTRING_ASC,\n        (const unsigned char*) \"123456789A\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    /*\n     * Set the public key on the request\n     */\n    rv = X509_REQ_set_pubkey(req, pkey);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_PUBKEY);\n    }\n\n    X509_REQ_print_fp(stderr, req);\n\n    return (EST_ERR_NONE);\n}\n\n#if 0\n/*\n * Sign an X509 certificate request using the digest and the key passed.\n * Returns OpenSSL error code from X509_REQ_sign_ctx();\n */\nstatic int sign_X509_REQ(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\n{\n    int rv;\n    EVP_PKEY_CTX *pkctx = NULL;\n    EVP_MD_CTX mctx;\n\n    EVP_MD_CTX_init(&mctx);\n\n    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {\n        return 0;\n    }\n\n    /*\n     * Encode using DER (ASN.1)\n     *\n     * We have to set the modified flag on the X509_REQ because\n     * OpenSSL keeps a cached copy of the DER encoded data in some\n     * cases.  Setting this flag tells OpenSSL to run the ASN\n     * encoding again rather than using the cached copy.\n     */\n    x->req_info->enc.modified = 1;\n    rv = X509_REQ_sign_ctx(x, &mctx);\n\n    EVP_MD_CTX_cleanup(&mctx);\n\n    return (rv);\n}\n#endif\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The enroll should succeed.\n */\nstatic void us1159_test2 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, \"Test 2\");\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n#if 0\n    /*\n     * Sign the request\n     */\n    ossl_rv = sign_X509_REQ(req, key, EVP_sha256());\n    CU_ASSERT(ossl_rv == 0);\n    if (!ossl_rv) {\n        ERR_print_errors_fp(stderr);\n    }\n#endif\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR except that the 521-bit curve is used. The enroll\n * should fail since the server CSR attrs specify to\n * use the 384-bit curve.\n */\nstatic void us1159_test3 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp521r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, \"Test 3\");\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR except that SHA-384 is used for the\n * signature. The enroll should fail since the server\n * CSR attrs require SHA-256.\n */\nstatic void us1159_test4 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, \"Test 3\");\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Change to SHA-384 for the signature\n     */\n    rv = est_client_set_sign_digest(ctx, NID_sha384);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured to only\n * require the CommonName.  The CSR attributes on\n * the server are configured through the static API,\n * not the callback.\n */\nstatic void us1159_test10 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Configure the static CSR attributes value\n     */\n    rv = est_server_init_csrattrs(ectx, US1159_ATTR_CN_ONLY,\n        strlen(US1159_ATTR_CN_ONLY));\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, \"Test 10\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The client also provides a large\n * quantity of additional attriutes.\n */\nstatic void us1159_test20 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n    int i;\n    char t_attr_str[50];\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, \"Test 20\");\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Jam another 25 attributes into the request\n     * We could do more, but this causes a failure on the EST server when\n     * base64 decoding the CSR due to a safeC constraint.  The max string\n     * size in safeC defaults to 4096 bytes.\n     */\n    for (i = 0; i < 25; i++) {\n        sprintf(t_attr_str, \"2.899.%d\", i);\n        rv = X509_REQ_add1_attr_by_txt(req, t_attr_str, MBSTRING_ASC,\n            (const unsigned char*) \"whatever\", -1);\n        CU_ASSERT(rv != 0);\n        if (!rv) {\n            ERR_print_errors_fp(stderr);\n        }\n    }\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The client also provides an attribute with\n * a very long name and value.\n */\nstatic void us1159_test21 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, \"Test 21\");\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Add an attribute with a long value\n     */\n    rv =\n            X509_REQ_add1_attr_by_txt(req, \"2.993.8\", MBSTRING_ASC,\n                (const unsigned char*) \"This is an attribute with a very long value that could potentially cause a problem on the EST server.  0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\",\n                -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n    }\n\n    /*\n     * Add an attribute with a long name\n     */\n    rv =\n            X509_REQ_add1_attr_by_txt(req,\n                \"2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.7\",\n                MBSTRING_ASC, (const unsigned char*) \"0123456789\", -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n    }\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured with\n * PoP enabled.\n */\nstatic void us1159_test50 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, \"Test 50\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured with\n * PoP disabled.\n */\nstatic void us1159_test51 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    st_disable_pop();\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, \"Test 51\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1159_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us1159_csr_attr_enforce\",\n            us1159_init_suite,\n            us1159_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, \"No attributes required w/pop\", us1159_test1)) ||\n        (NULL == CU_add_test(pSuite, \"All attributes provided w/pop\", us1159_test2)) ||\n        (NULL == CU_add_test(pSuite, \"EC public key wrong curve w/pop\", us1159_test3)) ||\n        (NULL == CU_add_test(pSuite, \"Wrong hash algorithm in signature w/pop\", us1159_test4)) ||\n        (NULL == CU_add_test(pSuite, \"CN only using static config w/pop\", us1159_test10)) ||\n        (NULL == CU_add_test(pSuite, \"A lot of attributes w/pop\", us1159_test20)) ||\n        (NULL == CU_add_test(pSuite, \"Long attribute w/pop\", us1159_test21)) ||\n        (NULL == CU_add_test(pSuite, \"No CSR attrs on server w/pop\", us1159_test50)) ||\n        (NULL == CU_add_test(pSuite, \"No CSR attrs on server w/o pop\", us1159_test51)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc6"},"name":"us903.c","system":"LibEST","applied_transformations":[],"ground_truth":[["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us903.c - Unit Tests for User Story 903 - Server simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#ifndef WIN32\nstatic char test5_outfile[FILENAME_MAX] = \"US903/test5.hdr\";\n#define US903_CACERTS       \"CA/estCA/cacert.crt\"\n#define US903_EXPLICIT_CERT \"US903/cert-RA.pem\" \n#define US903_EXPLICIT_KEY  \"US903/key-RA.pem\"\n#define US903_CACERTS       \"CA/estCA/cacert.crt\"\n#define US903_TRUSTED_CERT  \"CA/trustedcerts.crt\"\n#define US903_SERVER_CERT_AND_KEY \"CA/estCA/private/estservercertandkey.pem\"\n#else\nstatic char test5_outfile[FILENAME_MAX] = \"US903\\\\test5.hdr\";\n#define US903_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US903_EXPLICIT_CERT \"US903\\\\cert-RA.pem\" \n#define US903_EXPLICIT_KEY  \"US903\\\\key-RA.pem\"\n#define US903_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US903_TRUSTED_CERT  \"CA\\\\trustedcerts.crt\"\n#define US903_SERVER_CERT_AND_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US903_RETRY_INTERVAL    3600\n#define US903_TCP_PORT      29001\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US903_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US903_PKCS10_DSA1024 \"MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US903_PKCS10_ECDSA256 \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n#define US903_PKCS10_CORRUPT \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US903_PKCS10_STALE_POP \"MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=\"\n\n#define US903_ENROLL_URL_BA \"https://127.0.0.1:29001/.well-known/est/simpleenroll\"\n#define US903_PKCS10_CT     \"Content-Type: application/pkcs10\" \n#define US903_UIDPWD_GOOD   \"estuser:estpwd\"\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\nstatic void us903_clean (void)\n{\n}\n\nstatic int us903_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US903_TCP_PORT,\n                  US903_SERVER_CERT_AND_KEY,\n                  US903_SERVER_CERT_AND_KEY,\n                  \"US903 test realm\",\n                  US903_CACERTS,\n                  US903_TRUSTED_CERT,\n                  \"CA/estExampleCA.cnf\",\n                  manual_enroll,\n                  0,\n                  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us903_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US903_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us903_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us903_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us903_destory_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple enroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * enrollment of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n    US903_PKCS10_RSA2048,\n    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - EC prime 256\n *\n * This test case uses libcurl to test simple\n * enrollment of a 256 bit EC CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_ECDSA256,US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - DSA prime 1024\n *\n * This test case uses libcurl to test simple\n * enrollment of a 1024 bit DSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_DSA1024, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - Corrupted PKCS10\n *\n * This test case uses libcurl to test simple\n * enrollment usinga corrupted CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_CORRUPT, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since the CSR is not valid, the server should\n     * respond with a 400.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - manual enrollment\n *\n * This test case verifies the server is\n * sending the appropriate retry-after response.\n */\nstatic void us903_test5 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server with manual enrollment enabled */\n    us903_start_server(1, 0);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, &write_func);\n    fclose(outfile);\n\n    /*\n     * Since the server hasn't seen this CSR in the past,\n     * it should respond with a retry-after 202 response.\n     */\n    CU_ASSERT(rv == 202);\n\n    /*\n     * Verify the retry-after value\n     */\n    rv = grep(test5_outfile, \"Retry-After: 3600\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We will avoid waiting the full retry period since we're\n     * only simulating manual enrollment.  Wait a second and then\n     * try to enroll the cert again.\n     */\n    SLEEP(1);\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n\n    /*\n     * This enrollment request should succeed this time\n     * Our simulated manual enrollment will automatically\n     * enroll on the second attempt.\n     */\n    CU_ASSERT(rv == 200);\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server with manual enrollment disabled */\n    us903_start_server(0, 0);\n}\n\n/*\n * Simple enroll - PoP check fails with curl\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  Since curl does not\n * set the PoP, the EST enrollment should fail.\n */\nstatic void us903_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Send a valid enroll request using curl.  Curl does not\n     * include the PoP\n     */\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n\n    /*\n     * The server should respond with a failure code\n     */\n    CU_ASSERT(rv == 400);\n\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP check succeeds with estclient\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  We use\n * estclient since it supports the PoP.\n */\nstatic void us903_test7 (void)\n{\n    long rv;\n    EST_CTX *c_ctx;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len;\n    unsigned char *attr_data;\n    int attr_len;\n    int http_status;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This test case requires PoP to be enabled\n     */\n    st_enable_pop();\n\n    /*\n     * Create a client context\n     */\n    c_ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(c_ctx != NULL);\n    if (!c_ctx) {\n        return;\n    }\n\n    /*\n     * Specify user ID and password since the server is running\n     * in Basic Authentication mode.\n     */\n    rv = est_client_set_auth(c_ctx, \"estuser\", \"estpwd\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    est_client_set_server(c_ctx, \"127.0.0.1\", US903_TCP_PORT, NULL);\n\n    /*\n     * get a keypair to be used in the enroll.\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(c_ctx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll a CSR\n     */\n    rv = est_client_enroll(c_ctx, \"US903-test7 CN\", &pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Check HTTP status code received from server is 200\n     */\n    http_status = est_client_get_last_http_status(c_ctx);\n    CU_ASSERT(http_status == 200);\n\n    /*\n     * Client library has obtained the new client certificate.\n     * Now retrieve it from the library.\n     */\n    pkcs7 = malloc(pkcs7_len);\n    if (!pkcs7) {\n        return;\n    }\n    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Clean up\n     */\n    est_destroy(c_ctx);\n    EVP_PKEY_free(new_pkey);\n    free(pkcs7);\n\n    /*\n     * Disable PoP for future test cases\n     */\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - Use a non-default ECDHE curve\n *\n * This test case verifies the est_server_set_ecdhe_curve()\n * function is working.\n */\nstatic void us903_test8 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server using the secp384r1 curve  */\n    us903_start_server(0, NID_secp384r1);\n\n    rv = curl_http_post(\n        US903_ENROLL_URL_BA,\n        US903_PKCS10_CT,\n        US903_PKCS10_RSA2048,\n        US903_UIDPWD_GOOD,\n        US903_CACERTS,\n        CURLAUTH_BASIC,\n        \"ECDHE-ECDSA-AES256-GCM-SHA384\",\n        NULL,\n        NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 valid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes a valid PoP even when\n * the server didn't request it.  We have to use\n * CiscoEST as the client to generate a CSR containing\n * a valid PoP.  There's no way to include a valid PoP\n * using Curl since the TLS channel binding information\n * is not known in advance.\n */\n//The following include should never be used by an application\n//be we use it here to hack the EST_CTX values mid-way\n//through this test\n#include \"../../src/est/est_locl.h\"\nstatic void us903_test9 (void)\n{\n    EST_CTX *ctx;\n    int rv;\n    unsigned char *cacerts;\n    int caclen = 0;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len = 0;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    /*\n     * Read in the CA certs\n     */\n    caclen = read_binary_file(US903_CACERTS, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Init the client context\n     */\n    ctx = est_client_init(\n        cacerts,\n        caclen,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    /*\n     * We'll use simple HTTP auth to identify ourselves\n     */\n    rv = est_client_set_auth(ctx, \"estuser\", \"estpwd\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_client_set_server(ctx, \"127.0.0.1\", US903_TCP_PORT, NULL);\n\n    /*\n     * Create some space to hold the cert and generate\n     * a private key\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(ctx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll\n     */\n    ctx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR    \n    rv = est_client_enroll(ctx, \"TestCase9\", &pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    pkcs7 = malloc(pkcs7_len);\n    rv = est_client_copy_enrolled_cert(ctx, pkcs7);\n\n    free(pkcs7);\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 invalid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes an invalid PoP even when\n * the server didn't request it.\n */\nstatic void us903_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n    US903_PKCS10_STALE_POP,\n    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The enroll request should fail since the PoP was invalid\n     * We expect a 400 response.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - PoP is enabled, the CSR contains a\n *                 invalid PoP, and the client uses\n *                 a cert that contains id-kp-cmcRA.\n *\n * This test case ensures the server disables the PoP\n * check when the client is using a cert that contains\n * id-kp-cmcRA, which indicates the client is an RA.\n */\nstatic void us903_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_enable_pop();\n\n    rv = curl_http_post_certuid(\n    US903_ENROLL_URL_BA,\n    US903_PKCS10_CT,\n    US903_PKCS10_STALE_POP,\n    US903_UIDPWD_GOOD,\n    US903_EXPLICIT_CERT,\n    US903_EXPLICIT_KEY,\n    US903_CACERTS, NULL);\n\n    /*\n     * Even though the PoP value doesn't match in this CSR,\n     * the enroll will succeed since the client is using\n     * an RA certificate. We expect a 200 response.\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us903_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us903_srv_simpenroll\",\n            us903_init_suite,\n            us903_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"Enroll RSA cert\", us903_test1)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll ECDSA cert\", us903_test2)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll DSA cert\", us903_test3)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll corrupted ECDSA cert\", us903_test4)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll retry-after manual approval \", us903_test5)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll PoP fail with Curl\", us903_test6)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll PoP succeed with estclient\", us903_test7)) ||\n        (NULL == CU_add_test(pSuite, \"Non-default ECDHE curve\", us903_test8)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll w/PoP disabled, CSR includes valid PoP\", us903_test9)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll w/PoP disabled, CSR includes invalid PoP\", us903_test10)) ||\n        (NULL == CU_add_test(pSuite, \"Enroll w/PoP enabled using RA cert, CSR includes invalid PoP\", us903_test11)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc7"},"name":"us4020.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}]],"contents":"/*------------------------------------------------------------------\n * us4020.c - Unit Test for User Story 4020 - Unit test client\n *            proxy mode.  Test the new API function and\n *            verify correct operation of Client proxy modes.\n *\n * October, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include \"est.h\"\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include <errno.h>\n#include <fcntl.h>\n\n#define MAX_4020_CMDS 1024\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US4020_SERVER_DOMAIN_NAME \"localhost.cisco.com\"\n#define US4020_SERVER_IP        \"127.0.0.1\"\t\n#define US4020_SERVER_TCP_PORT\t40200\n\n#define US4020_PROXY_IP         \"127.0.0.1\"\t\n#define US4020_PROXY_TCP_PORT\t40208\n\n#define US4020_UID\t    \"estuser\"\n#define US4020_PWD\t    \"estpwd\"\n\n#ifndef WIN32\n#define US4020_CACERTS\t     \"CA/estCA/cacert.crt\"\n/* #define US4020_CACERT \"CA/estCA/cacert.crt\" */\n/* #define US4020_SERVER_CERT \"CA/estCA/private/estservercertandkey.pem\" */\n/* #define US4020_SERVER_KEY \"CA/estCA/private/estservercertandkey.pem\" */\n/* #define US4020_CLIENT_CERT \"CA/estCA/private/estservercertandkey.pem\" */\n/* #define US4020_CLIENT_KEY  \"CA/estCA/private/estservercertandkey.pem\" */\n#else\n#define US4020_CACERTS\t     \"CA\\\\estCA\\\\cacert.crt\"\n/* #define US4020_CACERT \"CA\\\\estCA\\\\cacert.crt\" */\n/* #define US4020_SERVER_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\" */\n/* #define US4020_SERVER_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\" */\n/* #define US4020_CLIENT_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\" */\n/* #define US4020_CLIENT_KEY  \"CA\\\\estCA\\\\private/estservercertandkey.pem\" */\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us4020_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&logger_critical_section); \n}\n#endif \n\nstatic EVP_PKEY *generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n\nstatic void us4020_clean (void)\n{\n}\n\nint us4020_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US4020_SERVER_TCP_PORT, \n\t          \"CA/estCA/private/estservercertandkey.pem\",\n\t          \"CA/estCA/private/estservercertandkey.pem\",\n\t          \"estrealm\",\n\t          \"CA/estCA/cacert.crt\",\n\t          \"CA/trustedcerts.crt\",\n\t          \"CA/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n#define MAX_CMD_BUF 256\n#define MAX_PID_BUF 128\nstatic void shutdown_antinat (void)\n{\n    int fh;\n    char read_pid[MAX_PID_BUF];\n    char cmd[MAX_CMD_BUF];\n    int rv = 0;\n    \n    fh = open (\"./antinat-pid\", O_RDWR, 0666);\n    \n    (void)read(fh, read_pid, MAX_PID_BUF);    \n    printf(\"pid read back in = %s\\n\", read_pid);\n\n    snprintf(cmd, MAX_CMD_BUF, \"kill %s\\n\", read_pid);\n    rv = system(cmd);\n\n    if (rv) {\n        printf(\"Failed to terminate antinat.\\n\");\n    }\n}\n\nstatic void shutdown_haproxy (void)\n{\n    int fh;\n/*     int readbyte_count = 0; */\n    char read_pid[MAX_PID_BUF];\n    char cmd[MAX_CMD_BUF];\n    int rv = 0;\n\n    fh = open (\"./haproxy.pid\", O_RDWR, 0666);\n    \n/*     readbyte_count = read(fh, read_pid, MAX_PID_BUF); */\n    (void)read(fh, read_pid, MAX_PID_BUF);\n    printf(\"pid read back in = %s\\n\", read_pid);\n\n    snprintf(cmd, MAX_CMD_BUF, \"kill %s\\n\", read_pid);\n    rv = system(cmd);\n\n    if (rv) {\n        printf(\"Failed to terminate haproxy.\\n\");\n    }\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us4020_init_suite (void)\n{\n    int rv;\n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us4020_logger_stderr);\n#else \n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n#endif    \n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US4020_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n\treturn 1;\n    }\n\n    us4020_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us4020_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us4020_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n\n\n/*\n * Error check the parameters to the API\n */\nstatic void us4020_test1 (void) \n{\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  Attempt to call the API without a context\n     */\n    e_rc= est_client_set_proxy(NULL, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n    CU_ASSERT(e_rc == EST_ERR_NO_CTX);\n\n    /*\n     * valid call\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * don't set the server \n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               NULL,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * server to empty string\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               \"\",\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * max server name \n     */\n    char * max_server_name = \"123456789012345678901234567890123456789012345678901234567890\"\n                             \"123456789012345678901234567890123456789012345678901234567890\"\n                             \"123456789012345678901234567890123456789012345678901234567890\"\n                             \"123456789012345678901234567890123456789012345678901234567890\"\n                             \"123456789012345\";\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               max_server_name,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * server name too long\n     */\n    char * long_server_name = \"123456789012345678901234567890123456789012345678901234567890\"\n                              \"123456789012345678901234567890123456789012345678901234567890\"\n                              \"123456789012345678901234567890123456789012345678901234567890\"\n                              \"123456789012345678901234567890123456789012345678901234567890\"\n                              \"1234567890123456\";\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               long_server_name,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * don't set the port\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               0,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PORT_NUM);\n\n    /* proxy protocol invalid */\n    e_rc= est_client_set_proxy(ectx, 25,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);\n\n    /* proxy protocol invalid */\n    e_rc= est_client_set_proxy(ectx, -2,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);\n\n    /* proxy auth invalid */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               25,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_AUTH);\n\n    /*\n     * max userid\n     */\n    char * max_userid = \"123456789012345678901234567890123456789012345678901234567890\"\n                        \"123456789012345678901234567890123456789012345678901234567890\"\n                        \"123456789012345678901234567890123456789012345678901234567890\"\n                        \"123456789012345678901234567890123456789012345678901234567890\"\n                        \"123456789012345\";\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               max_userid, \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * userid too long\n     */\n    char * long_userid = \"123456789012345678901234567890123456789012345678901234567890\"\n                         \"123456789012345678901234567890123456789012345678901234567890\"\n                         \"123456789012345678901234567890123456789012345678901234567890\"\n                         \"123456789012345678901234567890123456789012345678901234567890\"\n                         \"1234567890123456\";\n\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               long_userid, \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * userid is an empty string\n     */    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * max pwd\n     */\n    char * max_pwd = \"123456789012345678901234567890123456789012345678901234567890\"\n                     \"123456789012345678901234567890123456789012345678901234567890\"\n                     \"123456789012345678901234567890123456789012345678901234567890\"\n                     \"123456789012345678901234567890123456789012345678901234567890\"\n                     \"123456789012345\";\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", max_pwd);\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * pwd too long\n     */    \n    char * long_pwd = \"123456789012345678901234567890123456789012345678901234567890\"\n                      \"123456789012345678901234567890123456789012345678901234567890\"\n                      \"123456789012345678901234567890123456789012345678901234567890\"\n                      \"123456789012345678901234567890123456789012345678901234567890\"\n                      \"1234567890123456\";\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", long_pwd);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * password is an empty string\n     */    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"\");\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);    \n    \n    est_destroy(ectx);\n    \n}\n\n\n/*\n * Test for SOCKS 4 mode, no credentials, should pass\n *\n */\nstatic void us4020_test2 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-2\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 4 mode, with credentials, should pass\n *\n */\nstatic void us4020_test3 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-3\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode\n *\n */\nstatic void us4020_test4 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n/*                                \"estuser\", \"estpwd\"); */\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-4\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 4A mode\n *\n */\nstatic void us4020_test5 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n/*                                \"estuser\", \"estpwd\"); */\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-5\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with no credentials\n *\n */\nstatic void us4020_test6 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-6\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with good credentials\n *\n */\nstatic void us4020_test7 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg-goodcred.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-6\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with good credentials, but forgotten\n *\n */\nstatic void us4020_test8 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg-goodcred.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-6\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with bad credentials\n *\n */\nstatic void us4020_test9 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg-badcred.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-6\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n#if 0\n/*\n * could be tested, but needs certifcates updated\n */\n/*\n * Test for SOCKS 4A mode, with domain name \n *\n */\nstatic void us4020_test8 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"antinat -xcUS4020/antinat-cfg.xml\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_DOMAIN_NAME, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-7\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n#endif\n\n/*\n * Test HTTP proxy mode\n *\n * NOTE: only non-tunnel mode is tested.  tunnel mode does not\n * work with CiscoEST server.\n */\nstatic void us4020_test10 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a HTTP proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, \"haproxy -D -f US4020/haproxy.cfg -p ./haproxy.pid\");\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               \"estuser\", \"estpwd\");\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, \"TC4020-8\", &pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_haproxy();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Indicate whether client proxy support has been built into\n * the library or not\n */\nstatic int client_proxy_enabled (void) \n{\n    EST_ERROR e_rc;\n    \n    e_rc = est_client_set_proxy(NULL, 0, NULL, 0, 0, NULL, NULL);\n    if (e_rc == EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us4020_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us4020_tok_auth_client\", \n\t                  us4020_init_suite, \n\t\t\t  us4020_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n#ifndef WIN32\n   /*\n    * client proxy mode is only supported when libcurl has been specified.\n    */\n   if (client_proxy_enabled()){\n       \n       /* add the tests to the suite */\n       if (\n           (NULL == CU_add_test(pSuite, \"parameter check API\", us4020_test1)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 4 mode\", us4020_test2)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 4 mode w/ credentials\", us4020_test3)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 5 mode\", us4020_test4)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 4A mode\", us4020_test5)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 5 mode, no credentials\", us4020_test6)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 5 mode, good credentials\", us4020_test7)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 5 mode, forgotten credentials\", us4020_test8)) ||\n           (NULL == CU_add_test(pSuite, \"SOCKS 5 mode, bad credentials\", us4020_test9)) ||\n/*            (NULL == CU_add_test(pSuite, \"SOCKS 4A mode with domain name instead of IP address\", us4020_test7)) || */\n           (NULL == CU_add_test(pSuite, \"HTTP proxy\", us4020_test10))\n           )\n           {\n               CU_cleanup_registry();\n               return CU_get_error();\n           }\n   }\n#endif   \n   return CUE_SUCCESS;\n#endif\n}\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc8"},"name":"us896.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us896.c - Unit Tests for User Story 896 - Client CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#ifndef WIN32\n#define CLIENT_UT_CACERT \"CA/estCA/cacert.crt\"\n#define US896_CACERTS       \"CA/estCA/cacert.crt\"\n#define US896_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US896_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\n#else \n#define CLIENT_UT_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define US896_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US896_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US896_SERVER_CERTKEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif \n\n#define CLIENT_UT_PUBKEY \"./est_client_ut_keypair\"\n#define US896_SERVER_PORT   29896\n#define US896_SERVER_IP     \"127.0.0.1\" \n#define TEST_SHORT_ATTR \"M==\\0\"\n#define TEST_LONG_ATTR \"MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0\"\n#define TEST_CORRUPT_ATTR1 \"MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOIExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n#define TEST_CORRUPT_ATTR2 \"MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFM12345TIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0\"\n\n#define EST_UT_MAX_CMD_LEN 255\n\nstatic void us896_clean(void) {\n}\n\nstatic int us896_start_server(int manual_enroll, int nid) {\n    int rv;\n\n    rv = st_start(US896_SERVER_PORT,\n    US896_SERVER_CERTKEY,\n    US896_SERVER_CERTKEY, \"US896 test realm\",\n    US896_CACERTS,\n    US896_TRUST_CERTS, \"CA/estExampleCA.cnf\", manual_enroll, 0, nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us896_init_suite(void) {\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(\"Starting EST Server CSR attributes unit tests.\\n\");\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n            \"openssl ecparam -name prime256v1 -genkey -out %s\",\n            CLIENT_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us896_clean();\n\n    /*\n     * Start an instance of the EST server \n     */\n    rv = us896_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us896_destroy_suite(void) {\n    st_stop();\n    SLEEP(2);\n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error) {\n    BIO *bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n            \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n            __FUNCTION__, openssl_cert_error,\n            X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the est_client_get_csrattrs() API.\n */\nstatic void us896_test1(void) {\n    int rc;\n    unsigned char *csr_data;\n    int csr_len;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, NULL, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, NULL);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n}\n\n/*\n * Test2 - exercise the response  variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us896_test2(void) {\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n            client_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US896_SERVER_IP, US896_SERVER_PORT, NULL);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    /* \n     * All of these are negative tests and require that code in the\n     * EST server is modified such that it will allow bad/corrupted\n     * attributes to be initialized so they can be sent to the client.\n     */\n#ifdef NEGATIVE_UNIT_TEST\n    unsigned char *csr_data;\n    int csr_len;\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR1, strlen(TEST_CORRUPT_ATTR1));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR2, strlen(TEST_CORRUPT_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_SHORT_ATTR, strlen(TEST_SHORT_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n#endif\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us896_add_suite(void) {\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us896_client_csrattrs\",\n            us896_init_suite,\n            us896_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"CSR Client Attributes API1\", us896_test1)) ||\n            (NULL == CU_add_test(pSuite, \"CSR Client Attributes API2 \", us896_test2)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcc9"},"name":"us898.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us898.c - Unit Tests for User Story 898 - Client re-enroll \n *\n * October, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include <est_ossl_util.h>\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US898_SERVER_PORT   29898\n#define US898_SERVER_IP\t    \"127.0.0.1\"\t\n#define US898_UID\t    \"estuser\"\n#define US898_PWD\t    \"estpwd\"\n#ifndef WIN32\n#define US898_CACERTS\t    \"CA/estCA/cacert.crt\"\n#define US898_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US898_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n\n#define US898_TC2_CERT_TXT \"US898/tc2-new-cert.txt\"\n#define US898_TC2_CERT_B64 \"US898/tc2-new-cert.pkcs7b64\"\n#define US898_TC2_CERT_PK7 \"US898/tc2-new-cert.pkcs7\"\n#define US898_TC2_CERT_PEM \"US898/tc2-new-cert.pem\"\n\n#define US898_TC10_CSR\t\"US898/tc10_csr.pem\"\n#define US898_TC10_KEY\t\"US898/tc10_key.pem\"\n#define US898_TC10_CERT\t\"US898/tc10_cert.pem\"\n\n#define US898_TC11_KEY\t\"US898/tc11_key.pem\"\n#define US898_TC11_CERT\t\"US898/tc11_cert.pem\"\n#else\n  #define US898_CACERTS\t    \"CA\\\\estCA\\\\cacert.crt\"\n#define US898_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US898_SERVER_CERTKEY   \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n\n#define US898_TC2_CERT_TXT \"US898\\\\tc2-new-cert.txt\"\n#define US898_TC2_CERT_B64 \"US898\\\\tc2-new-cert.pkcs7b64\"\n#define US898_TC2_CERT_PK7 \"US898\\\\tc2-new-cert.pkcs7\"\n#define US898_TC2_CERT_PEM \"US898\\\\tc2-new-cert.pem\"\n\n#define US898_TC10_CSR\t\"US898\\\\tc10_csr.pem\"\n#define US898_TC10_KEY\t\"US898\\\\tc10_key.pem\"\n#define US898_TC10_CERT\t\"US898\\\\tc10_cert.pem\"\n\n#define US898_TC11_KEY\t\"US898\\\\tc11_key.pem\"\n#define US898_TC11_CERT\t\"US898\\\\tc11_cert.pem\"\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us898_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&logger_critical_section); \n}\n\n#endif\n\nstatic void us898_clean (void)\n{\n    char cmd[200];\n\n    /*\n     * These are all temporary files created \n     * by the various test cases.\n     */\n#ifndef WIN32\n    sprintf(cmd, \"rm %s\", US898_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC2_CERT_PEM);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC10_CERT);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC10_KEY);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US898_TC10_CSR);\n    system(cmd);\n#else\n    sprintf(cmd, \"del %s\", US898_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC2_CERT_PEM);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC10_CERT);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC10_KEY);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US898_TC10_CSR);\n    system(cmd);\n#endif \n}\n\n/*\n * This starts an instance of the EST server running on\n * a separate thread.  We use this to test the\n * client side API in this module.\n */\nstatic int us898_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US898_SERVER_PORT, \n\t          US898_SERVER_CERTKEY,\n\t          US898_SERVER_CERTKEY,\n\t          \"estrealm\",\n\t          US898_CACERTS,\n\t          US898_TRUST_CERTS,\n\t          \"US898/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us898_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us898_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US898_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n\treturn 1;\n    }\n\n    us898_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us898_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us898_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        return (1);\n    }    \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n//    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n\n    BIO_free(bio_err);\n    \n    return approve;\n}    \n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variet of test cases in this module.\n */\nstatic void us898_test1 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) *certs = NULL;\n    int i;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TC-US898-1\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    if (rv != EST_ERR_NONE) return;\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.  \n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out,NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i=OBJ_obj2nid(p7->type);\n    switch (i) {\n    case NID_pkcs7_signed:\n\tcerts = p7->d.sign->cert;\n\tbreak;\n    case NID_pkcs7_signedAndEnveloped:\n\tcerts = p7->d.signed_and_enveloped->cert;\n\tbreak;\n    default:\n\tbreak;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs) return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn't have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n\n    /* \n     * Wow, that's a lot of work, but we finally have the X509.\n     * (don't you just love OpenSSL!!!)\n     * Now that we have an X509 representation of the cert,\n     * let's try to re-enroll this cert with the CA\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (cert) X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  The expired certs contains\n * several X509 extensions. We verify the new issued\n * cert preserves these extensions using grep.  Note, \n * preserving these extensions requires the OpenSSL CA\n * to enable the \"copy_extensions\" knob in the OpenSSL\n * config file.  This is why this test suite uses a\n * unique copy of estExampleCA.cnf.\n */\nstatic void us898_test2 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    BIO *in;\n    char cmd[200];\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-expired.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Save the cert to a local file\n     */\n    rv = write_binary_file(US898_TC2_CERT_B64, new_cert, pkcs7_len);\n    CU_ASSERT(rv == 1);\n\n    /*\n     * Base 64 decode the cert response\n     */\n    sprintf(cmd, \"openssl base64 -d -in %s -out %s\", US898_TC2_CERT_B64, US898_TC2_CERT_PK7);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert the pkcs7 cert to a PEM cert\n     */\n    sprintf(cmd, \"openssl pkcs7 -in %s -inform DER -print_certs -out %s\", US898_TC2_CERT_PK7, US898_TC2_CERT_PEM);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert PEM cert to a textual representation of the cert\n     */\n    sprintf(cmd, \"openssl x509 -text -in %s > %s\", US898_TC2_CERT_PEM, US898_TC2_CERT_TXT);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the jimbob DNS extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, \"jimbob\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the bobcat DNS extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, \"bobcat\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the IP address extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT,\"172\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the Repudiation key usage extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT,\"Repudiation\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the public key was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, \"00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Clean up\n     */\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Test the re-enroll API to ensure it gracefully\n * handles a null X509 cert pointer.\n */\nstatic void us898_test3 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    int rv;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * re-enroll using a null x509 pointer.\n     */\n    rv = est_client_reenroll(ectx, NULL, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NO_CERT);\n\n    /*\n     * Clean up\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Test the re-enroll API to ensure it gracefully\n * handles a null EVP_PKEY pointer.\n */\nstatic void us898_test4 (void) \n{\n    EST_CTX *ectx;\n    int pkcs7_len = 0;\n    int rv;\n    X509 *cert = NULL;\n    unsigned char *cert_raw;\n    int cert_len;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in an old cert that we can use for re-enroll\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * re-enroll using a null EVP_KEY pointer.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, NULL);\n    CU_ASSERT(rv == EST_ERR_NO_KEY);\n\n    /*\n     * Clean up\n     */\n    X509_free(cert);\n    est_destroy(ectx);\n}\n\n/*\n * This test attempts to re-enroll a corrupted cert\n * The public key in the cert is has been corrupted.\n */\nstatic void us898_test5 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-corrupt.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-corrupt.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CLIENT_INVALID_KEY);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured for manual\n * approval.  The server will send back a retry-after\n * response.\n */\nstatic void us898_test6 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n\n    /*\n     * Restart the server with manual approval enabled\n     */\n    rv = us898_start_server(1, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-expired.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n\n    /*\n     * Restart the server with manual approval disabled\n     */\n    rv = us898_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Verify that a bogus user ID/password fails when\n * using HTTP basic auth.\n */\nstatic void us898_test7 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, \"hoagie\", \"chili\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-expired.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    est_destroy(ectx);\n}\n\n/*\n * Verify that a good user ID/password passes when\n * using HTTP digest auth.\n */\nstatic void us898_test8 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Enable HTTP digest authentication\n     */\n    st_enable_http_digest_auth();\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-expired.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable HTTP basic authentication\n     */\n    st_enable_http_basic_auth();\n\n}\n\n/*\n * Verify that a bogus user ID/password fails when\n * using HTTP digest auth.\n */\nstatic void us898_test9 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    int http_status;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Enable HTTP digest authentication\n     */\n    st_enable_http_digest_auth();\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, \"jdoe\", \"panthers\", NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(\"US898/key-expired.pem\", &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(\"US898/cert-expired.pem\", &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    /*\n     * Check the HTTP status code from the reenroll operation\n     */\n    http_status = est_client_get_last_http_status(ectx);\n    CU_ASSERT(http_status == 401);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable HTTP basic authentication\n     */\n    st_enable_http_basic_auth();\n\n}\n\n/*\n * Verify the server fails authentication when the\n * client sends a valid identity cert but doesn't \n * provide HTTP auth credentials.\n */\nstatic void us898_test10 (void) \n{\n    char cmd[200];\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a CSR\n     */\n    sprintf(cmd, \"openssl req -new -nodes -out %s -newkey rsa:2048 -keyout %s -subj /CN=127.0.0.1 \"\n\t    \"-config CA/estExampleCA.cnf\", \n\t    US898_TC10_CSR, US898_TC10_KEY);  \n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Sign the CSR using our local CA\n     */\n    sprintf(cmd, \"openssl ca -out %s -batch -config CA/estExampleCA.cnf -infiles %s\", \n\t    US898_TC10_CERT, US898_TC10_CSR);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US898_TC10_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US898_TC10_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n\n    /*\n     * Set the authentication mode to use the certificate \n     * No HTTP auth credentials are provided.\n     */\n    rv = est_client_set_auth(ectx, NULL, NULL, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll a cert, should fail because we \n     * didn't provide valid HTTP auth credentials\n     */\n    rv = est_client_enroll(ectx, \"TC-US898-10\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    /*\n     * Re-Enroll the cert, should work since\n     * we provide a valid cert to identify ourselves\n     * and HTTP auth isn't required for re-enroll even when\n     * the server has enabled HTTP auth.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n}\n\n/*\n * Verify the server fails authentication when the\n * client sends an expired identy cert and uses \n * valid HTTP auth credentials.\n */\nstatic void us898_test11 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US898_TC11_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US898_TC11_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n\n    /*\n     * Set the authentication mode to use the expired certificate \n     * and valid HTTP auth credentials.\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Re-Enroll the cert \n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    est_destroy(ectx);\n}\n\n\nint us898_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us898_client_reenroll\", \n\t                  us898_init_suite, \n\t\t\t  us898_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* \n    * Add the tests to the suite \n    */\n   if ((NULL == CU_add_test(pSuite, \"Simple enroll and re-enroll\", us898_test1)) ||\n       (NULL == CU_add_test(pSuite, \"Re-enroll expired cert with extensions\", us898_test2)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll using NULL cert\", us898_test3)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll using NULL key\", us898_test4)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll using corrupted X509 cert\", us898_test5)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll retry-after\", us898_test6)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll invalid UID/PWD Basic\", us898_test7)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll valid UID/PWD Digest\", us898_test8)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll invalid UID/PWD Digest\", us898_test9)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll valid certificate no HTTP auth\", us898_test10)) || \n       (NULL == CU_add_test(pSuite, \"Re-enroll expired certificate with HTTP auth\", us898_test11))) \n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcca"},"name":"us1864.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc83"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc89"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc84"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca3"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca8"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us1864.c - Unit Tests for User Story 1864 - Enable Token Auth mode in server\n *\n * March, 2015\n *\n * Copyright (c) 2015, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include <errno.h>\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1864_TCP_PORT     29001\n\n/*\n * The following CSR was generated using the following openssl command and theng\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US1864_PKCS10_RSA2048   \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n#define US1864_PKCS10_4096_REQ  \"MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\\n\"\n\n#define US1864_ENROLL_URL_BA    \"https://127.0.0.1:29001/.well-known/est/simpleenroll\"\n#define US1864_PKCS10_CT        \"Content-Type: application/pkcs10\"\n#define US1864_UIDPWD_GOOD      \"estuser:estpwd\"\n#ifndef WIN32\n#define US1864_CACERTS          \"CA/estCA/cacert.crt\"\n#define US1864_CACERT           \"CA/estCA/cacert.crt\"\n#define US1864_TRUSTED_CERT     \"CA/trustedcerts.crt\"\n#define US1864_SERVER_CERT      \"CA/estCA/private/estservercertandkey.pem\"\n#define US1864_SERVER_KEY       \"CA/estCA/private/estservercertandkey.pem\"\n#define US1864_CLIENT_CERT      \"CA/estCA/private/estservercertandkey.pem\"\n#define US1864_CLIENT_KEY       \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define US1864_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US1864_CACERT           \"CA\\\\estCA\\\\cacert.crt\"\n#define US1864_TRUSTED_CERT     \"CA\\\\trustedcerts.crt\"\n#define US1864_SERVER_CERT      \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1864_SERVER_KEY       \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1864_CLIENT_CERT      \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1864_CLIENT_KEY       \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif\n\n/*\n * curl_data_cb is passed to Curl and will be called from Curl whenever data\n * has been received, or if this function has been specified to retrieve the\n * http headers.  In this test it's used to retrieve the http headers and\n * look for the \"bearer\" token Authorization challenge.\n */\nstatic int bearer_found = 0;\nstatic size_t curl_data_cb (void *ptr, size_t size, size_t nmemb,\n                            void *userdata)\n{\n    void * rc;\n\n    if (bearer_found == 0) {\n\n        /*\n         * WARNING: strstr can be dangerous because it assumes null terminated\n         * strings.  In this case the http headers came from EST server and we\n         * know they are null terminated\n         */\n        rc = strstr(ptr, \"WWW-Authenticate: Bearer\");\n        if (rc) {\n            bearer_found = 1;\n        }\n    }\n\n    return size * nmemb;\n}\n\nstatic void us1864_clean (void)\n{\n}\n\nstatic int us1864_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US1864_TCP_PORT,\n                  US1864_SERVER_CERT,\n                  US1864_SERVER_KEY,\n                  \"US1864 test realm\",\n                  US1864_CACERTS,\n                  US1864_TRUSTED_CERT,\n                  \"CA/estExampleCA.cnf\",\n                  manual_enroll,\n                  0,\n                  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1864_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1864_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us1864_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1864_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1864_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * est_server_set_auth_mode() - unit test\n *\n * First, Test the parameters of est_server_set_auth_mode()\n */\nstatic void us1864_test1 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1864_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US1864_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US1864_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in server mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n        EST_CERT_FORMAT_PEM, \"testrealm\", x, priv_key);\n\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_server_set_auth_mode(ctx, AUTH_NONE);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_TOKEN);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, 0xffffffff);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n\n    /*\n     * Make sure we don't allow DIGEST mode when in FIPS mode\n     */\n    FIPS_mode_set(1);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    FIPS_mode_set(0);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - Token Auth Mode\n *\n * The goal of this test is to verify that the EST server responds with the\n * correct auth challenge when it's configured for Token Auth mode.  It will\n * first perform a sanity check by performing an HTTP Basic request while the\n * server is still in its default mode of HTTP Basic auth.  The test will then\n * configure the server for Token Auth mode and issue a request that does not\n * contain any auth header.  This should force the server to respond with a\n * token auth challenge header.\n */\nstatic void us1864_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US1864_ENROLL_URL_BA, US1864_PKCS10_CT,\n    US1864_PKCS10_RSA2048,\n    US1864_UIDPWD_GOOD, US1864_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we specify BASIC and the server is still in BASIC\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Switch the server over to Token mode.\n     *\n     * NOTE: I see this being done in numerous places, and it's probably safe\n     * in a test setting, but it is dangerous to change this on the fly in an\n     * operational setting.  Also note, no return code for any of these\n     * set/enable functions.\n     */\n    st_enable_http_token_auth();\n\n    bearer_found = 0;\n\n    rv = curl_http_post_cert_write(US1864_ENROLL_URL_BA,\n    US1864_PKCS10_CT,\n    US1864_PKCS10_RSA2048,\n    US1864_CLIENT_CERT,\n    US1864_CLIENT_KEY,\n    US1864_CACERTS, curl_data_cb, curl_data_cb);\n\n    /*\n     * Since we changed auth modes on the server we expect this to now\n     * fail.  We're not capturing the actual auth challenge we\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 401);\n    CU_ASSERT(bearer_found == 1);\n\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1864_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us1864_cfg_tok_auth\",\n            us1864_init_suite,\n            us1864_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"Check parms\", us1864_test1)) ||\n        (NULL == CU_add_test(pSuite, \"Attempt enroll - BASIC pass\", us1864_test2))\n        )\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n #endif\n }\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbccb"},"name":"us2174.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us2174.c - Unit Tests for User Story 2174 - Proxy simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US2174_RETRY_INTERVAL   3600\n//#define US2174_TCP_PORT       29001\n\n#define US2174_TCP_SERVER_PORT      52174\n#define US2174_TCP_PROXY_PORT       62174\n\n#ifndef WIN32\n#define US2174_SERVER_CERT      \"CA/estCA/private/estservercertandkey.pem\"\n#define US2174_SERVER_KEY       \"CA/estCA/private/estservercertandkey.pem\"\n/* #define US2174_PROXY_CERT \"CA/estCA/private/estservercertandkey.pem\"   */\n/* #define US2174_PROXY_KEY \"CA/estCA/private/estservercertandkey.pem\" */\n#define US2174_PROXY_CERT       \"US2174/cert.pem\"\n#define US2174_PROXY_KEY        \"US2174/key.pem\"\n#define US2174_CACERT           \"CA/estCA/cacert.crt\"\n#define US2174_CACERTS          \"CA/estCA/cacert.crt\"\n#define US2174_TRUSTED_CERTS    \"CA/trustedcerts.crt\"\n#define US2174_EXPLICIT_CERT    \"US2174/cert-RA.pem\"\n#define US2174_EXPLICIT_KEY     \"US2174/key-RA.pem\"\n\n#else\n#define US2174_SERVER_CERT      \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US2174_SERVER_KEY       \"CA\\\\estCA\\\\private/estservercertandkey.pem\"\n/* #define US2174_PROXY_CERT \"CA/estCA/private/estservercertandkey.pem\"   */\n/* #define US2174_PROXY_KEY \"CA/estCA/private/estservercertandkey.pem\" */\n#define US2174_PROXY_CERT       \"US2174\\\\cert.pem\"\n#define US2174_PROXY_KEY        \"US2174\\\\key.pem\"\n#define US2174_CACERT           \"CA\\\\estCA\\\\cacert.crt\"\n#define US2174_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US2174_TRUSTED_CERTS    \"CA\\\\trustedcerts.crt\"\n#define US2174_EXPLICIT_CERT    \"US2174\\\\cert-RA.pem\"\n#define US2174_EXPLICIT_KEY     \"US2174\\\\key-RA.pem\"\n#endif\n\n#define US2174_SERVER_IP        \"127.0.0.1\"\n#define US2174_TCP_PORT         US2174_TCP_SERVER_PORT\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US2174_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US2174_PKCS10_DSA1024 \"MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT\"\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US2174_PKCS10_ECDSA256 \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n#define US2174_PKCS10_CORRUPT \"MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO\"\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US2174_PKCS10_STALE_POP \"MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=\"\n\n#define US2174_ENROLL_URL_BA    \"https://127.0.0.1:62175/.well-known/est/simpleenroll\"\n#define US2174_PKCS10_CT        \"Content-Type: application/pkcs10\" \n#define US2174_UIDPWD_GOOD      \"estuser:estpwd\"\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n#define GOOD_TOKEN \"WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=\"\n#define DIFFERENT_TOKEN \"V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy\"\n#define NULL_TOKEN NULL;\n#define LONG_TOKEN \"SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U=\"\nstatic char *test_token = \"WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=\";\n\nstatic int auth_cred_callback_called = 0;\nstatic int auth_cred_force_error = 0;\n\n/*\n * auth_credentials_token_cb() is the application layer callback function that will\n * return a token based authentication credential when called.  It's registered\n * with the EST Client using the est_client_set_auth_cred_cb().\n * The test function is required to set some global values in order to make this\n * callback operate the way that the test case wants.\n * - auth_cred_force_error = tell this function to force a response code error\n * - test_token = pointer to a hard coded string that is the token string to return\n *\n * This callback must provide the token credentials in a heap based buffer, and\n * ownership of that buffer is implicitly transferred to the ET client library upon\n * return.\n */\nstatic EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb (\n        EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    char *token_ptr = NULL;\n    int token_len = 0;\n\n    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials->mode == AUTH_TOKEN) {\n        /*\n         * If the test_token is set to anything, then we need to allocate\n         * space from the heap and copy in the value.\n         */\n        if (test_token != NULL) {\n            token_len = strlen(test_token); /* use strlen() so that the string can be as large\n             as needed to test the EST client */\n            if (token_len == 0) {\n                printf(\n                    \"\\nError determining length of token string used for credentials\\n\");\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }\n            token_ptr = malloc(token_len + 1);\n            if (token_ptr == NULL) {\n                printf(\n                    \"\\nError allocating token string used for credentials\\n\");\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }\n            strncpy(token_ptr, test_token, strlen(test_token));\n            token_ptr[token_len] = '\\0';\n        }\n        /*\n         * If we made it this far, token_ptr is pointing to a string\n         * containing the token to be returned. Assign it and return success\n         */\n        auth_credentials->auth_token = token_ptr;\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n/*\n * auth_credentials_basic_cb() is the same as the token based one above, but\n * instead returns the basic credentials of userid and password\n */\nstatic EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb (\n        EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials->mode == AUTH_BASIC) {\n\n        auth_credentials->user = malloc(sizeof(\"estuser\"));\n        strncpy(auth_credentials->user, \"estuser\", sizeof(\"estuser\"));\n        auth_credentials->pwd = malloc(sizeof(\"estpwd\"));\n        strncpy(auth_credentials->pwd, \"estpwd\", sizeof(\"estpwd\"));\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n#if 0\n/*\n * auth_credentials_digest_cb() is the same as the basic based one above, but\n * instead verfies that the auth_mode passed is digest\n */\nstatic\nEST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials->mode == AUTH_DIGEST) {\n\n        auth_credentials->user = malloc(sizeof(\"estuser\"));\n        strncpy(auth_credentials->user, \"estuser\", sizeof(\"estuser\"));\n        auth_credentials->pwd = malloc(sizeof(\"estpwd\"));\n        strncpy(auth_credentials->pwd, \"estpwd\", sizeof(\"estpwd\"));\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n#endif\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * us2174_simple_enroll() is used by test cases to perform a simple enroll.\n */\nstatic void us2174_simple_enroll (char *cn, char *server,\n                                  EST_ERROR expected_enroll_rv,\n                                  auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    EST_ERROR e_rc;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\nstatic\nvoid us2174_simple_reenroll (char *cn, char *server,\n                             EST_ERROR expected_enroll_rv,\n                             auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) * certs = NULL;\n    int i;\n\n    EST_ERROR e_rc;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    est_destroy(ectx);\n    ectx = NULL;\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Now that we have the cert, switch the server over to token mode\n     */\n    st_enable_http_token_auth();\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PORT, NULL);\n\n    /*\n     * And attempt a reenroll while in token mode\n     *\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     * PDB: This conversion code comes from other test cases.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out, NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i = OBJ_obj2nid(p7->type);\n    switch (i) {\n    case NID_pkcs7_signed:\n        certs = p7->d.sign->cert;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        certs = p7->d.signed_and_enveloped->cert;\n        break;\n    default:\n        break;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs)\n        return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn't have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * PDB NOTE: At the moment, this is expected to fail since\n     * the server does not yet understand requests with token authentication.\n     * Once 1884 is complete, the below ASSERT will begin to fail and will need\n     * to be changed to a passing response.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\nstatic void us2174_clean (void)\n{\n}\n\nstatic int us2174_start_server (int manual_enroll, int nid)\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US2174_TCP_SERVER_PORT,\n                  US2174_SERVER_CERT,\n                  US2174_SERVER_KEY,\n                  \"estrealm\",\n                  US2174_CACERT,\n                  US2174_TRUSTED_CERTS,\n                  \"US2174/estExampleCA.cnf\",\n                  manual_enroll, // manual enroll\n                  0,  // disable PoP\n                  nid); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA with the server side\n     * operating in token auth mode.\n     */\n    rv = st_proxy_start_token(US2174_TCP_PROXY_PORT,\n                              US2174_PROXY_CERT,\n                              US2174_PROXY_KEY, \"estrealm\",\n                              US2174_CACERT,\n                              US2174_TRUSTED_CERTS,\n                              \"estuser\",\n                              \"estpwd\",\n                              \"127.0.0.1\",\n                              US2174_TCP_SERVER_PORT,\n                              0); //  disable PoP\n\n    SLEEP(1);\n\n    return rv;\n}\n\nvoid us2174_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us2174_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US2174_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us2174_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us2174_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us2174_destroy_suite (void)\n{\n    us2174_stop_server();\n    free(cacerts);\n    return 0;\n}\n\n#if 0\n/*\n * Simple enroll -\n * proxy - BASIC\n * server - BASIC\n *\n * Make sure token auth mode did not break anything.\n *\n */\nstatic void us2174_test1(void)\n{\n    long rv;\n\n    LOG_FUNC_NM;\n\n    rv = curl_http_post(US2174_ENROLL_URL_BA, US2174_PKCS10_CT,\n            US2174_PKCS10_RSA2048,\n            US2174_UIDPWD_GOOD, US2174_CACERTS, CURLAUTH_BASIC,\n            NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n#endif\n\n/*\n * Simple enroll -\n * proxy - TOKEN\n * server - TOKEN\n *\n */\nstatic void us2174_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(\"TC2174-4\", US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple enroll -\n * proxy - TOKEN\n * server - BASIC\n */\nstatic void us2174_test3 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do BASIC auth challenges\n     */\n    st_enable_http_basic_auth();\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(\"TC2174-4\", US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple enroll -\n * proxy - BASIC\n * server - TOKEN\n */\nstatic void us2174_test4 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do BASIC auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_basic_auth();\n    /*     st_proxy_set_srv_valid_token(GOOD_TOKEN); */\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(\"TC2174-4\", US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_basic_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple RE-enroll -\n * proxy - TOKEN\n * server - TOKEN\n *\n */\nstatic void us2174_test5 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple RE-enroll.\n     *\n     * RE-enroll should succeed.\n     */\n    us2174_simple_reenroll(\"TC2174-4\", US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us2174_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us2174_token_proxy\",\n            us2174_init_suite,\n            us2174_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if (/* (NULL == CU_add_test(pSuite, \"Proxy Enroll basic sanity test\", us2174_test1)) || */\n        (NULL == CU_add_test(pSuite, \"Proxy Enroll token auth, both proxy and server\", us2174_test2)) ||\n        (NULL == CU_add_test(pSuite, \"Proxy Enroll token auth, proxy token/server basic\", us2174_test3)) ||\n        (NULL == CU_add_test(pSuite, \"Proxy Enroll token auth, proxy basic/server token\", us2174_test4)) ||\n        (NULL == CU_add_test(pSuite, \"Proxy RE-Enroll token auth, proxy basic/server token\", us2174_test5))\n        )\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbccc"},"name":"us1883.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us1883.c - Unit Tests for User Story 1883 - Enable token auth mode for\n *            the EST Client.\n *\n * March, 2015\n *\n * Copyright (c) 2015, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include <errno.h>\n\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1883_SERVER_IP        \"127.0.0.1\"\t\n#define US1883_TCP_PORT\t\t29001\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US1883_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n#define US1883_PKCS10_4096_REQ \"MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\\n\"\n#define US1883_ENROLL_URL_BA \"https://127.0.0.1:29001/.well-known/est/simpleenroll\"\n#define US1883_PKCS10_CT     \"Content-Type: application/pkcs10\" \n#define US1883_UIDPWD_GOOD   \"estuser:estpwd\"\n#ifndef WIN32\n#define US1883_CACERTS\t     \"CA/estCA/cacert.crt\"\n#define US1883_CACERT \"CA/estCA/cacert.crt\"\n#define US1883_SERVER_CERT \"CA/estCA/private/estservercertandkey.pem\"\n#define US1883_SERVER_KEY \"CA/estCA/private/estservercertandkey.pem\"\n#define US1883_CLIENT_CERT \"CA/estCA/private/estservercertandkey.pem\"\n#define US1883_CLIENT_KEY  \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define US1883_CACERTS\t     \"CA\\\\estCA\\\\cacert.crt\"\n#define US1883_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define US1883_SERVER_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1883_SERVER_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1883_CLIENT_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1883_CLIENT_KEY  \"CA\\\\estCA\\\\private/estservercertandkey.pem\"\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us1883_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&logger_critical_section); \n}\n\n#endif \n\n\nstatic void us1883_clean (void)\n{\n}\n\nstatic int us1883_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US1883_TCP_PORT, \n\t          \"CA/estCA/private/estservercertandkey.pem\",\n\t          \"CA/estCA/private/estservercertandkey.pem\",\n\t          \"estrealm\",\n\t          \"CA/estCA/cacert.crt\",\n\t          \"CA/trustedcerts.crt\",\n\t          \"CA/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1883_init_suite (void)\n{\n    int rv;\n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us1883_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1883_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n\treturn 1;\n    }\n\n    us1883_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us1883_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1883_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n#define GOOD_TOKEN \"WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=\"\n#define DIFFERENT_TOKEN \"V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy\"\n#define NULL_TOKEN NULL;\n#define LONG_TOKEN \"SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U=\"\nchar *test_token = \"WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=\";\n\nint auth_cred_callback_called = 0;\nint auth_cred_force_error = 0;\n\n/*\n * auth_credentials_token_cb() is the application layer callback function that will\n * return a token based authentication credential when called.  It's registered\n * with the EST Client using the est_client_set_auth_cred_cb().\n * The test function is required to set some global values in order to make this\n * callback operate the way that the test case wants.\n * - auth_cred_force_error = tell this function to force a response code error\n * - test_token = pointer to a hard coded string that is the token string to return\n *\n * This callback must provide the token credentials in a heap based buffer, and\n * ownership of that buffer is implicitly transferred to the ET client library upon\n * return.\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_token_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    char *token_ptr = NULL;\n    int token_len = 0;\n\n    CU_ASSERT(auth_credentials->mode == AUTH_TOKEN);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials->mode == AUTH_TOKEN) {\n        /*\n         * If the test_token is set to anything, then we need to allocate\n         * space from the heap and copy in the value.\n         */\n        if (test_token != NULL) {\n            token_len = strlen(test_token); /* use strlen() so that the string can be as large\n                                               as needed to test the EST client */\n            if (token_len == 0) {\n                printf(\"\\nError determining length of token string used for credentials\\n\");\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }   \n            token_ptr = malloc(token_len+1);\n            if (token_ptr == NULL){\n                printf(\"\\nError allocating token string used for credentials\\n\");\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }   \n            strncpy(token_ptr, test_token, strlen(test_token));\n            token_ptr[token_len] = '\\0';\n        }\n        /*\n         * If we made it this far, token_ptr is pointing to a string\n         * containing the token to be returned. Assign it and return success\n         */\n        auth_credentials->auth_token = token_ptr;\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n/*\n * auth_credentials_basic_cb() is the same as the token based one above, but\n * instead returns the basic credentials of userid and password\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials->mode == AUTH_BASIC);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials->mode == AUTH_BASIC) {\n\n        auth_credentials->user = malloc(sizeof(\"estuser\"));\n        strncpy(auth_credentials->user, \"estuser\", sizeof(\"estuser\"));\n        auth_credentials->pwd = malloc(sizeof(\"estpwd\"));\n        strncpy(auth_credentials->pwd, \"estpwd\", sizeof(\"estpwd\"));\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n\n/*\n * auth_credentials_digest_cb() is the same as the basic based one above, but\n * instead verfies that the auth_mode passed is digest\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials->mode == AUTH_DIGEST);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials->mode == AUTH_DIGEST) {\n\n        auth_credentials->user = malloc(sizeof(\"estuser\"));\n        strncpy(auth_credentials->user, \"estuser\", sizeof(\"estuser\"));\n        auth_credentials->pwd = malloc(sizeof(\"estpwd\"));\n        strncpy(auth_credentials->pwd, \"estpwd\", sizeof(\"estpwd\"));\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n\n/*\n * Test the est_client_set_auth_cred_cb API\n *\n * Exercise the parameters\n */\nstatic void us1883_test1 (void) \n{\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /* Forgot to specify any parameters. Context will\n     * get caught\n     */\n    e_rc = est_client_set_auth_cred_cb(NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NO_CTX);\n\n    /*\n     * valid call\n     */\n    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_token_cb);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * attempt to reset the callback function\n     */\n    e_rc = est_client_set_auth_cred_cb(ectx, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    est_destroy(ectx);\n}\n\n/*\n * us1883_simple_enroll() is used by test cases to perform a simple enroll.\n */\nstatic void us1883_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    EST_ERROR e_rc; \n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Perform a simple enroll first in order to get a valid cert, then perform the\n * reenroll.  The simple enroll needs to be successful, so it's currently\n * being done using basic mode because the EST server does not yet have token\n * based support.\n * PDB NOTE:  Once the server side token support have been implemented, this\n * this function can optionally be updated to do token mode on the first enroll,\n * but it's not absolutely necessary since the purpose of this is to test reenroll\n * and the initial enroll is needed just to get the cert.\n */\nstatic\nvoid us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) *certs = NULL;\n    int i;\n    \n    EST_ERROR e_rc;    \n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Make sure the server is currently in  BASIC auth mode\n     */\n    st_enable_http_basic_auth();\n    \n    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_basic_cb);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    est_destroy(ectx);\n    ectx = NULL;\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);    \n    \n    /*\n     * Now that we have the cert, switch the server over to token mode\n     */\n    st_enable_http_token_auth();\n    \n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n    \n    /*\n     * And attempt a reenroll while in token mode\n     *\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     * PDB: This conversion code comes from other test cases.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out,NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i=OBJ_obj2nid(p7->type);\n    switch (i) {\n    case NID_pkcs7_signed:\n\tcerts = p7->d.sign->cert;\n\tbreak;\n    case NID_pkcs7_signedAndEnveloped:\n\tcerts = p7->d.signed_and_enveloped->cert;\n\tbreak;\n    default:\n\tbreak;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs) return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn't have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * PDB NOTE: At the moment, this is expected to fail since\n     * the server does not yet understand requests with token authentication.\n     * Once 1884 is complete, the below ASSERT will begin to fail and will need\n     * to be changed to a passing response.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n    \n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Test2 - Application layer did not register callback, causing an\n *         HTTP Aithentication header with an empty token credential\n *         \n * In this test,\n * - application layer DOES NOT register its callback\n * - EST Client gets the challenge, finds no callback registered and goes with\n *   the credentials it has stored in the Context, which is nothing.\n *   NOTE: This is the way the preloaded credential flow has always worked.\n * - enroll is sent with no token credentials\n * - server fails and does not give a certificate\n */\nstatic void us1883_test2 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass no callback function to catch and handle the request for a token auth.\n     *\n     * enroll better fail due to missing credentials\n     */\n    us1883_simple_enroll(\"TC1883-2\", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, NULL);\n\n    /*\n     * callback was never registered, so it should not have been invoked.\n     */\n    CU_ASSERT(auth_cred_callback_called == 0);\n}\n\n\n/*\n * Test3 - Application layer registers callback, BUT does not set any\n *         credentials when invoked.  Same result as previous test\n *         \n * In this test,\n * - application layer registers its callback\n * - EST Client gets the challenge, calls the callback, gets back an \n *   empty credential structure and ends up sending an HTTP auth header\n *   with no credentials.\n *   NOTE: This is the way the preloaded credential flow has always worked.\n * - enroll is sent with no token credentials\n * - server fails and does not give a certificate\n */\nstatic void us1883_test3 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = NULL_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Register the token based callback, but set it so that it passes back no token.\n     *\n     * enroll better fail due to missing credentials\n     */\n    us1883_simple_enroll(\"TC1883-3\", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test4 - Good token is sent to server and is accepted.  Cert should\n * be generated and returned\n *\n * In this test,\n * - application layer registers its callback and responds with a valid token\n * - enroll is sent with this token credential\n * - server is set to match on this token and send back a cert\n */\nstatic void us1883_test4 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us1883_simple_enroll(\"TC1883-4\", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test EST client receiving a token auth challenge\n *\n * In this test, the application layer registers its callback and responds\n * with a failing return code.\n */\nstatic void us1883_test5 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n\n    auth_cred_callback_called = 0;\n    /* Force the callback to give a failing return code */\n    auth_cred_force_error = 1;\n    test_token = GOOD_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * enroll better fail due to credentials not being supplied by the application layer\n     * and eventual failure at the server due to missing credentials.\n     */\n    us1883_simple_enroll(\"TC1883-5\", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test6 - Sanity test BASIC auth mode\n *\n * In this test,\n * - server into BASIC mode\n * - Client application registers its BASIC based callback\n * - Client should send the estuser/estpwd credentials and get a cert\n */\nstatic void us1883_test6 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to BASIC mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_basic_auth();\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     * enroll should pass because BASIC mode fully works.  Make sure that the\n     * callback is called.  This will ensure that the credentials came from\n     * the callback.\n     */\n    us1883_simple_enroll(\"TC1883-6\", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_basic_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Make sure re-enroll works with the credential callback flow\n *         to obtain credentials\n *\n * In this test,\n * - server into TOKEN mode\n * - Client application registers its TOKEN based callback\n * - Client should send the valid token credential and get a cert\n */\nstatic void us1883_test7 (void) \n{\n\n    LOG_FUNC_NM;\n    \n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Re-enroll should succeed.\n     *\n     */\n    us1883_simple_reenroll(\"TC1883-7\", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Token credentials that are too long\n *\n * In this test,\n * - server into TOKEN mode and told to match against the GOOD token\n * - Client application registers its TOKEN based callback and is told to\n *   give back a token that is TOO LONG.\n * - Client should send a corrupted token that does not match the GOOD token.\n */\nstatic void us1883_test8 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    /* Force the callback to give a failing return code */\n    auth_cred_force_error = 0;\n    test_token = LONG_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     */\n    us1883_simple_enroll(\"TC1883-8\", US1883_SERVER_IP, EST_ERR_AUTH_FAIL,\n                         auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Test DIGEST mode with on demand credential flow\n *\n * In this test,\n * - server into DIGEST mode\n *   NOTE: This means the server is expecting: \"estuser\"/\"estpwd\" and \"estrealm\"\n *         These values are hardcoded into data in the st_server, so st_server\n *         must be started with estrealm so that it returns this realm to client\n *         so that the client returns it in its request.\n * - Client application registers its DIGEST based callback\n * - Client should send a valid DIGEST and get a cert\n */\nstatic void us1883_test9 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to DIGEST mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_digest_auth();\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     * enroll should pass because DIGEST mode fully works.  Make sure that the\n     * callback is called.  This will ensure that the credentials came from\n     * the callback.\n     */\n    us1883_simple_enroll(\"TC1883-6\", US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_digest_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test4 - Valid token is provided by appliaction callback, but it's the WRONG\n *         token\n *\n * In this test,\n * - application layer registers its callback and responds with a valid token\n * - Server is set up for token mode, but with a different token.\n * - enroll is sent with this token credential\n * - server is set to match on this token and send back a cert\n */\nstatic void us1883_test10 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it's probably safe in a test setting, but it's dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(DIFFERENT_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should FAIL because the tokens will not match\n     */\n    us1883_simple_enroll(\"TC1883-4\", US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1883_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us1883_tok_auth_client\", \n\t                  us1883_init_suite, \n\t\t\t  us1883_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* add the tests to the suite */\n   if ((NULL == CU_add_test(pSuite, \"parse response\", us1883_test1)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll no cb\", us1883_test2)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb no token\", us1883_test3)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb good token\", us1883_test4)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb bad rc\", us1883_test5)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb basic mode\", us1883_test6)) ||\n       (NULL == CU_add_test(pSuite, \"simple re-enroll reg cb good token\", us1883_test7)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb token too long\", us1883_test8)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb digest mode\", us1883_test9)) ||\n       (NULL == CU_add_test(pSuite, \"simple enroll reg cb mismatched valid token\", us1883_test10))\n       )\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbccd"},"name":"us900.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us900.c - Unit Tests for User Story 900 - Server CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#define US900_SERVER_PORT   29900\n#define US900_SERVER_IP     \"127.0.0.1\" \n\n#ifndef WIN32\n#define CLIENT_UT_CACERT \"CA/estCA/cacert.crt\"\n#define CLIENT_UT_PUBKEY \"./est_client_ut_keypair\"\n#define US900_CACERTS       \"CA/estCA/cacert.crt\"\n#define US900_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US900_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define CLIENT_UT_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define CLIENT_UT_PUBKEY \"est_client_ut_keypair\"\n#define US900_CACERTS       \"CA\\\\estCA/cacert.crt\"\n#define US900_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US900_SERVER_CERTKEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#endif\n\n#define TEST_ATTR_POP \"MAsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR_NOPOP \"MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR_NOPOPPOP \"MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n#define TEST_ATTR_POPADDED \"MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n#define TEST_ATTR1 \"MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\\0\"\n#define TEST_ATTR2 \"MAA=\\0\"\n#define TEST_ATTR7 \"MA==\\0\"\n#define TEST_ATTR2_POP \"MAsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR8 \"MAthisis badsGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR3 \"MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\\0\"\n#define TEST_ATTR4_122 \"MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR4_122POP \"MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\\0\"\n#define TEST_ATTR5_117 \"MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR5_117POP \"MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0\"\n#define TEST_ATTR6_116 \"MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n#define TEST_ATTR_244 \"MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR_245 \"MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0\"\n#define TEST_ATTR_250 \"MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_ATTR_250POP \"MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0\"\n#define TEST_ALL_ATTR \"MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0\"\n#define TEST_1024_NOPOP \"MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\\0\"\n\n#define TEST_1025_NOPOP \"MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0\"\n#define TEST_1024_POP \"MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\\0\"\n\n#define TEST_LONG_ATTR \"MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0\"\n\n#define EST_UT_MAX_CMD_LEN 255\nextern EST_CTX *ectx;\n\nstatic void us900_clean (void)\n{\n}\n\nstatic int us900_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US900_SERVER_PORT,\n                  US900_SERVER_CERTKEY,\n                  US900_SERVER_CERTKEY,\n                  \"US900 test realm\",\n                  US900_CACERTS,\n                  US900_TRUST_CERTS,\n                  \"CA/estExampleCA.cnf\",\n                  manual_enroll,\n                  0,\n                  nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us900_init_suite (void)\n{\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(\"Starting EST Server CSR attributes unit tests.\\n\");\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(\n        cmd,\n        EST_UT_MAX_CMD_LEN,\n        \"openssl ecparam -name prime256v1 -genkey -out %s\",\n        CLIENT_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us900_clean();\n\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us900_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us900_destroy_suite (void)\n{\n    st_stop();\n    SLEEP(2);\n    return 0;\n}\n\nstatic unsigned char * handle_correct_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR1);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_corrupt_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR8);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_short_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR7);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_long_csrattrs_request (int *csr_len,\n                                                     char *path_seg,\n                                                     void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_LONG_ATTR);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_nopop_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR_NOPOP);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_empty_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = 0;\n    csr_data = NULL;\n    return (csr_data);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        \"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the est_server_init_csrattrs() API.\n */\nstatic void us900_test1 (void)\n{\n    int rc;\n\n    LOG_FUNC_NM\n    ;\n\n    /* NULL ctx - should fail */\n    rc = est_server_init_csrattrs(NULL, \"US900 test1\", 10);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* NULL string - should pass */\n    rc = est_server_init_csrattrs(ectx, NULL, 10);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Zero length - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", 0);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Length too long - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", MAX_CSRATTRS + 1);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the smallest base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting an illegally small base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR7, strlen(TEST_ATTR7));\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* enable PoP */\n    st_enable_pop();\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n}\n\n/*\n * Test2 - exercise the server side variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us900_test2 (void)\n{\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n    int csr_len;\n    unsigned char *csr_data = NULL;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US900_SERVER_IP, US900_SERVER_PORT, NULL);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ctx, &retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* should get 204 with no data */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_corrupt_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_short_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_long_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2));\n    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR3));\n    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));\n    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Enable PoP and test responses with PoP added */\n    st_enable_pop();\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_data != NULL);\n    CU_ASSERT(csr_len = 20);\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_POP));\n    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, \"US900 test1\", 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));\n    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_correct_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_nopop_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &handle_empty_csrattrs_request)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(\"\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n\");\n        exit(1);\n    }\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &csr_data, &csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));\n    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1025_NOPOP,\n        strlen(TEST_1025_NOPOP));\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us900_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us900_srv_csrattrs\",\n            us900_init_suite,\n            us900_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"CSR Server Attributes API1\", us900_test1)) ||\n        (NULL == CU_add_test(pSuite, \"CSR Server Attributes API2\", us900_test2)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcce"},"name":"us3496.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}]],"contents":"/*------------------------------------------------------------------\n * us3496.c - Unit Tests URI path segment extension support \n *\n * March, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include \"../../util/test_utils.h\"\n#include \"st_server.h\"\n\n#include \"../../src/est/est_locl.h\"\n\nextern char tst_srvr_path_seg_enroll[];\nextern char tst_srvr_path_seg_auth[];\n\nstatic int path_segment_support;\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server's directory\n */\n/* #define CLIENT_UT_CACERT \"../../example/server/estCA/cacert.crt\" */\n#define CLIENT_UT_CACERT \"CA/estCA/cacert.crt\"\n#define CLIENT_UT_PUBKEY \"./est_client_ut_keypair\"\n\n#define US3496_SERVER_PORT   29496\n#define US3496_SERVER_IP    \"127.0.0.1\"\t\n#define US3496_UIDPWD_GOOD   \"estuser:estpwd\"\n#define US3496_UID           \"estuser\"\n#define US3496_PWD           \"estpwd\"\n#ifndef WIN32\n#define US3496_CACERTS\t    \"CA/estCA/cacert.crt\"\n#define US3496_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US3496_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\n#else\n#define US3496_CACERTS\t    \"CA\\\\estCA\\\\cacert.crt\"\n#define US3496_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US3496_SERVER_CERTKEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us3496_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&logger_critical_section); \n}\n#endif\n\n#define US3496_ENROLL_URL_BA \"https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll\"\n#define US3496_PKCS10_CT\t    \"Content-Type: application/pkcs10\" \n\n#define US3496_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);\n\nstatic void us3496_clean (void)\n{\n}\n\nstatic int us3496_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US3496_SERVER_PORT, \n\t          US3496_SERVER_CERTKEY,\n\t          US3496_SERVER_CERTKEY,\n\t          \"US3496 test realm\",\n\t          US3496_CACERTS,\n\t          US3496_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    \n    SLEEP(1);\n    return rv;\n}\n\nstatic int path_seg_supported(void) {\n\n    EST_CTX *ectx;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, \"test_segment\");\n\n    if (rc == EST_ERR_NONE) {\n        return 1;\n    } else {\n        return 0;\n    }\n\n    return 0;\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite. \n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us3496_init_suite (void)\n{\n    int rv = 0;\n   \n    char cmd[EST_UT_MAX_CMD_LEN];    \n    printf(\"Starting EST Client/Proxy path segment unit tests.\\n\");\n\n    /*\n     * check to see if path segment support has been compiled in\n     */\n    if (!path_segment_support) {\n        printf(\"URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \\n\");\n        return 0;\n    }\n    \n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n             \"openssl ecparam -name prime256v1 -genkey -out %s\", CLIENT_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n    \n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us3496_clean();    \n    /*\n     * Start an instance of the EST server\n     */\n    rv = us3496_start_server(0, 0);\n    SLEEP(2);\n    \n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3496_destroy_suite (void)\n{\n    \n    st_stop();    \n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n    \n\n\n/*\n * This test case tests the set server with valid parameters,\n * NO path segment\n */\nstatic void us3496_test1 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, NULL);    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is valid\n */\nstatic void us3496_test2 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"somestring\");\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that contains 2 segments, should fail\n */\nstatic void us3496_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"somestring1/somestring2\");\n\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * all valid characters\n */\n#define PATH_SEG_ALL_VALID_CHARS \"@%50%44%42ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._~!$&'()*+,;=\"\nstatic void us3496_test4 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                             PATH_SEG_ALL_VALID_CHARS);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is invalid. invalid character.\n */\nstatic void us3496_test5 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"someinvalid<string\");\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is too long (129)\n */\n#define path_segment_too_long \"123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"\nstatic void us3496_test6 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               path_segment_too_long);\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that is equal to an operation (cacerts)\n */\nstatic void us3496_test7 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"cacerts\");\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that contains an operation (cacerts),\n * in this case it's at the front of the string\n */\nstatic void us3496_test8 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"cacerts-server\");\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that is the empty string.\n * This should fail.\n */\nstatic void us3496_test9 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               \"\");\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that contains a ':'.\n * This should pass.\n */\nstatic void us3496_test10 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, \"-._~:@!$&'()*+,;=\");    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is too long (129)\n */\n#define path_segment_max \"12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\"\nstatic void us3496_test11 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               path_segment_max);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us3496_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n    \n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us3496_client_proxy_path_seg\", \n\t                  us3496_init_suite, \n\t\t\t  us3496_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n   \n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us3496_logger_stderr);\n#endif\n\n   /*\n    * check to see if path segment support has been compiled in\n    */\n   if (!path_seg_supported()) {\n       printf(\"URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \\n\");\n       path_segment_support = 0;\n       return 0;\n   }\n   path_segment_support = 1; \n   \n   if (path_segment_support) {\n       \n       /* add the tests to the suite */\n       /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n       if (\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, no path segment\", us3496_test1)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, valid path segment\", us3496_test2)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, multi segment path segment\", us3496_test3)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, valid path segment - all valid chars\", us3496_test4)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, invalid path segment\", us3496_test5)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment too long\", us3496_test6)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment equals operation string\", us3496_test7)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment contains operation string\", us3496_test8)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment is the empty string\", us3496_test9)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment contains a colon\", us3496_test10)) ||\n           (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters, path segment is the max length\", us3496_test11))\n           ) {\n           CU_error = CU_get_error();\n           printf(\"%d\\n\", CU_error);\n           \n           CU_cleanup_registry();\n           printf(\"%s\\n\", CU_get_error_msg());\n           return CU_get_error();\n       }\n   }\n   \n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbccf"},"name":"us897.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us897.c - Unit Tests for User Story 897 - Client CACerts \n *\n * June, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n#include \"../../util/test_utils.h\"\n#include \"st_server.h\"\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n#define EST_CA_MAX\t    200000\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server's directory\n */\n/* #define CLIENT_UT_CACERT \"../../example/server/estCA/cacert.crt\" */\n#define US897_SERVER_PORT   29897\n#define CLIENT_UT_PUBKEY \"./est_client_ut_keypair\"\n#define US897_SERVER_IP\t    \"127.0.0.1\"\t\n#define US897_UID\t    \"estuser\"\n#define US897_PWD\t    \"estpwd\"\n\n#ifndef WIN32\n#define CLIENT_UT_CACERT \"CA/estCA/cacert.crt\"\n#define US897_CACERTS\t    \"CA/estCA/cacert.crt\"\n#define US897_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US897_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS \"US897/singlechain_10certs_trusted.crt\"\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING \"US897/singlechain_9certs_missingcert.crt\"\n#define US897_CACERTS_SINGLE_CHAIN_EXPIRED \"US897/singlechain_expired.crt\"\n#define US897_CACERTS_MULTI_CHAIN_CRLS \"US897/trustedCHain10RevokedDepth6Implicit10andcacert.crt\"\n#else\n#define CLIENT_UT_CACERT \"CA\\\\estCA/cacert.crt\"\n#define US897_CACERTS\t    \"CA\\\\estCA\\\\cacert.crt\"\n#define US897_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US897_SERVER_CERTKEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS \"US897\\\\singlechain_10certs_trusted.crt\"\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING \"US897\\\\singlechain_9certs_missingcert.crt\"\n#define US897_CACERTS_SINGLE_CHAIN_EXPIRED \"US897\\\\singlechain_expired.crt\"\n#define US897_CACERTS_MULTI_CHAIN_CRLS \"US897\\\\trustedCHain10RevokedDepth6Implicit10andcacert.crt\"\n#endif \n\nstatic void us897_clean (void)\n{\n}\n\nstatic int us897_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n\t          US897_CACERTS,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    \n    SLEEP(1);\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite. \n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us897_init_suite (void)\n{\n    int rv = 0;\n    \n    char cmd[EST_UT_MAX_CMD_LEN];    \n    printf(\"Starting EST Client unit tests. PDB\\n\");\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n             \"openssl ecparam -name prime256v1 -genkey -out %s\", CLIENT_UT_PUBKEY);\n    printf(\"%s\\n\", cmd);\n    \n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us897_clean();    \n    /*\n     * Start an instance of the EST server\n     */\n    rv = us897_start_server(0, 0);\n    SLEEP(2);\n    \n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us897_destroy_suite (void)\n{\n    \n    st_stop();    \n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n    \n\n/*\n * This test case initializes an EST client context\n * using local CA certs, no client cert, and a valid public key,\n * no userid and password.\n */\nstatic void us897_test1 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n    \n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    est_init_logger(EST_LOG_LVL_INFO, NULL);    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n                             \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }    \n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using no local CA certs.  This is expected to be a successful initialization\n * since the local CA trust anchor certs are not mandatory.\n */\nstatic void us897_test2 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(NULL, 0, EST_CERT_FORMAT_PEM, client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using a local CA cert, no client cert,\n * and a valid public key, no userid and password.\n */\nstatic void us897_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n#if 0\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, and a valid public key,\n * no userid and password.\n */\nstatic void us897_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n#endif\n\n\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, a public key,\n * and a userid and password.\n */\nstatic void us897_test6 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"USER\", \"PASSWORD\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, a public key,\n * and a userid and NO password.\n */\nstatic void us897_test7 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"USER\", NULL, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, NULL, \"PASSWORD\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the set server with valid parameters\n */\nstatic void us897_test9 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the set server with invalid parameters\n */\nstatic void us897_test10 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    char *server_name_too_long = \"12345678901234567890123456789012345678901234567890\"\\\n        \"12345678901234567890123456789012345678901234567890\"\\\n        \"12345678901234567890123456789012345678901234567890\"\\\n        \"12345678901234567890123456789012345678901234567890\"\\\n        \"12345678901234567890123456789012345678901234567890123456\";\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /*\n     * Null server name\n     */\n    rc = est_client_set_server(ectx, NULL, US897_SERVER_PORT, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * server too long\n     */\n    rc = est_client_set_server(ectx, server_name_too_long, US897_SERVER_PORT, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     *  port num less than 0\n     */\n    rc = est_client_set_server(ectx, US897_SERVER_IP, -1, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);\n\n    /*\n     * port num greater than max\n     */\n    rc = est_client_set_server(ectx, US897_SERVER_IP, 65536, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the Get CACerts request\n *\n */\nstatic void us897_test11 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n\n    /*\n     * make sure that the context is no longer valid and the EST client is\n     * back to the uninitialized state\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n    CU_ASSERT(rc == EST_ERR_CLIENT_NOT_INITIALIZED);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the Get CACerts request with invalid input parameters\n *\n */\nstatic void us897_test12 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, NULL);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single certificate\n */\nstatic void us897_test13 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n\t          US897_CACERTS,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs\n */\nstatic void us897_test14 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs and\n * a missing cert in the chain.  \n */\nstatic void us897_test15 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);\n    CU_ASSERT(retrieved_cacerts_len == 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn't be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there's no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs \n * with the intermediate cert expired.\n */\nstatic void us897_test16 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n                  US897_CACERTS_SINGLE_CHAIN_EXPIRED,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);\n    CU_ASSERT(retrieved_cacerts_len == 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn't be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there's no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a multiple chains with multiple certs and\n * a CRL block.  The CRLs should be ignored.  \n */\nstatic void us897_test17 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          \"US897 test realm\",\n                  US897_CACERTS_MULTI_CHAIN_CRLS,\n\t          US897_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in the startup CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn't be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there's no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NONE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the SSL read set timeout API.\n * The setting of the min, the max, a value in between, and a value\n * beyond the max.\n */\nstatic void us897_test18 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n  \n    /*\n     * Read in the startup CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(\"\\nError while reading private key file %s\\n\", CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, \"\", \"\", NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MIN);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX+1);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    rc = est_client_set_read_timeout(ectx, 2);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Now proceed on with a GET /cacerts to verify that nothing gets broken */\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len > 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn't be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there's no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NONE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(\"\\nRetrieved CA Certs buffer:\\n %s\\n\", retrieved_cacerts);\n        printf(\"Retrieved CA certs buffer length: %d\\n\", retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us897_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n    \n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us897_client_cacerts\", \n\t                  us897_init_suite, \n\t\t\t  us897_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* add the tests to the suite */\n   /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n   if ((NULL == CU_add_test(pSuite, \"EST Client Init: local CA, private key \", us897_test1))  ||\n       (NULL == CU_add_test(pSuite, \"EST Client Init: no local CA\", us897_test2)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client Init: local CA, explicit CA, private key\", us897_test3)) ||\n/*        (NULL == CU_add_test(pSuite, \"EST Client Init: local CA, explicit CA, client CA, private key\", us897_test4)) || */\n       (NULL == CU_add_test(pSuite, \"EST Client Init: local CA, userid/password\", us897_test6)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client Init: local CA, userid/no password\", us897_test7)) ||\n/*        (NULL == CU_add_test(pSuite, \"EST Client Init: local CA, no userid/password\", us897_test8)) || */\n       (NULL == CU_add_test(pSuite, \"EST Client Set Server: correct parameters\", us897_test9)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client Set Server: no parameters\", us897_test10)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: ca_cert valid parameters\", us897_test11)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: missing ca_cert pointers\", us897_test12)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: verify chain-simple chain-success\", us897_test13)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: verify chain-multiple certs-success\", us897_test14)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: verify chain-broken chain-fail\", us897_test15)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: verify chain-bad date-fail\", us897_test16)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client CA Certs: verify chain-multiple chains-success\", us897_test17)) ||\n       (NULL == CU_add_test(pSuite, \"EST Client SSL read timeout API\", us897_test18))\n       ) \n   {\n      CU_error = CU_get_error();\n      printf(\"%d\\n\", CU_error);\n   \n      CU_cleanup_registry();\n      printf(\"%s\\n\", CU_get_error_msg());\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd0"},"name":"us1060.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc86"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc84"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca8"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us1060.c - Unit Tests for User Story 1060 - TLS SRP support (Server/Proxy)\n *\n * May, 2014\n *\n * Copyright (c) 2014-2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#include <string.h>\n#ifndef WIN32\n#include <unistd.h>\n#include <pthread.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"test_utils.h\"\n#include \"curl_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#define US1060_SERVER_PORT      31060\n#define US1060_SERVER_IP        \"127.0.0.1\"\n#define US1060_UID              \"estuser\"\n#define US1060_PWD              \"estpwd\"\n#ifndef WIN32\n#define US1060_CACERTS          \"CA/estCA/cacert.crt\"\n#define US1060_TRUST_CERTS      \"CA/trustedcerts.crt\"\n#define US1060_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n#define US1060_VFILE            \"US1060/passwd.srpv\"\n\n#define US1060_EXPLICIT_CERT    \"US1060/explicit-cert.pem\" \n#define US1060_EXPLICIT_KEY     \"US1060/explicit-key.pem\"\n#define US1060_SELFSIGN_CERT    \"US1060/selfsigned-cert.pem\" \n#define US1060_SELFSIGN_KEY     \"US1060/selfsigned-key.pem\"\n#else\n#define US1060_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US1060_TRUST_CERTS      \"CA\\\\trustedcerts.crt\"\n#define US1060_SERVER_CERTKEY   \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1060_VFILE            \"US1060\\\\passwd.srpv\"\n\n#define US1060_EXPLICIT_CERT    \"US1060\\\\explicit-cert.pem\" \n#define US1060_EXPLICIT_KEY     \"US1060\\\\explicit-key.pem\"\n#define US1060_SELFSIGN_CERT    \"US1060\\\\selfsigned-cert.pem\" \n#define US1060_SELFSIGN_KEY     \"US1060\\\\selfsigned-key.pem\"\n#endif\n\n#define US1060_ENROLL_URL       \"https://127.0.0.1:31060/.well-known/est/simpleenroll\"\n#define US1060_UIDPWD_GOOD      \"estuser:estpwd\"\n#define US1060_UIDPWD_BAD       \"estuser:xxx111222\"\n#define US1060_PKCS10_CT        \"Content-Type: application/pkcs10\"\n\n#define US1060_PROXY_ENROLL_URL \"https://127.0.0.1:41060/.well-known/est/simpleenroll\"\n#define US1060_PROXY_PORT       41060\n\n#define US1060_PKCS10_REQ       \"MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n\"\n\nstatic char *log_search_target = NULL;\nstatic int search_target_found = 0;\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\nstatic SRP_VBASE *srpdb = NULL;\n\n#ifdef WIN32\nCRITICAL_SECTION logger_critical_section;\n#endif\n\n/*\n * This is a simple callback used to override the default\n * logging facility in libest.  We'll use this to look\n * for specific debug output.\n */\nstatic void us1060_logger_stderr (char *format, va_list l)\n{\n    char t_log[1024];\n#ifndef WIN32\n    flockfile(stderr);\n#else\n    EnterCriticalSection(&logger_critical_section);\n#endif \n    if (log_search_target) {\n        vsnprintf(t_log, 1024, format, l);\n        if (strstr(t_log, log_search_target)) {\n            search_target_found = 1;\n        }\n        fprintf(stderr, \"%s\", t_log);\n    } else {\n        vfprintf(stderr, format, l);\n    }\n    fflush(stderr);\n#ifndef WIN32\n    funlockfile(stderr);\n#else\n    LeaveCriticalSection(&logger_critical_section);\n#endif\n}\n\nstatic int us1060_start_server (char *cert, char *key, int no_http_auth,\n                                int enable_pop, int enable_srp)\n{\n    int rv;\n\n    if (enable_srp) {\n        rv = st_start_srp(US1060_SERVER_PORT,\n                          cert,\n                          key,\n                          \"US1060 test realm\",\n                          US1060_CACERTS,\n                          US1060_TRUST_CERTS,\n                          \"CA/estExampleCA.cnf\",\n                          enable_pop,\n                          US1060_VFILE);\n    } else {\n        rv = st_start(US1060_SERVER_PORT,\n                      cert,\n                      key,\n                      \"US1060 test realm\",\n                      US1060_CACERTS,\n                      US1060_TRUST_CERTS,\n                      \"CA/estExampleCA.cnf\",\n                      0,\n                      enable_pop,\n                      0);\n    }\n\n    if (no_http_auth) {\n        st_disable_http_auth();\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1060_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    /* Initialize critical section on Windows*/\n    InitializeCriticalSection(&logger_critical_section);\n#endif\n\n    est_init_logger(EST_LOG_LVL_INFO, &us1060_logger_stderr);\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,\n        1);\n\n    /*\n     * Start an instance of the proxy with SRP enabled\n     */\n    rv = st_proxy_start_srp(US1060_PROXY_PORT,\n                            US1060_SERVER_CERTKEY,\n                            US1060_SERVER_CERTKEY,\n                            \"US1060 proxy realm\",\n                            US1060_CACERTS,\n                            US1060_TRUST_CERTS,\n                            US1060_UID,\n                            US1060_PWD,\n                            US1060_SERVER_IP,\n                            US1060_SERVER_PORT,\n                            0,\n                            US1060_VFILE);\n\n    /*\n     * Read in the CA certificates\n     * Used for client-side API testing\n     */\n    cacerts_len = read_binary_file(US1060_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    srpdb = SRP_VBASE_new(NULL);\n    if (!srpdb) {\n        printf(\"\\nUnable allocate SRP verifier database.  Aborting!!!\\n\");\n    }\n    if (SRP_VBASE_init(srpdb, US1060_VFILE) != SRP_NO_ERROR) {\n        printf(\"\\nUnable initialize SRP verifier database.  Aborting!!!\\n\");\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1060_destroy_suite (void)\n{\n    if (srpdb) {\n        SRP_VBASE_free(srpdb);\n    }\n\n    st_stop();\n    st_proxy_stop();\n    free(cacerts);\n    return 0;\n}\n\ntypedef enum {\n    SRP_OFF, SRP_ON\n} server_srp_mode;\n\ntypedef enum {\n    SRP_GOOD, SRP_BAD, SRP_NONE,\n} client_srp_mode;\n\ntypedef enum {\n    HTTP_OFF, HTTP_OPTIONAL, HTTP_REQUIRED\n} server_http_mode;\n\ntypedef struct {\n    char *test_name;\n    char *curl_cert;\n    char *curl_key;\n    char *curl_http_auth;\n    client_srp_mode curl_srp;\n    server_http_mode server_http;\n    server_srp_mode server_srp;\n    int expected_http_result;\n} us1060_matrix;\n\n/*\n * This is the unit test matrix for server-side SRP support.  Curl is\n * used as the EST client.  Because of this PoP is disabled on the\n * server for all test cases.  We try to cover a variety of configurations\n * and potential scenarios.  The client side variations include:\n *\n * curl_cert:  The certificate curl uses, which may be NULL\n * curl_key:   The key curl uses, which may be NULL\n * curl_http_auth:  The HTTP auth credentials used by curl.\n * client_srp_mode: Either GOOD, BAD, NONE.  Determines which SRP credentials are used\n *                  Curl.\n *\n * On the server side we configure the server using the following variations:\n *\n * server_http_mode:  HTTP auth is required, optional, or disabled.\n *                    (optional means it only occurs when TLS auth fails)\n * server_srp_mode:   SRP is either enabled or disabled on the server.\n *\n * expected_http_result:  This is the expected HTTP status code received on by Curl.\n *                        When SRP fails, this results in a failed TLS session.  Curl\n *                        returns a zero in this case since the HTTP layer can not\n *                        communicate.  If TLS succeeds, but HTTP auth fails, then\n *                        the server should return a HTTP 401 response to the client.\n *                        When enrollment succeeds, the server should send a\n *                        HTTP 200 response.\n *\n *\n */\nstatic us1060_matrix test_matrix[] = {\n    {\"1\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 200},\n    {\"2\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},\n    {\"3\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 200},\n    {\"4\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},\n    {\"5\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},\n    {\"6\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 200},\n    {\"7\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},\n    {\"8\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},\n    {\"9\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},\n\n    {\"11\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 401},\n    {\"12\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},\n    {\"13\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 401},\n    {\"14\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},\n    {\"15\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},\n    {\"16\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 401},\n    {\"17\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},\n    {\"18\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},\n    {\"19\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},\n\n    {\"21\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},\n    {\"22\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},\n    {\"23\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},\n    {\"24\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"25\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"26\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {\"27\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},\n    {\"28\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},\n    {\"29\", NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},\n\n    {\"31\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},\n    {\"32\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},\n    {\"33\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},\n    {\"34\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"35\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"36\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 401},\n    {\"37\", NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},\n    {\"38\", NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},\n    {\"39\", NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},\n\n    {\"40\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  200},\n    {\"41\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  401},\n    {\"42\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},\n    {\"43\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},\n    {\"44\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  200},\n    {\"45\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  200},\n    {\"46\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},\n    {\"47\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},\n    {\"48\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {\"49\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {\"50\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 200},\n    {\"51\", US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 200},\n\n    {\"60\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},\n    {\"61\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},\n    {\"62\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},\n    {\"63\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},\n    {\"64\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  0},\n    {\"65\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  0},\n    {\"66\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},\n    {\"67\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},\n    {\"68\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"69\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},\n    {\"70\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 0},\n    {\"71\", US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 0},\n};\n\n/*\n * This is our worker for each entry in the test matrix above.\n * We read the configuration from the entry, configure the\n * server and client as needed, and attempt a simple enroll\n * using Curl as the client.\n * The argument i is the index of the entry in the table above.\n */\nstatic void us1060_test_matrix_item (int i)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    printf(\"\\nRunning matrix test %s\\n\", test_matrix[i].test_name);\n\n    /*\n     * Stop the server and restart it to make sure\n     * it's in the correct mode.\n     */\n    st_stop();\n    SLEEP(1);\n    if (test_matrix[i].server_srp == SRP_ON) {\n        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,\n            0, 0, 1);\n    } else {\n        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,\n            0, 0, 0);\n    }\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Set the server HTTP auth configuration\n     */\n    switch (test_matrix[i].server_http) {\n    case HTTP_OFF:\n        st_disable_http_auth();\n        break;\n    case HTTP_OPTIONAL:\n        st_enable_http_auth();\n        st_set_http_auth_optional();\n        break;\n    case HTTP_REQUIRED:\n        st_enable_http_auth();\n        st_set_http_auth_required();\n        break;\n    }\n\n    switch (test_matrix[i].curl_srp) {\n    case SRP_GOOD:\n        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,\n        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,\n            NULL, \"srp_user\", \"srp_pwd\", NULL, NULL);\n        break;\n    case SRP_BAD:\n        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,\n        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,\n            NULL, \"srp_user\", \"boguspwd\", NULL, NULL);\n        break;\n    case SRP_NONE:\n        /*\n         * Some of the SRP disabled test cases use a client\n         * certificate.\n         */\n        if (test_matrix[i].curl_cert) {\n            rv = curl_http_post_certuid(US1060_ENROLL_URL, US1060_PKCS10_CT,\n            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,\n                test_matrix[i].curl_cert, test_matrix[i].curl_key,\n                US1060_CACERTS, NULL);\n        } else {\n            rv = curl_http_post(US1060_ENROLL_URL, US1060_PKCS10_CT,\n            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,\n            US1060_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n        }\n        break;\n    }\n    CU_ASSERT(rv == test_matrix[i].expected_http_result);\n    if (rv != test_matrix[i].expected_http_result) {\n        printf(\"\\nMatrix test %s failed with rv = %d\\n\",\n            test_matrix[i].test_name, (int) rv);\n    }\n}\n\n/*\n * This test case runs all the tests in the matrix\n */\nstatic void us1060_test0 (void)\n{\n    int i;\n    int test_cnt = sizeof(test_matrix) / sizeof(test_matrix[0]);\n\n    for (i = 0; i < test_cnt; i++) {\n        us1060_test_matrix_item(i);\n    }\n}\n\n/*\n * This test case is verifies the happy path when EST\n * proxy is configured in SRP mode.  The client will attempt\n * to use SRP.  The connection between the proxy and\n * server does not use SRP.  We perform a simple enroll\n * operation.\n */\nstatic void us1060_test200 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the EST server with SRP disabled\n     */\n    st_stop();\n    SLEEP(2);\n    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,\n        0);\n    CU_ASSERT(rv == 0);\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, \"srp_user\", \"srp_pwd\", NULL,\n        NULL);\n    /*\n     * Since we passed in a valid SRP userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test case is verifies the simple enroll fails\n * when the EST client provides a bad SRP password.\n * The connection between the proxy and server does not\n * use SRP.\n */\nstatic void us1060_test201 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, \"srp_user\", \"boguspwd\",\n        NULL, NULL);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test case is verifies the simple enroll fails\n * when the EST client provides a bad HTTP password\n * and SRP is used.  The connection between the proxy\n * and server does not use SRP.\n */\nstatic void us1060_test202 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_BAD, NULL, CURLAUTH_BASIC, NULL, \"srp_user\", \"srp_pwd\", NULL,\n        NULL);\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * This test case is verifies the simple enroll works\n * when the EST client provides no HTTP password\n * and SRP is used.  The connection between the proxy\n * and server does not use SRP.  HTTP auth is disabled\n * on the proxy.\n */\nstatic void us1060_test203 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_http_disable(1);\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ, NULL, NULL, CURLAUTH_NONE, NULL, \"srp_user\", \"srp_pwd\",\n        NULL, NULL);\n    CU_ASSERT(rv == 200);\n}\n\nint us1060_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us1060_tls_srp (server/proxy)\",\n            us1060_init_suite,\n            us1060_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * Add the tests to the suite\n     *\n     * ********************IMPORTANT*********************\n     * Do not change the order of these tests.\n     * Some of the tests stop the EST server and restart\n     * it using different certs.  If you change the order\n     * then false negatives may occur.\n     * **************************************************\n     *\n     */\n    if ((NULL == CU_add_test(pSuite, \"TLS-SRP server: matrix master\", us1060_test0)) ||\n        (NULL == CU_add_test(pSuite, \"TLS-SRP proxy: enroll w/SRP\", us1060_test200)) ||\n        (NULL == CU_add_test(pSuite, \"TLS-SRP proxy: enroll bad SRP pwd\", us1060_test201)) ||\n        (NULL == CU_add_test(pSuite, \"TLS-SRP proxy: enroll bad HTTP pwd\", us1060_test202)) ||\n        (NULL == CU_add_test(pSuite, \"TLS-SRP proxy: enroll w/o HTTP auth\", us1060_test203)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd1"},"name":"us893.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us893.c - Unit Tests for User Story 893 - proxy reenroll\n *\n * October, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US893_TCP_SERVER_PORT       29893\n#define US893_TCP_PROXY_PORT        29093\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US893_PKCS10_RSA2048 \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n#define US893_PKCS10_CORRUPT \"MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDfffmdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X\"\n\n#define US893_SERVER_IP         \"127.0.0.1\" \n#define US893_REENROLL_URL_BA   \"https://127.0.0.1:29093/.well-known/est/simplereenroll\"\n#define US893_PKCS10_CT         \"Content-Type: application/pkcs10\" \n#define US893_UIDPWD_GOOD       \"estuser:estpwd\"\n#define US893_UID               \"estuser\"\n#define US893_PWD               \"estpwd\"\n#ifndef WIN32\n#define US893_CACERTS           \"CA/estCA/cacert.crt\"\n#define US893_TRUSTED_CERTS     \"CA/trustedcerts.crt\"\n#define US893_SERVER_CERTKEY    \"CA/estCA/private/estservercertandkey.pem\"\n#define US893_PROXY_CERT        \"US893/cert.pem\"\n#define US893_PROXY_KEY         \"US893/key.pem\"\n#define US893_UNTRUSTED_CERT    \"US893/cert-untrusted.pem\"\n#define US893_UNTRUSTED_KEY     \"US893/key-untrusted.pem\"\n#define US893_EXPIRED_KEY       \"US893/key-expired.pem\"\n#define US893_EXPIRED_CERT      \"US893/cert-expired.pem\"\n\n#define US893_TC2_CERT_TXT      \"US893/tc2-new-cert.txt\"\n#define US893_TC2_CERT_B64      \"US893/tc2-new-cert.pkcs7b64\"\n#define US893_TC2_CERT_PK7      \"US893/tc2-new-cert.pkcs7\"\n#define US893_TC2_CERT_PEM      \"US893/tc2-new-cert.pem\"\n#else\n#define US893_CACERTS           \"CA\\\\estCA\\\\cacert.crt\"\n#define US893_TRUSTED_CERTS     \"CA\\\\trustedcerts.crt\"\n#define US893_SERVER_CERTKEY    \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US893_PROXY_CERT        \"US893\\\\cert.pem\"\n#define US893_PROXY_KEY         \"US893\\\\key.pem\"\n#define US893_UNTRUSTED_CERT    \"US893\\\\cert-untrusted.pem\"\n#define US893_UNTRUSTED_KEY     \"US893\\\\key-untrusted.pem\"\n#define US893_EXPIRED_KEY       \"US893\\\\key-expired.pem\"\n#define US893_EXPIRED_CERT      \"US893\\\\cert-expired.pem\"\n\n#define US893_TC2_CERT_TXT      \"US893\\\\tc2-new-cert.txt\"\n#define US893_TC2_CERT_B64      \"US893\\\\tc2-new-cert.pkcs7b64\"\n#define US893_TC2_CERT_PK7      \"US893\\\\tc2-new-cert.pkcs7\"\n#define US893_TC2_CERT_PEM      \"US893\\\\tc2-new-cert.pem\"\n#endif\n\nstatic void us893_clean (void)\n{\n    char cmd[200];\n\n    /*\n     * These are all temporary files created\n     * by the various test cases.\n     */\n#ifndef WIN32\n    sprintf(cmd, \"rm %s\", US893_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US893_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US893_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", US893_TC2_CERT_PEM);\n    system(cmd);\n#else\n    sprintf(cmd, \"del %s\", US893_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US893_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US893_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, \"del %s\", US893_TC2_CERT_PEM);\n    system(cmd);\n#endif\n}\n\nstatic int us893_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US893_TCP_SERVER_PORT,\n                  US893_SERVER_CERTKEY,\n                  US893_SERVER_CERTKEY,\n                  \"US893 test realm\",\n                  US893_CACERTS,\n                  US893_TRUSTED_CERTS,\n                  \"US893/estExampleCA.cnf\",\n                  manual_enroll,\n                  0,\n                  nid);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy actging as an RA\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us893_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US893_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us893_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us893_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us893_destory_suite (void)\n{\n    st_stop();\n    st_proxy_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple reenroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * reenroll of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us893_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_RSA2048,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  The expired certs contains\n * several X509 extensions. We verify the new issued\n * cert preserves these extensions using grep.  Note,\n * preserving these extensions requires the OpenSSL CA\n * to enable the \"copy_extensions\" knob in the OpenSSL\n * config file.  This is why this test suite uses a\n * unique copy of estExampleCA.cnf.\n */\nstatic void us893_test2 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    BIO *in;\n    char cmd[200];\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Save the cert to a local file\n     */\n    rv = write_binary_file(US893_TC2_CERT_B64, new_cert, pkcs7_len);\n    CU_ASSERT(rv == 1);\n\n    /*\n     * Base 64 decode the cert response\n     */\n    sprintf(cmd, \"openssl base64 -d -in %s -out %s\", US893_TC2_CERT_B64,\n    US893_TC2_CERT_PK7);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert the pkcs7 cert to a PEM cert\n     */\n    sprintf(cmd, \"openssl pkcs7 -in %s -inform DER -print_certs -out %s\",\n    US893_TC2_CERT_PK7,\n    US893_TC2_CERT_PEM);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert PEM cert to a textual representation of the cert\n     */\n    sprintf(cmd, \"openssl x509 -text -in %s > %s\", US893_TC2_CERT_PEM,\n    US893_TC2_CERT_TXT);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the jimbob DNS extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, \"jimbob\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the bobcat DNS extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, \"bobcat\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the IP address extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, \"172\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the Repudiation key usage extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, \"Repudiation\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the public key was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT,\n        \"00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50\");\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Clean up\n     */\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Simple reenroll - Corrupt CSR\n *\n * Use libcurl to send a reenroll request containing\n * a corrupted CSR.\n */\nstatic void us893_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_CORRUPT,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a bad CSR,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured for manual\n * approval.  The server will send back a retry-after\n * response.  This verifies the proxy propagates the\n * retry-after response to the client.\n */\nstatic void us893_test4 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    int retry_val = 0;\n    time_t time_val;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n    st_proxy_stop();\n\n    /*\n     * Restart the server with manual approval enabled\n     */\n    rv = us893_start_server(1, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    /*\n     * The server should be configured with a retry-after\n     * value of 3600 seconds, which is the default.\n     */\n    rv = est_client_copy_retry_after(ectx, &retry_val, &time_val);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    CU_ASSERT(retry_val == 3600);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n    st_proxy_stop();\n\n    /*\n     * Restart the server with manual approval disabled\n     */\n    rv = us893_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * enabled, but the proxy server is using a cert\n * that doesn't contain id-kp-cmcRA.  This should\n * result in a failure.\n */\nstatic void us893_test5 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is enabled on the server\n     */\n    st_enable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA,\n                        US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD,\n                        US893_CACERTS,\n                        CURLAUTH_BASIC,\n                        NULL,\n                        NULL,\n                        NULL);\n    /*\n     * The PoP check should fail\n     */\n    CU_ASSERT(rv == 400);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\", \"estpwd\", \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * disabled, but the proxy server is using a cert\n * that doesn't contain id-kp-cmcRA.  This should\n * result in a successful reenroll.\n */\nstatic void us893_test6 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_RSA2048,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The reenroll should work since PoP is not enabled anywhere.\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * disabled, but the proxy server is using a cert\n * that doesn't contain id-kp-cmcRA.  The CSR will\n * contain the PoP, which forces it to be checked.\n * This should result in a failure since the RA\n * cert doesn't contain id-kp-cmcRA.\n */\n//The following include should never be used by an application\n//be we use it here to hack the EST_CTX values mid-way\n//through this test\n#include \"../../src/est/est_locl.h\"\nstatic void us893_test7 (void)\n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    ectx->csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n\n    est_destroy(ectx);\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  PoP is disabled on\n * the EST server.\n */\nstatic void us893_test8 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    X509 *cert = NULL;\n    int rv;\n    int pkcs7_len = 0;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &key_raw);\n    CU_ASSERT(key_len > 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &cert_raw);\n    CU_ASSERT(cert_len > 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  PoP is disabled on\n * the EST server.  The CSR does not contain a PoP.\n */\nstatic void us893_test9 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * The reenroll should work since PoP is not enabled anywhere.\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test case uses a bad password configured on\n * the EST proxy context.  This should cause the EST\n * server to reject the reenroll request.\n */\nstatic void us893_test10 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"bogus\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    CU_ASSERT(rv == 401);\n\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\nstatic void us893_test11 (void)\n{\n    int rv;\n    long http_code = 0;\n    CURL *hnd;\n    struct curl_slist *slist1;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using an untrusted cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_UNTRUSTED_CERT,\n                        US893_UNTRUSTED_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We don't use the normal curl util API here because\n     * we need to disable TLS peer verification for this\n     * special test case.\n     */\n    /*\n     * Set the Content-Type header in the HTTP request\n     */\n    slist1 = NULL;\n    slist1 = curl_slist_append(slist1, US893_PKCS10_CT);\n\n    /*\n     * Setup all the other fields that CURL requires\n     */\n    hnd = curl_easy_init();\n    curl_easy_setopt(hnd, CURLOPT_URL, US893_REENROLL_URL_BA);\n    curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);\n    curl_easy_setopt(hnd, CURLOPT_USERPWD, US893_UIDPWD_GOOD);\n    curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, US893_PKCS10_RSA2048);\n    curl_easy_setopt(hnd, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)strlen(US893_PKCS10_RSA2048));\n    curl_easy_setopt(hnd, CURLOPT_USERAGENT, \"curl/7.27.0\");\n    curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);\n    curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);\n    curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);\n    curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n    curl_easy_setopt(hnd, CURLOPT_CAINFO, US893_CACERTS);\n    curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);\n    curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);\n    curl_easy_setopt(hnd, CURLOPT_FORBID_REUSE, 1L);\n\n    /*\n     * Issue the HTTP request\n     */\n    curl_easy_perform(hnd);\n\n    /*\n     * Get the HTTP reponse status code from the server\n     */\n    curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &http_code);\n    curl_easy_cleanup(hnd);\n    hnd = NULL;\n    curl_slist_free_all(slist1);\n    slist1 = NULL;\n\n    CU_ASSERT(http_code == 400);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        \"US893 test realm\",\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Simple reenroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * reenroll of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.  However, PoP is now\n * enabled on the proxy, which should cause a\n * failure since libcurl doesn't include the PoP.\n */\nstatic void us893_test12 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_enable_pop();\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Should fail since the proxy will fail the PoP check\n     */\n    CU_ASSERT(rv == 400);\n\n    st_proxy_disable_pop();\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us893_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us893_proxy_simpreenroll\",\n                           us893_init_suite,\n                           us893_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, \"ReEnroll RSA cert\", us893_test1)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll expired cert\", us893_test2)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll corrupt CSR\", us893_test3)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll expired cert with retry-after\", us893_test4)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll no proxy id-kp-cmcRA with srv PoP\", us893_test5)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll no proxy id-kp-cmcRA w/o srv PoP\", us893_test6)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll no proxy id-kp-cmcRA w/o srv PoP CSR PoP\", us893_test7)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll expired cert w/o srv PoP CSR PoP\", us893_test8)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll expired cert w/o srv PoP no CSR PoP\", us893_test9)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll proxy misconfigured HTTP auth\", us893_test10)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll proxy untrusted identity cert\", us893_test11)) ||\n        (NULL == CU_add_test(pSuite, \"ReEnroll PoP enabled proxy no CSR PoP\", us893_test12)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd2"},"name":"us899.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc81"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca6"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca4"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc92"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8e"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8d"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us899.c - Unit Tests for User Story 899 - Client simple enroll \n *\n * September, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US899_SERVER_PORT   29899\n#define US899_SERVER_IP\t    \"127.0.0.1\"\t\n#define US899_UID\t    \"estuser\"\n#define US899_PWD\t    \"estpwd\"\n\n/*\n * The following certs are used for FQDN testing\n */\n#ifndef WIN32\n#define US899_CACERTS\t    \"CA/estCA/cacert.crt\"\n#define US899_TRUST_CERTS   \"CA/trustedcerts.crt\"\n#define US899_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n\n#define US899_SERVER_CERT_CN_MISMATCH\t    \"US899/cert_cn_mismatch.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH\t    \"US899/key_cn_mismatch.pem\"\n#define US899_SERVER_CERT_CN_MISMATCH_IP    \"US899/cert_cn_mismatch_ip.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH_IP\t    \"US899/key_cn_mismatch_ip.pem\"\n#define US899_SERVER_CERT_CN_MATCH_WC       \"US899/cert_cn_match_wc.pem\"\n#define US899_SERVER_KEY_CN_MATCH_WC\t    \"US899/key_cn_match_wc.pem\"\n#define US899_SERVER_CERT_CN_MISMATCH_WC    \"US899/cert_cn_mismatch_wc.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH_WC\t    \"US899/key_cn_mismatch_wc.pem\"\n#define US899_SERVER_CERT_SAN_MATCH\t    \"US899/cert_san_match.pem\"\n#define US899_SERVER_KEY_SAN_MATCH\t    \"US899/key_san_match.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH\t    \"US899/cert_san_mismatch.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH\t    \"US899/key_san_mismatch.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH_IP   \"US899/cert_san_mismatch_ip.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH_IP    \"US899/key_san_mismatch_ip.pem\"\n#define US899_SERVER_CERT_SAN_MATCH_IP      \"US899/cert_san_match_ip.pem\"\n#define US899_SERVER_KEY_SAN_MATCH_IP       \"US899/key_san_match_ip.pem\"\n#define US899_SERVER_CERT_SAN_MATCH_WC      \"US899/cert_san_match_wc.pem\"\n#define US899_SERVER_KEY_SAN_MATCH_WC       \"US899/key_san_match_wc.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH_WC   \"US899/cert_san_mismatch_wc.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH_WC    \"US899/key_san_mismatch_wc.pem\"\n#else \n#define US899_CACERTS\t    \"CA\\\\estCA\\\\cacert.crt\"\n#define US899_TRUST_CERTS   \"CA\\\\trustedcerts.crt\"\n#define US899_SERVER_CERTKEY   \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n\n#define US899_SERVER_CERT_CN_MISMATCH\t    \"US899\\\\cert_cn_mismatch.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH\t    \"US899\\\\key_cn_mismatch.pem\"\n#define US899_SERVER_CERT_CN_MISMATCH_IP    \"US899\\\\cert_cn_mismatch_ip.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH_IP\t    \"US899\\\\key_cn_mismatch_ip.pem\"\n#define US899_SERVER_CERT_CN_MATCH_WC       \"US899\\\\cert_cn_match_wc.pem\"\n#define US899_SERVER_KEY_CN_MATCH_WC\t    \"US899\\\\key_cn_match_wc.pem\"\n#define US899_SERVER_CERT_CN_MISMATCH_WC    \"US899\\\\cert_cn_mismatch_wc.pem\"\n#define US899_SERVER_KEY_CN_MISMATCH_WC\t    \"US899\\\\key_cn_mismatch_wc.pem\"\n#define US899_SERVER_CERT_SAN_MATCH\t    \"US899\\\\cert_san_match.pem\"\n#define US899_SERVER_KEY_SAN_MATCH\t    \"US899\\\\key_san_match.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH\t    \"US899\\\\cert_san_mismatch.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH\t    \"US899\\\\key_san_mismatch.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH_IP   \"US899\\\\cert_san_mismatch_ip.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH_IP    \"US899\\\\key_san_mismatch_ip.pem\"\n#define US899_SERVER_CERT_SAN_MATCH_IP      \"US899\\\\cert_san_match_ip.pem\"\n#define US899_SERVER_KEY_SAN_MATCH_IP       \"US899\\\\key_san_match_ip.pem\"\n#define US899_SERVER_CERT_SAN_MATCH_WC      \"US899\\\\cert_san_match_wc.pem\"\n#define US899_SERVER_KEY_SAN_MATCH_WC       \"US899\\\\key_san_match_wc.pem\"\n#define US899_SERVER_CERT_SAN_MISMATCH_WC   \"US899\\\\cert_san_mismatch_wc.pem\"\n#define US899_SERVER_KEY_SAN_MISMATCH_WC    \"US899\\\\key_san_mismatch_wc.pem\"\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us899_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&logger_critical_section); \n}\n#endif \n\n\n\n#define US899_VALID_CSR_PEM \"-----BEGIN CERTIFICATE REQUEST-----\\nMIIBhDCB7gIBADBFMQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEh\\nMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB\\nAQUAA4GNADCBiQKBgQC13wEG36vBY8Mq+uu80SKvkx0ZCt0lc18kaMSDLwML2IRS\\n+SaCLEZbjJYeSxwZ9qXy4Rt1vFDRRTL57/lQTgT5kzKI2D2YUZ+Dg6wQqx/4t99S\\naCv/lxcUTfIPiaqATUQxeZA+h7Fo0ti9wLSw6AQft9hibYPRJZ6zHa24lXwd7wID\\nAQABoAAwDQYJKoZIhvcNAQEFBQADgYEAjwSjLqFAzoPGa4GKn7AEitepVA+3QjXL\\n45LSzrVJMW4Jl8Ovm/aPatnFRQYm82rVKb7Sq4Ddo9nDJ9tgZ450oqIWbujUmGEU\\nsUUxJSJ3vGXyQy+8NeTy4GmmsNWIwhSKMkqh7YVlBvgkwGoNFuQ8mD90prFmld+J\\nhHBZXCaekrE=\\n-----END CERTIFICATE REQUEST-----\"\n\n\n/*\n * Note: this array was generated using:  xdd -i req.der req.c\n */\nstatic unsigned char US899_VALID_CSR_DER[] = {\n  0x30, 0x82, 0x01, 0xa8, 0x30, 0x82, 0x01, 0x11, 0x02, 0x01, 0x00, 0x30,\n  0x68, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n  0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,\n  0x02, 0x6e, 0x63, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x07,\n  0x0c, 0x03, 0x73, 0x73, 0x73, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55,\n  0x04, 0x0a, 0x0c, 0x03, 0x64, 0x64, 0x64, 0x31, 0x0d, 0x30, 0x0b, 0x06,\n  0x03, 0x55, 0x04, 0x0b, 0x0c, 0x04, 0x66, 0x6a, 0x6a, 0x64, 0x31, 0x0c,\n  0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x03, 0x31, 0x32, 0x37,\n  0x31, 0x13, 0x30, 0x11, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n  0x01, 0x09, 0x01, 0x16, 0x04, 0x6e, 0x6f, 0x6e, 0x65, 0x30, 0x81, 0x9f,\n  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n  0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81,\n  0x81, 0x00, 0xb9, 0x9f, 0xdd, 0xd0, 0xa4, 0xdf, 0x06, 0x50, 0xf5, 0x4e,\n  0x85, 0x80, 0xeb, 0x2a, 0x1e, 0xff, 0x3c, 0x0f, 0x0d, 0x98, 0x6e, 0xfe,\n  0x08, 0x74, 0xf4, 0xce, 0xf5, 0xfd, 0xf9, 0x2f, 0x86, 0x20, 0xf7, 0xcc,\n  0x08, 0x05, 0xce, 0x98, 0x69, 0x5c, 0x8c, 0xbd, 0x20, 0xa7, 0x28, 0xf7,\n  0xe4, 0x22, 0xfa, 0xaf, 0xe4, 0x15, 0xc4, 0xb9, 0x85, 0xcb, 0x0f, 0x11,\n  0xc6, 0x55, 0x0d, 0x31, 0x5c, 0xfb, 0x5e, 0xcf, 0x8e, 0xd1, 0xde, 0x77,\n  0x15, 0x2c, 0x8c, 0x4e, 0x88, 0x4e, 0x21, 0xb6, 0x69, 0x9c, 0xa7, 0x7d,\n  0x06, 0xc5, 0x75, 0x3f, 0xdc, 0x18, 0xf6, 0x00, 0x51, 0xd5, 0x00, 0x47,\n  0x62, 0xfc, 0x95, 0xc8, 0xd4, 0xef, 0x31, 0x4a, 0xb0, 0x15, 0xa9, 0x50,\n  0x04, 0x6e, 0x13, 0x14, 0xd4, 0xbb, 0x56, 0x22, 0x6f, 0x3b, 0x91, 0xb6,\n  0xeb, 0xba, 0x25, 0x8f, 0x12, 0xea, 0xfd, 0xd4, 0xd0, 0x6d, 0x02, 0x03,\n  0x01, 0x00, 0x01, 0xa0, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,\n  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,\n  0x3b, 0xa5, 0xb4, 0x97, 0x6c, 0xea, 0xe4, 0x9f, 0xeb, 0x56, 0xca, 0x7a,\n  0x7f, 0xfa, 0x53, 0x8d, 0xee, 0x6f, 0x7e, 0xa1, 0x08, 0x65, 0xe0, 0x05,\n  0x5b, 0x0e, 0x5a, 0x92, 0xdb, 0x3c, 0xc5, 0x6d, 0x0d, 0xcd, 0x2c, 0xcd,\n  0x4d, 0x10, 0x2a, 0x92, 0x78, 0x1d, 0xfb, 0x92, 0x66, 0x33, 0x18, 0xdd,\n  0xf8, 0x78, 0xc5, 0x1a, 0x03, 0xf9, 0x58, 0x9f, 0x32, 0x49, 0xde, 0xd2,\n  0x26, 0x78, 0x80, 0x87, 0x18, 0xf3, 0x6d, 0xc3, 0x35, 0x5d, 0x21, 0x8b,\n  0x4c, 0x8c, 0x87, 0xef, 0xb1, 0xfc, 0x2c, 0xec, 0xdb, 0xd6, 0x00, 0xe5,\n  0x21, 0xfa, 0x34, 0x5a, 0x3c, 0xc3, 0x82, 0x52, 0x6f, 0x81, 0x2a, 0x05,\n  0xcc, 0xdc, 0x8a, 0x51, 0xf6, 0x65, 0x1d, 0xc5, 0x64, 0x86, 0xc1, 0x28,\n  0xf5, 0x0c, 0x8f, 0x09, 0xd4, 0x84, 0x8f, 0x69, 0x04, 0x24, 0x65, 0xf4,\n  0x47, 0x6c, 0x90, 0x57, 0x3c, 0x04, 0x4d, 0x52\n};\nstatic unsigned int US899_VALID_CSR_DER_LEN = 428;\n#if 0\n//Leaving this in for now, we may need this for some test cases\nstatic FILE *outfile;\nstatic size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr,size,nmemb,outfile);\n    return written;\n}\n#endif\n\nstatic void us899_clean (void)\n{\n}\n\nstatic int us899_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERTKEY,\n\t          US899_SERVER_CERTKEY,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us899_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &us899_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US899_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n\treturn 1;\n    }\n\n    us899_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us899_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us899_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\"%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n\",\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(\"Failing Cert:\\n\");\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server's cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert->sig_alg, cur_cert->signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}    \n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\nstatic int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)\n{\n    X509_NAME *subj;\n\n    /* setup version number */\n    if (!X509_REQ_set_version(req, 0L)) {\n\tprintf(\"\\nUnable to set X509 version#\\n\");\n        return (-1);\n    }\n\n    /*\n     * Add Common Name entry\n     */\n    subj = X509_REQ_get_subject_name(req);\n    if (!X509_NAME_add_entry_by_txt(subj, \"CN\", MBSTRING_ASC,\n                                    (unsigned char*)cn, -1, -1, 0)) {\n\tprintf(\"\\nUnable to create X509 Common Name entry\\n\");\n        return (-1);\n    }\n\n    /*\n     * Set the public key on the request\n     */\n    if (!X509_REQ_set_pubkey(req, pkey)) {\n\tprintf(\"\\nUnable to set X509 public key\\n\");\n        return (-1);\n    }\n\n    return (0);\n}\n\n/*\n * Sign an X509 certificate request using the digest and the key passed.\n * Returns OpenSSL error code from X509_REQ_sign_ctx();\n */\nstatic int sign_X509_req (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\n{\n    int rv;\n    EVP_PKEY_CTX *pkctx = NULL;\n    EVP_MD_CTX mctx;\n\n    EVP_MD_CTX_init(&mctx);\n\n    if (!EVP_DigestSignInit(&mctx, &pkctx, md, NULL, pkey)) {\n        return 0;\n    }\n\n    /*\n     * Encode using DER (ASN.1) \n     *\n     * We have to set the modified flag on the X509_REQ because\n     * OpenSSL keeps a cached copy of the DER encoded data in some\n     * cases.  Setting this flag tells OpenSSL to run the ASN\n     * encoding again rather than using the cached copy.\n     */\n    x->req_info->enc.modified = 1; \n    rv = X509_REQ_sign_ctx(x, &mctx);\n\n    EVP_MD_CTX_cleanup(&mctx);\n\n    return (rv);\n}\n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll -  \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n */\nstatic void us899_test1 (void) \n{\n    LOG_FUNC_NM;\n\n    us899_simple_enroll(\"TC899-1\", US899_SERVER_IP, EST_ERR_NONE); \n}\n\n\n/*\n * Simple enroll CSR  \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n * This test case uses the alternate enroll method where the CSR\n * is provided by the application layer rather than having libest\n * generate the CSR.\n */\nstatic void us899_test2 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509_REQ *csr;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Generate a CSR\n     */\n    csr = X509_REQ_new();\n    CU_ASSERT(csr != NULL);\n    rv = populate_x509_csr(csr, key, \"US899-TC2\");\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the alternate API to enroll an existing CSR\n     */\n    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    X509_REQ_free(csr);\n    EVP_PKEY_free(key);\n    if (new_cert) {\n        free(new_cert);\n    }\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll CSR - Null \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n * This test case uses the alternate enroll method where the CSR\n * is provided by the application layer rather than having libest\n * generate the CSR.  It attempts to pass in null CSR, which should\n * fail.\n */\nstatic void us899_test3 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the alternate API to enroll a null CSR\n     */\n    rv = est_client_enroll_csr(ectx, NULL, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NO_CSR);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll CSR - corrupted  \n *\n * This test checks the X509_REQ helper function is working proplery.\n */\nstatic void us899_test4 (void) \n{\n    X509_REQ *csr;\n    unsigned char badreq[14] = \"bogus request\";\n\n    LOG_FUNC_NM;\n\n    /*\n     * First try PEM decoding \n     */\n    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try DER decoding \n     */\n    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_DER);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try an invalid format\n     */\n    csr = est_read_x509_request(badreq, 13, 999);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try an invalid csr length\n     */\n    csr = est_read_x509_request(badreq, 999999, EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try a valid PEM encoded csr\n     */\n    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_PEM, strlen(US899_VALID_CSR_PEM), \n\t                         EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr != NULL);\n    if (csr) {\n\tX509_REQ_free(csr);\n    }\n\n    /*\n     * Next try a valid DER encoded csr\n     */\n    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_DER, US899_VALID_CSR_DER_LEN, \n\t                         EST_CERT_FORMAT_DER);\n    CU_ASSERT(csr != NULL);\n    if (csr) {\n\tX509_REQ_free(csr);\n    }\n}\n\n//C. Attempt to enroll a newly created CSR that's already been signed \n//   via est_client_enroll_csr\nstatic void us899_test5 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    X509_REQ *csr;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * Generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Generate a new CSR\n     */\n    csr = X509_REQ_new();\n    CU_ASSERT(csr != NULL);\n    rv = populate_x509_csr(csr, key, \"US899-TC5\");\n    CU_ASSERT(csr != NULL);\n\n    /*\n     * Sign the CSR\n     */\n\n    rv = sign_X509_req(csr,key,EVP_sha256()); \n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the alternate API to enroll an existing CSR.  This should pass.\n     */\n    rv = est_client_enroll_csr(ectx, csr, &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    X509_REQ_free(csr);\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll - FQDN mismatch hostname in CN \n *\n * This test confirms that a mismatched host name on\n * the server cert CN will result in an auth failure\n * at the TLS layer on the client side.\n */\nstatic void us899_test6 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH,\n\t          US899_SERVER_KEY_CN_MISMATCH,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-6\", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n\n}\n\n/*\n * Simple enroll - FQDN mismatch IPv4 address in CN \n *\n * This test confirms that a mismatched IP address in\n * the server cert CN will result in an auth failure\n * at the TLS layer on the client side.\n * Note: this test may be redundant since the IP address\n *       matching logic only occurs when the dNSName is \n *       used instead of the CommonName.\n */\nstatic void us899_test7 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH_IP,\n\t          US899_SERVER_KEY_CN_MISMATCH_IP,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-7\", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n\n}\n\n/*\n * Simple enroll - FQDN matched wildcard in CN \n *\n * This test confirms that wildcard matching logic\n * in the CN is working. The cert uses a wildcard\n * pattern of *.cisco.com with a server address\n * of localhost.cisco.com.\n */\nstatic void us899_test8 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MATCH_WC,\n\t          US899_SERVER_KEY_CN_MATCH_WC,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-8\", \"localhost.cisco.com\", EST_ERR_NONE); \n\n}\n\n/*\n * Simple enroll - FQDN mismatched wildcard in CN \n *\n * This test confirms that wildcard matching logic\n * in the CN is working. The cert uses a wildcard\n * pattern of *.google.com with a server address\n * of localhost.cisco.com.\n */\nstatic void us899_test9 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH_WC,\n\t          US899_SERVER_KEY_CN_MISMATCH_WC,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-9\", \"localhost.cisco.com\", EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN matched hostname in SubjectAltName \n *\n * This test confirms that a matched host name on\n * the server cert SubjectAltName ext will result in an auth success. \n */\nstatic void us899_test10 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH,\n\t          US899_SERVER_KEY_SAN_MATCH,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-10\", \"localhost.cisco.com\", EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN mismatched hostname in SubjectAltName \n *\n * This test confirms that a mismatched host name on\n * the server cert SubjectAltName ext will result in an auth failure. \n */\nstatic void us899_test11 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH,\n\t          US899_SERVER_KEY_SAN_MISMATCH,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-11\", \"localhost.cisco.com\", EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN mismatched IPv4 address in SubjectAltName \n *\n * This test confirms that a mismatched IPv4 address on\n * the server cert SubjectAltName ext will result in an auth failure. \n */\nstatic void us899_test12 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH_IP,\n\t          US899_SERVER_KEY_SAN_MISMATCH_IP,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-12\", US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN matched IPv4 address in SubjectAltName \n *\n * This test confirms that a matched IPv4 address on\n * the server cert SubjectAltName ext will result in an auth success. \n */\nstatic void us899_test13 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH_IP,\n\t          US899_SERVER_KEY_SAN_MATCH_IP,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-13\", US899_SERVER_IP, EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN matched hostname in SubjectAltName with wildcard \n *\n * This test confirms that a hostname matches a wildcard pattern in\n * the server cert SubjectAltName ext, which will result in an auth success. \n */\nstatic void us899_test14 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH_WC,\n\t          US899_SERVER_KEY_SAN_MATCH_WC,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-14\", \"localhost.cisco.com\", EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN mismatched hostname in SubjectAltName with wildcard \n *\n * This test confirms that a hostname mismatches a wildcard pattern in\n * the server cert SubjectAltName ext, which will result in an auth fail. \n */\nstatic void us899_test15 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH_WC,\n\t          US899_SERVER_KEY_SAN_MISMATCH_WC,\n\t          \"US899 test realm\",\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          \"CA/estExampleCA.cnf\",\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(\"TC899-15\", \"localhost.cisco.com\", EST_ERR_FQDN_MISMATCH); \n}\n\n\n/*\n * Simple enroll - CRL check enabled on client\n *\n * We enable CRL checking on the client side.  We will\n * generate a CRL, but the server cert will not be\n * revoked.  The enroll should succeed.\n */\nstatic void us899_test16 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *cacrlcerts = NULL;\n    int cacrlcerts_len = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Now that all the FQDN tests are completed, start\n     * the normal server.\n     */\n    rv = us899_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Generate a CRL and append it to the CA chain\n     * we're using on the client side.\n     */\n#ifndef WIN32\n    system(\"openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem\");\n    SLEEP(1);\n    system(\"cat CA/trustedcerts.crt > US899/test16trust.crt\");\n    SLEEP(1);\n    system(\"cat US899/test16_crl.pem >> US899/test16trust.crt\");\n    SLEEP(1);\n#else\n    system(\"openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem\");\n    SLEEP(1);\n    system(\"type CA\\\\trustedcerts.crt > US899\\\\test16trust.crt\");\n    SLEEP(1);\n    system(\"type US899\\\\test16_crl.pem >> US899\\\\test16trust.crt\");\n    SLEEP(1);\n#endif \n\n    /*\n     * Read in the CA certificates\n     */\n    cacrlcerts_len = read_binary_file(\"US899/test16trust.crt\", &cacrlcerts);\n    CU_ASSERT(cacrlcerts > 0);\n    if (cacrlcerts_len <= 0) {\n\treturn;\n    }\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacrlcerts, cacrlcerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Enable CRL checking on the client\n     */\n    rv = est_enable_crl(ectx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TEST16-CN\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n    free(cacrlcerts);\n}\n\n/*\n * Simple enroll - CRL check enabled on client\n *\n * We enable CRL checking on the client side.  We will\n * generate a CRL, the server cert will  be\n * revoked.  The enroll should fail.\n */\nstatic void us899_test17 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    unsigned char *cacrlcerts = NULL;\n    int cacrlcerts_len = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    \n    LOG_FUNC_NM;\n\n    /*\n     * Revoke the server cert, generate a CRL and append it to the CA chain\n     * we're using on the client side.\n     */\n#ifndef WIN32\n    system(\"cp CA/estCA/index.txt CA/estCA/index.txt.save\");\n    SLEEP(1);\n    system(\"openssl ca -config CA/estExampleCA.cnf -revoke CA/estCA/private/estservercertandkey.pem\");\n    SLEEP(1);\n    system(\"openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test17_crl.pem\");\n    SLEEP(1);\n    system(\"cat CA/trustedcerts.crt > US899/test17trust.crt\");\n    SLEEP(1);\n    system(\"cat US899/test17_crl.pem >> US899/test17trust.crt\");\n    SLEEP(1);\n    system(\"cp CA/estCA/index.txt.save CA/estCA/index.txt\");\n    SLEEP(1);\n#else \n    system(\"copy CA\\\\estCA\\\\index.txt CA\\\\estCA\\\\index.txt.save\");\n    SLEEP(1);\n    system(\"openssl ca -config CA\\\\estExampleCA.cnf -revoke CA\\\\estCA\\\\private\\\\estservercertandkey.pem\");\n\tSLEEP(1); \n    system(\"openssl ca -config CA\\\\estExampleCA.cnf -gencrl -out US899\\\\test17_crl.pem\");\n    SLEEP(1);\n    system(\"type CA\\\\trustedcerts.crt > US899\\\\test17trust.crt\");\n    SLEEP(1);\n    system(\"type US899\\\\test17_crl.pem >> US899\\\\test17trust.crt\");\n    SLEEP(1);\n    system(\"copy CA\\\\estCA\\\\index.txt.save CA\\\\estCA\\\\index.txt\");\n    SLEEP(1);\n#endif \n\n    /*\n     * Read in the CA certificates\n     */\n    cacrlcerts_len = read_binary_file(\"US899/test17trust.crt\", &cacrlcerts);\n    CU_ASSERT(cacrlcerts > 0);\n    if (cacrlcerts_len <= 0) {\n\treturn;\n    }\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacrlcerts, cacrlcerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Enable CRL checking on the client\n     */\n    rv = est_enable_crl(ectx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TEST17-CN\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n    free(cacrlcerts);\n}\n\n/*\n * Simple enroll - Receive Retry-After response \n *\n * Client issues an Enroll request and receives\n * a Retry-After response.  Ensure that the\n * retry after value can be obtained from the client.\n */\nstatic void us899_test18 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    int delay_secs = 0;\n    time_t retry_date = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    \n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to go into manual enroll mode\n     */\n    st_stop();\n\n    /*\n     * Start the server up in manual enroll mode\n     */\n    rv = us899_start_server(1, 0);\n    CU_ASSERT(rv == 0);    \n\n    /*\n     * Create a client context using the default CA certs\n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &attr_data, &attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, \"TEST18-CN\", &pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    if (rv == EST_ERR_CA_ENROLL_RETRY) {\n        /*\n         * go get the retry duration\n         * make sure it's set to the default value\n         */\n        rv = est_client_copy_retry_after(ectx, &delay_secs, &retry_date);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        CU_ASSERT(delay_secs == 3600);\n    }\n    \n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n//TO DO\n//\n//Auth (HTTP basic auth enabled on server) \n//A. Enroll CSR using valid cert, no UID\n//B. Enroll CSR using valid cert, valid UID\n//C. Enroll CSR using valid cert, invalid UID\n//D. Enroll CSR using invalid cert, no UID\n//E. Enroll CSR using invalid cert, valid UID\n//F. Enroll CSR using invalid cert, invalid UID\n//\n//Auth (HTTP digest auth enabled on server) \n//A. Enroll CSR using valid cert, no UID\n//B. Enroll CSR using valid cert, valid UID\n//C. Enroll CSR using valid cert, invalid UID\n//D. Enroll CSR using invalid cert, no UID\n//E. Enroll CSR using invalid cert, valid UID\n//F. Enroll CSR using invalid cert, invalid UID\n//\n\nint us899_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(\"us899_client_simpenroll\", \n\t                  us899_init_suite, \n\t\t\t  us899_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* \n    * Add the tests to the suite \n    *\n    * ********************IMPORTANT*********************\n    * Do not change the order of these tests.\n    * Some of the tests stop the EST server and restart\n    * it using different certs.  If you change the order\n    * then false negatives may occur.\n    * **************************************************\n    *\n    */\n   if ((NULL == CU_add_test(pSuite, \"Simple enroll\", us899_test1)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll CSR\", us899_test2)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll null CSR\", us899_test3)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll corrupted CSR\", us899_test4)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll signed CSR\", us899_test5)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - hostname mismatch FQDN CN\", us899_test6)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - IPv4 mismatch FQDN CN\", us899_test7)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - wildcard match FQDN CN\", us899_test8)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - wildcard mismatch FQDN CN\", us899_test9)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - hostname match FQDN SAN\", us899_test10)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - hostname mismatch FQDN SAN\", us899_test11)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - IPv4 mismatch FQDN SAN\", us899_test12)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - IPv4 match FQDN SAN\", us899_test13)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - wildcard match FQDN SAN\", us899_test14)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - wildcard mismatch FQDN SAN\", us899_test15)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - CRL enabled, valid server cert\", us899_test16)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - CRL enabled, revoked server cert\", us899_test17)) ||\n       (NULL == CU_add_test(pSuite, \"Simple enroll - Retry-After received\", us899_test18)))\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd3"},"name":"us1005.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc8b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc83"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcae"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcab"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc87"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcad"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc7f"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc98"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9c"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc97"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}],["source_raw",{"$oid":"5ea8c50ab2d857f8956dbcb5"}]],"contents":"/*------------------------------------------------------------------\n * us1005.c - Unit Tests for User Story 1005 - Client easy provision\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#include <string.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif \n#include <est.h>\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n#include <openssl/x509v3.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#ifdef WIN32\nstatic CRITICAL_SECTION logger_critical_section;\n#endif \n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1005_SERVER_PORT      31005\n#define US1005_SERVER_IP    \"127.0.0.1\" \n#define US1005_UID          \"estuser\"\n#define US1005_PWD          \"estpwd\"\n#ifndef WIN32\n#define US1005_CACERTS          \"CA/estCA/cacert.crt\"\n#define US1005_TRUST_CERTS      \"CA/trustedcerts.crt\"\n#define US1005_SERVER_CERTKEY   \"CA/estCA/private/estservercertandkey.pem\"\n#define US1005_CLIENT_KEY       \"US1005/implicit-key.pem\"\n#define US1005_CLIENT_CERT      \"US1005/implicit-cert.pem\"\n#else\n#define US1005_CACERTS          \"CA\\\\estCA\\\\cacert.crt\"\n#define US1005_TRUST_CERTS      \"CA\\\\trustedcerts.crt\"\n#define US1005_SERVER_CERTKEY   \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US1005_CLIENT_KEY       \"US1005\\\\implicit-key.pem\"\n#define US1005_CLIENT_CERT      \"US1005\\\\implicit-cert.pem\"\n#endif \n#define US1005_CSR_NOPOP        \"MBQGBysGAQEBARYGCWCGSAFlAwQCAg==\\0\"\n\nstatic char *log_search_target = NULL;\nstatic int search_target_found = 0;\n/*\n * This is a simple callback used to override the default\n * logging facility in libest.  We'll use this to look\n * for specific debug output.\n */\nstatic void us1005_logger_stderr (char *format, va_list l)\n{\n    char t_log[1024];\n#ifndef WIN32\n    flockfile(stderr);\n#else\n    EnterCriticalSection(&logger_critical_section);\n#endif \n    if (log_search_target) {\n        vsnprintf(t_log, 1024, format, l);\n        if (strstr(t_log, log_search_target)) {\n            search_target_found = 1;\n        }\n        fprintf(stderr, \"%s\", t_log);\n    } else {\n        vfprintf(stderr, format, l);\n    }\n    fflush(stderr);\n#ifndef WIN32\n    funlockfile(stderr);\n#else\n    LeaveCriticalSection(&logger_critical_section);\n#endif \n}\n\nstatic void us1005_clean (void)\n{\n}\n\nstatic int us1005_start_server (int manual_enroll, int nid, int no_http_auth,\n                                int enable_pop)\n{\n    int rv;\n\n    rv = st_start(US1005_SERVER_PORT,\n                  US1005_SERVER_CERTKEY,\n                  US1005_SERVER_CERTKEY,\n                  \"US1005 test realm\",\n                  US1005_CACERTS,\n                  US1005_TRUST_CERTS,\n                  \"CA/estExampleCA.cnf\",\n                  manual_enroll,\n                  enable_pop,\n                  nid);\n\n    if (no_http_auth) {\n        st_disable_http_auth();\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1005_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    /* Initialize critical section on Windows*/\n    InitializeCriticalSection(&logger_critical_section);\n#endif \n\n    est_init_logger(EST_LOG_LVL_INFO, &us1005_logger_stderr);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1005_CACERTS, &cacerts);\n    if (cacerts_len <= 0) {\n        return 1;\n    }\n\n    us1005_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1005_start_server(0, 0, 0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1005_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(\"\\nError allocating PKEY structure for new key pair\\n\");\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(\"\\nError assigning RSA key pair to PKEY structure\\n\");\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function performs the easy provision operation using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us1005_easy_provision (char *cn, char *server, int ba_hint,\n                                   int use_cert)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *new_key;\n    int rv;\n    int pkcs7_len = 0;\n    int ca_certs_len = 0;\n    unsigned char *new_cert = NULL;\n    EVP_PKEY *key = NULL;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    X509 *cert = NULL;\n    BIO *in;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    if (use_cert) {\n        /*\n         * Read in the private key\n         */\n        key_len = read_binary_file(US1005_CLIENT_KEY, &key_raw);\n        CU_ASSERT(key_len > 0);\n        key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n        CU_ASSERT(key != NULL);\n        free(key_raw);\n\n        /*\n         * Read in the old cert\n         */\n        cert_len = read_binary_file(US1005_CLIENT_CERT, &cert_raw);\n        CU_ASSERT(cert_len > 0);\n        in = BIO_new_mem_buf(cert_raw, cert_len);\n        CU_ASSERT(in != NULL);\n        if (!in)\n            return;\n        cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n        CU_ASSERT(cert != NULL);\n        if (!cert)\n            return;\n        BIO_free_all(in);\n        free(cert_raw);\n    }\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    if (ba_hint) {\n        rv = est_client_enable_basic_auth_hint(ectx);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1005_SERVER_PORT, NULL);\n\n    /*\n     * generate a new private key\n     */\n    new_key = generate_private_key();\n    CU_ASSERT(new_key != NULL);\n\n    /*\n     * Attempt to provision a new cert\n     */\n    rv = est_client_provision_cert(ectx, cn, &pkcs7_len, &ca_certs_len,\n        new_key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    EVP_PKEY_free(new_key);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        if (new_cert)\n            free(new_cert);\n    } else {\n        est_destroy(ectx);\n        return;\n    }\n\n    /*\n     * Retrieve a copy of the new CA certs\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(ca_certs_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_cacerts(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        if (new_cert)\n            free(new_cert);\n    } else {\n        est_destroy(ectx);\n        return;\n    }\n\n    EVP_PKEY_free(key);\n    X509_free(cert);\n\n    /*\n     * Cleanup\n     */\n    est_destroy(ectx);\n}\n\n/*\n * Easy provision - HTTP basic auth, no client cert\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test1 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(\"TC1005-1\", US1005_SERVER_IP, 0, 0);\n}\n\n/*\n * Easy provision - with HTTP basic auth hint enabled, no client cert\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(\"TC1005-2\", US1005_SERVER_IP, 1, 0);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test3 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(\"TC1005-3\", US1005_SERVER_IP, 0, 1);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth hint enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test4 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(\"TC1005-4\", US1005_SERVER_IP, 1, 1);\n}\n\n/*\n * Null pointers test\n */\nstatic void us1005_test5 (void)\n{\n    int p7len = 0;\n    int calen = 0;\n    EVP_PKEY *key;\n    int rv;\n    EST_CTX *ectx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a valid context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US1005_SERVER_IP, US1005_SERVER_PORT, NULL);\n\n    /*\n     * Create a valid key pair\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Try with a NULL context\n     */\n    rv = est_client_provision_cert(NULL, \"TEST2\", &p7len, &calen, key);\n    CU_ASSERT(rv == EST_ERR_NO_CTX);\n\n    /*\n     * Try with a NULL p7 length\n     */\n    rv = est_client_provision_cert(ectx, \"TEST2\", NULL, &calen, key);\n    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * Try with a NULL cacerts length\n     */\n    rv = est_client_provision_cert(ectx, \"TEST2\", &p7len, NULL, key);\n    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * Try with a NULL key\n     */\n    rv = est_client_provision_cert(ectx, \"TEST2\", &p7len, &calen, NULL);\n    CU_ASSERT(rv == EST_ERR_NO_KEY);\n\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n *  Enable pop on server, enable CSR attributes on server w/o challengePassword OID\n */\nstatic void us1005_test6 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to a value that doesn't include challengePassword OID\n     */\n    st_set_csrattrs(US1005_CSR_NOPOP);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Client will include challengePassword in CSR\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-6\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, enable CSR attributes on server w/o challengePassword OID\n */\nstatic void us1005_test7 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to a value that doesn't include challengePassword OID\n     */\n    st_set_csrattrs(US1005_CSR_NOPOP);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Cert request does not contain PoP\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-7\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Enable pop on server, enable CSR attributes on server w/ challengePassword OID\n */\nstatic void us1005_test8 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Client will include challengePassword in CSR\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-8\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, enable CSR attributes on server w/challengePassword OID\n */\nstatic void us1005_test9 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Client will include challengePassword in CSR\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-9\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Enable pop on server, disable CSR attributes on server\n */\nstatic void us1005_test10 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n    st_disable_csr_cb();\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Client will include challengePassword in CSR\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-10\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, disable CSR attributes on server\n */\nstatic void us1005_test11 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n    st_disable_csr_cb();\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = \"Cert request does not contain PoP\\0\";\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(\"TC1005-11\", US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n//\n// The next two test caes repeate tests 3 & 4 but with\n// HTTP auth disabled on the server.\n//\n\n/*\n * Easy provision - client cert with HTTP basic auth disabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test93 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with HTTP auth disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 1, 0);\n\n    us1005_easy_provision(\"TC1005-93\", US1005_SERVER_IP, 0, 1);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth hint enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test94 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(\"TC1005-94\", US1005_SERVER_IP, 1, 1);\n}\n\nint us1005_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us1005_client_easy_provision\",\n            us1005_init_suite,\n            us1005_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * Add the tests to the suite\n     *\n     * ********************IMPORTANT*********************\n     * Do not change the order of these tests.\n     * Some of the tests stop the EST server and restart\n     * it using different certs.  If you change the order\n     * then false negatives may occur.\n     * **************************************************\n     *\n     */\n    if ((NULL == CU_add_test(pSuite, \"Easy provision - no cert\", us1005_test1)) ||\n        (NULL == CU_add_test(pSuite, \"Easy provision - no cert HTTP BA hint\", us1005_test2)) ||\n        (NULL == CU_add_test(pSuite, \"Easy provision - w/cert\", us1005_test3)) ||\n        (NULL == CU_add_test(pSuite, \"Easy provision - w/cert HTTP BA hint\", us1005_test4)) ||\n        (NULL == CU_add_test(pSuite, \"Null pointers\", us1005_test5)) ||\n        (NULL == CU_add_test(pSuite, \"Enable PoP - no challengePassword\", us1005_test6)) ||\n        (NULL == CU_add_test(pSuite, \"Disable PoP - no challengePassword\", us1005_test7)) ||\n        (NULL == CU_add_test(pSuite, \"Enable PoP - w/challengePassword\", us1005_test8)) ||\n        (NULL == CU_add_test(pSuite, \"Disable PoP - w/challengePassword\", us1005_test9)) ||\n        (NULL == CU_add_test(pSuite, \"Enable PoP - CSR disabled\", us1005_test10)) ||\n        (NULL == CU_add_test(pSuite, \"Disable PoP - CSR disabled\", us1005_test11)) ||\n        (NULL == CU_add_test(pSuite, \"Easy provision - w/cert no server auth\", us1005_test93)) ||\n        (NULL == CU_add_test(pSuite, \"Easy provision - w/cert HTTP BA hint no server auth\", us1005_test94)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd4"},"name":"us901.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc99"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc83"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc89"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca3"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca8"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcb2"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}]],"contents":"/*------------------------------------------------------------------\n * us901.c - Unit Tests for User Story 901 - Server cacerts\n *\n * June, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include \"st_server.h\"\n#include <openssl/ssl.h>\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#define US901_PKCS10_REQ    \"MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n\"\n#define US901_ENROLL_URL \"https://127.0.0.1:29901/.well-known/est/simpleenroll\"\n#define US901_CACERT_URL \"https://127.0.0.1:29901/.well-known/est/cacerts\"\n#define US901_PKCS10_CT     \"Content-Type: application/pkcs10\" \n#define US901_UIDPWD_GOOD   \"estuser:estpwd\"\n#define US901_UIDPWD_BAD    \"estuser:bogus\"\n#define US901_SERVER_PORT 29901\n#ifndef WIN32\n#define US901_CACERTS       \"CA/estCA/cacert.crt\"\n#define US901_EXPLICIT_CERT \"US901/explicit-cert.pem\" \n#define US901_EXPLICIT_KEY \"US901/explicit-key.pem\"\n#define US901_IMPLICIT_CERT \"US901/implicit-cert.pem\" \n#define US901_IMPLICIT_KEY \"US901/implicit-key.pem\"\n#define US901_REVOKED_CERT \"US901/revoked-cert.pem\" \n#define US901_REVOKED_KEY \"US901/revoked-key.pem\"\n#define US901_SELFSIGN_CERT \"US901/selfsigned-cert.pem\" \n#define US901_SELFSIGN_KEY \"US901/selfsigned-key.pem\"\n#define US901_CACERT \"CA/estCA/cacert.crt\"\n#define US901_EXTCERT \"CA/extCA/cacert.crt\"\n#define US901_SERVER_CERT \"CA/estCA/private/estservercertandkey.pem\"\n#define US901_SERVER_KEY \"CA/estCA/private/estservercertandkey.pem\"\n#define US901_SERVER_CERTKEY \"CA/estCA/private/estservercertandkey.pem\"\nstatic char test5_outfile[FILENAME_MAX] = \"US901/test5.crt\";\n#else\n#define US901_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US901_EXPLICIT_CERT \"US901\\\\explicit-cert.pem\" \n#define US901_EXPLICIT_KEY \"US901\\\\explicit-key.pem\"\n#define US901_IMPLICIT_CERT \"US901\\\\implicit-cert.pem\" \n#define US901_IMPLICIT_KEY \"US901\\\\implicit-key.pem\"\n#define US901_REVOKED_CERT \"US901\\\\revoked-cert.pem\" \n#define US901_REVOKED_KEY \"US901\\\\revoked-key.pem\"\n#define US901_SELFSIGN_CERT \"US901\\\\selfsigned-cert.pem\" \n#define US901_SELFSIGN_KEY \"US901\\\\selfsigned-key.pem\"\n#define US901_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define US901_EXTCERT \"CA\\\\extCA\\\\cacert.crt\"\n#define US901_SERVER_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US901_SERVER_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US901_SERVER_CERTKEY \"CA\\\\estCA\\\\private/estservercertandkey.pem\"\nstatic char test5_outfile[FILENAME_MAX] = \"US901\\\\test5.crt\";\n#endif\n\nstatic void us901_clean(void) {\n    char cmd[200];\n    sprintf(cmd, \"rm %s\", test5_outfile);\n    system(cmd);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us901_init_suite(void) {\n    us901_clean();\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    return 0;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us901_destory_suite(void) {\n    return 0;\n}\n\n/*\n * Start the appropriate flavor of st_server\n * based what character is specified\n * B - Basic auth\n * D - Digest auth\n * C - CRL checking\n * N = No auth\n */\nstatic int us901_start_server(char server_type) {\n    int rv;\n\n    switch (server_type) {\n    case 'B':\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, \"estrealm\", \"CA/estCA/cacert.crt\",\n                \"CA/trustedcerts.crt\", \"CA/estExampleCA.cnf\", 0, 0, 0);\n        st_enable_http_basic_auth();\n        break;\n    case 'D':\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, \"estrealm\", \"CA/estCA/cacert.crt\",\n                \"CA/trustedcerts.crt\", \"CA/estExampleCA.cnf\", 0, 0, 0);\n        st_enable_http_digest_auth();\n        break;\n    case 'C':\n        system(\n                \"openssl ca -config CA/estExampleCA.cnf -gencrl -out CA/estCA/crl.pem\");\n        SLEEP(1);\n        system(\n                \"cat CA/trustedcerts.crt CA/estCA/crl.pem > US901/trustedcertsandcrl.crt\");\n        SLEEP(1);\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, \"estrealm\", \"CA/estCA/cacert.crt\",\n                \"US901/trustedcertsandcrl.crt\", \"CA/estExampleCA.cnf\", 0, 0, 0);\n        st_enable_crl();\n        st_disable_http_auth();\n        break;\n    case 'N':\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, \"estrealm\", \"CA/estCA/cacert.crt\",\n                \"CA/trustedcerts.crt\", \"CA/estExampleCA.cnf\", 0, 0, 0);\n        st_disable_http_auth();\n        break;\n    default:\n        rv = -1;\n        break;\n    }\n\n    return rv;\n}\n\n/*\n * HTTP Basic auth\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listing to port 8088 prior to this\n * test being run.\n */\nstatic void us901_test1(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('B');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    st_stop();\n    SLEEP(1);\n\n}\n\n/*\n * HTTP Basic Auth failure\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST server,\n * while using a bogus password.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running prior to this test being run.\n */\nstatic void us901_test2(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('B');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 401);\n\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * HTTP Digest Auth\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us901_test3(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_DIGEST,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * HTTP Digest Auth fail\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST server.\n * This is the negative test case for Digest auth.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us901_test4(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_DIGEST,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\nstatic FILE *outfile;\nstatic size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata) {\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\n/*\n * This test case does a simple cacerts request\n * and looks for the HTTP 200 response code.\n */\nstatic void us901_test5(void) {\n    long rv;\n    char cmd[200];\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_get(US901_CACERT_URL, US901_CACERTS, &write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(cmd,\n            \"openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs\",\n            test5_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n    st_stop();\n    SLEEP(1);\n}\n\nstatic void us901_test_sslversion(const SSL_METHOD *m, int expect_fail) {\n    BIO *conn;\n    SSL *ssl;\n    SSL_CTX *ssl_ctx = NULL;\n    int rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    ssl_ctx = SSL_CTX_new(m);\n    CU_ASSERT(ssl_ctx != NULL);\n\n    /*\n     * Now that the SSL context is ready, open a socket\n     * with the server and bind that socket to the context.\n     */\n    conn = open_tcp_socket_ipv4(\"127.0.0.1\", \"29901\");\n    CU_ASSERT(conn != NULL);\n\n    /*\n     * Creaea SSL session context\n     */\n    ssl = SSL_new(ssl_ctx);\n    SSL_set_bio(ssl, conn, conn);\n\n    /*\n     * Now that we have everything ready, let's initiate the TLS\n     * handshake.\n     */\n    rv = SSL_connect(ssl);\n    if (!expect_fail) {\n        CU_ASSERT(rv > 0);\n    } else {\n        CU_ASSERT(rv <= 0);\n    }\n\n    /*\n     * Cleanup all the data\n     */\n    SSL_shutdown(ssl);\n    SSL_free(ssl);\n    SSL_CTX_free(ssl_ctx);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to create a SSL 3.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us901_test6(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(SSLv3_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us901_test7(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.1 connection\n * with the EST server.  This should succeed.\n */\nstatic void us901_test8(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_1_client_method(), 0);\n}\n\n/*\n * This test attempts to create a TLS 1.2 connection\n * with the EST server.  This should succeed.\n */\nstatic void us901_test9(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_2_client_method(), 0);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. This should succeed.\n */\nstatic void us901_test10(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('N');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the implicit cert\n * chain. This should succeed.\n */\nstatic void us901_test11(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('N');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_IMPLICIT_CERT,\n    US901_IMPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a revoked client certificate to\n * verify CRL checks are working in the TLS layer.\n * This should fail.\n */\nstatic void us901_test12(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('R');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_REVOKED_CERT,\n    US901_REVOKED_KEY,\n    US901_CACERTS,\n    NULL);\n\n    /*\n     * Since the client cert has been revoked the TLS handshake\n     * will fail.  The EST server should return a 401 response.\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n}\n\n/*\n * This test attempts to use a self-signed client certificate to\n * verify cert chain will reject a cert that has not been\n * signed by a valid CA.  This should fail.\n */\nstatic void us901_test13(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_SELFSIGN_CERT,\n    US901_SELFSIGN_KEY,\n    US901_CACERTS,\n    NULL);\n\n    /*\n     * Since the client cert is not signed by either the local CA\n     * or external CA, the TLS handshake will fail.\n     * We will not receive an HTTP status message\n     * from the server.\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n}\n\n/*\n * TLS anonymous cipher suites disabled\n *\n * This test case uses libcurl to test that the\n * EST server will not accept anonymous cipher\n * suites from the client.  We only test a single\n * cipher suite here.  This attempts to do a\n * simple enroll with the server.\n */\nstatic void us901_test14(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC, \"ADH-AES128-SHA256\", NULL,\n            NULL);\n    /*\n     * TLS handshake should have failed, curl should return 0\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * Null HTTP realm when initializing server\n */\nstatic void us901_test15(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL realm\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM,\n            NULL, x, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate when initializing server\n */\nstatic void us901_test16(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *keyin;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL server key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM, \"testrealm\", NULL, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate private key when initializing server\n */\nstatic void us901_test17(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin;\n    X509 *x;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Attempt to init EST server using NULL private key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM, \"testrealm\", x, NULL);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n}\n\n/*\n * Null trusted CA chain when initializing server\n */\nstatic void us901_test18(void) {\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL local CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(NULL, 0, NULL, 0, EST_CERT_FORMAT_PEM, \"testrealm\", x,\n            priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Corrupted CA chain when initializing server\n */\nstatic void us901_test19(void) {\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server a corrupted CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init((unsigned char*) \"Bogus CA chain\", 14,\n            (unsigned char*) \"Bogus CA chain\", 14, EST_CERT_FORMAT_PEM,\n            \"testrealm\", x, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * This test case attempts simple cacerts request using\n * POST instead of GET.  It should fail.\n */\nstatic void us901_test20(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_post(US901_CACERT_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 400);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Valid HTTP authentication credentials are\n * also provided.  This should succeed.\n */\nstatic void us901_test21(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('B');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Invalid HTTP authentication credentials are\n * also provided.  This should fail with a 401 response.\n */\nstatic void us901_test22(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('D');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_BAD,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to enroll without using a certificate\n * to identity the client, while using a good user ID/pwd.\n * However, the EST server is setup to only perform\n * certificate authentication (HTTP auth disabled).\n * This should fail with a 401 response.\n */\nstatic void us901_test23(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server('N');\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD,\n    US901_CACERTS,\n    CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us901_add_suite(void) {\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us901_srv_cacerts\",\n            us901_init_suite,\n            us901_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, \"HTTP Basic Auth\", us901_test1)) ||\n            (NULL == CU_add_test(pSuite, \"HTTP Basic Auth Fail\", us901_test2)) ||\n            (NULL == CU_add_test(pSuite, \"HTTP Digest Auth\", us901_test3)) ||\n            (NULL == CU_add_test(pSuite, \"HTTP Digest Auth Fail\", us901_test4)) ||\n            (NULL == CU_add_test(pSuite, \"Get CA Certificates\", us901_test5)) ||\n            (NULL == CU_add_test(pSuite, \"SSL 3.0 Fail\", us901_test6)) ||\n            (NULL == CU_add_test(pSuite, \"TLS 1.0 Fail\", us901_test7)) ||\n            (NULL == CU_add_test(pSuite, \"TLS 1.1\", us901_test8)) ||\n            (NULL == CU_add_test(pSuite, \"TLS 1.2\", us901_test9)) ||\n            (NULL == CU_add_test(pSuite, \"Certificate auth - explicit cert chain\", us901_test10)) ||\n            (NULL == CU_add_test(pSuite, \"Certificate auth - implicit cert chain\", us901_test11)) ||\n            (NULL == CU_add_test(pSuite, \"Certificate auth - revoked cert\", us901_test12)) ||\n            (NULL == CU_add_test(pSuite, \"Certificate auth - self-signed cert\", us901_test13)) ||\n            (NULL == CU_add_test(pSuite, \"Anon cipher suite disabled\", us901_test14)) ||\n            (NULL == CU_add_test(pSuite, \"NULL Realm\", us901_test15)) ||\n            (NULL == CU_add_test(pSuite, \"NULL server cert\", us901_test16)) ||\n            (NULL == CU_add_test(pSuite, \"NULL server key\", us901_test17)) ||\n            (NULL == CU_add_test(pSuite, \"NULL local CA chain\", us901_test18)) ||\n            (NULL == CU_add_test(pSuite, \"Corrupted local CA chain\", us901_test19)) ||\n            (NULL == CU_add_test(pSuite, \"HTTP POST cacerts\", us901_test20)) ||\n            (NULL == CU_add_test(pSuite, \"SimpleEnroll - good HTTP auth/good Cert\", us901_test21)) ||\n            (NULL == CU_add_test(pSuite, \"SimpleEnroll - bad HTTP auth/good Cert\", us901_test22)) ||\n            (NULL == CU_add_test(pSuite, \"SimpleEnroll - no HTTP auth/no Cert\", us901_test23)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c50bb2d857f8956dbcd5"},"name":"us894.c","system":"LibEST","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca7"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca9"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcaf"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbcac"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca0"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc95"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9b"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbca1"}],["requirement_raw",{"$oid":"5ea8c50ab2d857f8956dbc9d"}]],"contents":"/*------------------------------------------------------------------\n * us894.c - Unit Tests for User Story 894 - Proxy cacerts\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n *\n *  Proxy mode is primarily server mode where the processing of certain\n *  requests from clients are passed long to the upstream server using\n *  client mode functionality.  In the case of Get CACerts, proxy mode\n *  functions almost identically as server mode.  The CA certs response\n *  chain is passed in and is then sent in reply to the Get CACerts\n *  requests from downstream clients.\n *\n *  This test code is taken largely from US901, Server Get CACerts,\n *\n */\n#include <stdio.h>\n#ifndef WIN32\n#include <unistd.h>\n#endif\n#include <est.h>\n#include <curl/curl.h>\n#include \"curl_utils.h\"\n#include \"test_utils.h\"\n#include <openssl/ssl.h>\n#include \"st_server.h\"\n#include \"st_proxy.h\"\n\n#ifdef HAVE_CUNIT\n#include \"CUnit/Basic.h\"\n#include \"CUnit/Automated.h\"\n#endif\n\n#define US894_PKCS10_REQ    \"MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n\"\n#define US894_PKCS10_CT     \"Content-Type: application/pkcs10\" \n#define US894_UIDPWD_GOOD   \"estuser:estpwd\"\n#define US894_UIDPWD_BAD    \"estuser:bogus\"\n#ifndef WIN32\n#define US894_CACERTS       \"CA/estCA/cacert.crt\"\n#define US894_TRUSTED_CERT  \"CA/trustedcerts.crt\"\n#define US894_TRUSTED_CERT_AND_CRL \"US894/trustedcertsandcrl.crt\"\n#define US894_EXPLICIT_CERT \"US894/explicit-cert.pem\" \n#define US894_EXPLICIT_KEY \"US894/explicit-key.pem\"\n#define US894_IMPLICIT_CERT \"US894/implicit-cert.pem\" \n#define US894_IMPLICIT_KEY \"US894/implicit-key.pem\"\n#define US894_REVOKED_CERT \"US894/revoked-cert.pem\" \n#define US894_REVOKED_KEY \"US894/revoked-key.pem\"\n#define US894_SELFSIGN_CERT \"US894/selfsigned-cert.pem\" \n#define US894_SELFSIGN_KEY \"US894/selfsigned-key.pem\"\n#define US894_CACERT \"CA/estCA/cacert.crt\"\n#define US894_EXTCERT \"CA/extCA/cacert.crt\"\n#define US894_SERVER_CERT \"CA/estCA/private/estservercertandkey.pem\"\n#define US894_SERVER_KEY \"CA/estCA/private/estservercertandkey.pem\"\n#define US894_PROXY_CERT \"CA/estCA/private/estservercertandkey.pem\"  // change these other to dedicated ones\n#define US894_PROXY_KEY \"CA/estCA/private/estservercertandkey.pem\"\nstatic char test5_outfile[FILENAME_MAX] = \"US894/test5.crt\";\nstatic char test26_outfile[FILENAME_MAX] = \"US894/test26.crt\";\nstatic char test27_outfile[FILENAME_MAX] = \"US894/test27.crt\";\n#else\n#define US894_CACERTS       \"CA\\\\estCA\\\\cacert.crt\"\n#define US894_TRUSTED_CERT \"CA\\\\trustedcerts.crt\"\n#define US894_TRUSTED_CERT_AND_CRL  \"US894\\\\trustedcertsandcrl.crt\"\n#define US894_EXPLICIT_CERT \"US894\\\\explicit-cert.pem\" \n#define US894_EXPLICIT_KEY \"US894\\\\explicit-key.pem\"\n#define US894_IMPLICIT_CERT \"US894\\\\implicit-cert.pem\" \n#define US894_IMPLICIT_KEY \"US894\\\\implicit-key.pem\"\n#define US894_REVOKED_CERT \"US894\\\\revoked-cert.pem\" \n#define US894_REVOKED_KEY \"US894\\\\revoked-key.pem\"\n#define US894_SELFSIGN_CERT \"US894\\\\selfsigned-cert.pem\" \n#define US894_SELFSIGN_KEY \"US894\\\\selfsigned-key.pem\"\n#define US894_CACERT \"CA\\\\estCA\\\\cacert.crt\"\n#define US894_EXTCERT \"CA\\\\extCA\\\\cacert.crt\"\n#define US894_SERVER_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US894_SERVER_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n#define US894_PROXY_CERT \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"  // change these other to dedicated ones\n#define US894_PROXY_KEY \"CA\\\\estCA\\\\private\\\\estservercertandkey.pem\"\n\nstatic char test5_outfile[FILENAME_MAX] = \"US894\\\\test5.crt\";\nstatic char test26_outfile[FILENAME_MAX] = \"US894\\\\test26.crt\";\nstatic char test27_outfile[FILENAME_MAX] = \"US894\\\\test27.crt\";\n#endif\n\n/* #define US894_TCP_SERVER_PORT_BASIC     12894 */\n#define US894_ENROLL_URL \"https://127.0.0.1:16894/.well-known/est/simpleenroll\"\n#define US894_CACERT_URL \"https://127.0.0.1:16894/.well-known/est/cacerts\"\n/* #define US894_TCP_SERVER_PORT_DIGEST    13894 */\n/* #define US894_TCP_SERVER_PORT_HTTP_DISABLE 14894 */\n#define US894_TCP_SERVER_PORT       15894\n#define US894_TCP_PROXY_PORT        16894\n\nstatic void us894_clean (void)\n{\n    char cmd[200];\n#ifndef WIN32\n    sprintf(cmd, \"rm %s\", test5_outfile);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", test26_outfile);\n    system(cmd);\n    sprintf(cmd, \"rm %s\", test27_outfile);\n    system(cmd);\n#else\n    sprintf(cmd, \"del %s\", test5_outfile);\n    system(cmd);\n    sprintf(cmd, \"del %s\", test26_outfile);\n    system(cmd);\n    sprintf(cmd, \"del %s\", test27_outfile);\n    system(cmd);\n#endif\n}\n\nint us894_start_server ()\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US894_TCP_SERVER_PORT,\n                  US894_SERVER_CERT,\n                  US894_SERVER_KEY,\n                  \"estrealm\",\n                  US894_CACERT,\n                  US894_TRUSTED_CERT,\n                  \"US894/estExampleCA.cnf\",\n                  0,  // manual enroll\n                  0,  // disable PoP\n                  0); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        \"estrealm\",\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us894_init_suite (void)\n{\n    int rv;\n\n    us894_clean();\n\n    printf(\"\\nStarting EST Proxy Get CACerts unit tests.\\n\");\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us894_start_server();\n\n    return rv;\n}\n\nvoid us894_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us894_destroy_suite (void)\n{\n    us894_stop_server();\n    printf(\"Completed EST Proxy Get CACerts unit tests.\\n\");\n    return 0;\n}\n\n/*\n * HTTP Basic auth\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST proxy/server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n */\nstatic void us894_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * HTTP Basic Auth failure, Bad Password\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST proxy/server,\n * while using a bogus password.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n */\nstatic void us894_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * HTTP Digest Auth\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST proxy/server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n *\n * This test also tests the correct operation of est_proxy_set_auth()\n */\nstatic void us894_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_set_auth(AUTH_DIGEST);\n    SLEEP(1);\n\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_DIGEST,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n\n    st_proxy_set_auth(AUTH_BASIC);\n}\n\n/*\n * HTTP Digest Auth fail\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST proxy/server.\n * This is the negative test case for Digest auth.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST proxy/server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us894_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_set_auth(AUTH_DIGEST);\n    SLEEP(1);\n\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_DIGEST,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 401);\n\n    st_proxy_set_auth(AUTH_BASIC);\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\n/*\n * This test case does a simple cacerts request\n * and looks for the HTTP 200 response code.\n */\nstatic void us894_test5 (void)\n{\n    long rv;\n    char cmd[200];\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(\n        cmd,\n        \"openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs\",\n        test5_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n}\n\nstatic void us894_test_sslversion (const SSL_METHOD *m, int expect_fail)\n{\n    BIO *conn;\n    SSL *ssl;\n    SSL_CTX *ssl_ctx = NULL;\n    int rv;\n\n    ssl_ctx = SSL_CTX_new(m);\n    CU_ASSERT(ssl_ctx != NULL);\n\n    /*\n     * Now that the SSL context is ready, open a socket\n     * with the server and bind that socket to the context.\n     */\n    conn = open_tcp_socket_ipv4(\"127.0.0.1\", \"16894\");\n    CU_ASSERT(conn != NULL);\n\n    /*\n     * Create an SSL session context\n     */\n    ssl = SSL_new(ssl_ctx);\n    SSL_set_bio(ssl, conn, conn);\n\n    /*\n     * Now that we have everything ready, let's initiate the TLS\n     * handshake.\n     */\n    rv = SSL_connect(ssl);\n    if (!expect_fail) {\n        CU_ASSERT(rv > 0);\n    } else {\n        CU_ASSERT(rv <= 0);\n    }\n\n    /*\n     * Cleanup all the data\n     */\n    SSL_shutdown(ssl);\n    SSL_free(ssl);\n    SSL_CTX_free(ssl_ctx);\n\n}\n\n/*\n * This test attempts to create a SSL 3.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us894_test6 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(SSLv3_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us894_test7 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.1 connection\n * with the EST server.  This should succeed.\n */\nstatic void us894_test8 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_1_client_method(), 0);\n}\n\n/*\n * This test attempts to create a TLS 1.2 connection\n * with the EST server.  This should succeed.\n */\nstatic void us894_test9 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_2_client_method(), 0);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. This should succeed.\n */\nstatic void us894_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_EXPLICIT_CERT,\n    US894_EXPLICIT_KEY,\n    US894_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentication is working.\n * The certificate used is signed by the implicit cert\n * chain. This should succeed.\n */\nstatic void us894_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_IMPLICIT_CERT,\n    US894_IMPLICIT_KEY,\n    US894_CACERTS, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n}\n\n/*\n * This test attempts to use a revoked client certificate to\n * verify CRL checks are working in the TLS layer.\n * This should fail.\n */\nstatic void us894_test12 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_stop();\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        \"estrealm\",\n                        US894_CACERT,\n                        US894_TRUSTED_CERT_AND_CRL,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_REVOKED_CERT,\n    US894_REVOKED_KEY,\n    US894_CACERTS,\n    NULL);\n\n\n    /*\n     * Since the client cert has been revoked the TLS handshake\n     * will fail.  The EST server should return a 401 response.\n     */\n    CU_ASSERT(rv == 0);\n\n    st_proxy_stop();\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        \"estrealm\",\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n}\n\n/*\n * This test attempts to use a self-signed client certificate to\n * verify cert chain will reject a cert that has not been\n * signed by a valid CA.  This should fail.\n */\nstatic void us894_test13 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_SELFSIGN_CERT,\n    US894_SELFSIGN_KEY,\n    US894_CACERTS, NULL);\n\n    /*\n     * Since the client cert is not signed by either the local CA\n     * or external CA, the TLS handshake will fail.\n     * We will not receive an HTTP status message\n     * from the server.\n     */\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * TLS anonymous cipher suites disabled\n *\n * This test case uses libcurl to test that the\n * EST server will not accept anonymous cipher\n * suites from the client.  We only test a single\n * cipher suite here.  This attempts to do a\n * simple enroll with the server.\n */\nstatic void us894_test14 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        \"ADH-AES128-SHA256\", NULL, NULL);\n    /*\n     * TLS handshake should have failed, curl should return 0\n     */\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Null HTTP realm when initializing server\n */\nstatic void us894_test15 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL realm\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         NULL,\n                         x,\n                         priv_key,\n                         \"estuser\",\n                         \"estpwd\");\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate when initializing server\n */\nstatic void us894_test16 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *keyin;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL server key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         \"testrealm\",\n                         NULL,\n                         priv_key,\n                         \"estuser\",\n                         \"estpwd\");\n    CU_ASSERT(ctx == NULL);\n\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate private key when initializing server\n */\nstatic void us894_test17 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin;\n    X509 *x;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Attempt to init EST proxy using NULL private key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         \"testrealm\",\n                         x,\n                         NULL,\n                         \"estuser\",\n                         \"estpwd\");\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n}\n\n/*\n * Null trusted CA chain when initializing server\n */\nstatic void us894_test18 (void)\n{\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL local CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(NULL,\n                         0,\n                         NULL,\n                         0,\n                         EST_CERT_FORMAT_PEM,\n                         \"testrealm\",\n                         x,\n                         priv_key,\n                         \"estuser\",\n                         \"estpwd\");\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Corrupted CA chain when initializing server\n */\nstatic void us894_test19 (void)\n{\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy a corrupted CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init((unsigned char*) \"Bogus CA chain\",\n                         14,\n                         (unsigned char*) \"Bogus CA chain\",\n                         14,\n                         EST_CERT_FORMAT_PEM,\n                         \"testrealm\",\n                         x,\n                         priv_key,\n                         \"estuser\",\n                         \"estpwd\");\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * This test case attempts simple cacerts request using\n * POST instead of GET.  It should fail.\n */\nstatic void us894_test20 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, \"w\");\n    rv = curl_http_post(US894_CACERT_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Valid HTTP authentication credentials are\n * also provided.  This should succeed.\n */\nstatic void us894_test21 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US894_ENROLL_URL,\n                                US894_PKCS10_CT,\n                                US894_PKCS10_REQ,\n                                US894_UIDPWD_GOOD,\n                                US894_EXPLICIT_CERT,\n                                US894_EXPLICIT_KEY,\n                                US894_CACERTS, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Invalid HTTP authentication credentials are\n * also provided.  This should fail with a 401 response.\n */\nstatic void us894_test22 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US894_ENROLL_URL,\n                                US894_PKCS10_CT,\n                                US894_PKCS10_REQ,\n                                US894_UIDPWD_BAD,\n                                US894_EXPLICIT_CERT,\n                                US894_EXPLICIT_KEY,\n                                US894_CACERTS,\n                                NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * This test attempts to enroll without using a certificate\n * to identity the client, while using a good user ID/pwd.\n * However, the EST server is setup to only perform\n * certificate authentication (HTTP auth disabled).\n * This should fail with a 401 response.\n */\nstatic void us894_test23 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL,\n                        US894_PKCS10_CT,\n                        US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD,\n                        US894_CACERTS,\n                        CURLAUTH_BASIC,\n                        NULL,\n                        NULL,\n                        NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(\"Could not set HTTP authentication callback\\n\");\n        return;\n    }\n\n}\n\n/*\n * Test the parameters of est_proxy_set_server()\n */\nstatic void us894_test24 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in proxy mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(\n        cacerts,\n        cacerts_len,\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        \"testrealm\",\n        x,\n        priv_key,\n        \"estuser\",\n        \"estpwd\");\n\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_proxy_set_server(NULL, \"127.0.0.1\", 8080);\n    CU_ASSERT(est_rv == EST_ERR_NO_CTX);\n\n    est_rv = est_proxy_set_server(ctx, NULL, 8080);\n    CU_ASSERT(est_rv == EST_ERR_INVALID_SERVER_NAME);\n\n    est_rv = est_proxy_set_server(ctx, \"127.0.0.1\", 65536);\n    CU_ASSERT(est_rv == EST_ERR_INVALID_PORT_NUM);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Test the parameters of est_proxy_set_auth_mode()\n */\nstatic void us894_test25 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in proxy mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         \"testrealm\",\n                         x,\n                         priv_key,\n                         \"estuser\",\n                         \"estpwd\");\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_NONE);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_proxy_set_auth_mode(ctx, 0xffffffff);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n\n    est_rv = est_proxy_set_auth_mode(NULL, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NO_CTX);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Test the optional setting of the CA Certs response chain in est_proxy_init()\n * test passthrough (cache disabled) mode of the CA Certs response chain.\n */\nstatic void us894_test26 (void)\n{\n    long rv;\n    char cmd[200];\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_stop();\n    SLEEP(1);\n\n    /*\n     * restart the proxy without passing the ca certs response change parameter\n     * param 5\n     */\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        \"estrealm\",\n                        NULL,\n                        US894_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n\n    outfile = fopen(test26_outfile, \"w\");\n    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(\n        cmd,\n        \"openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs\",\n        test26_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * restart the proxy and include the CA Cert response chain\n     */\n    st_proxy_stop();\n    SLEEP(1);\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        \"estrealm\",\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        \"estuser\",\n                        \"estpwd\",\n                        \"127.0.0.1\",\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n}\n\n/*\n * Test the passing of bad userid/password values to est_proxy_init to make sure\n * they're error checked.\n */\nstatic void us894_test27 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &cacerts);\n    CU_ASSERT(cacerts_len > 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv > 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv > 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL userid\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(\n        cacerts,\n        cacerts_len,\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        \"estrealm\",\n        x,\n        priv_key,\n        NULL,\n        \"estpwd\");\n\n    CU_ASSERT(ctx == NULL);\n\n    ctx =\n            est_proxy_init(\n                cacerts,\n                cacerts_len,\n                cacerts,\n                cacerts_len,\n                EST_CERT_FORMAT_PEM,\n                \"estrealm\",\n                x,\n                priv_key,\n                \"bad_userid_too_long_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n                \"estpwd\");\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us894_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(\"us894_proxy_cacerts\",\n            us894_init_suite,\n            us894_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, \"HTTP Basic Auth\", us894_test1)) ||\n        (NULL == CU_add_test(pSuite, \"HTTP Basic Auth Fail\", us894_test2)) ||\n        (NULL == CU_add_test(pSuite, \"HTTP Digest Auth\", us894_test3)) ||\n        (NULL == CU_add_test(pSuite, \"HTTP Digest Auth Fail\", us894_test4)) ||\n        (NULL == CU_add_test(pSuite, \"Get CA Certificates\", us894_test5)) ||\n        (NULL == CU_add_test(pSuite, \"SSL 3.0 Fail\", us894_test6)) ||\n        (NULL == CU_add_test(pSuite, \"TLS 1.0 Fail\", us894_test7)) ||\n        (NULL == CU_add_test(pSuite, \"TLS 1.1\", us894_test8)) ||\n        (NULL == CU_add_test(pSuite, \"TLS 1.2\", us894_test9)) ||\n        (NULL == CU_add_test(pSuite, \"Certificate auth - explicit cert chain\", us894_test10)) ||\n        (NULL == CU_add_test(pSuite, \"Certificate auth - implicit cert chain\", us894_test11)) ||\n        (NULL == CU_add_test(pSuite, \"Certificate auth - revoked cert\", us894_test12)) ||\n        (NULL == CU_add_test(pSuite, \"Certificate auth - self-signed cert\", us894_test13)) ||\n        (NULL == CU_add_test(pSuite, \"Anon cipher suite disabled\", us894_test14)) ||\n        (NULL == CU_add_test(pSuite, \"NULL Realm\", us894_test15)) ||\n        (NULL == CU_add_test(pSuite, \"NULL server cert\", us894_test16)) ||\n        (NULL == CU_add_test(pSuite, \"NULL server key\", us894_test17)) ||\n        (NULL == CU_add_test(pSuite, \"NULL local CA chain\", us894_test18)) ||\n        (NULL == CU_add_test(pSuite, \"Corrupted local CA chain\", us894_test19)) ||\n        (NULL == CU_add_test(pSuite, \"HTTP POST cacerts\", us894_test20)) ||\n        (NULL == CU_add_test(pSuite, \"SimpleEnroll - good HTTP auth/good Cert\", us894_test21)) ||\n        (NULL == CU_add_test(pSuite, \"SimpleEnroll - bad HTTP auth/good Cert\", us894_test22)) ||\n        (NULL == CU_add_test(pSuite, \"SimpleEnroll - no HTTP auth/no Cert\", us894_test23)) ||\n        (NULL == CU_add_test(pSuite, \"Set Server Invalid parameters\", us894_test24)) ||\n        (NULL == CU_add_test(pSuite, \"Set Auth Mode Invalid parameters\", us894_test25)) ||\n        (NULL == CU_add_test(pSuite, \"Optional CA Chain Response\", us894_test26)) ||\n        (NULL == CU_add_test(pSuite, \"Bad userid/password for proxy init\", us894_test27)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n\n    return CUE_SUCCESS;\n#endif\n}\n\n"}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd31"},"name":"TC141","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcd8"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdb"}]],"contents":"Test case: Establish Trace  (2.1.1)(2.2.1) Preconditions Subscriber is registered Steps Subscriber establishes a trace between a UML artifact and a requirement. Postconditions A trace is established between the UML artifact and the requirement."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd32"},"name":"TC142","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdb"}]],"contents":"Test case: Non-registered subscriber attempts to establish a trace (2.1.1) Preconditions The proposed Subscriber is not registered Steps Subscriber attempts to establish a trace between a UML artifact and a requirement. Postconditions No trace is established between the UML artifact and the requirement."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd33"},"name":"TC143","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcd9"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcda"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdc"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce2"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1d"}]],"contents":"Test case: Subscriber registers with subscriber manager (2.1.3)(2.2.2)(3.2.2?)(2.1.2?) Preconditions The subscriber is a valid subscriber At least one valid subscriber manager is in the system Steps The subscriber registers itself with the subscriber manager. Postconditions The subscriber is registered under the subscriber manager."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd34"},"name":"TC144","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcda"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdc"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce2"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1d"}]],"contents":"Test case: Subscriber fails to register with subscriber manager (2.1.3)(2.2.2)(3.2.2?) Preconditions The subscriber is a valid subscriber Steps The subscriber attempts to exit from the registration process without registering itself under a subscriber manager. Postconditions The subscriber is removed from the system."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd35"},"name":"TC145","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdd"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd29"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}]],"contents":"Test case: Delete subscriptions (2.2.3) Preconditions At least one subscription has been established in the system Steps The user deletes the subscription Postconditions The subscription has been deleted."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd36"},"name":"TC146","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcde"}]],"contents":"\"Test case: Subscriber Manager registers with event server (3.1.1) Preconditions A subscriber manager has been created. Steps The subscriber manager registers its IP address  port  and name with the event server Post conditions The subscriber manager is registered with the event server. \""}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd37"},"name":"TC147","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcdf"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2e"}]],"contents":"Test case: An event is published in real time (3.1.2) Preconditions: At least one subscriber manager is online at its designated IP address and port. The subscriber manager has subscribed to at least one requirement. Steps The requirement changes. An event notification is sent to the relevant subscriber manager. Postconditions:"}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd38"},"name":"TC148","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce0"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}]],"contents":"Test case: Subscriber Manager comes online and checks for missed events (3.1.3) Preconditions: The subscriber manager is off line. The event server has stored an event notification that was not previously delivered to the subscriber manager. Steps: The subscriber manager comes online. Post conditions: The subscriber manager has successfully downloaded the relevant event notifications from the event server."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd39"},"name":"TC149","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce1"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce3"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce4"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd02"}]],"contents":"Test case: Subscriber manager receives non-speculative event notification (3.2.1)(3.2.3)(3.3.1) Preconditions: The subscriber manager has registered subscribers Steps An event notification is sent to the subscriber manager for a registered subscriber. The relevant subscriber manager receives the event notification. Postconditions: The event notification message is stored in the local event log."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3a"},"name":"TC150","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce1"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce3"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2e"}]],"contents":"Test case: Subscriber manager receives speculative event notification (3.2.1)(3.2.3) Preconditions: The subscriber manager has registered subscribers Steps An event notification is sent to the subscriber manager for a registered subscriber. The relevant subscriber manager receives the event notification. Postconditions: The event notification message is processed according to predefined protocols."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3b"},"name":"TC151","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce5"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd19"}]],"contents":"Test case: User constructs a speculative query (3.4.1) Preconditions: At least one performance model has been built. Requirements and constraints have been defined for this performance model. Steps: The user constructs a speculative query using a GUI tool. Postconditions: A speculative event message is received by the event server."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3c"},"name":"TC152","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce6"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce7"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce8"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fce9"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd26"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd29"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fcff"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd30"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd06"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd02"}]],"contents":"\"Test case: Speculative event message is processed by subscriber manager (3.4.2)(3.4.3)(3.4.4)(3.4.5) Preconditions: A speculative query has been issued and sent to the relevant subscriber manager. Steps: The subscriber manager receives the speculative event message. The subscriber manager parses the event message to determine that it is a speculative event. The subscriber manager injects values into the relevant performance model  re-executes the model  collates the results  restores the model to its prior state  and returns the results. Postconditions A response is sent to the speculative event. The performance model is restored to its original state\""}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3d"},"name":"TC153","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fceb"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd24"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Add New Requirement (4.1.)(4.1.1) Preconditions: The trigger driver is running. Steps The user specifies a new event. The user adds a new requirement Post conditions: A new event message is sent."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3e"},"name":"TC154","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcec"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Decompose a Requirement (4.1)(4.1.2) Preconditions: The trigger driver is running. At least one requirement is defined. Steps The user specifies a decompose event. The user selects an existing requirement and decomposes it into two or more requirements. Post conditions: The requirement is decomposed into two or more events. A decompose event message is sent. Temporary links are established between the original requirement and its decomposed parts."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd3f"},"name":"TC155","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fced"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2d"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Refine a requirement (4.1)(4.1.3) Preconditions: The trigger driver is running. At least one requirement is defined. Steps The user specifies a refine event. The user selects an existing requirement and adds an additional requirement related to it. Post conditions: The requirement is refined by adding at least one related requirement. A refine event message is sent. Temporary links are established between the original requirement and its refinements."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd40"},"name":"TC156","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcee"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0d"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Modify a requirement (4.1)(4.1.4) Preconditions: The trigger driver is running. At least one requirement is defined Steps The user specifies a modify event. The user selects an existing requirement and changes it. Post conditions: The requirement is changed. A modify event message is sent. Existing links from the original requirement are changed to tentative status."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd41"},"name":"TC157","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcef"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Delete a requirement (4.1)(4.1.5) Preconditions: The trigger driver is running. At least one requirement is defined Steps The user specifies a delete event. The user selects an existing requirement and deletes it. Post conditions: The status of the requirement is set to obsolete. A delete event message is sent. Existing links from the obsolete requirement are set to tentative status."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd42"},"name":"TC158","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcea"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf0"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd17"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd03"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0c"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd16"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2a"}]],"contents":"Test case: Merge two or more requirements (4.1)(4.1.6) Preconditions: The trigger driver is running. At least two requirements are defined Steps The user specifies a merge event. The user specifies two or more requirements to merge. Post conditions: The requirements are merged. A merge event message is sent. Existing links from the original requirements are assigned to the newly merged requirement."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd43"},"name":"TC159","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf1"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf2"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf4"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd05"}]],"contents":"Test case: Event server receives message (5.1)(5.2)(5.4) Preconditions: The event server is running and waiting for incoming events at a well known port and IP address. The event trigger issues an event message. Steps The event server receives an event message. The event server parses the event message into its constituent parts. The event server categorizes each event according to whether it is speculative or evolutionary. The event server stores event details in its event log. Post conditions: The event is stored in the log. The event is categorized according to whether it is evolutionary or speculative."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd44"},"name":"TC160","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf3"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd29"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2e"}]],"contents":"Test case: Event server identifies subscribers (5.3) Preconditions: The event server has received an event message. Steps: The event server identifies the impacted requirements from the received event message. The event server searches for subscribers to those impacted requirements. Post conditions All relevant subscribers are identified."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd45"},"name":"TC161","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf5"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd2e"}]],"contents":"Test case: Notify subscribers when an evolutionary event occurs  (5.5) Preconditions: The event server has received an evolutionary event message. The event server has identified a list of subscribers. Steps: The event server identifies the subscriber manager for each subscriber. The event server identifies the IP address and port for each relevant subscriber manager. The event server builds a notification event message and sends it to each relevant subscriber manager. Postconditions: The event message is received by each relevant subscriber manager or behalf of its managed subscribers."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd46"},"name":"TC162","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf6"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf7"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf8"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcf9"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfa"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd29"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fcff"}]],"contents":"\"Test case: Event server constructs composite event message for a speculate event (5.6)(5.6.1)(5.6.2)(5.6.3)(5.6.4) Preconditions: The event server has received a speculative event message. The event server has identified a list of subscribers. Steps: For each identified subscriber the event server identifies all additional requirements that are linked to the same artifact. The event server polls DOORS to obtain additional quantitative information for each of these additional requirements. The event server constructs a composite event message that includes the requirement that has changed  plus quantitative constraints obtained from other related requirements. The customized event message is sent to the relevant subscriber. \""}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd47"},"name":"TC163","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfb"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0f"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd21"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1d"}]],"contents":"Test case: Events are displayed in the order in which they are received.(6.1) Preconditions: At least three event messages received for a single artifact. Steps: The user activates the notification process tool. The user selects the artifact. Event messages are displayed in the order in which they were received. Postconditions: none"}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd48"},"name":"TC164","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfb"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0f"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd21"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd1d"}]],"contents":"Test case: User attempts to process an event message in the incorrect order (6.1) Preconditions: At least three event messages have been received by a subscriber manager on behalf of a single subscriber. The notification processing tool is running. Steps: The user examines the event messages that have been received for a single subscriber. The user tries to process an event other than the first one received. The system prohibits the user from processing the events in the incorrect order. Post conditions No events are processed."}
{"_id":{"$oid":"5ea8c55e2b8dd33caf44fd49"},"name":"TC165","system":"EBT","applied_transformations":[],"ground_truth":[["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfc"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfd"}],["requirement_raw",{"$oid":"5ea8c55e2b8dd33caf44fcfe"}],["source_raw",{"$oid":"5ea8c55e2b8dd33caf44fd0b"}]],"contents":"\"Test case: User processes an event message (6.2)(6.3)(6.4) Preconditions: Event messages are displayed for a single artifact. Steps: The user examines the first event message. The user applies any information from the event message to update the artifact accordingly. The user selects which of the tentative links should be made permanent and which ones should be discarded. Postconditions: The links in the event server are changed according to the users directions. Any additional event messages that had previously been sent on the basis of a tentative link  and for which the tentative link has now been eliminated  are removed from the event processing list and display.\""}
