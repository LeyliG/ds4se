---

title: Conventional Preprocessing

keywords: fastai
sidebar: home_sidebar

summary: "This module comprises preprocessing techniques applied to software artifacts (TODO:cite here the papers employed for this preprocessings):"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/11_mgmnt.prep.conv.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span> pip install dit
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="ch">#! pip install nltk</span>
<span class="n">nltk</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="s1">&#39;stopwords&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">nltk.stem.snowball</span> <span class="k">import</span> <span class="n">SnowballStemmer</span>
<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">punctuation</span>
<span class="kn">import</span> <span class="nn">csv</span>

<span class="kn">from</span> <span class="nn">nltk.stem.snowball</span> <span class="k">import</span> <span class="n">SnowballStemmer</span>
<span class="n">englishStemmer</span><span class="o">=</span><span class="n">SnowballStemmer</span><span class="p">(</span><span class="s2">&quot;english&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Implementing the Skip-Gram Model</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras.preprocessing</span> <span class="k">import</span> <span class="n">text</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dict_filenames</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#creating the function</span>
<span class="c1">#base_dir = os.path.abspath(os.getcwd())</span>
<span class="n">test_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;test_data/LibEST_semeru_format/test&#39;</span><span class="p">)</span>
<span class="c1">#path = os.path.join(base_dir, test_dir)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#reading all files in a folder</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span> <span class="s1">&#39;*.txt&#39;</span><span class="p">)):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># open in readonly mode</span>
        <span class="n">dict_filenames</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()]</span>      
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">test_dir</span><span class="p">)]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#reading all files in a folder</span>
<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">test_dir</span><span class="p">)]:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># open in readonly mode</span>
        <span class="n">dict_filenames</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()]</span>    
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="s1">&#39;test_data/LibEST_semeru_format/requirements/RQ17.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;-pre.txt&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dict_filenames</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;test_data/LibEST_semeru_format/test/us903.c&#39;: [&#39;/*------------------------------------------------------------------\n * us903.c - Unit Tests for User Story 903 - Server simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#ifndef WIN32\nstatic char test5_outfile[FILENAME_MAX] = &#34;US903/test5.hdr&#34;;\n#define US903_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US903_EXPLICIT_CERT &#34;US903/cert-RA.pem&#34; \n#define US903_EXPLICIT_KEY  &#34;US903/key-RA.pem&#34;\n#define US903_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US903_TRUSTED_CERT  &#34;CA/trustedcerts.crt&#34;\n#define US903_SERVER_CERT_AND_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\nstatic char test5_outfile[FILENAME_MAX] = &#34;US903\\\\test5.hdr&#34;;\n#define US903_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US903_EXPLICIT_CERT &#34;US903\\\\cert-RA.pem&#34; \n#define US903_EXPLICIT_KEY  &#34;US903\\\\key-RA.pem&#34;\n#define US903_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US903_TRUSTED_CERT  &#34;CA\\\\trustedcerts.crt&#34;\n#define US903_SERVER_CERT_AND_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US903_RETRY_INTERVAL    3600\n#define US903_TCP_PORT      29001\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US903_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US903_PKCS10_DSA1024 &#34;MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US903_PKCS10_ECDSA256 &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n#define US903_PKCS10_CORRUPT &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US903_PKCS10_STALE_POP &#34;MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=&#34;\n\n#define US903_ENROLL_URL_BA &#34;https://127.0.0.1:29001/.well-known/est/simpleenroll&#34;\n#define US903_PKCS10_CT     &#34;Content-Type: application/pkcs10&#34; \n#define US903_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\nstatic void us903_clean (void)\n{\n}\n\nstatic int us903_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US903_TCP_PORT,\n                  US903_SERVER_CERT_AND_KEY,\n                  US903_SERVER_CERT_AND_KEY,\n                  &#34;US903 test realm&#34;,\n                  US903_CACERTS,\n                  US903_TRUSTED_CERT,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  0,\n                  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us903_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US903_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us903_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us903_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us903_destory_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple enroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * enrollment of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n    US903_PKCS10_RSA2048,\n    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - EC prime 256\n *\n * This test case uses libcurl to test simple\n * enrollment of a 256 bit EC CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_ECDSA256,US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - DSA prime 1024\n *\n * This test case uses libcurl to test simple\n * enrollment of a 1024 bit DSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_DSA1024, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - Corrupted PKCS10\n *\n * This test case uses libcurl to test simple\n * enrollment usinga corrupted CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us903_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_CORRUPT, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since the CSR is not valid, the server should\n     * respond with a 400.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - manual enrollment\n *\n * This test case verifies the server is\n * sending the appropriate retry-after response.\n */\nstatic void us903_test5 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server with manual enrollment enabled */\n    us903_start_server(1, 0);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, &amp;write_func);\n    fclose(outfile);\n\n    /*\n     * Since the server hasn\&#39;t seen this CSR in the past,\n     * it should respond with a retry-after 202 response.\n     */\n    CU_ASSERT(rv == 202);\n\n    /*\n     * Verify the retry-after value\n     */\n    rv = grep(test5_outfile, &#34;Retry-After: 3600&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We will avoid waiting the full retry period since we\&#39;re\n     * only simulating manual enrollment.  Wait a second and then\n     * try to enroll the cert again.\n     */\n    SLEEP(1);\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n\n    /*\n     * This enrollment request should succeed this time\n     * Our simulated manual enrollment will automatically\n     * enroll on the second attempt.\n     */\n    CU_ASSERT(rv == 200);\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server with manual enrollment disabled */\n    us903_start_server(0, 0);\n}\n\n/*\n * Simple enroll - PoP check fails with curl\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  Since curl does not\n * set the PoP, the EST enrollment should fail.\n */\nstatic void us903_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Send a valid enroll request using curl.  Curl does not\n     * include the PoP\n     */\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n                        US903_PKCS10_RSA2048, US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n\n    /*\n     * The server should respond with a failure code\n     */\n    CU_ASSERT(rv == 400);\n\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP check succeeds with estclient\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  We use\n * estclient since it supports the PoP.\n */\nstatic void us903_test7 (void)\n{\n    long rv;\n    EST_CTX *c_ctx;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len;\n    unsigned char *attr_data;\n    int attr_len;\n    int http_status;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This test case requires PoP to be enabled\n     */\n    st_enable_pop();\n\n    /*\n     * Create a client context\n     */\n    c_ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(c_ctx != NULL);\n    if (!c_ctx) {\n        return;\n    }\n\n    /*\n     * Specify user ID and password since the server is running\n     * in Basic Authentication mode.\n     */\n    rv = est_client_set_auth(c_ctx, &#34;estuser&#34;, &#34;estpwd&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    est_client_set_server(c_ctx, &#34;127.0.0.1&#34;, US903_TCP_PORT, NULL);\n\n    /*\n     * get a keypair to be used in the enroll.\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(c_ctx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll a CSR\n     */\n    rv = est_client_enroll(c_ctx, &#34;US903-test7 CN&#34;, &amp;pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Check HTTP status code received from server is 200\n     */\n    http_status = est_client_get_last_http_status(c_ctx);\n    CU_ASSERT(http_status == 200);\n\n    /*\n     * Client library has obtained the new client certificate.\n     * Now retrieve it from the library.\n     */\n    pkcs7 = malloc(pkcs7_len);\n    if (!pkcs7) {\n        return;\n    }\n    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Clean up\n     */\n    est_destroy(c_ctx);\n    EVP_PKEY_free(new_pkey);\n    free(pkcs7);\n\n    /*\n     * Disable PoP for future test cases\n     */\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - Use a non-default ECDHE curve\n *\n * This test case verifies the est_server_set_ecdhe_curve()\n * function is working.\n */\nstatic void us903_test8 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    st_stop();\n\n    /* Restart the server using the secp384r1 curve  */\n    us903_start_server(0, NID_secp384r1);\n\n    rv = curl_http_post(\n        US903_ENROLL_URL_BA,\n        US903_PKCS10_CT,\n        US903_PKCS10_RSA2048,\n        US903_UIDPWD_GOOD,\n        US903_CACERTS,\n        CURLAUTH_BASIC,\n        &#34;ECDHE-ECDSA-AES256-GCM-SHA384&#34;,\n        NULL,\n        NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 valid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes a valid PoP even when\n * the server didn\&#39;t request it.  We have to use\n * CiscoEST as the client to generate a CSR containing\n * a valid PoP.  There\&#39;s no way to include a valid PoP\n * using Curl since the TLS channel binding information\n * is not known in advance.\n */\n//The following include should never be used by an application\n//be we use it here to hack the EST_CTX values mid-way\n//through this test\n#include &#34;../../src/est/est_locl.h&#34;\nstatic void us903_test9 (void)\n{\n    EST_CTX *ctx;\n    int rv;\n    unsigned char *cacerts;\n    int caclen = 0;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len = 0;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    /*\n     * Read in the CA certs\n     */\n    caclen = read_binary_file(US903_CACERTS, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Init the client context\n     */\n    ctx = est_client_init(\n        cacerts,\n        caclen,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    /*\n     * We\&#39;ll use simple HTTP auth to identify ourselves\n     */\n    rv = est_client_set_auth(ctx, &#34;estuser&#34;, &#34;estpwd&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_client_set_server(ctx, &#34;127.0.0.1&#34;, US903_TCP_PORT, NULL);\n\n    /*\n     * Create some space to hold the cert and generate\n     * a private key\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(ctx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll\n     */\n    ctx-&gt;csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR    \n    rv = est_client_enroll(ctx, &#34;TestCase9&#34;, &amp;pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    pkcs7 = malloc(pkcs7_len);\n    rv = est_client_copy_enrolled_cert(ctx, pkcs7);\n\n    free(pkcs7);\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 invalid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes an invalid PoP even when\n * the server didn\&#39;t request it.\n */\nstatic void us903_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    rv = curl_http_post(US903_ENROLL_URL_BA, US903_PKCS10_CT,\n    US903_PKCS10_STALE_POP,\n    US903_UIDPWD_GOOD, US903_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The enroll request should fail since the PoP was invalid\n     * We expect a 400 response.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - PoP is enabled, the CSR contains a\n *                 invalid PoP, and the client uses\n *                 a cert that contains id-kp-cmcRA.\n *\n * This test case ensures the server disables the PoP\n * check when the client is using a cert that contains\n * id-kp-cmcRA, which indicates the client is an RA.\n */\nstatic void us903_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_enable_pop();\n\n    rv = curl_http_post_certuid(\n    US903_ENROLL_URL_BA,\n    US903_PKCS10_CT,\n    US903_PKCS10_STALE_POP,\n    US903_UIDPWD_GOOD,\n    US903_EXPLICIT_CERT,\n    US903_EXPLICIT_KEY,\n    US903_CACERTS, NULL);\n\n    /*\n     * Even though the PoP value doesn\&#39;t match in this CSR,\n     * the enroll will succeed since the client is using\n     * an RA certificate. We expect a 200 response.\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us903_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us903_srv_simpenroll&#34;,\n            us903_init_suite,\n            us903_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;Enroll RSA cert&#34;, us903_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll ECDSA cert&#34;, us903_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll DSA cert&#34;, us903_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll corrupted ECDSA cert&#34;, us903_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll retry-after manual approval &#34;, us903_test5)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll PoP fail with Curl&#34;, us903_test6)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll PoP succeed with estclient&#34;, us903_test7)) ||\n        (NULL == CU_add_test(pSuite, &#34;Non-default ECDHE curve&#34;, us903_test8)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll w/PoP disabled, CSR includes valid PoP&#34;, us903_test9)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll w/PoP disabled, CSR includes invalid PoP&#34;, us903_test10)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll w/PoP enabled using RA cert, CSR includes invalid PoP&#34;, us903_test11)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us3496.c&#39;: [&#39;/*------------------------------------------------------------------\n * us3496.c - Unit Tests URI path segment extension support \n *\n * March, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &#34;../../util/test_utils.h&#34;\n#include &#34;st_server.h&#34;\n\n#include &#34;../../src/est/est_locl.h&#34;\n\nextern char tst_srvr_path_seg_enroll[];\nextern char tst_srvr_path_seg_auth[];\n\nstatic int path_segment_support;\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server\&#39;s directory\n */\n/* #define CLIENT_UT_CACERT &#34;../../example/server/estCA/cacert.crt&#34; */\n#define CLIENT_UT_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define CLIENT_UT_PUBKEY &#34;./est_client_ut_keypair&#34;\n\n#define US3496_SERVER_PORT   29496\n#define US3496_SERVER_IP    &#34;127.0.0.1&#34;\t\n#define US3496_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n#define US3496_UID           &#34;estuser&#34;\n#define US3496_PWD           &#34;estpwd&#34;\n#ifndef WIN32\n#define US3496_CACERTS\t    &#34;CA/estCA/cacert.crt&#34;\n#define US3496_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US3496_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define US3496_CACERTS\t    &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US3496_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US3496_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us3496_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&amp;logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section); \n}\n#endif\n\n#define US3496_ENROLL_URL_BA &#34;https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll&#34;\n#define US3496_PKCS10_CT\t    &#34;Content-Type: application/pkcs10&#34; \n\n#define US3496_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);\n\nstatic void us3496_clean (void)\n{\n}\n\nstatic int us3496_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US3496_SERVER_PORT, \n\t          US3496_SERVER_CERTKEY,\n\t          US3496_SERVER_CERTKEY,\n\t          &#34;US3496 test realm&#34;,\n\t          US3496_CACERTS,\n\t          US3496_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    \n    SLEEP(1);\n    return rv;\n}\n\nstatic int path_seg_supported(void) {\n\n    EST_CTX *ectx;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, &#34;test_segment&#34;);\n\n    if (rc == EST_ERR_NONE) {\n        return 1;\n    } else {\n        return 0;\n    }\n\n    return 0;\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite. \n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us3496_init_suite (void)\n{\n    int rv = 0;\n   \n    char cmd[EST_UT_MAX_CMD_LEN];    \n    printf(&#34;Starting EST Client/Proxy path segment unit tests.\\n&#34;);\n\n    /*\n     * check to see if path segment support has been compiled in\n     */\n    if (!path_segment_support) {\n        printf(&#34;URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \\n&#34;);\n        return 0;\n    }\n    \n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n             &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;, CLIENT_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n    \n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us3496_clean();    \n    /*\n     * Start an instance of the EST server\n     */\n    rv = us3496_start_server(0, 0);\n    SLEEP(2);\n    \n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3496_destroy_suite (void)\n{\n    \n    st_stop();    \n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n    \n\n\n/*\n * This test case tests the set server with valid parameters,\n * NO path segment\n */\nstatic void us3496_test1 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, NULL);    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is valid\n */\nstatic void us3496_test2 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;somestring&#34;);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that contains 2 segments, should fail\n */\nstatic void us3496_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;somestring1/somestring2&#34;);\n\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * all valid characters\n */\n#define PATH_SEG_ALL_VALID_CHARS &#34;@%50%44%42ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._~!$&amp;\&#39;()*+,;=&#34;\nstatic void us3496_test4 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                             PATH_SEG_ALL_VALID_CHARS);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is invalid. invalid character.\n */\nstatic void us3496_test5 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;someinvalid&lt;string&#34;);\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is too long (129)\n */\n#define path_segment_too_long &#34;123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&#34;\nstatic void us3496_test6 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               path_segment_too_long);\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that is equal to an operation (cacerts)\n */\nstatic void us3496_test7 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;cacerts&#34;);\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that contains an operation (cacerts),\n * in this case it\&#39;s at the front of the string\n */\nstatic void us3496_test8 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;cacerts-server&#34;);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that is the empty string.\n * This should fail.\n */\nstatic void us3496_test9 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               &#34;&#34;);\n    CU_ASSERT(rc == EST_ERR_HTTP_INVALID_PATH_SEGMENT);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down a path segment that contains a \&#39;:\&#39;.\n * This should pass.\n */\nstatic void us3496_test10 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT, &#34;-._~:@!$&amp;\&#39;()*+,;=&#34;);    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * pass down path segment that is too long (129)\n */\n#define path_segment_max &#34;12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678&#34;\nstatic void us3496_test11 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US3496_SERVER_IP, US3496_SERVER_PORT,\n                               path_segment_max);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us3496_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n    \n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us3496_client_proxy_path_seg&#34;, \n\t                  us3496_init_suite, \n\t\t\t  us3496_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n   \n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us3496_logger_stderr);\n#endif\n\n   /*\n    * check to see if path segment support has been compiled in\n    */\n   if (!path_seg_supported()) {\n       printf(&#34;URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \\n&#34;);\n       path_segment_support = 0;\n       return 0;\n   }\n   path_segment_support = 1; \n   \n   if (path_segment_support) {\n       \n       /* add the tests to the suite */\n       /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n       if (\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, no path segment&#34;, us3496_test1)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, valid path segment&#34;, us3496_test2)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, multi segment path segment&#34;, us3496_test3)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, valid path segment - all valid chars&#34;, us3496_test4)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, invalid path segment&#34;, us3496_test5)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment too long&#34;, us3496_test6)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment equals operation string&#34;, us3496_test7)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment contains operation string&#34;, us3496_test8)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment is the empty string&#34;, us3496_test9)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment contains a colon&#34;, us3496_test10)) ||\n           (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters, path segment is the max length&#34;, us3496_test11))\n           ) {\n           CU_error = CU_get_error();\n           printf(&#34;%d\\n&#34;, CU_error);\n           \n           CU_cleanup_registry();\n           printf(&#34;%s\\n&#34;, CU_get_error_msg());\n           return CU_get_error();\n       }\n   }\n   \n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us899.c&#39;: [&#39;/*------------------------------------------------------------------\n * us899.c - Unit Tests for User Story 899 - Client simple enroll \n *\n * September, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US899_SERVER_PORT   29899\n#define US899_SERVER_IP\t    &#34;127.0.0.1&#34;\t\n#define US899_UID\t    &#34;estuser&#34;\n#define US899_PWD\t    &#34;estpwd&#34;\n\n/*\n * The following certs are used for FQDN testing\n */\n#ifndef WIN32\n#define US899_CACERTS\t    &#34;CA/estCA/cacert.crt&#34;\n#define US899_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US899_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n\n#define US899_SERVER_CERT_CN_MISMATCH\t    &#34;US899/cert_cn_mismatch.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH\t    &#34;US899/key_cn_mismatch.pem&#34;\n#define US899_SERVER_CERT_CN_MISMATCH_IP    &#34;US899/cert_cn_mismatch_ip.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH_IP\t    &#34;US899/key_cn_mismatch_ip.pem&#34;\n#define US899_SERVER_CERT_CN_MATCH_WC       &#34;US899/cert_cn_match_wc.pem&#34;\n#define US899_SERVER_KEY_CN_MATCH_WC\t    &#34;US899/key_cn_match_wc.pem&#34;\n#define US899_SERVER_CERT_CN_MISMATCH_WC    &#34;US899/cert_cn_mismatch_wc.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH_WC\t    &#34;US899/key_cn_mismatch_wc.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH\t    &#34;US899/cert_san_match.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH\t    &#34;US899/key_san_match.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH\t    &#34;US899/cert_san_mismatch.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH\t    &#34;US899/key_san_mismatch.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH_IP   &#34;US899/cert_san_mismatch_ip.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH_IP    &#34;US899/key_san_mismatch_ip.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH_IP      &#34;US899/cert_san_match_ip.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH_IP       &#34;US899/key_san_match_ip.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH_WC      &#34;US899/cert_san_match_wc.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH_WC       &#34;US899/key_san_match_wc.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH_WC   &#34;US899/cert_san_mismatch_wc.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH_WC    &#34;US899/key_san_mismatch_wc.pem&#34;\n#else \n#define US899_CACERTS\t    &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US899_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US899_SERVER_CERTKEY   &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n\n#define US899_SERVER_CERT_CN_MISMATCH\t    &#34;US899\\\\cert_cn_mismatch.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH\t    &#34;US899\\\\key_cn_mismatch.pem&#34;\n#define US899_SERVER_CERT_CN_MISMATCH_IP    &#34;US899\\\\cert_cn_mismatch_ip.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH_IP\t    &#34;US899\\\\key_cn_mismatch_ip.pem&#34;\n#define US899_SERVER_CERT_CN_MATCH_WC       &#34;US899\\\\cert_cn_match_wc.pem&#34;\n#define US899_SERVER_KEY_CN_MATCH_WC\t    &#34;US899\\\\key_cn_match_wc.pem&#34;\n#define US899_SERVER_CERT_CN_MISMATCH_WC    &#34;US899\\\\cert_cn_mismatch_wc.pem&#34;\n#define US899_SERVER_KEY_CN_MISMATCH_WC\t    &#34;US899\\\\key_cn_mismatch_wc.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH\t    &#34;US899\\\\cert_san_match.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH\t    &#34;US899\\\\key_san_match.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH\t    &#34;US899\\\\cert_san_mismatch.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH\t    &#34;US899\\\\key_san_mismatch.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH_IP   &#34;US899\\\\cert_san_mismatch_ip.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH_IP    &#34;US899\\\\key_san_mismatch_ip.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH_IP      &#34;US899\\\\cert_san_match_ip.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH_IP       &#34;US899\\\\key_san_match_ip.pem&#34;\n#define US899_SERVER_CERT_SAN_MATCH_WC      &#34;US899\\\\cert_san_match_wc.pem&#34;\n#define US899_SERVER_KEY_SAN_MATCH_WC       &#34;US899\\\\key_san_match_wc.pem&#34;\n#define US899_SERVER_CERT_SAN_MISMATCH_WC   &#34;US899\\\\cert_san_mismatch_wc.pem&#34;\n#define US899_SERVER_KEY_SAN_MISMATCH_WC    &#34;US899\\\\key_san_mismatch_wc.pem&#34;\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us899_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&amp;logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section); \n}\n#endif \n\n\n\n#define US899_VALID_CSR_PEM &#34;-----BEGIN CERTIFICATE REQUEST-----\\nMIIBhDCB7gIBADBFMQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEh\\nMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB\\nAQUAA4GNADCBiQKBgQC13wEG36vBY8Mq+uu80SKvkx0ZCt0lc18kaMSDLwML2IRS\\n+SaCLEZbjJYeSxwZ9qXy4Rt1vFDRRTL57/lQTgT5kzKI2D2YUZ+Dg6wQqx/4t99S\\naCv/lxcUTfIPiaqATUQxeZA+h7Fo0ti9wLSw6AQft9hibYPRJZ6zHa24lXwd7wID\\nAQABoAAwDQYJKoZIhvcNAQEFBQADgYEAjwSjLqFAzoPGa4GKn7AEitepVA+3QjXL\\n45LSzrVJMW4Jl8Ovm/aPatnFRQYm82rVKb7Sq4Ddo9nDJ9tgZ450oqIWbujUmGEU\\nsUUxJSJ3vGXyQy+8NeTy4GmmsNWIwhSKMkqh7YVlBvgkwGoNFuQ8mD90prFmld+J\\nhHBZXCaekrE=\\n-----END CERTIFICATE REQUEST-----&#34;\n\n\n/*\n * Note: this array was generated using:  xdd -i req.der req.c\n */\nstatic unsigned char US899_VALID_CSR_DER[] = {\n  0x30, 0x82, 0x01, 0xa8, 0x30, 0x82, 0x01, 0x11, 0x02, 0x01, 0x00, 0x30,\n  0x68, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,\n  0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,\n  0x02, 0x6e, 0x63, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x07,\n  0x0c, 0x03, 0x73, 0x73, 0x73, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55,\n  0x04, 0x0a, 0x0c, 0x03, 0x64, 0x64, 0x64, 0x31, 0x0d, 0x30, 0x0b, 0x06,\n  0x03, 0x55, 0x04, 0x0b, 0x0c, 0x04, 0x66, 0x6a, 0x6a, 0x64, 0x31, 0x0c,\n  0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x03, 0x31, 0x32, 0x37,\n  0x31, 0x13, 0x30, 0x11, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n  0x01, 0x09, 0x01, 0x16, 0x04, 0x6e, 0x6f, 0x6e, 0x65, 0x30, 0x81, 0x9f,\n  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n  0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81,\n  0x81, 0x00, 0xb9, 0x9f, 0xdd, 0xd0, 0xa4, 0xdf, 0x06, 0x50, 0xf5, 0x4e,\n  0x85, 0x80, 0xeb, 0x2a, 0x1e, 0xff, 0x3c, 0x0f, 0x0d, 0x98, 0x6e, 0xfe,\n  0x08, 0x74, 0xf4, 0xce, 0xf5, 0xfd, 0xf9, 0x2f, 0x86, 0x20, 0xf7, 0xcc,\n  0x08, 0x05, 0xce, 0x98, 0x69, 0x5c, 0x8c, 0xbd, 0x20, 0xa7, 0x28, 0xf7,\n  0xe4, 0x22, 0xfa, 0xaf, 0xe4, 0x15, 0xc4, 0xb9, 0x85, 0xcb, 0x0f, 0x11,\n  0xc6, 0x55, 0x0d, 0x31, 0x5c, 0xfb, 0x5e, 0xcf, 0x8e, 0xd1, 0xde, 0x77,\n  0x15, 0x2c, 0x8c, 0x4e, 0x88, 0x4e, 0x21, 0xb6, 0x69, 0x9c, 0xa7, 0x7d,\n  0x06, 0xc5, 0x75, 0x3f, 0xdc, 0x18, 0xf6, 0x00, 0x51, 0xd5, 0x00, 0x47,\n  0x62, 0xfc, 0x95, 0xc8, 0xd4, 0xef, 0x31, 0x4a, 0xb0, 0x15, 0xa9, 0x50,\n  0x04, 0x6e, 0x13, 0x14, 0xd4, 0xbb, 0x56, 0x22, 0x6f, 0x3b, 0x91, 0xb6,\n  0xeb, 0xba, 0x25, 0x8f, 0x12, 0xea, 0xfd, 0xd4, 0xd0, 0x6d, 0x02, 0x03,\n  0x01, 0x00, 0x01, 0xa0, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,\n  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00,\n  0x3b, 0xa5, 0xb4, 0x97, 0x6c, 0xea, 0xe4, 0x9f, 0xeb, 0x56, 0xca, 0x7a,\n  0x7f, 0xfa, 0x53, 0x8d, 0xee, 0x6f, 0x7e, 0xa1, 0x08, 0x65, 0xe0, 0x05,\n  0x5b, 0x0e, 0x5a, 0x92, 0xdb, 0x3c, 0xc5, 0x6d, 0x0d, 0xcd, 0x2c, 0xcd,\n  0x4d, 0x10, 0x2a, 0x92, 0x78, 0x1d, 0xfb, 0x92, 0x66, 0x33, 0x18, 0xdd,\n  0xf8, 0x78, 0xc5, 0x1a, 0x03, 0xf9, 0x58, 0x9f, 0x32, 0x49, 0xde, 0xd2,\n  0x26, 0x78, 0x80, 0x87, 0x18, 0xf3, 0x6d, 0xc3, 0x35, 0x5d, 0x21, 0x8b,\n  0x4c, 0x8c, 0x87, 0xef, 0xb1, 0xfc, 0x2c, 0xec, 0xdb, 0xd6, 0x00, 0xe5,\n  0x21, 0xfa, 0x34, 0x5a, 0x3c, 0xc3, 0x82, 0x52, 0x6f, 0x81, 0x2a, 0x05,\n  0xcc, 0xdc, 0x8a, 0x51, 0xf6, 0x65, 0x1d, 0xc5, 0x64, 0x86, 0xc1, 0x28,\n  0xf5, 0x0c, 0x8f, 0x09, 0xd4, 0x84, 0x8f, 0x69, 0x04, 0x24, 0x65, 0xf4,\n  0x47, 0x6c, 0x90, 0x57, 0x3c, 0x04, 0x4d, 0x52\n};\nstatic unsigned int US899_VALID_CSR_DER_LEN = 428;\n#if 0\n//Leaving this in for now, we may need this for some test cases\nstatic FILE *outfile;\nstatic size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr,size,nmemb,outfile);\n    return written;\n}\n#endif\n\nstatic void us899_clean (void)\n{\n}\n\nstatic int us899_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERTKEY,\n\t          US899_SERVER_CERTKEY,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us899_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us899_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US899_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n\treturn 1;\n    }\n\n    us899_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us899_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us899_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}    \n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\nstatic int populate_x509_csr (X509_REQ *req, EVP_PKEY *pkey, char *cn)\n{\n    X509_NAME *subj;\n\n    /* setup version number */\n    if (!X509_REQ_set_version(req, 0L)) {\n\tprintf(&#34;\\nUnable to set X509 version#\\n&#34;);\n        return (-1);\n    }\n\n    /*\n     * Add Common Name entry\n     */\n    subj = X509_REQ_get_subject_name(req);\n    if (!X509_NAME_add_entry_by_txt(subj, &#34;CN&#34;, MBSTRING_ASC,\n                                    (unsigned char*)cn, -1, -1, 0)) {\n\tprintf(&#34;\\nUnable to create X509 Common Name entry\\n&#34;);\n        return (-1);\n    }\n\n    /*\n     * Set the public key on the request\n     */\n    if (!X509_REQ_set_pubkey(req, pkey)) {\n\tprintf(&#34;\\nUnable to set X509 public key\\n&#34;);\n        return (-1);\n    }\n\n    return (0);\n}\n\n/*\n * Sign an X509 certificate request using the digest and the key passed.\n * Returns OpenSSL error code from X509_REQ_sign_ctx();\n */\nstatic int sign_X509_req (X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\n{\n    int rv;\n    EVP_PKEY_CTX *pkctx = NULL;\n    EVP_MD_CTX mctx;\n\n    EVP_MD_CTX_init(&amp;mctx);\n\n    if (!EVP_DigestSignInit(&amp;mctx, &amp;pkctx, md, NULL, pkey)) {\n        return 0;\n    }\n\n    /*\n     * Encode using DER (ASN.1) \n     *\n     * We have to set the modified flag on the X509_REQ because\n     * OpenSSL keeps a cached copy of the DER encoded data in some\n     * cases.  Setting this flag tells OpenSSL to run the ASN\n     * encoding again rather than using the cached copy.\n     */\n    x-&gt;req_info-&gt;enc.modified = 1; \n    rv = X509_REQ_sign_ctx(x, &amp;mctx);\n\n    EVP_MD_CTX_cleanup(&amp;mctx);\n\n    return (rv);\n}\n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us899_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll -  \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n */\nstatic void us899_test1 (void) \n{\n    LOG_FUNC_NM;\n\n    us899_simple_enroll(&#34;TC899-1&#34;, US899_SERVER_IP, EST_ERR_NONE); \n}\n\n\n/*\n * Simple enroll CSR  \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n * This test case uses the alternate enroll method where the CSR\n * is provided by the application layer rather than having libest\n * generate the CSR.\n */\nstatic void us899_test2 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509_REQ *csr;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Generate a CSR\n     */\n    csr = X509_REQ_new();\n    CU_ASSERT(csr != NULL);\n    rv = populate_x509_csr(csr, key, &#34;US899-TC2&#34;);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the alternate API to enroll an existing CSR\n     */\n    rv = est_client_enroll_csr(ectx, csr, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    X509_REQ_free(csr);\n    EVP_PKEY_free(key);\n    if (new_cert) {\n        free(new_cert);\n    }\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll CSR - Null \n *\n * This is a basic test to perform a /simpleenroll using a \n * user ID and password to identify the client to the server. \n * No identity certificate is used by the client.\n * This test case uses the alternate enroll method where the CSR\n * is provided by the application layer rather than having libest\n * generate the CSR.  It attempts to pass in null CSR, which should\n * fail.\n */\nstatic void us899_test3 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the alternate API to enroll a null CSR\n     */\n    rv = est_client_enroll_csr(ectx, NULL, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NO_CSR);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll CSR - corrupted  \n *\n * This test checks the X509_REQ helper function is working proplery.\n */\nstatic void us899_test4 (void) \n{\n    X509_REQ *csr;\n    unsigned char badreq[14] = &#34;bogus request&#34;;\n\n    LOG_FUNC_NM;\n\n    /*\n     * First try PEM decoding \n     */\n    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try DER decoding \n     */\n    csr = est_read_x509_request(badreq, 13, EST_CERT_FORMAT_DER);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try an invalid format\n     */\n    csr = est_read_x509_request(badreq, 13, 999);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try an invalid csr length\n     */\n    csr = est_read_x509_request(badreq, 999999, EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr == NULL);\n\n    /*\n     * Next try a valid PEM encoded csr\n     */\n    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_PEM, strlen(US899_VALID_CSR_PEM), \n\t                         EST_CERT_FORMAT_PEM);\n    CU_ASSERT(csr != NULL);\n    if (csr) {\n\tX509_REQ_free(csr);\n    }\n\n    /*\n     * Next try a valid DER encoded csr\n     */\n    csr = est_read_x509_request((unsigned char*)US899_VALID_CSR_DER, US899_VALID_CSR_DER_LEN, \n\t                         EST_CERT_FORMAT_DER);\n    CU_ASSERT(csr != NULL);\n    if (csr) {\n\tX509_REQ_free(csr);\n    }\n}\n\n//C. Attempt to enroll a newly created CSR that\&#39;s already been signed \n//   via est_client_enroll_csr\nstatic void us899_test5 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    X509_REQ *csr;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * Generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Generate a new CSR\n     */\n    csr = X509_REQ_new();\n    CU_ASSERT(csr != NULL);\n    rv = populate_x509_csr(csr, key, &#34;US899-TC5&#34;);\n    CU_ASSERT(csr != NULL);\n\n    /*\n     * Sign the CSR\n     */\n\n    rv = sign_X509_req(csr,key,EVP_sha256()); \n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the alternate API to enroll an existing CSR.  This should pass.\n     */\n    rv = est_client_enroll_csr(ectx, csr, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    X509_REQ_free(csr);\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Simple enroll - FQDN mismatch hostname in CN \n *\n * This test confirms that a mismatched host name on\n * the server cert CN will result in an auth failure\n * at the TLS layer on the client side.\n */\nstatic void us899_test6 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH,\n\t          US899_SERVER_KEY_CN_MISMATCH,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-6&#34;, US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n\n}\n\n/*\n * Simple enroll - FQDN mismatch IPv4 address in CN \n *\n * This test confirms that a mismatched IP address in\n * the server cert CN will result in an auth failure\n * at the TLS layer on the client side.\n * Note: this test may be redundant since the IP address\n *       matching logic only occurs when the dNSName is \n *       used instead of the CommonName.\n */\nstatic void us899_test7 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH_IP,\n\t          US899_SERVER_KEY_CN_MISMATCH_IP,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-7&#34;, US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n\n}\n\n/*\n * Simple enroll - FQDN matched wildcard in CN \n *\n * This test confirms that wildcard matching logic\n * in the CN is working. The cert uses a wildcard\n * pattern of *.cisco.com with a server address\n * of localhost.cisco.com.\n */\nstatic void us899_test8 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MATCH_WC,\n\t          US899_SERVER_KEY_CN_MATCH_WC,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-8&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_NONE); \n\n}\n\n/*\n * Simple enroll - FQDN mismatched wildcard in CN \n *\n * This test confirms that wildcard matching logic\n * in the CN is working. The cert uses a wildcard\n * pattern of *.google.com with a server address\n * of localhost.cisco.com.\n */\nstatic void us899_test9 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_CN_MISMATCH_WC,\n\t          US899_SERVER_KEY_CN_MISMATCH_WC,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-9&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN matched hostname in SubjectAltName \n *\n * This test confirms that a matched host name on\n * the server cert SubjectAltName ext will result in an auth success. \n */\nstatic void us899_test10 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH,\n\t          US899_SERVER_KEY_SAN_MATCH,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-10&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN mismatched hostname in SubjectAltName \n *\n * This test confirms that a mismatched host name on\n * the server cert SubjectAltName ext will result in an auth failure. \n */\nstatic void us899_test11 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH,\n\t          US899_SERVER_KEY_SAN_MISMATCH,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-11&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN mismatched IPv4 address in SubjectAltName \n *\n * This test confirms that a mismatched IPv4 address on\n * the server cert SubjectAltName ext will result in an auth failure. \n */\nstatic void us899_test12 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH_IP,\n\t          US899_SERVER_KEY_SAN_MISMATCH_IP,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-12&#34;, US899_SERVER_IP, EST_ERR_FQDN_MISMATCH); \n}\n\n/*\n * Simple enroll - FQDN matched IPv4 address in SubjectAltName \n *\n * This test confirms that a matched IPv4 address on\n * the server cert SubjectAltName ext will result in an auth success. \n */\nstatic void us899_test13 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH_IP,\n\t          US899_SERVER_KEY_SAN_MATCH_IP,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-13&#34;, US899_SERVER_IP, EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN matched hostname in SubjectAltName with wildcard \n *\n * This test confirms that a hostname matches a wildcard pattern in\n * the server cert SubjectAltName ext, which will result in an auth success. \n */\nstatic void us899_test14 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MATCH_WC,\n\t          US899_SERVER_KEY_SAN_MATCH_WC,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-14&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_NONE); \n}\n\n/*\n * Simple enroll - FQDN mismatched hostname in SubjectAltName with wildcard \n *\n * This test confirms that a hostname mismatches a wildcard pattern in\n * the server cert SubjectAltName ext, which will result in an auth fail. \n */\nstatic void us899_test15 (void) \n{\n    int rv;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a certificate that contains a\n     * bogus hostname in the CN\n     */\n    rv = st_start(US899_SERVER_PORT, \n\t          US899_SERVER_CERT_SAN_MISMATCH_WC,\n\t          US899_SERVER_KEY_SAN_MISMATCH_WC,\n\t          &#34;US899 test realm&#34;,\n\t          US899_CACERTS,\n\t          US899_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n    CU_ASSERT(rv == 0);\n    if (rv) return;\n\n    us899_simple_enroll(&#34;TC899-15&#34;, &#34;localhost.cisco.com&#34;, EST_ERR_FQDN_MISMATCH); \n}\n\n\n/*\n * Simple enroll - CRL check enabled on client\n *\n * We enable CRL checking on the client side.  We will\n * generate a CRL, but the server cert will not be\n * revoked.  The enroll should succeed.\n */\nstatic void us899_test16 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *cacrlcerts = NULL;\n    int cacrlcerts_len = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to use a different cert.\n     */\n    st_stop();\n\n    /*\n     * Now that all the FQDN tests are completed, start\n     * the normal server.\n     */\n    rv = us899_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Generate a CRL and append it to the CA chain\n     * we\&#39;re using on the client side.\n     */\n#ifndef WIN32\n    system(&#34;openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem&#34;);\n    SLEEP(1);\n    system(&#34;cat CA/trustedcerts.crt &gt; US899/test16trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;cat US899/test16_crl.pem &gt;&gt; US899/test16trust.crt&#34;);\n    SLEEP(1);\n#else\n    system(&#34;openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test16_crl.pem&#34;);\n    SLEEP(1);\n    system(&#34;type CA\\\\trustedcerts.crt &gt; US899\\\\test16trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;type US899\\\\test16_crl.pem &gt;&gt; US899\\\\test16trust.crt&#34;);\n    SLEEP(1);\n#endif \n\n    /*\n     * Read in the CA certificates\n     */\n    cacrlcerts_len = read_binary_file(&#34;US899/test16trust.crt&#34;, &amp;cacrlcerts);\n    CU_ASSERT(cacrlcerts &gt; 0);\n    if (cacrlcerts_len &lt;= 0) {\n\treturn;\n    }\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacrlcerts, cacrlcerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Enable CRL checking on the client\n     */\n    rv = est_enable_crl(ectx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TEST16-CN&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n    free(cacrlcerts);\n}\n\n/*\n * Simple enroll - CRL check enabled on client\n *\n * We enable CRL checking on the client side.  We will\n * generate a CRL, the server cert will  be\n * revoked.  The enroll should fail.\n */\nstatic void us899_test17 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    unsigned char *cacrlcerts = NULL;\n    int cacrlcerts_len = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    \n    LOG_FUNC_NM;\n\n    /*\n     * Revoke the server cert, generate a CRL and append it to the CA chain\n     * we\&#39;re using on the client side.\n     */\n#ifndef WIN32\n    system(&#34;cp CA/estCA/index.txt CA/estCA/index.txt.save&#34;);\n    SLEEP(1);\n    system(&#34;openssl ca -config CA/estExampleCA.cnf -revoke CA/estCA/private/estservercertandkey.pem&#34;);\n    SLEEP(1);\n    system(&#34;openssl ca -config CA/estExampleCA.cnf -gencrl -out US899/test17_crl.pem&#34;);\n    SLEEP(1);\n    system(&#34;cat CA/trustedcerts.crt &gt; US899/test17trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;cat US899/test17_crl.pem &gt;&gt; US899/test17trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;cp CA/estCA/index.txt.save CA/estCA/index.txt&#34;);\n    SLEEP(1);\n#else \n    system(&#34;copy CA\\\\estCA\\\\index.txt CA\\\\estCA\\\\index.txt.save&#34;);\n    SLEEP(1);\n    system(&#34;openssl ca -config CA\\\\estExampleCA.cnf -revoke CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;);\n\tSLEEP(1); \n    system(&#34;openssl ca -config CA\\\\estExampleCA.cnf -gencrl -out US899\\\\test17_crl.pem&#34;);\n    SLEEP(1);\n    system(&#34;type CA\\\\trustedcerts.crt &gt; US899\\\\test17trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;type US899\\\\test17_crl.pem &gt;&gt; US899\\\\test17trust.crt&#34;);\n    SLEEP(1);\n    system(&#34;copy CA\\\\estCA\\\\index.txt.save CA\\\\estCA\\\\index.txt&#34;);\n    SLEEP(1);\n#endif \n\n    /*\n     * Read in the CA certificates\n     */\n    cacrlcerts_len = read_binary_file(&#34;US899/test17trust.crt&#34;, &amp;cacrlcerts);\n    CU_ASSERT(cacrlcerts &gt; 0);\n    if (cacrlcerts_len &lt;= 0) {\n\treturn;\n    }\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacrlcerts, cacrlcerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Enable CRL checking on the client\n     */\n    rv = est_enable_crl(ectx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TEST17-CN&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n    free(cacrlcerts);\n}\n\n/*\n * Simple enroll - Receive Retry-After response \n *\n * Client issues an Enroll request and receives\n * a Retry-After response.  Ensure that the\n * retry after value can be obtained from the client.\n */\nstatic void us899_test18 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    int delay_secs = 0;\n    time_t retry_date = 0;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    \n    LOG_FUNC_NM;\n\n    /*\n     * Stop the existing server.  This test case needs\n     * the server to go into manual enroll mode\n     */\n    st_stop();\n\n    /*\n     * Start the server up in manual enroll mode\n     */\n    rv = us899_start_server(1, 0);\n    CU_ASSERT(rv == 0);    \n\n    /*\n     * Create a client context using the default CA certs\n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM, \n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US899_UID, US899_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US899_SERVER_IP, US899_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TEST18-CN&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    if (rv == EST_ERR_CA_ENROLL_RETRY) {\n        /*\n         * go get the retry duration\n         * make sure it\&#39;s set to the default value\n         */\n        rv = est_client_copy_retry_after(ectx, &amp;delay_secs, &amp;retry_date);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        CU_ASSERT(delay_secs == 3600);\n    }\n    \n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n//TO DO\n//\n//Auth (HTTP basic auth enabled on server) \n//A. Enroll CSR using valid cert, no UID\n//B. Enroll CSR using valid cert, valid UID\n//C. Enroll CSR using valid cert, invalid UID\n//D. Enroll CSR using invalid cert, no UID\n//E. Enroll CSR using invalid cert, valid UID\n//F. Enroll CSR using invalid cert, invalid UID\n//\n//Auth (HTTP digest auth enabled on server) \n//A. Enroll CSR using valid cert, no UID\n//B. Enroll CSR using valid cert, valid UID\n//C. Enroll CSR using valid cert, invalid UID\n//D. Enroll CSR using invalid cert, no UID\n//E. Enroll CSR using invalid cert, valid UID\n//F. Enroll CSR using invalid cert, invalid UID\n//\n\nint us899_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us899_client_simpenroll&#34;, \n\t                  us899_init_suite, \n\t\t\t  us899_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* \n    * Add the tests to the suite \n    *\n    * ********************IMPORTANT*********************\n    * Do not change the order of these tests.\n    * Some of the tests stop the EST server and restart\n    * it using different certs.  If you change the order\n    * then false negatives may occur.\n    * **************************************************\n    *\n    */\n   if ((NULL == CU_add_test(pSuite, &#34;Simple enroll&#34;, us899_test1)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll CSR&#34;, us899_test2)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll null CSR&#34;, us899_test3)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll corrupted CSR&#34;, us899_test4)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll signed CSR&#34;, us899_test5)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - hostname mismatch FQDN CN&#34;, us899_test6)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - IPv4 mismatch FQDN CN&#34;, us899_test7)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - wildcard match FQDN CN&#34;, us899_test8)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - wildcard mismatch FQDN CN&#34;, us899_test9)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - hostname match FQDN SAN&#34;, us899_test10)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - hostname mismatch FQDN SAN&#34;, us899_test11)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - IPv4 mismatch FQDN SAN&#34;, us899_test12)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - IPv4 match FQDN SAN&#34;, us899_test13)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - wildcard match FQDN SAN&#34;, us899_test14)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - wildcard mismatch FQDN SAN&#34;, us899_test15)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - CRL enabled, valid server cert&#34;, us899_test16)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - CRL enabled, revoked server cert&#34;, us899_test17)) ||\n       (NULL == CU_add_test(pSuite, &#34;Simple enroll - Retry-After received&#34;, us899_test18)))\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us4020.c&#39;: [&#39;/*------------------------------------------------------------------\n * us4020.c - Unit Test for User Story 4020 - Unit test client\n *            proxy mode.  Test the new API function and\n *            verify correct operation of Client proxy modes.\n *\n * October, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &#34;est.h&#34;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n\n#define MAX_4020_CMDS 1024\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US4020_SERVER_DOMAIN_NAME &#34;localhost.cisco.com&#34;\n#define US4020_SERVER_IP        &#34;127.0.0.1&#34;\t\n#define US4020_SERVER_TCP_PORT\t40200\n\n#define US4020_PROXY_IP         &#34;127.0.0.1&#34;\t\n#define US4020_PROXY_TCP_PORT\t40208\n\n#define US4020_UID\t    &#34;estuser&#34;\n#define US4020_PWD\t    &#34;estpwd&#34;\n\n#ifndef WIN32\n#define US4020_CACERTS\t     &#34;CA/estCA/cacert.crt&#34;\n/* #define US4020_CACERT &#34;CA/estCA/cacert.crt&#34; */\n/* #define US4020_SERVER_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n/* #define US4020_SERVER_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n/* #define US4020_CLIENT_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n/* #define US4020_CLIENT_KEY  &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n#else\n#define US4020_CACERTS\t     &#34;CA\\\\estCA\\\\cacert.crt&#34;\n/* #define US4020_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34; */\n/* #define US4020_SERVER_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34; */\n/* #define US4020_SERVER_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34; */\n/* #define US4020_CLIENT_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34; */\n/* #define US4020_CLIENT_KEY  &#34;CA\\\\estCA\\\\private/estservercertandkey.pem&#34; */\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us4020_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&amp;logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section); \n}\n#endif \n\nstatic EVP_PKEY *generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n\nstatic void us4020_clean (void)\n{\n}\n\nint us4020_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US4020_SERVER_TCP_PORT, \n\t          &#34;CA/estCA/private/estservercertandkey.pem&#34;,\n\t          &#34;CA/estCA/private/estservercertandkey.pem&#34;,\n\t          &#34;estrealm&#34;,\n\t          &#34;CA/estCA/cacert.crt&#34;,\n\t          &#34;CA/trustedcerts.crt&#34;,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n#define MAX_CMD_BUF 256\n#define MAX_PID_BUF 128\nstatic void shutdown_antinat (void)\n{\n    int fh;\n    char read_pid[MAX_PID_BUF];\n    char cmd[MAX_CMD_BUF];\n    int rv = 0;\n    \n    fh = open (&#34;./antinat-pid&#34;, O_RDWR, 0666);\n    \n    (void)read(fh, read_pid, MAX_PID_BUF);    \n    printf(&#34;pid read back in = %s\\n&#34;, read_pid);\n\n    snprintf(cmd, MAX_CMD_BUF, &#34;kill %s\\n&#34;, read_pid);\n    rv = system(cmd);\n\n    if (rv) {\n        printf(&#34;Failed to terminate antinat.\\n&#34;);\n    }\n}\n\nstatic void shutdown_haproxy (void)\n{\n    int fh;\n/*     int readbyte_count = 0; */\n    char read_pid[MAX_PID_BUF];\n    char cmd[MAX_CMD_BUF];\n    int rv = 0;\n\n    fh = open (&#34;./haproxy.pid&#34;, O_RDWR, 0666);\n    \n/*     readbyte_count = read(fh, read_pid, MAX_PID_BUF); */\n    (void)read(fh, read_pid, MAX_PID_BUF);\n    printf(&#34;pid read back in = %s\\n&#34;, read_pid);\n\n    snprintf(cmd, MAX_CMD_BUF, &#34;kill %s\\n&#34;, read_pid);\n    rv = system(cmd);\n\n    if (rv) {\n        printf(&#34;Failed to terminate haproxy.\\n&#34;);\n    }\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us4020_init_suite (void)\n{\n    int rv;\n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us4020_logger_stderr);\n#else \n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n#endif    \n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US4020_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n\treturn 1;\n    }\n\n    us4020_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us4020_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us4020_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n\n\n/*\n * Error check the parameters to the API\n */\nstatic void us4020_test1 (void) \n{\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  Attempt to call the API without a context\n     */\n    e_rc= est_client_set_proxy(NULL, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n    CU_ASSERT(e_rc == EST_ERR_NO_CTX);\n\n    /*\n     * valid call\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * don\&#39;t set the server \n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               NULL,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * server to empty string\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               &#34;&#34;,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * max server name \n     */\n    char * max_server_name = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                             &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                             &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                             &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                             &#34;123456789012345&#34;;\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               max_server_name,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * server name too long\n     */\n    char * long_server_name = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                              &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                              &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                              &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                              &#34;1234567890123456&#34;;\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               long_server_name,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * don\&#39;t set the port\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               0,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PORT_NUM);\n\n    /* proxy protocol invalid */\n    e_rc= est_client_set_proxy(ectx, 25,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);\n\n    /* proxy protocol invalid */\n    e_rc= est_client_set_proxy(ectx, -2,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_PROTOCOL);\n\n    /* proxy auth invalid */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               25,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_CLIENT_PROXY_AUTH);\n\n    /*\n     * max userid\n     */\n    char * max_userid = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                        &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                        &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                        &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                        &#34;123456789012345&#34;;\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               max_userid, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * userid too long\n     */\n    char * long_userid = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                         &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                         &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                         &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                         &#34;1234567890123456&#34;;\n\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               long_userid, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * userid is an empty string\n     */    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * max pwd\n     */\n    char * max_pwd = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                     &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                     &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                     &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                     &#34;123456789012345&#34;;\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, max_pwd);\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * pwd too long\n     */    \n    char * long_pwd = &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                      &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                      &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                      &#34;123456789012345678901234567890123456789012345678901234567890&#34;\n                      &#34;1234567890123456&#34;;\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, long_pwd);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * password is an empty string\n     */    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_INVALID_PARAMETERS);    \n    \n    est_destroy(ectx);\n    \n}\n\n\n/*\n * Test for SOCKS 4 mode, no credentials, should pass\n *\n */\nstatic void us4020_test2 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-2&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 4 mode, with credentials, should pass\n *\n */\nstatic void us4020_test3 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-3&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode\n *\n */\nstatic void us4020_test4 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n/*                                &#34;estuser&#34;, &#34;estpwd&#34;); */\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-4&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 4A mode\n *\n */\nstatic void us4020_test5 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n/*                                &#34;estuser&#34;, &#34;estpwd&#34;); */\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-5&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with no credentials\n *\n */\nstatic void us4020_test6 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-6&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with good credentials\n *\n */\nstatic void us4020_test7 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg-goodcred.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-6&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with good credentials, but forgotten\n *\n */\nstatic void us4020_test8 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg-goodcred.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-6&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n/*\n * Test for SOCKS 5 mode, with bad credentials\n *\n */\nstatic void us4020_test9 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg-badcred.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS5,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-6&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_IP_CONNECT);\n    \n    shutdown_antinat();\n    est_destroy(ectx);\n}\n\n\n#if 0\n/*\n * could be tested, but needs certifcates updated\n */\n/*\n * Test for SOCKS 4A mode, with domain name \n *\n */\nstatic void us4020_test8 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a SOCKS 4 proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;antinat -xcUS4020/antinat-cfg.xml&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    /*\n     *  socks4\n     */\n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_SOCKS4A,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_DOMAIN_NAME, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-7&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_antinat();    \n    est_destroy(ectx);\n}\n#endif\n\n/*\n * Test HTTP proxy mode\n *\n * NOTE: only non-tunnel mode is tested.  tunnel mode does not\n * work with CiscoEST server.\n */\nstatic void us4020_test10 (void) \n{\n    int sys_rc = 0;\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n    char cmd[MAX_4020_CMDS];\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Set up a HTTP proxy server locally\n     */\n    snprintf(cmd, MAX_4020_CMDS, &#34;haproxy -D -f US4020/haproxy.cfg -p ./haproxy.pid&#34;);\n\n    sys_rc = system(cmd);\n    CU_ASSERT(sys_rc == 0);    \n    \n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n    \n    e_rc= est_client_set_proxy(ectx, EST_CLIENT_PROXY_HTTP_NOTUNNEL,\n                               US4020_PROXY_IP,\n                               US4020_PROXY_TCP_PORT,\n                               EST_CLIENT_PROXY_AUTH_BASIC,\n                               &#34;estuser&#34;, &#34;estpwd&#34;);\n\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    e_rc = est_client_set_auth(ectx, US4020_UID, US4020_PWD, NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US4020_SERVER_IP, US4020_SERVER_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    e_rc = est_client_enroll(ectx, &#34;TC4020-8&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    shutdown_haproxy();    \n    est_destroy(ectx);\n}\n\n\n/*\n * Indicate whether client proxy support has been built into\n * the library or not\n */\nstatic int client_proxy_enabled (void) \n{\n    EST_ERROR e_rc;\n    \n    e_rc = est_client_set_proxy(NULL, 0, NULL, 0, 0, NULL, NULL);\n    if (e_rc == EST_ERR_CLIENT_PROXY_MODE_NOT_SUPPORTED) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us4020_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us4020_tok_auth_client&#34;, \n\t                  us4020_init_suite, \n\t\t\t  us4020_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n#ifndef WIN32\n   /*\n    * client proxy mode is only supported when libcurl has been specified.\n    */\n   if (client_proxy_enabled()){\n       \n       /* add the tests to the suite */\n       if (\n           (NULL == CU_add_test(pSuite, &#34;parameter check API&#34;, us4020_test1)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 4 mode&#34;, us4020_test2)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 4 mode w/ credentials&#34;, us4020_test3)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 5 mode&#34;, us4020_test4)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 4A mode&#34;, us4020_test5)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 5 mode, no credentials&#34;, us4020_test6)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 5 mode, good credentials&#34;, us4020_test7)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 5 mode, forgotten credentials&#34;, us4020_test8)) ||\n           (NULL == CU_add_test(pSuite, &#34;SOCKS 5 mode, bad credentials&#34;, us4020_test9)) ||\n/*            (NULL == CU_add_test(pSuite, &#34;SOCKS 4A mode with domain name instead of IP address&#34;, us4020_test7)) || */\n           (NULL == CU_add_test(pSuite, &#34;HTTP proxy&#34;, us4020_test10))\n           )\n           {\n               CU_cleanup_registry();\n               return CU_get_error();\n           }\n   }\n#endif   \n   return CUE_SUCCESS;\n#endif\n}\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us897.c&#39;: [&#39;/*------------------------------------------------------------------\n * us897.c - Unit Tests for User Story 897 - Client CACerts \n *\n * June, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &#34;../../util/test_utils.h&#34;\n#include &#34;st_server.h&#34;\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n#define EST_CA_MAX\t    200000\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server\&#39;s directory\n */\n/* #define CLIENT_UT_CACERT &#34;../../example/server/estCA/cacert.crt&#34; */\n#define US897_SERVER_PORT   29897\n#define CLIENT_UT_PUBKEY &#34;./est_client_ut_keypair&#34;\n#define US897_SERVER_IP\t    &#34;127.0.0.1&#34;\t\n#define US897_UID\t    &#34;estuser&#34;\n#define US897_PWD\t    &#34;estpwd&#34;\n\n#ifndef WIN32\n#define CLIENT_UT_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US897_CACERTS\t    &#34;CA/estCA/cacert.crt&#34;\n#define US897_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US897_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS &#34;US897/singlechain_10certs_trusted.crt&#34;\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING &#34;US897/singlechain_9certs_missingcert.crt&#34;\n#define US897_CACERTS_SINGLE_CHAIN_EXPIRED &#34;US897/singlechain_expired.crt&#34;\n#define US897_CACERTS_MULTI_CHAIN_CRLS &#34;US897/trustedCHain10RevokedDepth6Implicit10andcacert.crt&#34;\n#else\n#define CLIENT_UT_CACERT &#34;CA\\\\estCA/cacert.crt&#34;\n#define US897_CACERTS\t    &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US897_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US897_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS &#34;US897\\\\singlechain_10certs_trusted.crt&#34;\n#define US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING &#34;US897\\\\singlechain_9certs_missingcert.crt&#34;\n#define US897_CACERTS_SINGLE_CHAIN_EXPIRED &#34;US897\\\\singlechain_expired.crt&#34;\n#define US897_CACERTS_MULTI_CHAIN_CRLS &#34;US897\\\\trustedCHain10RevokedDepth6Implicit10andcacert.crt&#34;\n#endif \n\nstatic void us897_clean (void)\n{\n}\n\nstatic int us897_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n\t          US897_CACERTS,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    \n    SLEEP(1);\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit initializes this test\n * suite. \n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us897_init_suite (void)\n{\n    int rv = 0;\n    \n    char cmd[EST_UT_MAX_CMD_LEN];    \n    printf(&#34;Starting EST Client unit tests. PDB\\n&#34;);\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n             &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;, CLIENT_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n    \n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us897_clean();    \n    /*\n     * Start an instance of the EST server\n     */\n    rv = us897_start_server(0, 0);\n    SLEEP(2);\n    \n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us897_destroy_suite (void)\n{\n    \n    st_stop();    \n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n    \n\n/*\n * This test case initializes an EST client context\n * using local CA certs, no client cert, and a valid public key,\n * no userid and password.\n */\nstatic void us897_test1 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n    \n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    est_init_logger(EST_LOG_LVL_INFO, NULL);    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n                             \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }    \n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using no local CA certs.  This is expected to be a successful initialization\n * since the local CA trust anchor certs are not mandatory.\n */\nstatic void us897_test2 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(NULL, 0, EST_CERT_FORMAT_PEM, client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using a local CA cert, no client cert,\n * and a valid public key, no userid and password.\n */\nstatic void us897_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n#if 0\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, and a valid public key,\n * no userid and password.\n */\nstatic void us897_test3 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n    \n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n#endif\n\n\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, a public key,\n * and a userid and password.\n */\nstatic void us897_test6 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;USER&#34;, &#34;PASSWORD&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case initializes an EST client context\n * using explict CA certs, no client cert, a public key,\n * and a userid and NO password.\n */\nstatic void us897_test7 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;USER&#34;, NULL, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, NULL, &#34;PASSWORD&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }    \n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the set server with valid parameters\n */\nstatic void us897_test9 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    rc = est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);    \n    CU_ASSERT(rc == EST_ERR_NONE);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the set server with invalid parameters\n */\nstatic void us897_test10 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    char *server_name_too_long = &#34;12345678901234567890123456789012345678901234567890&#34;\\\n        &#34;12345678901234567890123456789012345678901234567890&#34;\\\n        &#34;12345678901234567890123456789012345678901234567890&#34;\\\n        &#34;12345678901234567890123456789012345678901234567890&#34;\\\n        &#34;12345678901234567890123456789012345678901234567890123456&#34;;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /*\n     * Null server name\n     */\n    rc = est_client_set_server(ectx, NULL, US897_SERVER_PORT, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     * server too long\n     */\n    rc = est_client_set_server(ectx, server_name_too_long, US897_SERVER_PORT, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_SERVER_NAME);\n\n    /*\n     *  port num less than 0\n     */\n    rc = est_client_set_server(ectx, US897_SERVER_IP, -1, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);\n\n    /*\n     * port num greater than max\n     */\n    rc = est_client_set_server(ectx, US897_SERVER_IP, 65536, NULL);\n    CU_ASSERT(rc == EST_ERR_INVALID_PORT_NUM);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the Get CACerts request\n *\n */\nstatic void us897_test11 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n    \n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);    \n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n\n    /*\n     * make sure that the context is no longer valid and the EST client is\n     * back to the uninitialized state\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n    CU_ASSERT(rc == EST_ERR_CLIENT_NOT_INITIALIZED);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the Get CACerts request with invalid input parameters\n *\n */\nstatic void us897_test12 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, NULL);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single certificate\n */\nstatic void us897_test13 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n\t          US897_CACERTS,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs\n */\nstatic void us897_test14 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n    \n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs and\n * a missing cert in the chain.  \n */\nstatic void us897_test15 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n                  US897_CACERTS_SINGLE_CHAIN_MULT_CERTS_ONE_MISSING,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);\n    CU_ASSERT(retrieved_cacerts_len == 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn\&#39;t be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there\&#39;s no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a single chain with multiple certs \n * with the intermediate cert expired.\n */\nstatic void us897_test16 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n                  US897_CACERTS_SINGLE_CHAIN_EXPIRED,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in thestartup  CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_CACERT_VERIFICATION);\n    CU_ASSERT(retrieved_cacerts_len == 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn\&#39;t be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there\&#39;s no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NO_CERTIFICATE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the CA cert response verification function.  It will\n * verify a CAcert response containing a multiple chains with multiple certs and\n * a CRL block.  The CRLs should be ignored.  \n */\nstatic void us897_test17 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n\n    /*\n     * Stop the existing server.  Need to ensure that the server\n     * is using a specific CA cert chain.\n     */\n    st_stop();\n    SLEEP(2);\n\n    /*\n     * Spin up a new instance of the EST server\n     * using a CA cert chain that contains just one cert\n     */\n    rc = st_start(US897_SERVER_PORT, \n\t          US897_SERVER_CERTKEY,\n\t          US897_SERVER_CERTKEY,\n\t          &#34;US897 test realm&#34;,\n                  US897_CACERTS_MULTI_CHAIN_CRLS,\n\t          US897_TRUST_CERTS,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  0, 0, 0);\n\n    CU_ASSERT(rc == 0);\n    if (rc) return;\n    SLEEP(1);\n\n    /*\n     * Read in the startup CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn\&#39;t be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there\&#39;s no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NONE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/*\n * This test case tests the SSL read set timeout API.\n * The setting of the min, the max, a value in between, and a value\n * beyond the max.\n */\nstatic void us897_test18 (void) \n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY *priv_key;\n    unsigned char *retrieved_cacerts = NULL;\n    int  retrieved_cacerts_len = 0;    \n  \n    /*\n     * Read in the startup CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n\tprintf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US897_SERVER_IP, US897_SERVER_PORT, NULL);\n\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MIN);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_set_read_timeout(ectx, EST_SSL_READ_TIMEOUT_MAX+1);\n    CU_ASSERT(rc == EST_ERR_INVALID_PARAMETERS);\n    rc = est_client_set_read_timeout(ectx, 2);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Now proceed on with a GET /cacerts to verify that nothing gets broken */\n    \n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n\n    /*\n     * should be successful, and should have obtained a valid length\n     * for the size of the CA certs buffer\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    if (retrieved_cacerts_len) {\n        /*\n         * Shouldn\&#39;t be in here, but if we are, malloc and call\n         */\n        retrieved_cacerts = malloc(retrieved_cacerts_len);\n        rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n        /*\n         * est should fail indicating that there\&#39;s no cert to provide\n         */\n         CU_ASSERT(rc == EST_ERR_NONE);\n    }    \n    \n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */    \n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);    \n    }\n    free(retrieved_cacerts);\n    \n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us897_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n    \n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us897_client_cacerts&#34;, \n\t                  us897_init_suite, \n\t\t\t  us897_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* add the tests to the suite */\n   /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n   if ((NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, private key &#34;, us897_test1))  ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client Init: no local CA&#34;, us897_test2)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, explicit CA, private key&#34;, us897_test3)) ||\n/*        (NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, explicit CA, client CA, private key&#34;, us897_test4)) || */\n       (NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, userid/password&#34;, us897_test6)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, userid/no password&#34;, us897_test7)) ||\n/*        (NULL == CU_add_test(pSuite, &#34;EST Client Init: local CA, no userid/password&#34;, us897_test8)) || */\n       (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: correct parameters&#34;, us897_test9)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client Set Server: no parameters&#34;, us897_test10)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: ca_cert valid parameters&#34;, us897_test11)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: missing ca_cert pointers&#34;, us897_test12)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: verify chain-simple chain-success&#34;, us897_test13)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: verify chain-multiple certs-success&#34;, us897_test14)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: verify chain-broken chain-fail&#34;, us897_test15)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: verify chain-bad date-fail&#34;, us897_test16)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client CA Certs: verify chain-multiple chains-success&#34;, us897_test17)) ||\n       (NULL == CU_add_test(pSuite, &#34;EST Client SSL read timeout API&#34;, us897_test18))\n       ) \n   {\n      CU_error = CU_get_error();\n      printf(&#34;%d\\n&#34;, CU_error);\n   \n      CU_cleanup_registry();\n      printf(&#34;%s\\n&#34;, CU_get_error_msg());\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us1060.c&#39;: [&#39;/*------------------------------------------------------------------\n * us1060.c - Unit Tests for User Story 1060 - TLS SRP support (Server/Proxy)\n *\n * May, 2014\n *\n * Copyright (c) 2014-2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#include &lt;pthread.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;test_utils.h&#34;\n#include &#34;curl_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#define US1060_SERVER_PORT      31060\n#define US1060_SERVER_IP        &#34;127.0.0.1&#34;\n#define US1060_UID              &#34;estuser&#34;\n#define US1060_PWD              &#34;estpwd&#34;\n#ifndef WIN32\n#define US1060_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US1060_TRUST_CERTS      &#34;CA/trustedcerts.crt&#34;\n#define US1060_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1060_VFILE            &#34;US1060/passwd.srpv&#34;\n\n#define US1060_EXPLICIT_CERT    &#34;US1060/explicit-cert.pem&#34; \n#define US1060_EXPLICIT_KEY     &#34;US1060/explicit-key.pem&#34;\n#define US1060_SELFSIGN_CERT    &#34;US1060/selfsigned-cert.pem&#34; \n#define US1060_SELFSIGN_KEY     &#34;US1060/selfsigned-key.pem&#34;\n#else\n#define US1060_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1060_TRUST_CERTS      &#34;CA\\\\trustedcerts.crt&#34;\n#define US1060_SERVER_CERTKEY   &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1060_VFILE            &#34;US1060\\\\passwd.srpv&#34;\n\n#define US1060_EXPLICIT_CERT    &#34;US1060\\\\explicit-cert.pem&#34; \n#define US1060_EXPLICIT_KEY     &#34;US1060\\\\explicit-key.pem&#34;\n#define US1060_SELFSIGN_CERT    &#34;US1060\\\\selfsigned-cert.pem&#34; \n#define US1060_SELFSIGN_KEY     &#34;US1060\\\\selfsigned-key.pem&#34;\n#endif\n\n#define US1060_ENROLL_URL       &#34;https://127.0.0.1:31060/.well-known/est/simpleenroll&#34;\n#define US1060_UIDPWD_GOOD      &#34;estuser:estpwd&#34;\n#define US1060_UIDPWD_BAD       &#34;estuser:xxx111222&#34;\n#define US1060_PKCS10_CT        &#34;Content-Type: application/pkcs10&#34;\n\n#define US1060_PROXY_ENROLL_URL &#34;https://127.0.0.1:41060/.well-known/est/simpleenroll&#34;\n#define US1060_PROXY_PORT       41060\n\n#define US1060_PKCS10_REQ       &#34;MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n&#34;\n\nstatic char *log_search_target = NULL;\nstatic int search_target_found = 0;\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\nstatic SRP_VBASE *srpdb = NULL;\n\n#ifdef WIN32\nCRITICAL_SECTION logger_critical_section;\n#endif\n\n/*\n * This is a simple callback used to override the default\n * logging facility in libest.  We\&#39;ll use this to look\n * for specific debug output.\n */\nstatic void us1060_logger_stderr (char *format, va_list l)\n{\n    char t_log[1024];\n#ifndef WIN32\n    flockfile(stderr);\n#else\n    EnterCriticalSection(&amp;logger_critical_section);\n#endif \n    if (log_search_target) {\n        vsnprintf(t_log, 1024, format, l);\n        if (strstr(t_log, log_search_target)) {\n            search_target_found = 1;\n        }\n        fprintf(stderr, &#34;%s&#34;, t_log);\n    } else {\n        vfprintf(stderr, format, l);\n    }\n    fflush(stderr);\n#ifndef WIN32\n    funlockfile(stderr);\n#else\n    LeaveCriticalSection(&amp;logger_critical_section);\n#endif\n}\n\nstatic int us1060_start_server (char *cert, char *key, int no_http_auth,\n                                int enable_pop, int enable_srp)\n{\n    int rv;\n\n    if (enable_srp) {\n        rv = st_start_srp(US1060_SERVER_PORT,\n                          cert,\n                          key,\n                          &#34;US1060 test realm&#34;,\n                          US1060_CACERTS,\n                          US1060_TRUST_CERTS,\n                          &#34;CA/estExampleCA.cnf&#34;,\n                          enable_pop,\n                          US1060_VFILE);\n    } else {\n        rv = st_start(US1060_SERVER_PORT,\n                      cert,\n                      key,\n                      &#34;US1060 test realm&#34;,\n                      US1060_CACERTS,\n                      US1060_TRUST_CERTS,\n                      &#34;CA/estExampleCA.cnf&#34;,\n                      0,\n                      enable_pop,\n                      0);\n    }\n\n    if (no_http_auth) {\n        st_disable_http_auth();\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1060_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    /* Initialize critical section on Windows*/\n    InitializeCriticalSection(&amp;logger_critical_section);\n#endif\n\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us1060_logger_stderr);\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,\n        1);\n\n    /*\n     * Start an instance of the proxy with SRP enabled\n     */\n    rv = st_proxy_start_srp(US1060_PROXY_PORT,\n                            US1060_SERVER_CERTKEY,\n                            US1060_SERVER_CERTKEY,\n                            &#34;US1060 proxy realm&#34;,\n                            US1060_CACERTS,\n                            US1060_TRUST_CERTS,\n                            US1060_UID,\n                            US1060_PWD,\n                            US1060_SERVER_IP,\n                            US1060_SERVER_PORT,\n                            0,\n                            US1060_VFILE);\n\n    /*\n     * Read in the CA certificates\n     * Used for client-side API testing\n     */\n    cacerts_len = read_binary_file(US1060_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    srpdb = SRP_VBASE_new(NULL);\n    if (!srpdb) {\n        printf(&#34;\\nUnable allocate SRP verifier database.  Aborting!!!\\n&#34;);\n    }\n    if (SRP_VBASE_init(srpdb, US1060_VFILE) != SRP_NO_ERROR) {\n        printf(&#34;\\nUnable initialize SRP verifier database.  Aborting!!!\\n&#34;);\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1060_destroy_suite (void)\n{\n    if (srpdb) {\n        SRP_VBASE_free(srpdb);\n    }\n\n    st_stop();\n    st_proxy_stop();\n    free(cacerts);\n    return 0;\n}\n\ntypedef enum {\n    SRP_OFF, SRP_ON\n} server_srp_mode;\n\ntypedef enum {\n    SRP_GOOD, SRP_BAD, SRP_NONE,\n} client_srp_mode;\n\ntypedef enum {\n    HTTP_OFF, HTTP_OPTIONAL, HTTP_REQUIRED\n} server_http_mode;\n\ntypedef struct {\n    char *test_name;\n    char *curl_cert;\n    char *curl_key;\n    char *curl_http_auth;\n    client_srp_mode curl_srp;\n    server_http_mode server_http;\n    server_srp_mode server_srp;\n    int expected_http_result;\n} us1060_matrix;\n\n/*\n * This is the unit test matrix for server-side SRP support.  Curl is\n * used as the EST client.  Because of this PoP is disabled on the\n * server for all test cases.  We try to cover a variety of configurations\n * and potential scenarios.  The client side variations include:\n *\n * curl_cert:  The certificate curl uses, which may be NULL\n * curl_key:   The key curl uses, which may be NULL\n * curl_http_auth:  The HTTP auth credentials used by curl.\n * client_srp_mode: Either GOOD, BAD, NONE.  Determines which SRP credentials are used\n *                  Curl.\n *\n * On the server side we configure the server using the following variations:\n *\n * server_http_mode:  HTTP auth is required, optional, or disabled.\n *                    (optional means it only occurs when TLS auth fails)\n * server_srp_mode:   SRP is either enabled or disabled on the server.\n *\n * expected_http_result:  This is the expected HTTP status code received on by Curl.\n *                        When SRP fails, this results in a failed TLS session.  Curl\n *                        returns a zero in this case since the HTTP layer can not\n *                        communicate.  If TLS succeeds, but HTTP auth fails, then\n *                        the server should return a HTTP 401 response to the client.\n *                        When enrollment succeeds, the server should send a\n *                        HTTP 200 response.\n *\n *\n */\nstatic us1060_matrix test_matrix[] = {\n    {&#34;1&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 200},\n    {&#34;2&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},\n    {&#34;3&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 200},\n    {&#34;4&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},\n    {&#34;5&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},\n    {&#34;6&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 200},\n    {&#34;7&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},\n    {&#34;8&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},\n    {&#34;9&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},\n\n    {&#34;11&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_ON, 401},\n    {&#34;12&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_ON, 0},\n    {&#34;13&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_ON, 401},\n    {&#34;14&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_ON, 200},\n    {&#34;15&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_ON, 0},\n    {&#34;16&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_ON, 401},\n    {&#34;17&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_ON, 200},\n    {&#34;18&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_ON, 0},\n    {&#34;19&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_ON, 401},\n\n    {&#34;21&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;22&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;23&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},\n    {&#34;24&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;25&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;26&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {&#34;27&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},\n    {&#34;28&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},\n    {&#34;29&#34;, NULL, NULL, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},\n\n    {&#34;31&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;32&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;33&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},\n    {&#34;34&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;35&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;36&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 401},\n    {&#34;37&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_GOOD, HTTP_OFF,      SRP_OFF, 0},\n    {&#34;38&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_BAD,  HTTP_OFF,      SRP_OFF, 0},\n    {&#34;39&#34;, NULL, NULL, US1060_UIDPWD_BAD, SRP_NONE, HTTP_OFF,      SRP_OFF, 401},\n\n    {&#34;40&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  200},\n    {&#34;41&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  401},\n    {&#34;42&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},\n    {&#34;43&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  200},\n    {&#34;44&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  200},\n    {&#34;45&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  200},\n    {&#34;46&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 200},\n    {&#34;47&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 401},\n    {&#34;48&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {&#34;49&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 200},\n    {&#34;50&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 200},\n    {&#34;51&#34;, US1060_EXPLICIT_CERT, US1060_EXPLICIT_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 200},\n\n    {&#34;60&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},\n    {&#34;61&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_ON,  0},\n    {&#34;62&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},\n    {&#34;63&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_ON,  0},\n    {&#34;64&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_ON,  0},\n    {&#34;65&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_ON,  0},\n    {&#34;66&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;67&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_REQUIRED, SRP_OFF, 0},\n    {&#34;68&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;69&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OPTIONAL, SRP_OFF, 0},\n    {&#34;70&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_GOOD, SRP_NONE, HTTP_OFF,      SRP_OFF, 0},\n    {&#34;71&#34;, US1060_SELFSIGN_CERT, US1060_SELFSIGN_KEY, US1060_UIDPWD_BAD,  SRP_NONE, HTTP_OFF,      SRP_OFF, 0},\n};\n\n/*\n * This is our worker for each entry in the test matrix above.\n * We read the configuration from the entry, configure the\n * server and client as needed, and attempt a simple enroll\n * using Curl as the client.\n * The argument i is the index of the entry in the table above.\n */\nstatic void us1060_test_matrix_item (int i)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    printf(&#34;\\nRunning matrix test %s\\n&#34;, test_matrix[i].test_name);\n\n    /*\n     * Stop the server and restart it to make sure\n     * it\&#39;s in the correct mode.\n     */\n    st_stop();\n    SLEEP(1);\n    if (test_matrix[i].server_srp == SRP_ON) {\n        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,\n            0, 0, 1);\n    } else {\n        rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY,\n            0, 0, 0);\n    }\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Set the server HTTP auth configuration\n     */\n    switch (test_matrix[i].server_http) {\n    case HTTP_OFF:\n        st_disable_http_auth();\n        break;\n    case HTTP_OPTIONAL:\n        st_enable_http_auth();\n        st_set_http_auth_optional();\n        break;\n    case HTTP_REQUIRED:\n        st_enable_http_auth();\n        st_set_http_auth_required();\n        break;\n    }\n\n    switch (test_matrix[i].curl_srp) {\n    case SRP_GOOD:\n        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,\n        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,\n            NULL, &#34;srp_user&#34;, &#34;srp_pwd&#34;, NULL, NULL);\n        break;\n    case SRP_BAD:\n        rv = curl_http_post_srp(US1060_ENROLL_URL, US1060_PKCS10_CT,\n        US1060_PKCS10_REQ, test_matrix[i].curl_http_auth, NULL, CURLAUTH_BASIC,\n            NULL, &#34;srp_user&#34;, &#34;boguspwd&#34;, NULL, NULL);\n        break;\n    case SRP_NONE:\n        /*\n         * Some of the SRP disabled test cases use a client\n         * certificate.\n         */\n        if (test_matrix[i].curl_cert) {\n            rv = curl_http_post_certuid(US1060_ENROLL_URL, US1060_PKCS10_CT,\n            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,\n                test_matrix[i].curl_cert, test_matrix[i].curl_key,\n                US1060_CACERTS, NULL);\n        } else {\n            rv = curl_http_post(US1060_ENROLL_URL, US1060_PKCS10_CT,\n            US1060_PKCS10_REQ, test_matrix[i].curl_http_auth,\n            US1060_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n        }\n        break;\n    }\n    CU_ASSERT(rv == test_matrix[i].expected_http_result);\n    if (rv != test_matrix[i].expected_http_result) {\n        printf(&#34;\\nMatrix test %s failed with rv = %d\\n&#34;,\n            test_matrix[i].test_name, (int) rv);\n    }\n}\n\n/*\n * This test case runs all the tests in the matrix\n */\nstatic void us1060_test0 (void)\n{\n    int i;\n    int test_cnt = sizeof(test_matrix) / sizeof(test_matrix[0]);\n\n    for (i = 0; i &lt; test_cnt; i++) {\n        us1060_test_matrix_item(i);\n    }\n}\n\n/*\n * This test case is verifies the happy path when EST\n * proxy is configured in SRP mode.  The client will attempt\n * to use SRP.  The connection between the proxy and\n * server does not use SRP.  We perform a simple enroll\n * operation.\n */\nstatic void us1060_test200 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the EST server with SRP disabled\n     */\n    st_stop();\n    SLEEP(2);\n    rv = us1060_start_server(US1060_SERVER_CERTKEY, US1060_SERVER_CERTKEY, 0, 0,\n        0);\n    CU_ASSERT(rv == 0);\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, &#34;srp_user&#34;, &#34;srp_pwd&#34;, NULL,\n        NULL);\n    /*\n     * Since we passed in a valid SRP userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test case is verifies the simple enroll fails\n * when the EST client provides a bad SRP password.\n * The connection between the proxy and server does not\n * use SRP.\n */\nstatic void us1060_test201 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_GOOD, NULL, CURLAUTH_BASIC, NULL, &#34;srp_user&#34;, &#34;boguspwd&#34;,\n        NULL, NULL);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test case is verifies the simple enroll fails\n * when the EST client provides a bad HTTP password\n * and SRP is used.  The connection between the proxy\n * and server does not use SRP.\n */\nstatic void us1060_test202 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ,\n    US1060_UIDPWD_BAD, NULL, CURLAUTH_BASIC, NULL, &#34;srp_user&#34;, &#34;srp_pwd&#34;, NULL,\n        NULL);\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * This test case is verifies the simple enroll works\n * when the EST client provides no HTTP password\n * and SRP is used.  The connection between the proxy\n * and server does not use SRP.  HTTP auth is disabled\n * on the proxy.\n */\nstatic void us1060_test203 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_http_disable(1);\n\n    rv = curl_http_post_srp(US1060_PROXY_ENROLL_URL, US1060_PKCS10_CT,\n    US1060_PKCS10_REQ, NULL, NULL, CURLAUTH_NONE, NULL, &#34;srp_user&#34;, &#34;srp_pwd&#34;,\n        NULL, NULL);\n    CU_ASSERT(rv == 200);\n}\n\nint us1060_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us1060_tls_srp (server/proxy)&#34;,\n            us1060_init_suite,\n            us1060_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * Add the tests to the suite\n     *\n     * ********************IMPORTANT*********************\n     * Do not change the order of these tests.\n     * Some of the tests stop the EST server and restart\n     * it using different certs.  If you change the order\n     * then false negatives may occur.\n     * **************************************************\n     *\n     */\n    if ((NULL == CU_add_test(pSuite, &#34;TLS-SRP server: matrix master&#34;, us1060_test0)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS-SRP proxy: enroll w/SRP&#34;, us1060_test200)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS-SRP proxy: enroll bad SRP pwd&#34;, us1060_test201)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS-SRP proxy: enroll bad HTTP pwd&#34;, us1060_test202)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS-SRP proxy: enroll w/o HTTP auth&#34;, us1060_test203)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us900.c&#39;: [&#39;/*------------------------------------------------------------------\n * us900.c - Unit Tests for User Story 900 - Server CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#define US900_SERVER_PORT   29900\n#define US900_SERVER_IP     &#34;127.0.0.1&#34; \n\n#ifndef WIN32\n#define CLIENT_UT_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define CLIENT_UT_PUBKEY &#34;./est_client_ut_keypair&#34;\n#define US900_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US900_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US900_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define CLIENT_UT_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define CLIENT_UT_PUBKEY &#34;est_client_ut_keypair&#34;\n#define US900_CACERTS       &#34;CA\\\\estCA/cacert.crt&#34;\n#define US900_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US900_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif\n\n#define TEST_ATTR_POP &#34;MAsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR_NOPOP &#34;MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR_NOPOPPOP &#34;MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n#define TEST_ATTR_POPADDED &#34;MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n#define TEST_ATTR1 &#34;MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\\0&#34;\n#define TEST_ATTR2 &#34;MAA=\\0&#34;\n#define TEST_ATTR7 &#34;MA==\\0&#34;\n#define TEST_ATTR2_POP &#34;MAsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR8 &#34;MAthisis badsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR3 &#34;MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR4_122 &#34;MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR4_122POP &#34;MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR5_117 &#34;MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR5_117POP &#34;MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0&#34;\n#define TEST_ATTR6_116 &#34;MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR_244 &#34;MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR_245 &#34;MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0&#34;\n#define TEST_ATTR_250 &#34;MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR_250POP &#34;MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0&#34;\n#define TEST_ALL_ATTR &#34;MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0&#34;\n#define TEST_1024_NOPOP &#34;MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n\n#define TEST_1025_NOPOP &#34;MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_1024_POP &#34;MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n\n#define TEST_LONG_ATTR &#34;MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0&#34;\n\n#define EST_UT_MAX_CMD_LEN 255\nextern EST_CTX *ectx;\n\nstatic void us900_clean (void)\n{\n}\n\nstatic int us900_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US900_SERVER_PORT,\n                  US900_SERVER_CERTKEY,\n                  US900_SERVER_CERTKEY,\n                  &#34;US900 test realm&#34;,\n                  US900_CACERTS,\n                  US900_TRUST_CERTS,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  0,\n                  nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us900_init_suite (void)\n{\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(&#34;Starting EST Server CSR attributes unit tests.\\n&#34;);\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(\n        cmd,\n        EST_UT_MAX_CMD_LEN,\n        &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;,\n        CLIENT_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us900_clean();\n\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us900_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us900_destroy_suite (void)\n{\n    st_stop();\n    SLEEP(2);\n    return 0;\n}\n\nstatic unsigned char * handle_correct_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR1);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_corrupt_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR8);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_short_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR7);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_long_csrattrs_request (int *csr_len,\n                                                     char *path_seg,\n                                                     void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_LONG_ATTR);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_nopop_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR_NOPOP);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_empty_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = 0;\n    csr_data = NULL;\n    return (csr_data);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the est_server_init_csrattrs() API.\n */\nstatic void us900_test1 (void)\n{\n    int rc;\n\n    LOG_FUNC_NM\n    ;\n\n    /* NULL ctx - should fail */\n    rc = est_server_init_csrattrs(NULL, &#34;US900 test1&#34;, 10);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* NULL string - should pass */\n    rc = est_server_init_csrattrs(ectx, NULL, 10);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Zero length - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, 0);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Length too long - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, MAX_CSRATTRS + 1);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the smallest base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting an illegally small base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR7, strlen(TEST_ATTR7));\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* enable PoP */\n    st_enable_pop();\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n}\n\n/*\n * Test2 - exercise the server side variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us900_test2 (void)\n{\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n    int csr_len;\n    unsigned char *csr_data = NULL;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US900_SERVER_IP, US900_SERVER_PORT, NULL);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ctx, &amp;retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* should get 204 with no data */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_corrupt_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_short_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_long_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_correct_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2));\n    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR3));\n    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));\n    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Enable PoP and test responses with PoP added */\n    st_enable_pop();\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_data != NULL);\n    CU_ASSERT(csr_len = 20);\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_POP));\n    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));\n    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_correct_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_nopop_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_empty_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));\n    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1025_NOPOP,\n        strlen(TEST_1025_NOPOP));\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us900_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us900_srv_csrattrs&#34;,\n            us900_init_suite,\n            us900_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;CSR Server Attributes API1&#34;, us900_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;CSR Server Attributes API2&#34;, us900_test2)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us896.c&#39;: [&#39;/*------------------------------------------------------------------\n * us896.c - Unit Tests for User Story 896 - Client CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#ifndef WIN32\n#define CLIENT_UT_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US896_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US896_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US896_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else \n#define CLIENT_UT_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US896_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US896_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US896_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif \n\n#define CLIENT_UT_PUBKEY &#34;./est_client_ut_keypair&#34;\n#define US896_SERVER_PORT   29896\n#define US896_SERVER_IP     &#34;127.0.0.1&#34; \n#define TEST_SHORT_ATTR &#34;M==\\0&#34;\n#define TEST_LONG_ATTR &#34;MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0&#34;\n#define TEST_CORRUPT_ATTR1 &#34;MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOIExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n#define TEST_CORRUPT_ATTR2 &#34;MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFM12345TIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0&#34;\n\n#define EST_UT_MAX_CMD_LEN 255\n\nstatic void us896_clean(void) {\n}\n\nstatic int us896_start_server(int manual_enroll, int nid) {\n    int rv;\n\n    rv = st_start(US896_SERVER_PORT,\n    US896_SERVER_CERTKEY,\n    US896_SERVER_CERTKEY, &#34;US896 test realm&#34;,\n    US896_CACERTS,\n    US896_TRUST_CERTS, &#34;CA/estExampleCA.cnf&#34;, manual_enroll, 0, nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us896_init_suite(void) {\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(&#34;Starting EST Server CSR attributes unit tests.\\n&#34;);\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n            &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;,\n            CLIENT_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us896_clean();\n\n    /*\n     * Start an instance of the EST server \n     */\n    rv = us896_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us896_destroy_suite(void) {\n    st_stop();\n    SLEEP(2);\n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error) {\n    BIO *bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n            &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n            __FUNCTION__, openssl_cert_error,\n            X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the est_client_get_csrattrs() API.\n */\nstatic void us896_test1(void) {\n    int rc;\n    unsigned char *csr_data;\n    int csr_len;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, NULL, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, NULL);\n    CU_ASSERT(rc != EST_ERR_NONE);\n\n}\n\n/*\n * Test2 - exercise the response  variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us896_test2(void) {\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY *priv_key;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n            client_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US896_SERVER_IP, US896_SERVER_PORT, NULL);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ctx, &amp;retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ctx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    /* \n     * All of these are negative tests and require that code in the\n     * EST server is modified such that it will allow bad/corrupted\n     * attributes to be initialized so they can be sent to the client.\n     */\n#ifdef NEGATIVE_UNIT_TEST\n    unsigned char *csr_data;\n    int csr_len;\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR1, strlen(TEST_CORRUPT_ATTR1));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_CORRUPT_ATTR2, strlen(TEST_CORRUPT_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_SHORT_ATTR, strlen(TEST_SHORT_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    rc = est_server_init_csrattrs(ectx, TEST_LONG_ATTR, strlen(TEST_LONG_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n#endif\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us896_add_suite(void) {\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us896_client_csrattrs&#34;,\n            us896_init_suite,\n            us896_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;CSR Client Attributes API1&#34;, us896_test1)) ||\n            (NULL == CU_add_test(pSuite, &#34;CSR Client Attributes API2 &#34;, us896_test2)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us894.c&#39;: [&#39;/*------------------------------------------------------------------\n * us894.c - Unit Tests for User Story 894 - Proxy cacerts\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n *\n *  Proxy mode is primarily server mode where the processing of certain\n *  requests from clients are passed long to the upstream server using\n *  client mode functionality.  In the case of Get CACerts, proxy mode\n *  functions almost identically as server mode.  The CA certs response\n *  chain is passed in and is then sent in reply to the Get CACerts\n *  requests from downstream clients.\n *\n *  This test code is taken largely from US901, Server Get CACerts,\n *\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#define US894_PKCS10_REQ    &#34;MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n&#34;\n#define US894_PKCS10_CT     &#34;Content-Type: application/pkcs10&#34; \n#define US894_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n#define US894_UIDPWD_BAD    &#34;estuser:bogus&#34;\n#ifndef WIN32\n#define US894_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US894_TRUSTED_CERT  &#34;CA/trustedcerts.crt&#34;\n#define US894_TRUSTED_CERT_AND_CRL &#34;US894/trustedcertsandcrl.crt&#34;\n#define US894_EXPLICIT_CERT &#34;US894/explicit-cert.pem&#34; \n#define US894_EXPLICIT_KEY &#34;US894/explicit-key.pem&#34;\n#define US894_IMPLICIT_CERT &#34;US894/implicit-cert.pem&#34; \n#define US894_IMPLICIT_KEY &#34;US894/implicit-key.pem&#34;\n#define US894_REVOKED_CERT &#34;US894/revoked-cert.pem&#34; \n#define US894_REVOKED_KEY &#34;US894/revoked-key.pem&#34;\n#define US894_SELFSIGN_CERT &#34;US894/selfsigned-cert.pem&#34; \n#define US894_SELFSIGN_KEY &#34;US894/selfsigned-key.pem&#34;\n#define US894_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US894_EXTCERT &#34;CA/extCA/cacert.crt&#34;\n#define US894_SERVER_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US894_SERVER_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US894_PROXY_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;  // change these other to dedicated ones\n#define US894_PROXY_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\nstatic char test5_outfile[FILENAME_MAX] = &#34;US894/test5.crt&#34;;\nstatic char test26_outfile[FILENAME_MAX] = &#34;US894/test26.crt&#34;;\nstatic char test27_outfile[FILENAME_MAX] = &#34;US894/test27.crt&#34;;\n#else\n#define US894_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US894_TRUSTED_CERT &#34;CA\\\\trustedcerts.crt&#34;\n#define US894_TRUSTED_CERT_AND_CRL  &#34;US894\\\\trustedcertsandcrl.crt&#34;\n#define US894_EXPLICIT_CERT &#34;US894\\\\explicit-cert.pem&#34; \n#define US894_EXPLICIT_KEY &#34;US894\\\\explicit-key.pem&#34;\n#define US894_IMPLICIT_CERT &#34;US894\\\\implicit-cert.pem&#34; \n#define US894_IMPLICIT_KEY &#34;US894\\\\implicit-key.pem&#34;\n#define US894_REVOKED_CERT &#34;US894\\\\revoked-cert.pem&#34; \n#define US894_REVOKED_KEY &#34;US894\\\\revoked-key.pem&#34;\n#define US894_SELFSIGN_CERT &#34;US894\\\\selfsigned-cert.pem&#34; \n#define US894_SELFSIGN_KEY &#34;US894\\\\selfsigned-key.pem&#34;\n#define US894_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US894_EXTCERT &#34;CA\\\\extCA\\\\cacert.crt&#34;\n#define US894_SERVER_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US894_SERVER_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US894_PROXY_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;  // change these other to dedicated ones\n#define US894_PROXY_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n\nstatic char test5_outfile[FILENAME_MAX] = &#34;US894\\\\test5.crt&#34;;\nstatic char test26_outfile[FILENAME_MAX] = &#34;US894\\\\test26.crt&#34;;\nstatic char test27_outfile[FILENAME_MAX] = &#34;US894\\\\test27.crt&#34;;\n#endif\n\n/* #define US894_TCP_SERVER_PORT_BASIC     12894 */\n#define US894_ENROLL_URL &#34;https://127.0.0.1:16894/.well-known/est/simpleenroll&#34;\n#define US894_CACERT_URL &#34;https://127.0.0.1:16894/.well-known/est/cacerts&#34;\n/* #define US894_TCP_SERVER_PORT_DIGEST    13894 */\n/* #define US894_TCP_SERVER_PORT_HTTP_DISABLE 14894 */\n#define US894_TCP_SERVER_PORT       15894\n#define US894_TCP_PROXY_PORT        16894\n\nstatic void us894_clean (void)\n{\n    char cmd[200];\n#ifndef WIN32\n    sprintf(cmd, &#34;rm %s&#34;, test5_outfile);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, test26_outfile);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, test27_outfile);\n    system(cmd);\n#else\n    sprintf(cmd, &#34;del %s&#34;, test5_outfile);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, test26_outfile);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, test27_outfile);\n    system(cmd);\n#endif\n}\n\nint us894_start_server ()\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US894_TCP_SERVER_PORT,\n                  US894_SERVER_CERT,\n                  US894_SERVER_KEY,\n                  &#34;estrealm&#34;,\n                  US894_CACERT,\n                  US894_TRUSTED_CERT,\n                  &#34;US894/estExampleCA.cnf&#34;,\n                  0,  // manual enroll\n                  0,  // disable PoP\n                  0); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us894_init_suite (void)\n{\n    int rv;\n\n    us894_clean();\n\n    printf(&#34;\\nStarting EST Proxy Get CACerts unit tests.\\n&#34;);\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us894_start_server();\n\n    return rv;\n}\n\nvoid us894_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us894_destroy_suite (void)\n{\n    us894_stop_server();\n    printf(&#34;Completed EST Proxy Get CACerts unit tests.\\n&#34;);\n    return 0;\n}\n\n/*\n * HTTP Basic auth\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST proxy/server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n */\nstatic void us894_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * HTTP Basic Auth failure, Bad Password\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST proxy/server,\n * while using a bogus password.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n */\nstatic void us894_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * HTTP Digest Auth\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST proxy/server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.\n *\n * This test also tests the correct operation of est_proxy_set_auth()\n */\nstatic void us894_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_set_auth(AUTH_DIGEST);\n    SLEEP(1);\n\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_DIGEST,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n\n    st_proxy_set_auth(AUTH_BASIC);\n}\n\n/*\n * HTTP Digest Auth fail\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST proxy/server.\n * This is the negative test case for Digest auth.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST proxy/server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us894_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_set_auth(AUTH_DIGEST);\n    SLEEP(1);\n\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_BAD, US894_CACERTS, CURLAUTH_DIGEST,\n                        NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 401);\n\n    st_proxy_set_auth(AUTH_BASIC);\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\n/*\n * This test case does a simple cacerts request\n * and looks for the HTTP 200 response code.\n */\nstatic void us894_test5 (void)\n{\n    long rv;\n    char cmd[200];\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &amp;write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(\n        cmd,\n        &#34;openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs&#34;,\n        test5_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n}\n\nstatic void us894_test_sslversion (const SSL_METHOD *m, int expect_fail)\n{\n    BIO *conn;\n    SSL *ssl;\n    SSL_CTX *ssl_ctx = NULL;\n    int rv;\n\n    ssl_ctx = SSL_CTX_new(m);\n    CU_ASSERT(ssl_ctx != NULL);\n\n    /*\n     * Now that the SSL context is ready, open a socket\n     * with the server and bind that socket to the context.\n     */\n    conn = open_tcp_socket_ipv4(&#34;127.0.0.1&#34;, &#34;16894&#34;);\n    CU_ASSERT(conn != NULL);\n\n    /*\n     * Create an SSL session context\n     */\n    ssl = SSL_new(ssl_ctx);\n    SSL_set_bio(ssl, conn, conn);\n\n    /*\n     * Now that we have everything ready, let\&#39;s initiate the TLS\n     * handshake.\n     */\n    rv = SSL_connect(ssl);\n    if (!expect_fail) {\n        CU_ASSERT(rv &gt; 0);\n    } else {\n        CU_ASSERT(rv &lt;= 0);\n    }\n\n    /*\n     * Cleanup all the data\n     */\n    SSL_shutdown(ssl);\n    SSL_free(ssl);\n    SSL_CTX_free(ssl_ctx);\n\n}\n\n/*\n * This test attempts to create a SSL 3.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us894_test6 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(SSLv3_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us894_test7 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.1 connection\n * with the EST server.  This should succeed.\n */\nstatic void us894_test8 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_1_client_method(), 0);\n}\n\n/*\n * This test attempts to create a TLS 1.2 connection\n * with the EST server.  This should succeed.\n */\nstatic void us894_test9 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us894_test_sslversion(TLSv1_2_client_method(), 0);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. This should succeed.\n */\nstatic void us894_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_EXPLICIT_CERT,\n    US894_EXPLICIT_KEY,\n    US894_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentication is working.\n * The certificate used is signed by the implicit cert\n * chain. This should succeed.\n */\nstatic void us894_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_IMPLICIT_CERT,\n    US894_IMPLICIT_KEY,\n    US894_CACERTS, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n}\n\n/*\n * This test attempts to use a revoked client certificate to\n * verify CRL checks are working in the TLS layer.\n * This should fail.\n */\nstatic void us894_test12 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_stop();\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        US894_CACERT,\n                        US894_TRUSTED_CERT_AND_CRL,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_REVOKED_CERT,\n    US894_REVOKED_KEY,\n    US894_CACERTS,\n    NULL);\n\n\n    /*\n     * Since the client cert has been revoked the TLS handshake\n     * will fail.  The EST server should return a 401 response.\n     */\n    CU_ASSERT(rv == 0);\n\n    st_proxy_stop();\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n}\n\n/*\n * This test attempts to use a self-signed client certificate to\n * verify cert chain will reject a cert that has not been\n * signed by a valid CA.  This should fail.\n */\nstatic void us894_test13 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US894_ENROLL_URL,\n    US894_PKCS10_CT,\n    US894_PKCS10_REQ,\n    US894_SELFSIGN_CERT,\n    US894_SELFSIGN_KEY,\n    US894_CACERTS, NULL);\n\n    /*\n     * Since the client cert is not signed by either the local CA\n     * or external CA, the TLS handshake will fail.\n     * We will not receive an HTTP status message\n     * from the server.\n     */\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * TLS anonymous cipher suites disabled\n *\n * This test case uses libcurl to test that the\n * EST server will not accept anonymous cipher\n * suites from the client.  We only test a single\n * cipher suite here.  This attempts to do a\n * simple enroll with the server.\n */\nstatic void us894_test14 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        &#34;ADH-AES128-SHA256&#34;, NULL, NULL);\n    /*\n     * TLS handshake should have failed, curl should return 0\n     */\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Null HTTP realm when initializing server\n */\nstatic void us894_test15 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL realm\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         NULL,\n                         x,\n                         priv_key,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate when initializing server\n */\nstatic void us894_test16 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *keyin;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL server key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         &#34;testrealm&#34;,\n                         NULL,\n                         priv_key,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n    CU_ASSERT(ctx == NULL);\n\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate private key when initializing server\n */\nstatic void us894_test17 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin;\n    X509 *x;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Attempt to init EST proxy using NULL private key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         &#34;testrealm&#34;,\n                         x,\n                         NULL,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n}\n\n/*\n * Null trusted CA chain when initializing server\n */\nstatic void us894_test18 (void)\n{\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL local CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(NULL,\n                         0,\n                         NULL,\n                         0,\n                         EST_CERT_FORMAT_PEM,\n                         &#34;testrealm&#34;,\n                         x,\n                         priv_key,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Corrupted CA chain when initializing server\n */\nstatic void us894_test19 (void)\n{\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy a corrupted CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init((unsigned char*) &#34;Bogus CA chain&#34;,\n                         14,\n                         (unsigned char*) &#34;Bogus CA chain&#34;,\n                         14,\n                         EST_CERT_FORMAT_PEM,\n                         &#34;testrealm&#34;,\n                         x,\n                         priv_key,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * This test case attempts simple cacerts request using\n * POST instead of GET.  It should fail.\n */\nstatic void us894_test20 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_post(US894_CACERT_URL, US894_PKCS10_CT, US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD, US894_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Valid HTTP authentication credentials are\n * also provided.  This should succeed.\n */\nstatic void us894_test21 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US894_ENROLL_URL,\n                                US894_PKCS10_CT,\n                                US894_PKCS10_REQ,\n                                US894_UIDPWD_GOOD,\n                                US894_EXPLICIT_CERT,\n                                US894_EXPLICIT_KEY,\n                                US894_CACERTS, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Invalid HTTP authentication credentials are\n * also provided.  This should fail with a 401 response.\n */\nstatic void us894_test22 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US894_ENROLL_URL,\n                                US894_PKCS10_CT,\n                                US894_PKCS10_REQ,\n                                US894_UIDPWD_BAD,\n                                US894_EXPLICIT_CERT,\n                                US894_EXPLICIT_KEY,\n                                US894_CACERTS,\n                                NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n}\n\n/*\n * This test attempts to enroll without using a certificate\n * to identity the client, while using a good user ID/pwd.\n * However, the EST server is setup to only perform\n * certificate authentication (HTTP auth disabled).\n * This should fail with a 401 response.\n */\nstatic void us894_test23 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = st_proxy_http_disable(1);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n\n    SLEEP(1);\n    rv = curl_http_post(US894_ENROLL_URL,\n                        US894_PKCS10_CT,\n                        US894_PKCS10_REQ,\n                        US894_UIDPWD_GOOD,\n                        US894_CACERTS,\n                        CURLAUTH_BASIC,\n                        NULL,\n                        NULL,\n                        NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n\n    rv = st_proxy_http_disable(0);\n    if (rv == -1) {\n        printf(&#34;Could not set HTTP authentication callback\\n&#34;);\n        return;\n    }\n\n}\n\n/*\n * Test the parameters of est_proxy_set_server()\n */\nstatic void us894_test24 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in proxy mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(\n        cacerts,\n        cacerts_len,\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        &#34;testrealm&#34;,\n        x,\n        priv_key,\n        &#34;estuser&#34;,\n        &#34;estpwd&#34;);\n\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_proxy_set_server(NULL, &#34;127.0.0.1&#34;, 8080);\n    CU_ASSERT(est_rv == EST_ERR_NO_CTX);\n\n    est_rv = est_proxy_set_server(ctx, NULL, 8080);\n    CU_ASSERT(est_rv == EST_ERR_INVALID_SERVER_NAME);\n\n    est_rv = est_proxy_set_server(ctx, &#34;127.0.0.1&#34;, 65536);\n    CU_ASSERT(est_rv == EST_ERR_INVALID_PORT_NUM);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Test the parameters of est_proxy_set_auth_mode()\n */\nstatic void us894_test25 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in proxy mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(cacerts,\n                         cacerts_len,\n                         cacerts,\n                         cacerts_len,\n                         EST_CERT_FORMAT_PEM,\n                         &#34;testrealm&#34;,\n                         x,\n                         priv_key,\n                         &#34;estuser&#34;,\n                         &#34;estpwd&#34;);\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_NONE);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_proxy_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_proxy_set_auth_mode(ctx, 0xffffffff);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n\n    est_rv = est_proxy_set_auth_mode(NULL, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NO_CTX);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Test the optional setting of the CA Certs response chain in est_proxy_init()\n * test passthrough (cache disabled) mode of the CA Certs response chain.\n */\nstatic void us894_test26 (void)\n{\n    long rv;\n    char cmd[200];\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_stop();\n    SLEEP(1);\n\n    /*\n     * restart the proxy without passing the ca certs response change parameter\n     * param 5\n     */\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        NULL,\n                        US894_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n\n    outfile = fopen(test26_outfile, &#34;w&#34;);\n    rv = curl_http_get(US894_CACERT_URL, US894_CACERTS, &amp;write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(\n        cmd,\n        &#34;openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs&#34;,\n        test26_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * restart the proxy and include the CA Cert response chain\n     */\n    st_proxy_stop();\n    SLEEP(1);\n    rv = st_proxy_start(US894_TCP_PROXY_PORT,\n                        US894_PROXY_CERT,\n                        US894_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        US894_CACERT,\n                        US894_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US894_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        0);  // ecdhe nid info\n    SLEEP(1);\n}\n\n/*\n * Test the passing of bad userid/password values to est_proxy_init to make sure\n * they\&#39;re error checked.\n */\nstatic void us894_test27 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US894_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US894_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US894_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST proxy using NULL userid\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_proxy_init(\n        cacerts,\n        cacerts_len,\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        &#34;estrealm&#34;,\n        x,\n        priv_key,\n        NULL,\n        &#34;estpwd&#34;);\n\n    CU_ASSERT(ctx == NULL);\n\n    ctx =\n            est_proxy_init(\n                cacerts,\n                cacerts_len,\n                cacerts,\n                cacerts_len,\n                EST_CERT_FORMAT_PEM,\n                &#34;estrealm&#34;,\n                x,\n                priv_key,\n                &#34;bad_userid_too_long_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#34;,\n                &#34;estpwd&#34;);\n\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us894_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us894_proxy_cacerts&#34;,\n            us894_init_suite,\n            us894_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, &#34;HTTP Basic Auth&#34;, us894_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;HTTP Basic Auth Fail&#34;, us894_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;HTTP Digest Auth&#34;, us894_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;HTTP Digest Auth Fail&#34;, us894_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;Get CA Certificates&#34;, us894_test5)) ||\n        (NULL == CU_add_test(pSuite, &#34;SSL 3.0 Fail&#34;, us894_test6)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS 1.0 Fail&#34;, us894_test7)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS 1.1&#34;, us894_test8)) ||\n        (NULL == CU_add_test(pSuite, &#34;TLS 1.2&#34;, us894_test9)) ||\n        (NULL == CU_add_test(pSuite, &#34;Certificate auth - explicit cert chain&#34;, us894_test10)) ||\n        (NULL == CU_add_test(pSuite, &#34;Certificate auth - implicit cert chain&#34;, us894_test11)) ||\n        (NULL == CU_add_test(pSuite, &#34;Certificate auth - revoked cert&#34;, us894_test12)) ||\n        (NULL == CU_add_test(pSuite, &#34;Certificate auth - self-signed cert&#34;, us894_test13)) ||\n        (NULL == CU_add_test(pSuite, &#34;Anon cipher suite disabled&#34;, us894_test14)) ||\n        (NULL == CU_add_test(pSuite, &#34;NULL Realm&#34;, us894_test15)) ||\n        (NULL == CU_add_test(pSuite, &#34;NULL server cert&#34;, us894_test16)) ||\n        (NULL == CU_add_test(pSuite, &#34;NULL server key&#34;, us894_test17)) ||\n        (NULL == CU_add_test(pSuite, &#34;NULL local CA chain&#34;, us894_test18)) ||\n        (NULL == CU_add_test(pSuite, &#34;Corrupted local CA chain&#34;, us894_test19)) ||\n        (NULL == CU_add_test(pSuite, &#34;HTTP POST cacerts&#34;, us894_test20)) ||\n        (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - good HTTP auth/good Cert&#34;, us894_test21)) ||\n        (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - bad HTTP auth/good Cert&#34;, us894_test22)) ||\n        (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - no HTTP auth/no Cert&#34;, us894_test23)) ||\n        (NULL == CU_add_test(pSuite, &#34;Set Server Invalid parameters&#34;, us894_test24)) ||\n        (NULL == CU_add_test(pSuite, &#34;Set Auth Mode Invalid parameters&#34;, us894_test25)) ||\n        (NULL == CU_add_test(pSuite, &#34;Optional CA Chain Response&#34;, us894_test26)) ||\n        (NULL == CU_add_test(pSuite, &#34;Bad userid/password for proxy init&#34;, us894_test27)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us1005.c&#39;: [&#39;/*------------------------------------------------------------------\n * us1005.c - Unit Tests for User Story 1005 - Client easy provision\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#ifdef WIN32\nstatic CRITICAL_SECTION logger_critical_section;\n#endif \n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1005_SERVER_PORT      31005\n#define US1005_SERVER_IP    &#34;127.0.0.1&#34; \n#define US1005_UID          &#34;estuser&#34;\n#define US1005_PWD          &#34;estpwd&#34;\n#ifndef WIN32\n#define US1005_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US1005_TRUST_CERTS      &#34;CA/trustedcerts.crt&#34;\n#define US1005_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1005_CLIENT_KEY       &#34;US1005/implicit-key.pem&#34;\n#define US1005_CLIENT_CERT      &#34;US1005/implicit-cert.pem&#34;\n#else\n#define US1005_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1005_TRUST_CERTS      &#34;CA\\\\trustedcerts.crt&#34;\n#define US1005_SERVER_CERTKEY   &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1005_CLIENT_KEY       &#34;US1005\\\\implicit-key.pem&#34;\n#define US1005_CLIENT_CERT      &#34;US1005\\\\implicit-cert.pem&#34;\n#endif \n#define US1005_CSR_NOPOP        &#34;MBQGBysGAQEBARYGCWCGSAFlAwQCAg==\\0&#34;\n\nstatic char *log_search_target = NULL;\nstatic int search_target_found = 0;\n/*\n * This is a simple callback used to override the default\n * logging facility in libest.  We\&#39;ll use this to look\n * for specific debug output.\n */\nstatic void us1005_logger_stderr (char *format, va_list l)\n{\n    char t_log[1024];\n#ifndef WIN32\n    flockfile(stderr);\n#else\n    EnterCriticalSection(&amp;logger_critical_section);\n#endif \n    if (log_search_target) {\n        vsnprintf(t_log, 1024, format, l);\n        if (strstr(t_log, log_search_target)) {\n            search_target_found = 1;\n        }\n        fprintf(stderr, &#34;%s&#34;, t_log);\n    } else {\n        vfprintf(stderr, format, l);\n    }\n    fflush(stderr);\n#ifndef WIN32\n    funlockfile(stderr);\n#else\n    LeaveCriticalSection(&amp;logger_critical_section);\n#endif \n}\n\nstatic void us1005_clean (void)\n{\n}\n\nstatic int us1005_start_server (int manual_enroll, int nid, int no_http_auth,\n                                int enable_pop)\n{\n    int rv;\n\n    rv = st_start(US1005_SERVER_PORT,\n                  US1005_SERVER_CERTKEY,\n                  US1005_SERVER_CERTKEY,\n                  &#34;US1005 test realm&#34;,\n                  US1005_CACERTS,\n                  US1005_TRUST_CERTS,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  enable_pop,\n                  nid);\n\n    if (no_http_auth) {\n        st_disable_http_auth();\n    }\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1005_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    /* Initialize critical section on Windows*/\n    InitializeCriticalSection(&amp;logger_critical_section);\n#endif \n\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us1005_logger_stderr);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1005_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us1005_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1005_start_server(0, 0, 0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1005_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function performs the easy provision operation using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us1005_easy_provision (char *cn, char *server, int ba_hint,\n                                   int use_cert)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *new_key;\n    int rv;\n    int pkcs7_len = 0;\n    int ca_certs_len = 0;\n    unsigned char *new_cert = NULL;\n    EVP_PKEY *key = NULL;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    X509 *cert = NULL;\n    BIO *in;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    if (use_cert) {\n        /*\n         * Read in the private key\n         */\n        key_len = read_binary_file(US1005_CLIENT_KEY, &amp;key_raw);\n        CU_ASSERT(key_len &gt; 0);\n        key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n        CU_ASSERT(key != NULL);\n        free(key_raw);\n\n        /*\n         * Read in the old cert\n         */\n        cert_len = read_binary_file(US1005_CLIENT_CERT, &amp;cert_raw);\n        CU_ASSERT(cert_len &gt; 0);\n        in = BIO_new_mem_buf(cert_raw, cert_len);\n        CU_ASSERT(in != NULL);\n        if (!in)\n            return;\n        cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n        CU_ASSERT(cert != NULL);\n        if (!cert)\n            return;\n        BIO_free_all(in);\n        free(cert_raw);\n    }\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    if (ba_hint) {\n        rv = est_client_enable_basic_auth_hint(ectx);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1005_SERVER_PORT, NULL);\n\n    /*\n     * generate a new private key\n     */\n    new_key = generate_private_key();\n    CU_ASSERT(new_key != NULL);\n\n    /*\n     * Attempt to provision a new cert\n     */\n    rv = est_client_provision_cert(ectx, cn, &amp;pkcs7_len, &amp;ca_certs_len,\n        new_key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    EVP_PKEY_free(new_key);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        if (new_cert)\n            free(new_cert);\n    } else {\n        est_destroy(ectx);\n        return;\n    }\n\n    /*\n     * Retrieve a copy of the new CA certs\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(ca_certs_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_cacerts(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n        if (new_cert)\n            free(new_cert);\n    } else {\n        est_destroy(ectx);\n        return;\n    }\n\n    EVP_PKEY_free(key);\n    X509_free(cert);\n\n    /*\n     * Cleanup\n     */\n    est_destroy(ectx);\n}\n\n/*\n * Easy provision - HTTP basic auth, no client cert\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test1 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(&#34;TC1005-1&#34;, US1005_SERVER_IP, 0, 0);\n}\n\n/*\n * Easy provision - with HTTP basic auth hint enabled, no client cert\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(&#34;TC1005-2&#34;, US1005_SERVER_IP, 1, 0);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test3 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(&#34;TC1005-3&#34;, US1005_SERVER_IP, 0, 1);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth hint enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test4 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(&#34;TC1005-4&#34;, US1005_SERVER_IP, 1, 1);\n}\n\n/*\n * Null pointers test\n */\nstatic void us1005_test5 (void)\n{\n    int p7len = 0;\n    int calen = 0;\n    EVP_PKEY *key;\n    int rv;\n    EST_CTX *ectx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a valid context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US1005_UID, US1005_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US1005_SERVER_IP, US1005_SERVER_PORT, NULL);\n\n    /*\n     * Create a valid key pair\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Try with a NULL context\n     */\n    rv = est_client_provision_cert(NULL, &#34;TEST2&#34;, &amp;p7len, &amp;calen, key);\n    CU_ASSERT(rv == EST_ERR_NO_CTX);\n\n    /*\n     * Try with a NULL p7 length\n     */\n    rv = est_client_provision_cert(ectx, &#34;TEST2&#34;, NULL, &amp;calen, key);\n    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * Try with a NULL cacerts length\n     */\n    rv = est_client_provision_cert(ectx, &#34;TEST2&#34;, &amp;p7len, NULL, key);\n    CU_ASSERT(rv == EST_ERR_INVALID_PARAMETERS);\n\n    /*\n     * Try with a NULL key\n     */\n    rv = est_client_provision_cert(ectx, &#34;TEST2&#34;, &amp;p7len, &amp;calen, NULL);\n    CU_ASSERT(rv == EST_ERR_NO_KEY);\n\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n *  Enable pop on server, enable CSR attributes on server w/o challengePassword OID\n */\nstatic void us1005_test6 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to a value that doesn\&#39;t include challengePassword OID\n     */\n    st_set_csrattrs(US1005_CSR_NOPOP);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Client will include challengePassword in CSR\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-6&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, enable CSR attributes on server w/o challengePassword OID\n */\nstatic void us1005_test7 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to a value that doesn\&#39;t include challengePassword OID\n     */\n    st_set_csrattrs(US1005_CSR_NOPOP);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Cert request does not contain PoP\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-7&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Enable pop on server, enable CSR attributes on server w/ challengePassword OID\n */\nstatic void us1005_test8 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Client will include challengePassword in CSR\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-8&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, enable CSR attributes on server w/challengePassword OID\n */\nstatic void us1005_test9 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Client will include challengePassword in CSR\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-9&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Enable pop on server, disable CSR attributes on server\n */\nstatic void us1005_test10 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP enabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 1);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n    st_disable_csr_cb();\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Client will include challengePassword in CSR\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-10&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n/*\n *  Disable pop on server, disable CSR attributes on server\n */\nstatic void us1005_test11 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with PoP disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 0, 0);\n\n    /*\n     * Set the CSR attributes to the default value, which includes challengePassword OID\n     */\n    st_set_csrattrs(NULL);\n    st_disable_csr_cb();\n\n    /*\n     * We will search the debugs for the appropriate output\n     * to confirm the PoP behavior is working as desired.\n     */\n    log_search_target = &#34;Cert request does not contain PoP\\0&#34;;\n    search_target_found = 0;\n\n    /*\n     * Provision a new cert\n     */\n    us1005_easy_provision(&#34;TC1005-11&#34;, US1005_SERVER_IP, 0, 0);\n\n    CU_ASSERT(search_target_found == 1);\n\n    /*\n     * Set the CSR attributes back to default value\n     */\n    st_set_csrattrs(NULL);\n}\n\n//\n// The next two test caes repeate tests 3 &amp; 4 but with\n// HTTP auth disabled on the server.\n//\n\n/*\n * Easy provision - client cert with HTTP basic auth disabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test93 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Restart the server with HTTP auth disabled\n     */\n    st_stop();\n    us1005_start_server(0, 0, 1, 0);\n\n    us1005_easy_provision(&#34;TC1005-93&#34;, US1005_SERVER_IP, 0, 1);\n}\n\n/*\n * Easy provision - client cert with HTTP basic auth hint enabled\n *\n * This is a basic test to perform a a full trusted enroll\n * sequence of /cacerts, /csrattrs, and /simpleenroll using a\n * user ID and password to identify the client to the server.\n * No identity certificate is used by the client.\n */\nstatic void us1005_test94 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    us1005_easy_provision(&#34;TC1005-94&#34;, US1005_SERVER_IP, 1, 1);\n}\n\nint us1005_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us1005_client_easy_provision&#34;,\n            us1005_init_suite,\n            us1005_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * Add the tests to the suite\n     *\n     * ********************IMPORTANT*********************\n     * Do not change the order of these tests.\n     * Some of the tests stop the EST server and restart\n     * it using different certs.  If you change the order\n     * then false negatives may occur.\n     * **************************************************\n     *\n     */\n    if ((NULL == CU_add_test(pSuite, &#34;Easy provision - no cert&#34;, us1005_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;Easy provision - no cert HTTP BA hint&#34;, us1005_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;Easy provision - w/cert&#34;, us1005_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;Easy provision - w/cert HTTP BA hint&#34;, us1005_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;Null pointers&#34;, us1005_test5)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enable PoP - no challengePassword&#34;, us1005_test6)) ||\n        (NULL == CU_add_test(pSuite, &#34;Disable PoP - no challengePassword&#34;, us1005_test7)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enable PoP - w/challengePassword&#34;, us1005_test8)) ||\n        (NULL == CU_add_test(pSuite, &#34;Disable PoP - w/challengePassword&#34;, us1005_test9)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enable PoP - CSR disabled&#34;, us1005_test10)) ||\n        (NULL == CU_add_test(pSuite, &#34;Disable PoP - CSR disabled&#34;, us1005_test11)) ||\n        (NULL == CU_add_test(pSuite, &#34;Easy provision - w/cert no server auth&#34;, us1005_test93)) ||\n        (NULL == CU_add_test(pSuite, &#34;Easy provision - w/cert HTTP BA hint no server auth&#34;, us1005_test94)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us898.c&#39;: [&#39;/*------------------------------------------------------------------\n * us898.c - Unit Tests for User Story 898 - Client re-enroll \n *\n * October, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &lt;est_ossl_util.h&gt;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US898_SERVER_PORT   29898\n#define US898_SERVER_IP\t    &#34;127.0.0.1&#34;\t\n#define US898_UID\t    &#34;estuser&#34;\n#define US898_PWD\t    &#34;estpwd&#34;\n#ifndef WIN32\n#define US898_CACERTS\t    &#34;CA/estCA/cacert.crt&#34;\n#define US898_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US898_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n\n#define US898_TC2_CERT_TXT &#34;US898/tc2-new-cert.txt&#34;\n#define US898_TC2_CERT_B64 &#34;US898/tc2-new-cert.pkcs7b64&#34;\n#define US898_TC2_CERT_PK7 &#34;US898/tc2-new-cert.pkcs7&#34;\n#define US898_TC2_CERT_PEM &#34;US898/tc2-new-cert.pem&#34;\n\n#define US898_TC10_CSR\t&#34;US898/tc10_csr.pem&#34;\n#define US898_TC10_KEY\t&#34;US898/tc10_key.pem&#34;\n#define US898_TC10_CERT\t&#34;US898/tc10_cert.pem&#34;\n\n#define US898_TC11_KEY\t&#34;US898/tc11_key.pem&#34;\n#define US898_TC11_CERT\t&#34;US898/tc11_cert.pem&#34;\n#else\n  #define US898_CACERTS\t    &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US898_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US898_SERVER_CERTKEY   &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n\n#define US898_TC2_CERT_TXT &#34;US898\\\\tc2-new-cert.txt&#34;\n#define US898_TC2_CERT_B64 &#34;US898\\\\tc2-new-cert.pkcs7b64&#34;\n#define US898_TC2_CERT_PK7 &#34;US898\\\\tc2-new-cert.pkcs7&#34;\n#define US898_TC2_CERT_PEM &#34;US898\\\\tc2-new-cert.pem&#34;\n\n#define US898_TC10_CSR\t&#34;US898\\\\tc10_csr.pem&#34;\n#define US898_TC10_KEY\t&#34;US898\\\\tc10_key.pem&#34;\n#define US898_TC10_CERT\t&#34;US898\\\\tc10_cert.pem&#34;\n\n#define US898_TC11_KEY\t&#34;US898\\\\tc11_key.pem&#34;\n#define US898_TC11_CERT\t&#34;US898\\\\tc11_cert.pem&#34;\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us898_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&amp;logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section); \n}\n\n#endif\n\nstatic void us898_clean (void)\n{\n    char cmd[200];\n\n    /*\n     * These are all temporary files created \n     * by the various test cases.\n     */\n#ifndef WIN32\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC2_CERT_PEM);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC10_CERT);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC10_KEY);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US898_TC10_CSR);\n    system(cmd);\n#else\n    sprintf(cmd, &#34;del %s&#34;, US898_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC2_CERT_PEM);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC10_CERT);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC10_KEY);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US898_TC10_CSR);\n    system(cmd);\n#endif \n}\n\n/*\n * This starts an instance of the EST server running on\n * a separate thread.  We use this to test the\n * client side API in this module.\n */\nstatic int us898_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US898_SERVER_PORT, \n\t          US898_SERVER_CERTKEY,\n\t          US898_SERVER_CERTKEY,\n\t          &#34;estrealm&#34;,\n\t          US898_CACERTS,\n\t          US898_TRUST_CERTS,\n\t          &#34;US898/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us898_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us898_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US898_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n\treturn 1;\n    }\n\n    us898_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us898_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us898_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        return (1);\n    }    \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n//    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n\n    BIO_free(bio_err);\n    \n    return approve;\n}    \n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variet of test cases in this module.\n */\nstatic void us898_test1 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) *certs = NULL;\n    int i;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TC-US898-1&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    if (rv != EST_ERR_NONE) return;\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.  \n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out,NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i=OBJ_obj2nid(p7-&gt;type);\n    switch (i) {\n    case NID_pkcs7_signed:\n\tcerts = p7-&gt;d.sign-&gt;cert;\n\tbreak;\n    case NID_pkcs7_signedAndEnveloped:\n\tcerts = p7-&gt;d.signed_and_enveloped-&gt;cert;\n\tbreak;\n    default:\n\tbreak;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs) return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn\&#39;t have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n\n    /* \n     * Wow, that\&#39;s a lot of work, but we finally have the X509.\n     * (don\&#39;t you just love OpenSSL!!!)\n     * Now that we have an X509 representation of the cert,\n     * let\&#39;s try to re-enroll this cert with the CA\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (cert) X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  The expired certs contains\n * several X509 extensions. We verify the new issued\n * cert preserves these extensions using grep.  Note, \n * preserving these extensions requires the OpenSSL CA\n * to enable the &#34;copy_extensions&#34; knob in the OpenSSL\n * config file.  This is why this test suite uses a\n * unique copy of estExampleCA.cnf.\n */\nstatic void us898_test2 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    BIO *in;\n    char cmd[200];\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-expired.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Save the cert to a local file\n     */\n    rv = write_binary_file(US898_TC2_CERT_B64, new_cert, pkcs7_len);\n    CU_ASSERT(rv == 1);\n\n    /*\n     * Base 64 decode the cert response\n     */\n    sprintf(cmd, &#34;openssl base64 -d -in %s -out %s&#34;, US898_TC2_CERT_B64, US898_TC2_CERT_PK7);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert the pkcs7 cert to a PEM cert\n     */\n    sprintf(cmd, &#34;openssl pkcs7 -in %s -inform DER -print_certs -out %s&#34;, US898_TC2_CERT_PK7, US898_TC2_CERT_PEM);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert PEM cert to a textual representation of the cert\n     */\n    sprintf(cmd, &#34;openssl x509 -text -in %s &gt; %s&#34;, US898_TC2_CERT_PEM, US898_TC2_CERT_TXT);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the jimbob DNS extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, &#34;jimbob&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the bobcat DNS extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, &#34;bobcat&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the IP address extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT,&#34;172&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the Repudiation key usage extension was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT,&#34;Repudiation&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the public key was preserved\n     */\n    rv = grep(US898_TC2_CERT_TXT, &#34;00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Clean up\n     */\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Test the re-enroll API to ensure it gracefully\n * handles a null X509 cert pointer.\n */\nstatic void us898_test3 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int pkcs7_len = 0;\n    int rv;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * re-enroll using a null x509 pointer.\n     */\n    rv = est_client_reenroll(ectx, NULL, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NO_CERT);\n\n    /*\n     * Clean up\n     */\n    EVP_PKEY_free(key);\n    est_destroy(ectx);\n}\n\n/*\n * Test the re-enroll API to ensure it gracefully\n * handles a null EVP_PKEY pointer.\n */\nstatic void us898_test4 (void) \n{\n    EST_CTX *ectx;\n    int pkcs7_len = 0;\n    int rv;\n    X509 *cert = NULL;\n    unsigned char *cert_raw;\n    int cert_len;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in an old cert that we can use for re-enroll\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * re-enroll using a null EVP_KEY pointer.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, NULL);\n    CU_ASSERT(rv == EST_ERR_NO_KEY);\n\n    /*\n     * Clean up\n     */\n    X509_free(cert);\n    est_destroy(ectx);\n}\n\n/*\n * This test attempts to re-enroll a corrupted cert\n * The public key in the cert is has been corrupted.\n */\nstatic void us898_test5 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-corrupt.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-corrupt.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CLIENT_INVALID_KEY);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured for manual\n * approval.  The server will send back a retry-after\n * response.\n */\nstatic void us898_test6 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n\n    /*\n     * Restart the server with manual approval enabled\n     */\n    rv = us898_start_server(1, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-expired.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n\n    /*\n     * Restart the server with manual approval disabled\n     */\n    rv = us898_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Verify that a bogus user ID/password fails when\n * using HTTP basic auth.\n */\nstatic void us898_test7 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, &#34;hoagie&#34;, &#34;chili&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-expired.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    est_destroy(ectx);\n}\n\n/*\n * Verify that a good user ID/password passes when\n * using HTTP digest auth.\n */\nstatic void us898_test8 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Enable HTTP digest authentication\n     */\n    st_enable_http_digest_auth();\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-expired.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable HTTP basic authentication\n     */\n    st_enable_http_basic_auth();\n\n}\n\n/*\n * Verify that a bogus user ID/password fails when\n * using HTTP digest auth.\n */\nstatic void us898_test9 (void) \n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    int http_status;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Enable HTTP digest authentication\n     */\n    st_enable_http_digest_auth();\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, &#34;jdoe&#34;, &#34;panthers&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(&#34;US898/key-expired.pem&#34;, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(&#34;US898/cert-expired.pem&#34;, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    /*\n     * Check the HTTP status code from the reenroll operation\n     */\n    http_status = est_client_get_last_http_status(ectx);\n    CU_ASSERT(http_status == 401);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable HTTP basic authentication\n     */\n    st_enable_http_basic_auth();\n\n}\n\n/*\n * Verify the server fails authentication when the\n * client sends a valid identity cert but doesn\&#39;t \n * provide HTTP auth credentials.\n */\nstatic void us898_test10 (void) \n{\n    char cmd[200];\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a CSR\n     */\n    sprintf(cmd, &#34;openssl req -new -nodes -out %s -newkey rsa:2048 -keyout %s -subj /CN=127.0.0.1 &#34;\n\t    &#34;-config CA/estExampleCA.cnf&#34;, \n\t    US898_TC10_CSR, US898_TC10_KEY);  \n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Sign the CSR using our local CA\n     */\n    sprintf(cmd, &#34;openssl ca -out %s -batch -config CA/estExampleCA.cnf -infiles %s&#34;, \n\t    US898_TC10_CERT, US898_TC10_CSR);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US898_TC10_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US898_TC10_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n\n    /*\n     * Set the authentication mode to use the certificate \n     * No HTTP auth credentials are provided.\n     */\n    rv = est_client_set_auth(ectx, NULL, NULL, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll a cert, should fail because we \n     * didn\&#39;t provide valid HTTP auth credentials\n     */\n    rv = est_client_enroll(ectx, &#34;TC-US898-10&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_AUTH_FAIL);\n\n    /*\n     * Re-Enroll the cert, should work since\n     * we provide a valid cert to identify ourselves\n     * and HTTP auth isn\&#39;t required for re-enroll even when\n     * the server has enabled HTTP auth.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n}\n\n/*\n * Verify the server fails authentication when the\n * client sends an expired identy cert and uses \n * valid HTTP auth credentials.\n */\nstatic void us898_test11 (void) \n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US898_TC11_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US898_TC11_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in) return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert) return; \n    BIO_free_all(in);\n    free(cert_raw);\n\n\n    /*\n     * Set the authentication mode to use the expired certificate \n     * and valid HTTP auth credentials.\n     */\n    rv = est_client_set_auth(ectx, US898_UID, US898_PWD, cert, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US898_SERVER_IP, US898_SERVER_PORT, NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    /*\n     * Re-Enroll the cert \n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_SSL_CONNECT);\n\n    est_destroy(ectx);\n}\n\n\nint us898_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us898_client_reenroll&#34;, \n\t                  us898_init_suite, \n\t\t\t  us898_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* \n    * Add the tests to the suite \n    */\n   if ((NULL == CU_add_test(pSuite, &#34;Simple enroll and re-enroll&#34;, us898_test1)) ||\n       (NULL == CU_add_test(pSuite, &#34;Re-enroll expired cert with extensions&#34;, us898_test2)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll using NULL cert&#34;, us898_test3)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll using NULL key&#34;, us898_test4)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll using corrupted X509 cert&#34;, us898_test5)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll retry-after&#34;, us898_test6)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll invalid UID/PWD Basic&#34;, us898_test7)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll valid UID/PWD Digest&#34;, us898_test8)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll invalid UID/PWD Digest&#34;, us898_test9)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll valid certificate no HTTP auth&#34;, us898_test10)) || \n       (NULL == CU_add_test(pSuite, &#34;Re-enroll expired certificate with HTTP auth&#34;, us898_test11))) \n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us3512.c&#39;: [&#39;/*------------------------------------------------------------------\n * us3512.c - Unit Tests URI path segment support in the Server\n *\n * April, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &#34;../../util/test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n\n#include &#34;../../src/est/est_locl.h&#34;\n\nextern char tst_srvr_path_seg_enroll[];\nextern char tst_srvr_path_seg_cacerts[];\nextern char tst_srvr_path_seg_csrattrs[];\nextern char tst_srvr_path_seg_auth[];\nextern char tst_proxy_path_seg_auth[];\n\nstatic int path_segment_support;\n\n/*\n * max command line length when generating system commands\n */\n#define EST_UT_MAX_CMD_LEN 256\n\n#define US3512_SERVER_PORT      29496\n#define US3512_SERVER_IP        &#34;127.0.0.1&#34;\n#define US3512_UIDPWD_GOOD      &#34;estuser:estpwd&#34;\n#define US3512_UID              &#34;estuser&#34;\n#define US3512_PWD              &#34;estpwd&#34;\n#ifndef WIN32\n#define US3512_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US3512_TRUST_CERTS      &#34;CA/trustedcerts.crt&#34;\n#define US3512_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US3512_PROXY_CERT       &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US3512_PROXY_KEY        &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US3512_CACERT           &#34;CA/estCA/cacert.crt&#34;\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server\&#39;s directory\n */\n/* #define CLIENT_UT_CACERT &#34;../../example/server/estCA/cacert.crt&#34; */\n#define CLIENT_UT_CACERT        &#34;CA/estCA/cacert.crt&#34;\n#define CLIENT_UT_PUBKEY        &#34;./est_client_ut_keypair&#34;\n#else\n#define US3512_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US3512_TRUST_CERTS      &#34;CA/trustedcerts.crt&#34;\n#define US3512_SERVER_CERTKEY   &#34;CA\\\\estCA/private/estservercertandkey.pem&#34;\n#define US3512_PROXY_CERT       &#34;CA\\\\estCA\\\\private/estservercertandkey.pem&#34;\n#define US3512_PROXY_KEY        &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US3512_CACERT           &#34;CA\\\\estCA\\\\cacert.crt&#34;\n/*\n * The CA certificate used to verify the EST server.  Grab it from the server\&#39;s directory\n */\n/* #define CLIENT_UT_CACERT &#34;../../example/server/estCA/cacert.crt&#34; */\n#define CLIENT_UT_CACERT        &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define CLIENT_UT_PUBKEY        &#34;est_client_ut_keypair&#34;\n#endif\n\n#define US3512_ENROLL_URL_BA &#34;https://127.0.0.1:29496/.well-known/est/cacerts-somestring/simpleenroll&#34;\n#define US3512_ENROLL_URL_BA_BACKSLASH &#34;https://127.0.0.1:29496/.well-known/est/cacerts-\\\\somestring/simpleenroll&#34;\n#define US3512_ENROLL_URL_BA_NOSEGMENT &#34;https://127.0.0.1:29496/.well-known/est/simpleenroll&#34;\n#define US3512_PKCS10_CT        &#34;Content-Type: application/pkcs10&#34; \n\n#define US3512_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n#define US3512_TCP_PROXY_PORT       16894\n#define PATH_SEG_VALID    &#34;somestring&#34;\n#define PATH_SEG_TOO_MANY_SEGS    &#34;somestring1/somestring2&#34;\n#define PATH_SEG_IS_OPERATION    &#34;cacerts&#34;\n#define PATH_SEG_CONTAINS_OPERATION    &#34;cacertssomestring&#34;\n#define PATH_SEG_MAX &#34;12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678&#34;\n#define PATH_SEG_TOO_LONG &#34;123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&#34;\n\n#define US3512_PROXY_ENROLL_URL_VALID &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_VALID&#34;/simpleenroll&#34;\n#define US3512_PROXY_ENROLL_URL_TOO_LONG &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_TOO_LONG&#34;/simpleenroll&#34;\n#define US3512_PROXY_ENROLL_URL_MAX &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_MAX&#34;/simpleenroll&#34;\n#define US3512_PROXY_ENROLL_URL_TOO_MANY &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_TOO_MANY_SEGS&#34;/simpleenroll&#34;\n#define US3512_PROXY_ENROLL_URL_IS_OPERATION &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_IS_OPERATION&#34;/simpleenroll&#34;\n#define US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_CONTAINS_OPERATION&#34;/simpleenroll&#34;\n#define US3512_PROXY_CACERTS_URL_VALID &#34;https://127.0.0.1:16894/.well-known/est/&#34;PATH_SEG_VALID&#34;/cacerts&#34;\n\n#define US3512_PKCS10_REQ    &#34;MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n&#34;\n\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error);\n\nstatic void us3512_clean (void)\n{\n}\n\nstatic int us3512_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start_nocacerts(US3512_SERVER_PORT,\n                            US3512_SERVER_CERTKEY,\n                            US3512_SERVER_CERTKEY,\n                            &#34;US3512 test realm&#34;,\n                            US3512_CACERTS,\n                            US3512_TRUST_CERTS,\n                            &#34;CA/estExampleCA.cnf&#34;,\n                            manual_enroll,\n                            0,\n                            nid);\n\n    SLEEP(1);\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start_nocacerts(US3512_TCP_PROXY_PORT,\n                                  US3512_PROXY_CERT,\n                                  US3512_PROXY_KEY,\n                                  &#34;estrealm&#34;,\n                                  US3512_CACERT,\n                                  US3512_TRUST_CERTS,\n                                  &#34;estuser&#34;,\n                                  &#34;estpwd&#34;,\n                                  &#34;127.0.0.1&#34;,\n                                  US3512_SERVER_PORT,\n                                  0,  // disable PoP\n                                  0);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\nstatic int path_seg_supported (void)\n{\n\n    EST_CTX *ectx;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    rc = est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        &#34;test_segment&#34;);\n    if (rc == EST_ERR_NONE) {\n        return 1;\n    } else {\n        return 0;\n    }\n\n    return 0;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.\n * 1. Generate the keypair to be used for this EST Client UT suite\n */\nstatic int us3512_init_suite (void)\n{\n    int rv = 0;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    char cmd[EST_UT_MAX_CMD_LEN];\n    printf(&#34;Starting EST Server path segment unit tests.\\n&#34;);\n\n    if (!path_segment_support) {\n        printf(\n            &#34;URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir \\n&#34;);\n        return 0;\n    }\n\n    /*\n     * gen the keypair to be used for EST Client testing\n     */\n    snprintf(cmd, EST_UT_MAX_CMD_LEN,\n        &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;,\n        CLIENT_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n\n    rv = system(cmd);\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us3512_clean();\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us3512_start_server(0, 0);\n    SLEEP(2);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3512_destroy_suite (void)\n{\n\n    st_stop();\n    st_proxy_stop();\n    return 0;\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Sanity check of the server side path segment processing.\n * - simple enroll\n * - direct to server\n * - with path segment\n * Outcome: pass\n */\nstatic void us3512_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US3512_ENROLL_URL_BA_NOSEGMENT, US3512_PKCS10_CT,\n    US3512_PKCS10_RSA2048,\n    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function performs a basic simple enroll using\n * a UID/PWD to identify the client to the server.  This\n * is used for a variety of test cases in this module.\n */\nstatic void us3512_simple_enroll (char *cn, char *server,\n                                  EST_ERROR expected_enroll_rv,\n                                  char *path_segment)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US3512_SERVER_PORT, path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * taken from US899/test1\n * Simple enroll -  including a path segment in the uri.\n *\n * Path Segment testing\n * - This verifies the client includes a configured\n *   path segment properly and sends it.\n * - This verifies that the server correctly parses out\n *   a valid path segment and passes it up on a simple enroll.\n *\n */\nstatic void us3512_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n    char *path_segment = &#34;path_segment&#34;;\n\n    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    us3512_simple_enroll(&#34;TC3512-2&#34;, US3512_SERVER_IP, EST_ERR_NONE,\n        path_segment);\n\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);\n}\n\n/*\n * taken from US898/test1\n * Simple re-enroll -  including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on a simple re-enroll\n *   as well as the auth callback.\n */\nstatic void us3512_test3 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) * certs = NULL;\n    int i;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    char *path_segment = &#34;path_seg_us3512_test3&#34;;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TC-US898-1&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    if (rv != EST_ERR_NONE)\n        return;\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out, NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i = OBJ_obj2nid(p7-&gt;type);\n    switch (i) {\n    case NID_pkcs7_signed:\n        certs = p7-&gt;d.sign-&gt;cert;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        certs = p7-&gt;d.signed_and_enveloped-&gt;cert;\n        break;\n    default:\n        break;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs)\n        return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn\&#39;t have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * Wow, that\&#39;s a lot of work, but we finally have the X509.\n     * (don\&#39;t you just love OpenSSL!!!)\n     * Now that we have an X509 representation of the cert,\n     * let\&#39;s try to re-enroll this cert with the CA\n     */\n    memset(tst_srvr_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_auth) == 0);\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_enroll) == 0);\n\n    /*\n     * Cleanup\n     */\n    if (cert)\n        X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * taken from US897/test11\n * CAcerts to the server - including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on the CA certs callback.\n */\nstatic void us3512_test4 (void)\n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n\n    char *path_segment = &#34;path_seg_us3512_test4&#34;;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer\&#39;s cal back function\n     */\n    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/*\n * taken from US898/test1\n * CSRAttributes -  including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on a csr attributes callback\n */\nstatic void us3512_test5 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n    char *path_segment = &#34;path_seg_us3512_test5&#34;;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3512_UID, US3512_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_SERVER_PORT,\n        path_segment);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer\&#39;s cal back function\n     */\n    memset(tst_srvr_path_seg_csrattrs, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rv == EST_ERR_NONE);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_csrattrs) == 0);\n\n    /*\n     * Cleanup\n     */\n    if (cert)\n        X509_free(cert);\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Test the flow of path segments through proxy mode - valid path segment\n * SimpleEnroll\n */\nstatic void us3512_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_VALID, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD,\n    US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    CU_ASSERT(strcmp(PATH_SEG_VALID, tst_srvr_path_seg_enroll) == 0);\n\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Test the flow of path segments through proxy mode -\n *  path segment is set to the maximum size\n *\n */\nstatic void us3512_test7 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_MAX, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that is too long, it\n     * should get caught at the proxy and a 400 should be returned\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Test the flow of path segments through proxy mode -\n *  path segment that is too large\n *\n */\nstatic void us3512_test8 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_LONG, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that is too long, it\n     * should get caught at the proxy and a 400 should be returned\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that is an operation path\n *\n */\nstatic void us3512_test9 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_IS_OPERATION, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that is an operation path\n *\n */\nstatic void us3512_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_TOO_MANY, US3512_PKCS10_CT,\n    US3512_PKCS10_REQ, US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL,\n        NULL, NULL);\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Test segment that contains a valid operation string within it,\n * in this case, at the front.  This is a valid path segment, so\n * the test should pass.\n *\n */\nstatic void us3512_test11 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    memset(tst_srvr_path_seg_enroll, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n    memset(tst_proxy_path_seg_auth, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    rv = curl_http_post(US3512_PROXY_ENROLL_URL_CONTAINS_OPERATION,\n    US3512_PKCS10_CT, US3512_PKCS10_REQ,\n    US3512_UIDPWD_GOOD, US3512_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    CU_ASSERT(\n        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_srvr_path_seg_enroll) == 0);\n    CU_ASSERT(\n        strcmp(PATH_SEG_CONTAINS_OPERATION, tst_proxy_path_seg_auth) == 0);\n\n    /*\n     * Since we passed in a path segment that equals an operation we\n     * should get a 400 in return\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * taken from US897/test11\n * CAcerts to the server - including a path segment in the uri.\n *\n * Path Segment testing\n * - Verifies the client includes a configured\n *   path segment\n * - Verifies that the server correctly parses out\n *   a valid path segment and passes it up on the CA certs callback.\n */\nstatic void us3512_test12 (void)\n{\n    EST_CTX *ectx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n\n    unsigned char *retrieved_cacerts = NULL;\n    int retrieved_cacerts_len = 0;\n    EVP_PKEY * priv_key;\n\n    char *path_segment = &#34;path_seg_us3512_test4&#34;;\n\n    SLEEP(1);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(CLIENT_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(CLIENT_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(&#34;\\nError while reading private key file %s\\n&#34;, CLIENT_UT_PUBKEY);\n        return;\n    }\n\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    rc = est_client_set_auth(ectx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ectx, US3512_SERVER_IP, US3512_TCP_PROXY_PORT,\n        path_segment);\n\n    /*\n     * clear out the global that proves that the path segment\n     * made it to the application layer\&#39;s cal back function\n     */\n    memset(tst_srvr_path_seg_cacerts, 0, EST_MAX_PATH_SEGMENT_LEN + 1);\n\n    /*\n     * issue the get ca certs request\n     */\n    rc = est_client_get_cacerts(ectx, &amp;retrieved_cacerts_len);\n    /*\n     * should be successful, and should have obtained a valid buffer\n     * containing the CA certs\n     */\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(retrieved_cacerts_len &gt; 0);\n    /*\n     * verify that the path segment made it all the way to the callback function\n     * at the application layer\n     */\n    CU_ASSERT(strcmp(path_segment, tst_srvr_path_seg_cacerts) == 0);\n\n    retrieved_cacerts = malloc(retrieved_cacerts_len);\n\n    rc = est_client_copy_cacerts(ectx, retrieved_cacerts);\n\n    /*\n     * output the retrieved ca certs and compare to what they should be\n     */\n    if (retrieved_cacerts) {\n\n        printf(&#34;\\nRetrieved CA Certs buffer:\\n %s\\n&#34;, retrieved_cacerts);\n        printf(&#34;Retrieved CA certs buffer length: %d\\n&#34;, retrieved_cacerts_len);\n    }\n    free(retrieved_cacerts);\n\n    if (ectx) {\n        est_destroy(ectx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us3512_add_suite (void)\n{\n    CU_ErrorCode CU_error;\n\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us3512_server_path_seg&#34;,\n            us3512_init_suite,\n            us3512_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /*\n     * check to see if path segment support has been compiled in\n     */\n    if (!path_seg_supported()) {\n        printf(&#34;URI Path Segment is not supported in this build of EST.  Rebuild using --with-uriparser-dir= \\n&#34;);\n        path_segment_support = 0;\n        return 0;\n    }\n    path_segment_support = 1;\n\n    if (path_segment_support) {\n\n        /* add the tests to the suite */\n        /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n        if (\n            (NULL == CU_add_test(pSuite, &#34;EST Client: Simple enroll with no path segment&#34;, us3512_test1)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: Simple Enroll with path segment&#34;, us3512_test2)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: Simple Re-enroll with path segment&#34;, us3512_test3)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: CACerts with path segment&#34;, us3512_test4)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: CSRAttrs with path segment&#34;, us3512_test5)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment&#34;, us3512_test6)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment at the max&#34;, us3512_test7)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment too long&#34;, us3512_test8)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment that is operation&#34;, us3512_test9)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment containing too many segments&#34;, us3512_test10)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment containing an operation&#34;, us3512_test11)) ||\n            (NULL == CU_add_test(pSuite, &#34;EST Server: EST Proxy with path segment valid and cacerts&#34;, us3512_test12))\n            )\n            {\n                CU_error = CU_get_error();\n                printf(&#34;%d\\n&#34;, CU_error);\n\n                CU_cleanup_registry();\n                printf(&#34;%s\\n&#34;, CU_get_error_msg());\n                return CU_get_error();\n            }\n        }\n        return CUE_SUCCESS;\n     #endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us1883.c&#39;: [&#39;/*------------------------------------------------------------------\n * us1883.c - Unit Tests for User Story 1883 - Enable token auth mode for\n *            the EST Client.\n *\n * March, 2015\n *\n * Copyright (c) 2015, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif \n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &lt;errno.h&gt;\n\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1883_SERVER_IP        &#34;127.0.0.1&#34;\t\n#define US1883_TCP_PORT\t\t29001\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US1883_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n#define US1883_PKCS10_4096_REQ &#34;MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\\n&#34;\n#define US1883_ENROLL_URL_BA &#34;https://127.0.0.1:29001/.well-known/est/simpleenroll&#34;\n#define US1883_PKCS10_CT     &#34;Content-Type: application/pkcs10&#34; \n#define US1883_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n#ifndef WIN32\n#define US1883_CACERTS\t     &#34;CA/estCA/cacert.crt&#34;\n#define US1883_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US1883_SERVER_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1883_SERVER_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1883_CLIENT_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1883_CLIENT_KEY  &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define US1883_CACERTS\t     &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1883_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1883_SERVER_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1883_SERVER_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1883_CLIENT_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1883_CLIENT_KEY  &#34;CA\\\\estCA\\\\private/estservercertandkey.pem&#34;\n\nstatic CRITICAL_SECTION logger_critical_section;  \nstatic void us1883_logger_stderr (char *format, va_list l) \n{\n    EnterCriticalSection(&amp;logger_critical_section);\n\tvfprintf(stderr, format, l);\n\tfflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section); \n}\n\n#endif \n\n\nstatic void us1883_clean (void)\n{\n}\n\nstatic int us1883_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US1883_TCP_PORT, \n\t          &#34;CA/estCA/private/estservercertandkey.pem&#34;,\n\t          &#34;CA/estCA/private/estservercertandkey.pem&#34;,\n\t          &#34;estrealm&#34;,\n\t          &#34;CA/estCA/cacert.crt&#34;,\n\t          &#34;CA/trustedcerts.crt&#34;,\n\t          &#34;CA/estExampleCA.cnf&#34;,\n\t\t  manual_enroll,\n\t\t  0,\n\t\t  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1883_init_suite (void)\n{\n    int rv;\n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us1883_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1883_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n\treturn 1;\n    }\n\n    us1883_clean();\n\n    /*\n     * Start an instance of the EST server with \n     * automatic enrollment enabled.\n     */\n    rv = us1883_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1883_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0; \n    \n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n    \n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }    \n\n    BIO_free(bio_err);\n    \n    return approve;\n}\n\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);    \n\n    pkey = EVP_PKEY_new();\n    if (pkey==NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }        \n    \n    RSA_free(rsa);\n    BN_free(bn);\n    \n    return (pkey);\n}\n\n#define GOOD_TOKEN &#34;WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=&#34;\n#define DIFFERENT_TOKEN &#34;V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy&#34;\n#define NULL_TOKEN NULL;\n#define LONG_TOKEN &#34;SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U=&#34;\nchar *test_token = &#34;WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=&#34;;\n\nint auth_cred_callback_called = 0;\nint auth_cred_force_error = 0;\n\n/*\n * auth_credentials_token_cb() is the application layer callback function that will\n * return a token based authentication credential when called.  It\&#39;s registered\n * with the EST Client using the est_client_set_auth_cred_cb().\n * The test function is required to set some global values in order to make this\n * callback operate the way that the test case wants.\n * - auth_cred_force_error = tell this function to force a response code error\n * - test_token = pointer to a hard coded string that is the token string to return\n *\n * This callback must provide the token credentials in a heap based buffer, and\n * ownership of that buffer is implicitly transferred to the ET client library upon\n * return.\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_token_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    char *token_ptr = NULL;\n    int token_len = 0;\n\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_TOKEN);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials-&gt;mode == AUTH_TOKEN) {\n        /*\n         * If the test_token is set to anything, then we need to allocate\n         * space from the heap and copy in the value.\n         */\n        if (test_token != NULL) {\n            token_len = strlen(test_token); /* use strlen() so that the string can be as large\n                                               as needed to test the EST client */\n            if (token_len == 0) {\n                printf(&#34;\\nError determining length of token string used for credentials\\n&#34;);\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }   \n            token_ptr = malloc(token_len+1);\n            if (token_ptr == NULL){\n                printf(&#34;\\nError allocating token string used for credentials\\n&#34;);\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }   \n            strncpy(token_ptr, test_token, strlen(test_token));\n            token_ptr[token_len] = \&#39;\\0\&#39;;\n        }\n        /*\n         * If we made it this far, token_ptr is pointing to a string\n         * containing the token to be returned. Assign it and return success\n         */\n        auth_credentials-&gt;auth_token = token_ptr;\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n/*\n * auth_credentials_basic_cb() is the same as the token based one above, but\n * instead returns the basic credentials of userid and password\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_BASIC);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials-&gt;mode == AUTH_BASIC) {\n\n        auth_credentials-&gt;user = malloc(sizeof(&#34;estuser&#34;));\n        strncpy(auth_credentials-&gt;user, &#34;estuser&#34;, sizeof(&#34;estuser&#34;));\n        auth_credentials-&gt;pwd = malloc(sizeof(&#34;estpwd&#34;));\n        strncpy(auth_credentials-&gt;pwd, &#34;estpwd&#34;, sizeof(&#34;estpwd&#34;));\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n\n/*\n * auth_credentials_digest_cb() is the same as the basic based one above, but\n * instead verfies that the auth_mode passed is digest\n */\nEST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_DIGEST);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n    \n    if (auth_credentials-&gt;mode == AUTH_DIGEST) {\n\n        auth_credentials-&gt;user = malloc(sizeof(&#34;estuser&#34;));\n        strncpy(auth_credentials-&gt;user, &#34;estuser&#34;, sizeof(&#34;estuser&#34;));\n        auth_credentials-&gt;pwd = malloc(sizeof(&#34;estpwd&#34;));\n        strncpy(auth_credentials-&gt;pwd, &#34;estpwd&#34;, sizeof(&#34;estpwd&#34;));\n        \n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n    \n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n\n/*\n * Test the est_client_set_auth_cred_cb API\n *\n * Exercise the parameters\n */\nstatic void us1883_test1 (void) \n{\n    EST_ERROR e_rc;\n    EST_CTX *ectx = NULL;\n     \n    LOG_FUNC_NM;\n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /* Forgot to specify any parameters. Context will\n     * get caught\n     */\n    e_rc = est_client_set_auth_cred_cb(NULL, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NO_CTX);\n\n    /*\n     * valid call\n     */\n    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_token_cb);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * attempt to reset the callback function\n     */\n    e_rc = est_client_set_auth_cred_cb(ectx, NULL);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    est_destroy(ectx);\n}\n\n/*\n * us1883_simple_enroll() is used by test cases to perform a simple enroll.\n */\nstatic void us1883_simple_enroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    EST_ERROR e_rc; \n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n    \n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Perform a simple enroll first in order to get a valid cert, then perform the\n * reenroll.  The simple enroll needs to be successful, so it\&#39;s currently\n * being done using basic mode because the EST server does not yet have token\n * based support.\n * PDB NOTE:  Once the server side token support have been implemented, this\n * this function can optionally be updated to do token mode on the first enroll,\n * but it\&#39;s not absolutely necessary since the purpose of this is to test reenroll\n * and the initial enroll is needed just to get the cert.\n */\nstatic\nvoid us1883_simple_reenroll (char *cn, char *server, EST_ERROR expected_enroll_rv, auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) *certs = NULL;\n    int i;\n    \n    EST_ERROR e_rc;    \n\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Make sure the server is currently in  BASIC auth mode\n     */\n    st_enable_http_basic_auth();\n    \n    e_rc = est_client_set_auth_cred_cb(ectx, auth_credentials_basic_cb);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n\tnew_cert = malloc(pkcs7_len);\n\tCU_ASSERT(new_cert != NULL);\n\trv = est_client_copy_enrolled_cert(ectx, new_cert);\n\tCU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    est_destroy(ectx);\n    ectx = NULL;\n    /*\n     * Create a client context \n     */\n    ectx = est_client_init(cacerts, cacerts_len, \n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);    \n    \n    /*\n     * Now that we have the cert, switch the server over to token mode\n     */\n    st_enable_http_token_auth();\n    \n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US1883_TCP_PORT, NULL);\n    \n    /*\n     * And attempt a reenroll while in token mode\n     *\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     * PDB: This conversion code comes from other test cases.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out,NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i=OBJ_obj2nid(p7-&gt;type);\n    switch (i) {\n    case NID_pkcs7_signed:\n\tcerts = p7-&gt;d.sign-&gt;cert;\n\tbreak;\n    case NID_pkcs7_signedAndEnveloped:\n\tcerts = p7-&gt;d.signed_and_enveloped-&gt;cert;\n\tbreak;\n    default:\n\tbreak;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs) return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn\&#39;t have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * PDB NOTE: At the moment, this is expected to fail since\n     * the server does not yet understand requests with token authentication.\n     * Once 1884 is complete, the below ASSERT will begin to fail and will need\n     * to be changed to a passing response.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n    \n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Test2 - Application layer did not register callback, causing an\n *         HTTP Aithentication header with an empty token credential\n *         \n * In this test,\n * - application layer DOES NOT register its callback\n * - EST Client gets the challenge, finds no callback registered and goes with\n *   the credentials it has stored in the Context, which is nothing.\n *   NOTE: This is the way the preloaded credential flow has always worked.\n * - enroll is sent with no token credentials\n * - server fails and does not give a certificate\n */\nstatic void us1883_test2 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass no callback function to catch and handle the request for a token auth.\n     *\n     * enroll better fail due to missing credentials\n     */\n    us1883_simple_enroll(&#34;TC1883-2&#34;, US1883_SERVER_IP, EST_ERR_AUTH_FAIL, NULL);\n\n    /*\n     * callback was never registered, so it should not have been invoked.\n     */\n    CU_ASSERT(auth_cred_callback_called == 0);\n}\n\n\n/*\n * Test3 - Application layer registers callback, BUT does not set any\n *         credentials when invoked.  Same result as previous test\n *         \n * In this test,\n * - application layer registers its callback\n * - EST Client gets the challenge, calls the callback, gets back an \n *   empty credential structure and ends up sending an HTTP auth header\n *   with no credentials.\n *   NOTE: This is the way the preloaded credential flow has always worked.\n * - enroll is sent with no token credentials\n * - server fails and does not give a certificate\n */\nstatic void us1883_test3 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = NULL_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Register the token based callback, but set it so that it passes back no token.\n     *\n     * enroll better fail due to missing credentials\n     */\n    us1883_simple_enroll(&#34;TC1883-3&#34;, US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test4 - Good token is sent to server and is accepted.  Cert should\n * be generated and returned\n *\n * In this test,\n * - application layer registers its callback and responds with a valid token\n * - enroll is sent with this token credential\n * - server is set to match on this token and send back a cert\n */\nstatic void us1883_test4 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us1883_simple_enroll(&#34;TC1883-4&#34;, US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test EST client receiving a token auth challenge\n *\n * In this test, the application layer registers its callback and responds\n * with a failing return code.\n */\nstatic void us1883_test5 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n\n    auth_cred_callback_called = 0;\n    /* Force the callback to give a failing return code */\n    auth_cred_force_error = 1;\n    test_token = GOOD_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * enroll better fail due to credentials not being supplied by the application layer\n     * and eventual failure at the server due to missing credentials.\n     */\n    us1883_simple_enroll(&#34;TC1883-5&#34;, US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test6 - Sanity test BASIC auth mode\n *\n * In this test,\n * - server into BASIC mode\n * - Client application registers its BASIC based callback\n * - Client should send the estuser/estpwd credentials and get a cert\n */\nstatic void us1883_test6 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to BASIC mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_basic_auth();\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     * enroll should pass because BASIC mode fully works.  Make sure that the\n     * callback is called.  This will ensure that the credentials came from\n     * the callback.\n     */\n    us1883_simple_enroll(&#34;TC1883-6&#34;, US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_basic_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Make sure re-enroll works with the credential callback flow\n *         to obtain credentials\n *\n * In this test,\n * - server into TOKEN mode\n * - Client application registers its TOKEN based callback\n * - Client should send the valid token credential and get a cert\n */\nstatic void us1883_test7 (void) \n{\n\n    LOG_FUNC_NM;\n    \n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Re-enroll should succeed.\n     *\n     */\n    us1883_simple_reenroll(&#34;TC1883-7&#34;, US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Token credentials that are too long\n *\n * In this test,\n * - server into TOKEN mode and told to match against the GOOD token\n * - Client application registers its TOKEN based callback and is told to\n *   give back a token that is TOO LONG.\n * - Client should send a corrupted token that does not match the GOOD token.\n */\nstatic void us1883_test8 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(GOOD_TOKEN);\n\n    auth_cred_callback_called = 0;\n    /* Force the callback to give a failing return code */\n    auth_cred_force_error = 0;\n    test_token = LONG_TOKEN;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     */\n    us1883_simple_enroll(&#34;TC1883-8&#34;, US1883_SERVER_IP, EST_ERR_AUTH_FAIL,\n                         auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test7 - Test DIGEST mode with on demand credential flow\n *\n * In this test,\n * - server into DIGEST mode\n *   NOTE: This means the server is expecting: &#34;estuser&#34;/&#34;estpwd&#34; and &#34;estrealm&#34;\n *         These values are hardcoded into data in the st_server, so st_server\n *         must be started with estrealm so that it returns this realm to client\n *         so that the client returns it in its request.\n * - Client application registers its DIGEST based callback\n * - Client should send a valid DIGEST and get a cert\n */\nstatic void us1883_test9 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to DIGEST mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_digest_auth();\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    \n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     * Pass a callback function to catch and handle the request for a token auth.\n     *\n     * enroll should pass because DIGEST mode fully works.  Make sure that the\n     * callback is called.  This will ensure that the credentials came from\n     * the callback.\n     */\n    us1883_simple_enroll(&#34;TC1883-6&#34;, US1883_SERVER_IP, EST_ERR_NONE, auth_credentials_digest_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/*\n * Test4 - Valid token is provided by appliaction callback, but it\&#39;s the WRONG\n *         token\n *\n * In this test,\n * - application layer registers its callback and responds with a valid token\n * - Server is set up for token mode, but with a different token.\n * - enroll is sent with this token credential\n * - server is set to match on this token and send back a cert\n */\nstatic void us1883_test10 (void) \n{\n\n    LOG_FUNC_NM;\n\n    /*\n     * Switch the server over to Token mode.\n     * \n     * NOTE: I see the equivalent calls being made in numerous places, and\n     * it\&#39;s probably safe in a test setting, but it\&#39;s dangerous to change\n     * this on the fly in an operational setting.  Also note, no return code\n     * for any of these set/enable functions.\n     */\n    st_enable_http_token_auth();\n    /*\n     * tell the server which token to check against.\n     */\n    st_set_token(DIFFERENT_TOKEN);\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n    test_token = GOOD_TOKEN;\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should FAIL because the tokens will not match\n     */\n    us1883_simple_enroll(&#34;TC1883-4&#34;, US1883_SERVER_IP, EST_ERR_AUTH_FAIL, auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1883_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us1883_tok_auth_client&#34;, \n\t                  us1883_init_suite, \n\t\t\t  us1883_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /* add the tests to the suite */\n   if ((NULL == CU_add_test(pSuite, &#34;parse response&#34;, us1883_test1)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll no cb&#34;, us1883_test2)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb no token&#34;, us1883_test3)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb good token&#34;, us1883_test4)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb bad rc&#34;, us1883_test5)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb basic mode&#34;, us1883_test6)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple re-enroll reg cb good token&#34;, us1883_test7)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb token too long&#34;, us1883_test8)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb digest mode&#34;, us1883_test9)) ||\n       (NULL == CU_add_test(pSuite, &#34;simple enroll reg cb mismatched valid token&#34;, us1883_test10))\n       )\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us748.c&#39;: [&#39;/*------------------------------------------------------------------\n * us748.c - Unit Tests for User Story 748 - Proxy simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US748_RETRY_INTERVAL    3600\n//#define US748_TCP_PORT        29001\n\n#define US748_TCP_SERVER_PORT       15748\n#define US748_TCP_PROXY_PORT        16748\n\n#ifndef WIN32\nstatic char test5_outfile[FILENAME_MAX] = &#34;US748/test5.hdr&#34;;\n#define US748_SERVER_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US748_SERVER_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n/* #define US748_PROXY_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;   */\n/* #define US748_PROXY_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n#define US748_PROXY_CERT &#34;US748/cert.pem&#34;  \n#define US748_PROXY_KEY &#34;US748/key.pem&#34;\n#define US748_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US748_TRUSTED_CERT &#34;CA/trustedcerts.crt&#34;\n#else\nstatic char test5_outfile[FILENAME_MAX] = &#34;US748\\\\test5.hdr&#34;;\n#define US748_SERVER_CERT &#34;CA\\\\estCA/private\\\\estservercertandkey.pem&#34;\n#define US748_SERVER_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n/* #define US748_PROXY_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;   */\n/* #define US748_PROXY_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n#define US748_PROXY_CERT &#34;US748\\\\cert.pem&#34;  \n#define US748_PROXY_KEY &#34;US748\\\\key.pem&#34;\n#define US748_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US748_TRUSTED_CERT &#34;CA\\\\trustedcerts.crt&#34;\n#endif\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US748_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US748_PKCS10_DSA1024 &#34;MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US748_PKCS10_ECDSA256 &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n#define US748_PKCS10_CORRUPT &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US748_PKCS10_STALE_POP &#34;MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=&#34;\n\n#define US748_ENROLL_URL_BA &#34;https://127.0.0.1:15748/.well-known/est/simpleenroll&#34;\n\n#define US748_PKCS10_CT     &#34;Content-Type: application/pkcs10&#34; \n#define US748_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n#define US748_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US748_EXPLICIT_CERT &#34;US748/cert-RA.pem&#34; \n#define US748_EXPLICIT_KEY  &#34;US748/key-RA.pem&#34;\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\nstatic FILE *outfile;\nstatic size_t write_func (void *ptr, size_t size, size_t nmemb, void *userdata)\n{\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\nstatic void us748_clean (void)\n{\n}\n\nstatic int us748_start_server (int manual_enroll, int nid)\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US748_TCP_SERVER_PORT,\n                  US748_SERVER_CERT,\n                  US748_SERVER_KEY,\n                  &#34;estrealm&#34;,\n                  US748_CACERT,\n                  US748_TRUSTED_CERT,\n                  &#34;US748/estExampleCA.cnf&#34;,\n                  manual_enroll, // manual enroll\n                  0,  // disable PoP\n                  nid); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA.\n     */\n    rv = st_proxy_start(US748_TCP_PROXY_PORT,\n                        US748_PROXY_CERT,\n                        US748_PROXY_KEY,\n                        &#34;estrealm&#34;,\n                        US748_CACERT,\n                        US748_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US748_TCP_SERVER_PORT,\n                        0,  // disable PoP\n                        nid);  // ecdhe nid info\n    SLEEP(1);\n\n    return rv;\n}\n\nvoid us748_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us748_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US748_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us748_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us748_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us748_destroy_suite (void)\n{\n    us748_stop_server();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple enroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * enrollment of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - EC prime 256\n *\n * This test case uses libcurl to test simple\n * enrollment of a 256 bit EC CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_ECDSA256,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - DSA prime 1024\n *\n * This test case uses libcurl to test simple\n * enrollment of a 1024 bit DSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_DSA1024,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * Simple enroll - Corrupted PKCS10\n *\n * This test case uses libcurl to test simple\n * enrollment usinga corrupted CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us748_test4 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_CORRUPT,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since the CSR is not valid, the server should\n     * respond with a 400.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * Simple enroll - manual enrollment\n *\n * This test case verifies the server is\n * sending the appropriate retry-after response.\n */\nstatic void us748_test5 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /* Stop the EST server */\n    us748_stop_server();\n\n    /* Restart the server with manual enrollment enabled */\n    us748_start_server(1, 0);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, &amp;write_func);\n    fclose(outfile);\n\n    /*\n     * Since the server hasn\&#39;t seen this CSR in the past,\n     * it should respond with a retry-after 202 response.\n     */\n    CU_ASSERT(rv == 202);\n\n    /*\n     * Verify the retry-after value\n     \n     sprintf(cmd, &#34;grep Retry-After %s | grep %d&#34;, test5_outfile,\n     US748_RETRY_INTERVAL);\n     rv = system(cmd);\n     */\n    rv = grep(test5_outfile, &#34;Retry-After: 3600&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We will avoid waiting the full retry period since we\&#39;re\n     * only simulating manual enrollment.  Wait a second and then\n     * try to enroll the cert again.\n     */\n    SLEEP(1);\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * This enrollment request should succeed this time\n     * Our simulated manual enrollment will automatically\n     * enroll on the second attempt.\n     */\n    CU_ASSERT(rv == 200);\n\n    /* Stop the EST server */\n    us748_stop_server();\n\n    /* Restart the server with manual enrollment disabled */\n    us748_start_server(0, 0);\n}\n\n/*\n * Simple enroll - PoP check fails with curl\n *\n * This test case verifies the server is\n * verifying the PoP from the client CSR.  Since curl does not\n * set the PoP, the EST enrollment should fail.\n */\nstatic void us748_test6 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Send a valid enroll request using curl.  Curl does not\n     * include the PoP\n     */\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_RSA2048,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n\n    /*\n     * The server should respond with a failure code\n     */\n    CU_ASSERT(rv == 400);\n\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP check succeeds with estclient\n *\n * This test case verifies the proxy is\n * verifying the PoP from the client CSR.  We use\n * estclient since it supports the PoP.\n */\nstatic void us748_test7 (void)\n{\n    long rv;\n    EST_CTX *c_ctx;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This test case requires PoP to be enabled\n     */\n    st_enable_pop();\n\n    /*\n     * Create a client context\n     */\n    c_ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(c_ctx != NULL);\n    if (!c_ctx) {\n        return;\n    }\n\n    /*\n     * Specify user ID and password since the server is running\n     * in Basic Authentication mode.\n     */\n    rv = est_client_set_auth(c_ctx, &#34;estuser&#34;, &#34;estpwd&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    est_client_set_server(c_ctx, &#34;127.0.0.1&#34;, US748_TCP_PROXY_PORT, NULL);\n\n    /*\n     * get a keypair to be used in the enroll.\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(c_ctx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll a CSR\n     */\n    rv = est_client_enroll(c_ctx, &#34;US748-test7 CN&#34;, &amp;pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Client library has obtained the new client certificate.\n     * Now retrieve it from the library.\n     */\n    pkcs7 = malloc(pkcs7_len);\n    if (!pkcs7) {\n        return;\n    }\n    rv = est_client_copy_enrolled_cert(c_ctx, pkcs7);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Clean up\n     */\n    est_destroy(c_ctx);\n    EVP_PKEY_free(new_pkey);\n    free(pkcs7);\n\n    /*\n     * Disable PoP for future test cases\n     */\n    st_disable_pop();\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 valid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes a valid PoP even when\n * the server didn\&#39;t request it.  We have to use\n * CiscoEST as the client to generate a CSR containing\n * a valid PoP.  There\&#39;s no way to include a valid PoP\n * using Curl since the TLS channel binding information\n * is not known in advance.\n */\n//The following include should never be used by an application\n//but we use it here to hack the EST_CTX values mid-way\n//through this test\n#include &#34;../../src/est/est_locl.h&#34;\nstatic void us748_test9 (void)\n{\n    EST_CTX *ctx;\n    int rv;\n    unsigned char *cacerts;\n    int caclen = 0;\n    EVP_PKEY *new_pkey;\n    unsigned char *pkcs7;\n    int pkcs7_len = 0;\n    unsigned char *attr_data;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    /*\n     * Read in the CA certs\n     */\n    caclen = read_binary_file(US748_CACERTS, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Init the client context\n     */\n    ctx = est_client_init(cacerts, caclen, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n\n    /*\n     * We\&#39;ll use simple HTTP auth to identify ourselves\n     */\n    rv = est_client_set_auth(ctx, &#34;estuser&#34;, &#34;estpwd&#34;, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_client_set_server(ctx, &#34;127.0.0.1&#34;, US748_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Create some space to hold the cert and generate\n     * a private key\n     */\n    new_pkey = generate_private_key();\n\n    rv = est_client_get_csrattrs(ctx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Attempt to enroll\n     */\n    ctx-&gt;csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR    \n    rv = est_client_enroll(ctx, &#34;TestCase9&#34;, &amp;pkcs7_len, new_pkey);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    pkcs7 = malloc(pkcs7_len);\n    rv = est_client_copy_enrolled_cert(ctx, pkcs7);\n\n    free(pkcs7);\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - PoP is disabled, the CSR contains a\n *                 invalid PoP.\n *\n * This test case ensures the server can handle the\n * scenario where the CSR includes an invalid PoP even when\n * the server didn\&#39;t request it.\n */\nstatic void us748_test10 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure our EST server has PoP disabled\n     */\n    st_disable_pop();\n\n    rv = curl_http_post(US748_ENROLL_URL_BA, US748_PKCS10_CT,\n    US748_PKCS10_STALE_POP,\n    US748_UIDPWD_GOOD, US748_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The enroll request should fail since the PoP was invalid\n     * We expect a 400 response.\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us748_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us748_srv_simpenroll&#34;,\n            us748_init_suite,\n            us748_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;Enroll RSA cert&#34;, us748_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll ECDSA cert&#34;, us748_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll DSA cert&#34;, us748_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll corrupted ECDSA cert&#34;, us748_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll retry-after manual approval &#34;, us748_test5)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll PoP fail with Curl&#34;, us748_test6)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll PoP succeed with estclient&#34;, us748_test7)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll w/PoP disabled, CSR includes valid PoP&#34;, us748_test9)) ||\n        (NULL == CU_add_test(pSuite, &#34;Enroll w/PoP disabled, CSR includes invalid PoP&#34;, us748_test10)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us3612.c&#39;: [&#39;/*------------------------------------------------------------------\n * us3612.c - Unit Tests for User Story US3612 - Encrypted Private Key Support\n *\n *\n *\n * July, 2016\n *\n * Copyright (c) 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n*/\n\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic char *key_password = NULL;\nstatic int cacerts_len = 0;\n\n#define US3612_SERVER_PORT   29899\n#define US3612_SERVER_IP     &#34;127.0.0.1&#34;\n#define US3612_UID           &#34;estuser&#34;\n#define US3612_PWD           &#34;estpwd&#34;\n#define US3612_GOOD_PWD &#34;us3612&#34;\n#define US3612_BAD_PWD  &#34;thiscantpossiblywork&#34;\n#define RSA_KEYSIZE 4096\n\n/*\n * Key wrap algorithm optionally used to protect private keys\n */\n#define EST_PRIVATE_KEY_ENC EVP_aes_128_cbc()\n\n/*\n * The following certs are used for FQDN testing\n */\n#ifndef WIN32\n#define US3612_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US3612_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US3612_SERVER_CERTKEY   &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US3612_PRIVATE_KEY_FILE &#34;US3612/us3612_key.pem&#34;\n\n#else\n#define US3612_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US3612_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US3612_SERVER_CERTKEY   &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US3612_PRIVATE_KEY_FILE &#34;US3612\\\\us3612_key.pem&#34;\n\nstatic CRITICAL_SECTION logger_critical_section;\nstatic void us3612_logger_stderr (char *format, va_list l)\n{\n    EnterCriticalSection(&amp;logger_critical_section);\n    vfprintf(stderr, format, l);\n    fflush(stderr);\n    LeaveCriticalSection(&amp;logger_critical_section);\n}\n#endif\n\nunsigned char *BIO_copy_data(BIO *out, int *data_lenp) {\n    unsigned char *data, *tdata;\n    int data_len;\n\n    data_len = BIO_get_mem_data(out, &amp;tdata);\n    data = malloc(data_len+1);\n    if (data) {\n        memcpy(data, tdata, data_len);\n\tdata[data_len]=\&#39;\\0\&#39;;  // Make sure it\&#39;s \\0 terminated, in case used as string\n\tif (data_lenp) {\n\t    *data_lenp = data_len;\n\t}\n    } else {\n        printf(&#34;malloc failed&#34;);\n    }\n    return data;\n}\n\nchar *generate_private_RSA_key (int key_size, pem_password_cb *cb)\n{\n    char *key_data = NULL;\n\n    RSA *rsa = RSA_new();\n    if (!rsa) {\n        return NULL;\n    }\n    BIGNUM *bn = BN_new();\n    if (!bn) {\n        RSA_free(rsa);\n        return NULL;\n    }\n\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, key_size, bn, NULL);\n\n    do {\n        BIO *out = BIO_new(BIO_s_mem());\n        if (!out) {\n            break;\n        }\n        PEM_write_bio_RSAPrivateKey(out, rsa, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);\n        key_data = (char *)BIO_copy_data(out, NULL);\n        BIO_free(out);\n        if (key_data &amp;&amp; !key_data[0]) {\n            // happens if passphrase entered via STDIN does not verify or has less than 4 characters\n            free(key_data);\n            key_data = NULL;\n        }\n    } while (cb &amp;&amp; !key_data);\n\n    RSA_free(rsa);\n    BN_free(bn);\n    return (key_data);\n}\n\nchar *generate_private_EC_key (int curve_nid, pem_password_cb *cb)\n{\n    EC_KEY *eckey;\n    EC_GROUP *group = NULL;\n    char *key_data = NULL;\n    int asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\n\n    /*\n     * Generate an EC key\n     */\n\n    eckey = EC_KEY_new();\n    if (!eckey) {\n        return NULL;\n    }\n\n    group = EC_GROUP_new_by_curve_name(curve_nid);\n    EC_GROUP_set_asn1_flag(group, asn1_flag);\n    EC_GROUP_set_point_conversion_form(group, form);\n    EC_KEY_set_group(eckey, group);\n    if (!EC_KEY_generate_key(eckey)) {\n        return (NULL);\n    }\n\n    do {\n        BIO *out = BIO_new(BIO_s_mem());\n        if (!out) {\n            break;\n        }\n        PEM_write_bio_ECPKParameters(out, group);\n        PEM_write_bio_ECPrivateKey(out, eckey, cb ? EST_PRIVATE_KEY_ENC : NULL, NULL, 0, cb, NULL);\n        key_data = (char *)BIO_copy_data(out, NULL);\n        BIO_free(out);\n        if (key_data &amp;&amp; !strstr(key_data, &#34;-----BEGIN EC PRIVATE KEY-----&#34;)) {\n            // happens if passphrase entered via STDIN does not verify or has less than 4 characters\n            free(key_data);\n            key_data = NULL;\n        }\n    } while (cb &amp;&amp; !key_data);\n\n    EC_KEY_free(eckey);\n    return (key_data);\n}\n\nstatic int string_password_cb (char *buf, int size, int wflag, void *data)\n{\n    /*\n     * Hard code a password for this suite\n     */\n    strncpy(buf, key_password, size);\n    return(strnlen(buf, size));\n}\n\n\nstatic void us3612_clean (void)\n{\n}\n\nstatic int us3612_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US3612_SERVER_PORT,\n              US3612_SERVER_CERTKEY,\n              US3612_SERVER_CERTKEY,\n              &#34;US3612 test realm&#34;,\n              US3612_CACERTS,\n              US3612_TRUST_CERTS,\n              &#34;CA/estExampleCA.cnf&#34;,\n          manual_enroll,\n          0,\n          nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us3612_init_suite (void)\n{\n    int rv;\n\n#ifdef WIN32\n    InitializeCriticalSection (&amp;logger_critical_section);\n    est_init_logger(EST_LOG_LVL_INFO, &amp;us3612_logger_stderr);\n#endif\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US3612_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n    return 1;\n    }\n\n    us3612_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us3612_start_server(0, 0);\n\n    return rv;\n}\n\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us3612_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify(X509 *cur_cert, int openssl_cert_error)\n{\n    BIO *bio_err;\n    bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(&#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n           __FUNCTION__, openssl_cert_error,\n           X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout,cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Simple Enroll b- client\n * Load in a password prortected private key with\n * the correct passphrase and attempt to enroll for a certificate\n */\nstatic void us3612_test1 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len,\n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n    /*\n     * Read in our test private key\n     * generated via the command below:\n     *\n     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TCUS3612-1&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n    new_cert = malloc(pkcs7_len);\n    CU_ASSERT(new_cert != NULL);\n    rv = est_client_copy_enrolled_cert(ectx, new_cert);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll CSR\n *\n * Load in a password protected private key with the incorrect password\n * and attempt to enroll for a certificate. This will fail.\n */\nstatic void us3612_test2 (void)\n{\n     EST_CTX *ectx;\n     EVP_PKEY *key;\n     int rv;\n     int pkcs7_len = 0;\n     unsigned char *new_cert = NULL;\n     unsigned char *attr_data = NULL;\n     int attr_len;\n\n     /*\n      * Create a client context\n      */\n     ectx = est_client_init(cacerts, cacerts_len,\n                            EST_CERT_FORMAT_PEM,\n                            client_manual_cert_verify);\n     CU_ASSERT(ectx != NULL);\n\n     /*\n      * Set the authentication mode to use a user id/password\n      */\n     rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n     CU_ASSERT(rv == EST_ERR_NONE);\n\n     /*\n      * Set the EST server address/port\n      */\n     est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n     /*\n      * Read in our test private key\n      * generated via the command below:\n      *\n      * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n      */\n\n     key_password = US3612_BAD_PWD;\n\n     key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n     CU_ASSERT(key == NULL);\n\n     /*\n      * Get the latest CSR attributes\n      */\n     rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n     CU_ASSERT(rv == EST_ERR_NONE);\n\n     /*\n      * Use the simplified API to enroll a CSR\n      */\n     rv = est_client_enroll(ectx, &#34;TC3612-2&#34;, &amp;pkcs7_len, key);\n     CU_ASSERT(rv != EST_ERR_NONE);\n\n     /*\n      * Cleanup\n      */\n     EVP_PKEY_free(key);\n     if (new_cert) free(new_cert);\n     est_destroy(ectx);\n}\n\n\n/*\n * Simple enroll CSR\n *\n * Change the password used by the callback after reading\n * in the protected private key file.\n */\nstatic void us3612_test3 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len,\n                           EST_CERT_FORMAT_PEM,\n                           client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US3612_UID, US3612_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US3612_SERVER_IP, US3612_SERVER_PORT, NULL);\n\n    /*\n     * Read in our test private key\n     * generated via the command below:\n     *\n     * openssl genrsa -aes128 -passout pass:us3612 -out us3612_key.pem 4096\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    key = read_protected_private_key(US3612_PRIVATE_KEY_FILE, string_password_cb);\n\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Change out the password, EVP_PKEY should remain unaffected\n     */\n\n    key_password = US3612_BAD_PWD;\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, &#34;TCUS3612-3&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n    new_cert = malloc(pkcs7_len);\n    CU_ASSERT(new_cert != NULL);\n    rv = est_client_copy_enrolled_cert(ectx, new_cert);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert) free(new_cert);\n    est_destroy(ectx);\n}\n\n\n/*\n * Test key generation utility functions\n * and associated password callbacks\n */\nstatic void us3612_test4 (void)\n{\n    char * new_pkey = NULL;\n\n    /*\n     * Generate an RSA key without a password\n     */\n\n    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, NULL);\n    CU_ASSERT(new_pkey != NULL);\n    printf(&#34;\\n%s\\n&#34;, new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n    /*\n     * Generate an RSA key with password\n     */\n\n    key_password = US3612_GOOD_PWD;\n\n    new_pkey = generate_private_RSA_key(RSA_KEYSIZE, string_password_cb);\n    CU_ASSERT(new_pkey != NULL);\n    printf(&#34;\\n%s\\n&#34;, new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n    /*\n     * Generate an EC key without a password\n     */\n\n    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) &#34;prime256v1&#34;), NULL);\n    CU_ASSERT(new_pkey != NULL);\n    printf(&#34;\\n%s\\n&#34;, new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n\n    /*\n     * Generate an EC key with a password\n     */\n    new_pkey = generate_private_EC_key(OBJ_sn2nid((char *) &#34;prime256v1&#34;), string_password_cb);\n    CU_ASSERT(new_pkey != NULL);\n    printf(&#34;\\n%s\\n&#34;, new_pkey);\n    free(new_pkey);\n    new_pkey = NULL;\n\n}\n\nint us3612_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n   CU_pSuite pSuite = NULL;\n\n   /* add a suite to the registry */\n   pSuite = CU_add_suite(&#34;us3612_encrypted_private_keys&#34;,\n                      us3612_init_suite,\n              us3612_destroy_suite);\n   if (NULL == pSuite) {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   /*\n    * Add the tests to the suite\n    */\n   if ((NULL == CU_add_test(pSuite, &#34;Client simple enroll w/ correct pwd&#34;, us3612_test1)) ||\n       (NULL == CU_add_test(pSuite, &#34;Client simple enroll w/ incorrect pwd&#34;, us3612_test2)) ||\n       (NULL == CU_add_test(pSuite, &#34;Client simple enroll w/ incorrect pwd&#34;, us3612_test3)) ||\n       (NULL == CU_add_test(pSuite, &#34;Keygen Test&#34;, us3612_test4)))\n   {\n      CU_cleanup_registry();\n      return CU_get_error();\n   }\n\n   return CUE_SUCCESS;\n#endif\n}\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us901.c&#39;: [&#39;/*------------------------------------------------------------------\n * us901.c - Unit Tests for User Story 901 - Server cacerts\n *\n * June, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#define US901_PKCS10_REQ    &#34;MIIChjCCAW4CAQAwQTElMCMGA1UEAxMccmVxIGJ5IGNsaWVudCBpbiBkZW1vIHN0\\nZXAgMjEYMBYGA1UEBRMPUElEOldpZGdldCBTTjoyMIIBIjANBgkqhkiG9w0BAQEF\\nAAOCAQ8AMIIBCgKCAQEA/6JUWpXXDwCkvWPDWO0yANDQzFMxroLEIh6/vdNwfRSG\\neNGC0efcL5L4NxHZOmO14yqMEMGpCyHz7Ob3hhNPu0K81gMUzRqzwmmJHXwRqobA\\ni59OQEkHaPhI1T4RkVnSYZLOowSqonMZjWbT0iqZDY/RD8l3GjH3gEIBMQFv62NT\\n1CSu9dfHEg76+DnJAhdddUDJDXO3AWI5s7zsLlzBoPlgd4oK5K1wqEE2pqhnZxei\\nc94WFqXQ1kyrW0POVlQ+32moWTQTFA7SQE2uEF+GBXsRPaEO+FLQjE8JHOewLf/T\\nqX0ngywnvxKRpKguSBic31WVkswPs8E34pjjZAvdxQIDAQABoAAwDQYJKoZIhvcN\\nAQEFBQADggEBAAZXVoorRxAvQPiMNDpRZHhiD5O2Yd7APBBznVgRll1HML5dpgnu\\nXY7ZCYwQtxwNGYVtKJaZCiW7dWrZhvnF5ua3wUr9R2ZNoLwVR0Z9Y5wwn1cJrdSG\\ncUuBN/0XBGI6g6fQlDDImQoPSF8gygcTCCHba7Uv0i8oiCiwf5UF+F3NYBoBL/PP\\nlO2zBEYNQ65+W3YgfUyYP0Cr0NyXgkz3Qh2Xa2eRFeW56oejmcEaMjq6yx7WAC2X\\nk3w1G6Le1UInzuenMScNgnt8FaI43eAILMdLQ/Ekxc30fjxA12RDh/YzDYiExFv0\\ndPd4o5uPKt4jRitvGiAPm/OCdXiYAwqiu2w=\\n&#34;\n#define US901_ENROLL_URL &#34;https://127.0.0.1:29901/.well-known/est/simpleenroll&#34;\n#define US901_CACERT_URL &#34;https://127.0.0.1:29901/.well-known/est/cacerts&#34;\n#define US901_PKCS10_CT     &#34;Content-Type: application/pkcs10&#34; \n#define US901_UIDPWD_GOOD   &#34;estuser:estpwd&#34;\n#define US901_UIDPWD_BAD    &#34;estuser:bogus&#34;\n#define US901_SERVER_PORT 29901\n#ifndef WIN32\n#define US901_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US901_EXPLICIT_CERT &#34;US901/explicit-cert.pem&#34; \n#define US901_EXPLICIT_KEY &#34;US901/explicit-key.pem&#34;\n#define US901_IMPLICIT_CERT &#34;US901/implicit-cert.pem&#34; \n#define US901_IMPLICIT_KEY &#34;US901/implicit-key.pem&#34;\n#define US901_REVOKED_CERT &#34;US901/revoked-cert.pem&#34; \n#define US901_REVOKED_KEY &#34;US901/revoked-key.pem&#34;\n#define US901_SELFSIGN_CERT &#34;US901/selfsigned-cert.pem&#34; \n#define US901_SELFSIGN_KEY &#34;US901/selfsigned-key.pem&#34;\n#define US901_CACERT &#34;CA/estCA/cacert.crt&#34;\n#define US901_EXTCERT &#34;CA/extCA/cacert.crt&#34;\n#define US901_SERVER_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US901_SERVER_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US901_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\nstatic char test5_outfile[FILENAME_MAX] = &#34;US901/test5.crt&#34;;\n#else\n#define US901_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US901_EXPLICIT_CERT &#34;US901\\\\explicit-cert.pem&#34; \n#define US901_EXPLICIT_KEY &#34;US901\\\\explicit-key.pem&#34;\n#define US901_IMPLICIT_CERT &#34;US901\\\\implicit-cert.pem&#34; \n#define US901_IMPLICIT_KEY &#34;US901\\\\implicit-key.pem&#34;\n#define US901_REVOKED_CERT &#34;US901\\\\revoked-cert.pem&#34; \n#define US901_REVOKED_KEY &#34;US901\\\\revoked-key.pem&#34;\n#define US901_SELFSIGN_CERT &#34;US901\\\\selfsigned-cert.pem&#34; \n#define US901_SELFSIGN_KEY &#34;US901\\\\selfsigned-key.pem&#34;\n#define US901_CACERT &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US901_EXTCERT &#34;CA\\\\extCA\\\\cacert.crt&#34;\n#define US901_SERVER_CERT &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US901_SERVER_KEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US901_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private/estservercertandkey.pem&#34;\nstatic char test5_outfile[FILENAME_MAX] = &#34;US901\\\\test5.crt&#34;;\n#endif\n\nstatic void us901_clean(void) {\n    char cmd[200];\n    sprintf(cmd, &#34;rm %s&#34;, test5_outfile);\n    system(cmd);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us901_init_suite(void) {\n    us901_clean();\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    return 0;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us901_destory_suite(void) {\n    return 0;\n}\n\n/*\n * Start the appropriate flavor of st_server\n * based what character is specified\n * B - Basic auth\n * D - Digest auth\n * C - CRL checking\n * N = No auth\n */\nstatic int us901_start_server(char server_type) {\n    int rv;\n\n    switch (server_type) {\n    case \&#39;B\&#39;:\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, &#34;estrealm&#34;, &#34;CA/estCA/cacert.crt&#34;,\n                &#34;CA/trustedcerts.crt&#34;, &#34;CA/estExampleCA.cnf&#34;, 0, 0, 0);\n        st_enable_http_basic_auth();\n        break;\n    case \&#39;D\&#39;:\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, &#34;estrealm&#34;, &#34;CA/estCA/cacert.crt&#34;,\n                &#34;CA/trustedcerts.crt&#34;, &#34;CA/estExampleCA.cnf&#34;, 0, 0, 0);\n        st_enable_http_digest_auth();\n        break;\n    case \&#39;C\&#39;:\n        system(\n                &#34;openssl ca -config CA/estExampleCA.cnf -gencrl -out CA/estCA/crl.pem&#34;);\n        SLEEP(1);\n        system(\n                &#34;cat CA/trustedcerts.crt CA/estCA/crl.pem &gt; US901/trustedcertsandcrl.crt&#34;);\n        SLEEP(1);\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, &#34;estrealm&#34;, &#34;CA/estCA/cacert.crt&#34;,\n                &#34;US901/trustedcertsandcrl.crt&#34;, &#34;CA/estExampleCA.cnf&#34;, 0, 0, 0);\n        st_enable_crl();\n        st_disable_http_auth();\n        break;\n    case \&#39;N\&#39;:\n        rv = st_start(US901_SERVER_PORT,\n        US901_SERVER_CERTKEY,\n        US901_SERVER_CERTKEY, &#34;estrealm&#34;, &#34;CA/estCA/cacert.crt&#34;,\n                &#34;CA/trustedcerts.crt&#34;, &#34;CA/estExampleCA.cnf&#34;, 0, 0, 0);\n        st_disable_http_auth();\n        break;\n    default:\n        rv = -1;\n        break;\n    }\n\n    return rv;\n}\n\n/*\n * HTTP Basic auth\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listing to port 8088 prior to this\n * test being run.\n */\nstatic void us901_test1(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;B\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    st_stop();\n    SLEEP(1);\n\n}\n\n/*\n * HTTP Basic Auth failure\n *\n * This test case uses libcurl to test HTTP Basic\n * authentication is working on the EST server,\n * while using a bogus password.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running prior to this test being run.\n */\nstatic void us901_test2(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;B\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 401);\n\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * HTTP Digest Auth\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST server.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us901_test3(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_DIGEST,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with success\n     */\n    CU_ASSERT(rv == 200);\n\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * HTTP Digest Auth fail\n *\n * This test case uses libcurl to test HTTP Digest\n * authentication is working on the EST server.\n * This is the negative test case for Digest auth.\n * It must use a simpleenroll message since the\n * cacerts message does not require the client\n * to be authenticated.  The EST server should be\n * running and listening to port 8087 prior to this\n * test being run.\n */\nstatic void us901_test4(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_BAD, US901_CACERTS, CURLAUTH_DIGEST,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\nstatic FILE *outfile;\nstatic size_t write_func(void *ptr, size_t size, size_t nmemb, void *userdata) {\n    size_t written;\n    written = fwrite(ptr, size, nmemb, outfile);\n    return written;\n}\n\n/*\n * This test case does a simple cacerts request\n * and looks for the HTTP 200 response code.\n */\nstatic void us901_test5(void) {\n    long rv;\n    char cmd[200];\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_get(US901_CACERT_URL, US901_CACERTS, &amp;write_func);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 200\n     */\n    CU_ASSERT(rv == 200);\n\n    sprintf(cmd,\n            &#34;openssl base64 -d -in %s | openssl pkcs7 -inform DER -text -print_certs&#34;,\n            test5_outfile);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n    st_stop();\n    SLEEP(1);\n}\n\nstatic void us901_test_sslversion(const SSL_METHOD *m, int expect_fail) {\n    BIO *conn;\n    SSL *ssl;\n    SSL_CTX *ssl_ctx = NULL;\n    int rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    ssl_ctx = SSL_CTX_new(m);\n    CU_ASSERT(ssl_ctx != NULL);\n\n    /*\n     * Now that the SSL context is ready, open a socket\n     * with the server and bind that socket to the context.\n     */\n    conn = open_tcp_socket_ipv4(&#34;127.0.0.1&#34;, &#34;29901&#34;);\n    CU_ASSERT(conn != NULL);\n\n    /*\n     * Creaea SSL session context\n     */\n    ssl = SSL_new(ssl_ctx);\n    SSL_set_bio(ssl, conn, conn);\n\n    /*\n     * Now that we have everything ready, let\&#39;s initiate the TLS\n     * handshake.\n     */\n    rv = SSL_connect(ssl);\n    if (!expect_fail) {\n        CU_ASSERT(rv &gt; 0);\n    } else {\n        CU_ASSERT(rv &lt;= 0);\n    }\n\n    /*\n     * Cleanup all the data\n     */\n    SSL_shutdown(ssl);\n    SSL_free(ssl);\n    SSL_CTX_free(ssl_ctx);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to create a SSL 3.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us901_test6(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(SSLv3_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.0 connection\n * with the EST server.  This should fail, as TLS 1.0\n * is not allowed.\n */\nstatic void us901_test7(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_client_method(), 1);\n}\n\n/*\n * This test attempts to create a TLS 1.1 connection\n * with the EST server.  This should succeed.\n */\nstatic void us901_test8(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_1_client_method(), 0);\n}\n\n/*\n * This test attempts to create a TLS 1.2 connection\n * with the EST server.  This should succeed.\n */\nstatic void us901_test9(void) {\n    LOG_FUNC_NM\n    ;\n\n    us901_test_sslversion(TLSv1_2_client_method(), 0);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. This should succeed.\n */\nstatic void us901_test10(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;N\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the implicit cert\n * chain. This should succeed.\n */\nstatic void us901_test11(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;N\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_IMPLICIT_CERT,\n    US901_IMPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a revoked client certificate to\n * verify CRL checks are working in the TLS layer.\n * This should fail.\n */\nstatic void us901_test12(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;R\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_REVOKED_CERT,\n    US901_REVOKED_KEY,\n    US901_CACERTS,\n    NULL);\n\n    /*\n     * Since the client cert has been revoked the TLS handshake\n     * will fail.  The EST server should return a 401 response.\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n}\n\n/*\n * This test attempts to use a self-signed client certificate to\n * verify cert chain will reject a cert that has not been\n * signed by a valid CA.  This should fail.\n */\nstatic void us901_test13(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_cert(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_SELFSIGN_CERT,\n    US901_SELFSIGN_KEY,\n    US901_CACERTS,\n    NULL);\n\n    /*\n     * Since the client cert is not signed by either the local CA\n     * or external CA, the TLS handshake will fail.\n     * We will not receive an HTTP status message\n     * from the server.\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n}\n\n/*\n * TLS anonymous cipher suites disabled\n *\n * This test case uses libcurl to test that the\n * EST server will not accept anonymous cipher\n * suites from the client.  We only test a single\n * cipher suite here.  This attempts to do a\n * simple enroll with the server.\n */\nstatic void us901_test14(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC, &#34;ADH-AES128-SHA256&#34;, NULL,\n            NULL);\n    /*\n     * TLS handshake should have failed, curl should return 0\n     */\n    CU_ASSERT(rv == 0);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * Null HTTP realm when initializing server\n */\nstatic void us901_test15(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL realm\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM,\n            NULL, x, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate when initializing server\n */\nstatic void us901_test16(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *keyin;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL server key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM, &#34;testrealm&#34;, NULL, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Null Server certificate private key when initializing server\n */\nstatic void us901_test17(void) {\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin;\n    X509 *x;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US901_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Attempt to init EST server using NULL private key\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n            EST_CERT_FORMAT_PEM, &#34;testrealm&#34;, x, NULL);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n}\n\n/*\n * Null trusted CA chain when initializing server\n */\nstatic void us901_test18(void) {\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server using NULL local CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(NULL, 0, NULL, 0, EST_CERT_FORMAT_PEM, &#34;testrealm&#34;, x,\n            priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * Corrupted CA chain when initializing server\n */\nstatic void us901_test19(void) {\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY *priv_key;\n    int rv;\n    EST_CTX *ctx;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US901_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US901_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * Attempt to init EST server a corrupted CA chain\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init((unsigned char*) &#34;Bogus CA chain&#34;, 14,\n            (unsigned char*) &#34;Bogus CA chain&#34;, 14, EST_CERT_FORMAT_PEM,\n            &#34;testrealm&#34;, x, priv_key);\n    CU_ASSERT(ctx == NULL);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n}\n\n/*\n * This test case attempts simple cacerts request using\n * POST instead of GET.  It should fail.\n */\nstatic void us901_test20(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n\n    outfile = fopen(test5_outfile, &#34;w&#34;);\n    rv = curl_http_post(US901_CACERT_URL, US901_PKCS10_CT, US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD, US901_CACERTS, CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    fclose(outfile);\n\n    /*\n     * we expect the server to respond with a 400\n     */\n    CU_ASSERT(rv == 400);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Valid HTTP authentication credentials are\n * also provided.  This should succeed.\n */\nstatic void us901_test21(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;B\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to use a client certificate to\n * verify the TLS client authentiaiton is working.\n * The certificate used is signed by the explicit cert\n * chain. Invalid HTTP authentication credentials are\n * also provided.  This should fail with a 401 response.\n */\nstatic void us901_test22(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;D\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post_certuid(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_BAD,\n    US901_EXPLICIT_CERT,\n    US901_EXPLICIT_KEY,\n    US901_CACERTS,\n    NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\n/*\n * This test attempts to enroll without using a certificate\n * to identity the client, while using a good user ID/pwd.\n * However, the EST server is setup to only perform\n * certificate authentication (HTTP auth disabled).\n * This should fail with a 401 response.\n */\nstatic void us901_test23(void) {\n    long rv;\n    int st_rv;\n\n    st_rv = us901_start_server(\&#39;N\&#39;);\n    if (st_rv) {\n        return;\n    }\n\n    LOG_FUNC_NM\n    ;\n\n    SLEEP(1);\n    rv = curl_http_post(US901_ENROLL_URL,\n    US901_PKCS10_CT,\n    US901_PKCS10_REQ,\n    US901_UIDPWD_GOOD,\n    US901_CACERTS,\n    CURLAUTH_BASIC,\n    NULL, NULL, NULL);\n    /*\n     * Since we passed in an invalid userID/password,\n     * we expect the server to respond with 401\n     */\n    CU_ASSERT(rv == 401);\n    st_stop();\n    SLEEP(1);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us901_add_suite(void) {\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us901_srv_cacerts&#34;,\n            us901_init_suite,\n            us901_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, &#34;HTTP Basic Auth&#34;, us901_test1)) ||\n            (NULL == CU_add_test(pSuite, &#34;HTTP Basic Auth Fail&#34;, us901_test2)) ||\n            (NULL == CU_add_test(pSuite, &#34;HTTP Digest Auth&#34;, us901_test3)) ||\n            (NULL == CU_add_test(pSuite, &#34;HTTP Digest Auth Fail&#34;, us901_test4)) ||\n            (NULL == CU_add_test(pSuite, &#34;Get CA Certificates&#34;, us901_test5)) ||\n            (NULL == CU_add_test(pSuite, &#34;SSL 3.0 Fail&#34;, us901_test6)) ||\n            (NULL == CU_add_test(pSuite, &#34;TLS 1.0 Fail&#34;, us901_test7)) ||\n            (NULL == CU_add_test(pSuite, &#34;TLS 1.1&#34;, us901_test8)) ||\n            (NULL == CU_add_test(pSuite, &#34;TLS 1.2&#34;, us901_test9)) ||\n            (NULL == CU_add_test(pSuite, &#34;Certificate auth - explicit cert chain&#34;, us901_test10)) ||\n            (NULL == CU_add_test(pSuite, &#34;Certificate auth - implicit cert chain&#34;, us901_test11)) ||\n            (NULL == CU_add_test(pSuite, &#34;Certificate auth - revoked cert&#34;, us901_test12)) ||\n            (NULL == CU_add_test(pSuite, &#34;Certificate auth - self-signed cert&#34;, us901_test13)) ||\n            (NULL == CU_add_test(pSuite, &#34;Anon cipher suite disabled&#34;, us901_test14)) ||\n            (NULL == CU_add_test(pSuite, &#34;NULL Realm&#34;, us901_test15)) ||\n            (NULL == CU_add_test(pSuite, &#34;NULL server cert&#34;, us901_test16)) ||\n            (NULL == CU_add_test(pSuite, &#34;NULL server key&#34;, us901_test17)) ||\n            (NULL == CU_add_test(pSuite, &#34;NULL local CA chain&#34;, us901_test18)) ||\n            (NULL == CU_add_test(pSuite, &#34;Corrupted local CA chain&#34;, us901_test19)) ||\n            (NULL == CU_add_test(pSuite, &#34;HTTP POST cacerts&#34;, us901_test20)) ||\n            (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - good HTTP auth/good Cert&#34;, us901_test21)) ||\n            (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - bad HTTP auth/good Cert&#34;, us901_test22)) ||\n            (NULL == CU_add_test(pSuite, &#34;SimpleEnroll - no HTTP auth/no Cert&#34;, us901_test23)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us1864.c&#39;: [&#39;/*------------------------------------------------------------------\n * us1864.c - Unit Tests for User Story 1864 - Enable Token Auth mode in server\n *\n * March, 2015\n *\n * Copyright (c) 2015, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n#include &lt;errno.h&gt;\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US1864_TCP_PORT     29001\n\n/*\n * The following CSR was generated using the following openssl command and theng\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US1864_PKCS10_RSA2048   &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n#define US1864_PKCS10_4096_REQ  &#34;MIIEZjCCAk4CAQAwITEPMA0GA1UEAwwGSkpUZXN0MQ4wDAYDVQQFEwUwMDAwMTCC\\nAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALfLlHxqzObiKWDfX8saZ4l3\\n1JyrCP4xmyQitY2pIIGlLvHT7t1WZ0LO9uo0uB7b/8iGbXki8FgqSm1jROe5lwCN\\nDIhTJdG4b705c6XmD3Mh436De9d4gzpjedA2qurSI9+GVNVgU0ZOWJFu9g+y3iRH\\ndfsjO9u0E2MfZWWR8M72gBqzvbDDPN4BDwLa9TkQ2Rsxf3h2d7bN2DNShNSYX/dE\\nIX89d9uC6FegsHQxHINUOdZzeAn3yuQMBU+FwohEl9Ub8Qu9gub2MJUrYNRQnii7\\nduvq5/UjkhjNWzIh7LAbdaM+0wSmCe0ju+wKbayUZZkrqoVK6bWZzFs4dYtn95/S\\nVVOv95MD5D1EokXw3Iih7GRJygtWn5e4/YO68LONBF7UE24vgBwEieF6J0bFAlxw\\n15s7pIalkGF7CUbitRhbB3kTjGfUDR8YpSsKdqxHNmWBXY7ZVk4T8K7168cNWSOL\\netZpTk4BtoUJBnWP8Uq38YOi6389U24gmZtGpSpJEEtDy1MJ8Ha4PZE/VkFtmUWq\\nbETOx2kubGwc9vXvWfi5BxE2VvetGNsy2EQEZPVwscYaCy0/yO3fu06coEtr7Ekr\\ngapDDEzVtiP9NPe5q18Azu+T9ngoOx3PqrCPG1BDN6z1Ue2tSDdOxKNFMNMwqYIn\\nZP9MXh+tz8RaKvsclv9JAgMBAAGgADANBgkqhkiG9w0BAQUFAAOCAgEAJMwZ4IUB\\nUSH5wQBfsYT4SxtKsZtvun6QX0+7jNMtzzQUOqO79Kx/DKpzsKxLNvHKmFqcxA7g\\ngbEwXkAP5+VaMD92DghcNjXOqGKclZdmGj2oREqZwzvTDRo4zP1yen5vgL/Yz7SA\\nxze8wPg2WhlV9+qvkVCpHN3EUIfO+rBgi2reo/vF7xq5CAU4UtQ1h4gHax67Yww8\\nJmypyGGa0ad0Z8ruiclI/QtluADUxy1YM0Up2FC0s7j72xzrRpEl1fPlOi/bFaZp\\nsr4zllOpwnRdxvffXO7gXtXVIr4IHVHNWj6kmDzyk0ovat2Ms5aGUcMDN6Jm8KIB\\nNBVH5FgkBVQOPSngkwnEOj0RsaKSxT5EfmOxm9pCrAE3rNdVOgO4t8wZ6DQUqye/\\nBUdmgXtWoGsKIg8oR5HAWBER8yw/qdiRlBGgN/PKZdpmYI2TEfZvp/nXwG7QLjGx\\nsj5TWeRKNgghUCu3uF+1s0R+gqgY1S9GgiDSifL7+h+bXJ4ncyRGq+XPnrfMiRkB\\neSyv3kyIxtZfAB6TjkUbtVfo2KrfqNxu4lbJYE2b6hs1L6t7YPhjubz9aES7wES7\\nk+ZZPZn/k/GsqUpsWHnEFEvi5C5WPrnpvVN6rKh0fB+AukGrS+9EK4KNZWfV/yf8\\nXN5qWyOtgd4oLUUsgFDJsqNh6A1mlmx6CnY=\\n&#34;\n\n#define US1864_ENROLL_URL_BA    &#34;https://127.0.0.1:29001/.well-known/est/simpleenroll&#34;\n#define US1864_PKCS10_CT        &#34;Content-Type: application/pkcs10&#34;\n#define US1864_UIDPWD_GOOD      &#34;estuser:estpwd&#34;\n#ifndef WIN32\n#define US1864_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US1864_CACERT           &#34;CA/estCA/cacert.crt&#34;\n#define US1864_TRUSTED_CERT     &#34;CA/trustedcerts.crt&#34;\n#define US1864_SERVER_CERT      &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1864_SERVER_KEY       &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1864_CLIENT_CERT      &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1864_CLIENT_KEY       &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define US1864_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1864_CACERT           &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1864_TRUSTED_CERT     &#34;CA\\\\trustedcerts.crt&#34;\n#define US1864_SERVER_CERT      &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1864_SERVER_KEY       &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1864_CLIENT_CERT      &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1864_CLIENT_KEY       &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif\n\n/*\n * curl_data_cb is passed to Curl and will be called from Curl whenever data\n * has been received, or if this function has been specified to retrieve the\n * http headers.  In this test it\&#39;s used to retrieve the http headers and\n * look for the &#34;bearer&#34; token Authorization challenge.\n */\nstatic int bearer_found = 0;\nstatic size_t curl_data_cb (void *ptr, size_t size, size_t nmemb,\n                            void *userdata)\n{\n    void * rc;\n\n    if (bearer_found == 0) {\n\n        /*\n         * WARNING: strstr can be dangerous because it assumes null terminated\n         * strings.  In this case the http headers came from EST server and we\n         * know they are null terminated\n         */\n        rc = strstr(ptr, &#34;WWW-Authenticate: Bearer&#34;);\n        if (rc) {\n            bearer_found = 1;\n        }\n    }\n\n    return size * nmemb;\n}\n\nstatic void us1864_clean (void)\n{\n}\n\nstatic int us1864_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US1864_TCP_PORT,\n                  US1864_SERVER_CERT,\n                  US1864_SERVER_KEY,\n                  &#34;US1864 test realm&#34;,\n                  US1864_CACERTS,\n                  US1864_TRUSTED_CERT,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  0,\n                  nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1864_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1864_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us1864_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1864_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1864_destroy_suite (void)\n{\n    st_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * est_server_set_auth_mode() - unit test\n *\n * First, Test the parameters of est_server_set_auth_mode()\n */\nstatic void us1864_test1 (void)\n{\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    BIO *certin, *keyin;\n    X509 *x;\n    EVP_PKEY * priv_key;\n    int rv;\n    EST_CTX *ctx;\n    EST_ERROR est_rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1864_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read the server cert\n     */\n    certin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(certin, US1864_SERVER_CERT);\n    CU_ASSERT(rv &gt; 0);\n    x = PEM_read_bio_X509(certin, NULL, NULL, NULL);\n    CU_ASSERT(x != NULL);\n    BIO_free(certin);\n\n    /*\n     * Read the server key\n     */\n    keyin = BIO_new(BIO_s_file_internal());\n    rv = BIO_read_filename(keyin, US1864_SERVER_KEY);\n    CU_ASSERT(rv &gt; 0);\n    priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    CU_ASSERT(priv_key != NULL);\n    BIO_free(keyin);\n\n    /*\n     * init EST in server mode\n     */\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n    ctx = est_server_init(cacerts, cacerts_len, cacerts, cacerts_len,\n        EST_CERT_FORMAT_PEM, &#34;testrealm&#34;, x, priv_key);\n\n    CU_ASSERT(ctx != NULL);\n\n    est_rv = est_server_set_auth_mode(ctx, AUTH_NONE);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_BASIC);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_TOKEN);\n    CU_ASSERT(est_rv == EST_ERR_NONE);\n    est_rv = est_server_set_auth_mode(ctx, 0xffffffff);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n\n    /*\n     * Make sure we don\&#39;t allow DIGEST mode when in FIPS mode\n     */\n    FIPS_mode_set(1);\n    est_rv = est_server_set_auth_mode(ctx, AUTH_DIGEST);\n    CU_ASSERT(est_rv == EST_ERR_BAD_MODE);\n    FIPS_mode_set(0);\n\n    X509_free(x);\n    EVP_PKEY_free(priv_key);\n\n    est_destroy(ctx);\n}\n\n/*\n * Simple enroll - Token Auth Mode\n *\n * The goal of this test is to verify that the EST server responds with the\n * correct auth challenge when it\&#39;s configured for Token Auth mode.  It will\n * first perform a sanity check by performing an HTTP Basic request while the\n * server is still in its default mode of HTTP Basic auth.  The test will then\n * configure the server for Token Auth mode and issue a request that does not\n * contain any auth header.  This should force the server to respond with a\n * token auth challenge header.\n */\nstatic void us1864_test2 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US1864_ENROLL_URL_BA, US1864_PKCS10_CT,\n    US1864_PKCS10_RSA2048,\n    US1864_UIDPWD_GOOD, US1864_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we specify BASIC and the server is still in BASIC\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Switch the server over to Token mode.\n     *\n     * NOTE: I see this being done in numerous places, and it\&#39;s probably safe\n     * in a test setting, but it is dangerous to change this on the fly in an\n     * operational setting.  Also note, no return code for any of these\n     * set/enable functions.\n     */\n    st_enable_http_token_auth();\n\n    bearer_found = 0;\n\n    rv = curl_http_post_cert_write(US1864_ENROLL_URL_BA,\n    US1864_PKCS10_CT,\n    US1864_PKCS10_RSA2048,\n    US1864_CLIENT_CERT,\n    US1864_CLIENT_KEY,\n    US1864_CACERTS, curl_data_cb, curl_data_cb);\n\n    /*\n     * Since we changed auth modes on the server we expect this to now\n     * fail.  We\&#39;re not capturing the actual auth challenge we\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 401);\n    CU_ASSERT(bearer_found == 1);\n\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1864_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us1864_cfg_tok_auth&#34;,\n            us1864_init_suite,\n            us1864_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;Check parms&#34;, us1864_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;Attempt enroll - BASIC pass&#34;, us1864_test2))\n        )\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n #endif\n }\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us1159.c&#39;: [&#39;/*------------------------------------------------------------------\n * us1159.c - Unit Tests for User Story 1159 - CSR Attributes enforce\n *\n * October, 2014\n *\n * Copyright (c) 2014, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &#34;test_utils.h&#34;\n#include &lt;openssl/ssl.h&gt;\n#include &lt;openssl/x509v3.h&gt;\n#include &#34;st_server.h&#34;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\n#ifndef WIN32\n#define US1159_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US1159_CACERT           &#34;CA/estCA/cacert.crt&#34;\n#define US1159_SERVER_CERT      &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US1159_SERVER_KEY       &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define US1159_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1159_CACERT           &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US1159_SERVER_CERT      &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US1159_SERVER_KEY       &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif\n#define US1159_UID              &#34;estuser&#34;\n#define US1159_PWD              &#34;estpwd&#34;\n\n#define US1159_SERVER_PORT      15897\n#define US1159_SERVER_IP        &#34;127.0.0.1&#34;\n\n#define US1159_ATTR_POP_ONLY    &#34;MAsGCSqGSIb3DQEJBw==\\0&#34;\n#define US1159_ATTR_CN_ONLY     &#34;MAUGA1UEAw==\\0&#34;\n#define US1159_ATTR_TEST        &#34;MHEGBysGAQEBARYwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBgUrgQQAIgYDVQQDBggqhkjOPQQDAg==\\0&#34;\n\nextern EST_CTX *ectx;\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\nstatic char *attrs;\n\nstatic unsigned char * handle_csrattrs_request (int *csr_len, char *path_seg,\n                                                void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(attrs);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, attrs, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic void us1159_clean (void)\n{\n}\n\nint us1159_start_server ()\n{\n    int rv = 0;\n\n    /*\n     * Start an EST server acting as the CA\n     */\n    rv = st_start(US1159_SERVER_PORT,\n                  US1159_SERVER_CERT,\n                  US1159_SERVER_KEY,\n                  &#34;estrealm&#34;,\n                  US1159_CACERT,\n                  &#34;CA/trustedcerts.crt&#34;,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  0, // manual enroll\n                  0,  // disable PoP\n                  0); // ecdhe nid info\n    if (rv != EST_ERR_NONE) {\n        printf(&#34;\\nUnable to start EST server for US1159.\\n&#34;);\n        return rv;\n    }\n\n    st_enable_csrattr_enforce();\n\n    rv = est_set_csr_cb(ectx, &amp;handle_csrattrs_request);\n    if (rv != EST_ERR_NONE) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback for US1159.\\n&#34;);\n        return (rv);\n    }\n\n    SLEEP(1);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us1159_init_suite (void)\n{\n    int rv;\n\n    us1159_clean();\n\n    printf(\n        &#34;\\nStarting server for CSR attributes enforcement unit tests (US1159).\\n&#34;);\n\n    attrs = US1159_ATTR_POP_ONLY;\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US1159_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us1159_start_server();\n\n    return rv;\n}\n\nvoid us1159_stop_server ()\n{\n    st_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us1159_destroy_suite (void)\n{\n    us1159_stop_server();\n    free(cacerts);\n    printf(&#34;Completed CSR attributes enforcement unit tests.\\n&#34;);\n    return 0;\n}\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n/*\n * This function generates an EC public/private key\n * pair that will be used with the certificate\n * we provision.\n */\nstatic EVP_PKEY * generate_ec_private_key (int nid)\n{\n    EC_KEY *eckey;\n    EC_GROUP *group = NULL;\n    BIO *out;\n    unsigned char *tdata;\n    unsigned char *key_data;\n    int key_len;\n    BIO *keyin;\n    EVP_PKEY *new_priv_key;\n    int asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    point_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\n\n    /*\n     * Generate an EC key\n     */\n    group = EC_GROUP_new_by_curve_name(nid /*NID_X9_62_prime256v1*/);\n    EC_GROUP_set_asn1_flag(group, asn1_flag);\n    EC_GROUP_set_point_conversion_form(group, form);\n    eckey = EC_KEY_new();\n    EC_KEY_set_group(eckey, group);\n    if (!EC_KEY_generate_key(eckey)) {\n        printf(&#34;Failed to generate EC key\\n&#34;);\n        return NULL;\n    }\n    out = BIO_new(BIO_s_mem());\n    PEM_write_bio_ECPKParameters(out, group);\n    PEM_write_bio_ECPrivateKey(out, eckey, NULL, NULL, 0, NULL, NULL);\n    key_len = BIO_get_mem_data(out, &amp;tdata);\n    key_data = malloc(key_len + 1);\n    memcpy(key_data, tdata, key_len);\n    EC_KEY_free(eckey);\n    BIO_free(out);\n\n    /*\n     * read it back in to an EVP_PKEY struct\n     */\n    keyin = BIO_new(BIO_s_mem());\n    keyin = BIO_new_mem_buf(key_data, key_len);\n\n    /*\n     * This reads in the private key file, which is expected to be a PEM\n     * encoded private key.  If using DER encoding, you would invoke\n     * d2i_PrivateKey_bio() instead.\n     */\n    new_priv_key = PEM_read_bio_PrivateKey(keyin, NULL, NULL, NULL);\n    if (new_priv_key == NULL) {\n        printf(&#34;\\nError while reading PEM encoded private key\\n&#34;);\n        ERR_print_errors_fp(stderr);\n        return NULL;\n    }\n    BIO_free(keyin);\n    free(key_data);\n\n    return (new_priv_key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing no CSR attributes other than\n * challengePassword. The enroll should succeed.\n */\nstatic void us1159_test1 (void)\n{\n    EST_CTX *ctx;\n    EVP_PKEY *key;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ctx, &#34;Test 1&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ctx);\n}\n\n/*\n * This routine builds a PKCS10 CSR.\n */\nstatic EST_ERROR populate_x509_request (X509_REQ *req, EVP_PKEY *pkey, char *cn)\n{\n    X509_NAME *subj;\n    int rv;\n\n    /* setup version number */\n    rv = X509_REQ_set_version(req, 0L);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_VER);\n    }\n\n    /*\n     * Add Common Name entry\n     */\n    subj = X509_REQ_get_subject_name(req);\n    rv = X509_NAME_add_entry_by_txt(subj, &#34;CN&#34;, MBSTRING_ASC,\n        (const unsigned char*) cn, -1, -1, 0);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_CN);\n    }\n\n    /*\n     * Add serial number Name entry\n     */\n    rv = X509_NAME_add_entry_by_NID(subj, NID_serialNumber, MBSTRING_ASC,\n        (unsigned char*) &#34;12349999B&#34;, -1, -1, 0);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_CN);\n    }\n\n    /*\n     * Add all the other attributes that the server will be expecting\n     */\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;1.3.6.1.1.1.1.22&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;dummymac&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;2.999.1&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;dummy&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;2.999.2&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;dummy&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;2.999.3&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;dummy&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;2.999.4&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;dummy&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;1.2.840.10045.2.1&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;1.3.132.0.34&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_txt(req, &#34;1.2.840.10045.4.3.3&#34;, MBSTRING_ASC,\n        (const unsigned char*) &#34;&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    rv = X509_REQ_add1_attr_by_NID(req, NID_serialNumber, MBSTRING_ASC,\n        (const unsigned char*) &#34;123456789A&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_UNKNOWN);\n    }\n\n    /*\n     * Set the public key on the request\n     */\n    rv = X509_REQ_set_pubkey(req, pkey);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n        return (EST_ERR_X509_PUBKEY);\n    }\n\n    X509_REQ_print_fp(stderr, req);\n\n    return (EST_ERR_NONE);\n}\n\n#if 0\n/*\n * Sign an X509 certificate request using the digest and the key passed.\n * Returns OpenSSL error code from X509_REQ_sign_ctx();\n */\nstatic int sign_X509_REQ(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\n{\n    int rv;\n    EVP_PKEY_CTX *pkctx = NULL;\n    EVP_MD_CTX mctx;\n\n    EVP_MD_CTX_init(&amp;mctx);\n\n    if (!EVP_DigestSignInit(&amp;mctx, &amp;pkctx, md, NULL, pkey)) {\n        return 0;\n    }\n\n    /*\n     * Encode using DER (ASN.1)\n     *\n     * We have to set the modified flag on the X509_REQ because\n     * OpenSSL keeps a cached copy of the DER encoded data in some\n     * cases.  Setting this flag tells OpenSSL to run the ASN\n     * encoding again rather than using the cached copy.\n     */\n    x-&gt;req_info-&gt;enc.modified = 1;\n    rv = X509_REQ_sign_ctx(x, &amp;mctx);\n\n    EVP_MD_CTX_cleanup(&amp;mctx);\n\n    return (rv);\n}\n#endif\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The enroll should succeed.\n */\nstatic void us1159_test2 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, &#34;Test 2&#34;);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n#if 0\n    /*\n     * Sign the request\n     */\n    ossl_rv = sign_X509_REQ(req, key, EVP_sha256());\n    CU_ASSERT(ossl_rv == 0);\n    if (!ossl_rv) {\n        ERR_print_errors_fp(stderr);\n    }\n#endif\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR except that the 521-bit curve is used. The enroll\n * should fail since the server CSR attrs specify to\n * use the 384-bit curve.\n */\nstatic void us1159_test3 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp521r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, &#34;Test 3&#34;);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR except that SHA-384 is used for the\n * signature. The enroll should fail since the server\n * CSR attrs require SHA-256.\n */\nstatic void us1159_test4 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, &#34;Test 3&#34;);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Change to SHA-384 for the signature\n     */\n    rv = est_client_set_sign_digest(ctx, NID_sha384);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured to only\n * require the CommonName.  The CSR attributes on\n * the server are configured through the static API,\n * not the callback.\n */\nstatic void us1159_test10 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Configure the static CSR attributes value\n     */\n    rv = est_server_init_csrattrs(ectx, US1159_ATTR_CN_ONLY,\n        strlen(US1159_ATTR_CN_ONLY));\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, &#34;Test 10&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The client also provides a large\n * quantity of additional attriutes.\n */\nstatic void us1159_test20 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n    int i;\n    char t_attr_str[50];\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, &#34;Test 20&#34;);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Jam another 25 attributes into the request\n     * We could do more, but this causes a failure on the EST server when\n     * base64 decoding the CSR due to a safeC constraint.  The max string\n     * size in safeC defaults to 4096 bytes.\n     */\n    for (i = 0; i &lt; 25; i++) {\n        sprintf(t_attr_str, &#34;2.899.%d&#34;, i);\n        rv = X509_REQ_add1_attr_by_txt(req, t_attr_str, MBSTRING_ASC,\n            (const unsigned char*) &#34;whatever&#34;, -1);\n        CU_ASSERT(rv != 0);\n        if (!rv) {\n            ERR_print_errors_fp(stderr);\n        }\n    }\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll with the\n * client providing all the required CSR attributes in\n * the CSR. The client also provides an attribute with\n * a very long name and value.\n */\nstatic void us1159_test21 (void)\n{\n    X509_REQ *req = NULL;\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * This sets the full list of attributes on the server\n     */\n    attrs = US1159_ATTR_TEST;\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    req = X509_REQ_new();\n    CU_ASSERT(req != NULL);\n\n    rv = populate_x509_request(req, key, &#34;Test 21&#34;);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Add an attribute with a long value\n     */\n    rv =\n            X509_REQ_add1_attr_by_txt(req, &#34;2.993.8&#34;, MBSTRING_ASC,\n                (const unsigned char*) &#34;This is an attribute with a very long value that could potentially cause a problem on the EST server.  0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789&#34;,\n                -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n    }\n\n    /*\n     * Add an attribute with a long name\n     */\n    rv =\n            X509_REQ_add1_attr_by_txt(req,\n                &#34;2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.2.993.8.828.85.8142.9999.2.1883.7&#34;,\n                MBSTRING_ASC, (const unsigned char*) &#34;0123456789&#34;, -1);\n    CU_ASSERT(rv != 0);\n    if (!rv) {\n        ERR_print_errors_fp(stderr);\n    }\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll_csr(ctx, req, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ctx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Cleanup\n     */\n    if (new_cert)\n        free(new_cert);\n    if (ctx)\n        est_destroy(ctx);\n    if (req)\n        X509_REQ_free(req);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured with\n * PoP enabled.\n */\nstatic void us1159_test50 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    st_enable_pop();\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    rv = est_client_force_pop(ctx);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, &#34;Test 50&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/*\n * This test attempts does a simple enroll when the\n * server has no CSR attributes configured with\n * PoP disabled.\n */\nstatic void us1159_test51 (void)\n{\n    EVP_PKEY *key = NULL;\n    int pkcs7_len = 0;\n    int rv;\n    EST_CTX *ctx = NULL;\n\n    LOG_FUNC_NM\n    ;\n\n    st_disable_pop();\n\n    /*\n     * Disable the CSR attr callback on the server context\n     */\n    rv = est_set_csr_cb(ectx, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * generate a private key\n     */\n    key = generate_ec_private_key(NID_secp384r1);\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Create a client context\n     */\n    ctx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ctx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ctx, US1159_UID, US1159_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ctx, US1159_SERVER_IP, US1159_SERVER_PORT, NULL);\n\n    /*\n     * Enroll a new cert\n     */\n    rv = est_client_enroll(ctx, &#34;Test 51&#34;, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Cleanup\n     */\n    if (ctx)\n        est_destroy(ctx);\n    if (key)\n        EVP_PKEY_free(key);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us1159_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us1159_csr_attr_enforce&#34;,\n            us1159_init_suite,\n            us1159_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    /* NOTE - ORDER IS IMPORTANT - MUST TEST fread() AFTER fprintf() */\n    if ((NULL == CU_add_test(pSuite, &#34;No attributes required w/pop&#34;, us1159_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;All attributes provided w/pop&#34;, us1159_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;EC public key wrong curve w/pop&#34;, us1159_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;Wrong hash algorithm in signature w/pop&#34;, us1159_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;CN only using static config w/pop&#34;, us1159_test10)) ||\n        (NULL == CU_add_test(pSuite, &#34;A lot of attributes w/pop&#34;, us1159_test20)) ||\n        (NULL == CU_add_test(pSuite, &#34;Long attribute w/pop&#34;, us1159_test21)) ||\n        (NULL == CU_add_test(pSuite, &#34;No CSR attrs on server w/pop&#34;, us1159_test50)) ||\n        (NULL == CU_add_test(pSuite, &#34;No CSR attrs on server w/o pop&#34;, us1159_test51)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us2174.c&#39;: [&#39;/*------------------------------------------------------------------\n * us2174.c - Unit Tests for User Story 2174 - Proxy simple enroll\n *\n * August, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US2174_RETRY_INTERVAL   3600\n//#define US2174_TCP_PORT       29001\n\n#define US2174_TCP_SERVER_PORT      52174\n#define US2174_TCP_PROXY_PORT       62174\n\n#ifndef WIN32\n#define US2174_SERVER_CERT      &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US2174_SERVER_KEY       &#34;CA/estCA/private/estservercertandkey.pem&#34;\n/* #define US2174_PROXY_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;   */\n/* #define US2174_PROXY_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n#define US2174_PROXY_CERT       &#34;US2174/cert.pem&#34;\n#define US2174_PROXY_KEY        &#34;US2174/key.pem&#34;\n#define US2174_CACERT           &#34;CA/estCA/cacert.crt&#34;\n#define US2174_CACERTS          &#34;CA/estCA/cacert.crt&#34;\n#define US2174_TRUSTED_CERTS    &#34;CA/trustedcerts.crt&#34;\n#define US2174_EXPLICIT_CERT    &#34;US2174/cert-RA.pem&#34;\n#define US2174_EXPLICIT_KEY     &#34;US2174/key-RA.pem&#34;\n\n#else\n#define US2174_SERVER_CERT      &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US2174_SERVER_KEY       &#34;CA\\\\estCA\\\\private/estservercertandkey.pem&#34;\n/* #define US2174_PROXY_CERT &#34;CA/estCA/private/estservercertandkey.pem&#34;   */\n/* #define US2174_PROXY_KEY &#34;CA/estCA/private/estservercertandkey.pem&#34; */\n#define US2174_PROXY_CERT       &#34;US2174\\\\cert.pem&#34;\n#define US2174_PROXY_KEY        &#34;US2174\\\\key.pem&#34;\n#define US2174_CACERT           &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US2174_CACERTS          &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US2174_TRUSTED_CERTS    &#34;CA\\\\trustedcerts.crt&#34;\n#define US2174_EXPLICIT_CERT    &#34;US2174\\\\cert-RA.pem&#34;\n#define US2174_EXPLICIT_KEY     &#34;US2174\\\\key-RA.pem&#34;\n#endif\n\n#define US2174_SERVER_IP        &#34;127.0.0.1&#34;\n#define US2174_TCP_PORT         US2174_TCP_SERVER_PORT\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US2174_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the ec.req file:\n *\n * openssl req -newkey ec:256parms -keyout eckey.pem -keyform PEM -out ec.req -outform PEM\n */\n#define US2174_PKCS10_DSA1024 &#34;MIICfjCCAj0CAQAwfDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEzARBgNVBAoMCkRTQUNvbXBhbnkxDzANBgNVBAsMBkRTQW9yZzEQMA4G\\nA1UEAwwHZHNhIGRvZTEaMBgGCSqGSIb3DQEJARYLZHNhQGRvZS5jb20wggG2MIIB\\nKwYHKoZIzjgEATCCAR4CgYEAqIfbyk7rEAaULIPB1GcHHc0ctx6g0dhBfdUdOPNG\\nBSE+TP5UF5lw8Qm6oCXstU3nYEJalmMvkjFwbgvBws8aJBnj09dDDn8spKEGcG0M\\nZpqdMys6+b4QJjq5YAxEaATVY/1L/rBgGGm1EFDhc/6Ezm2T3CGeQklwo5aBZQCc\\naIsCFQDC1olBFuE+phOhjXAwEE5EPJkRJwKBgD+vZ+tLCTjBzVFNjAO8X/SMamwW\\noraNfdyZ+ZCEAmYI/D4838nCGAjVRQyDb1q5akkLyxoJX1YV7gNbaBNUys3waqdu\\nso1HtuEur2cbhU5iOeKBWpj6MIWlPdD3uCRu4uiBF9XBiANaRID8CT2kchhwy4Ok\\nFfQMuYOz4eBhMQqmA4GEAAKBgDuwR7H3U4CfuQjWeTtrI50M1TxhlVZ3TonRtVIx\\nEHpuXxAouxATVkthJtaCBKc0EHii1bE/kgNUgGX/ZdFjBUb/XfpkYsRT3QRLF0+s\\nPZGY/0TovO9pKjqiw0C10leNKFbEVdlXYtAkjXUbHmyNog3195/t7oKXHMT1A/5p\\nhUCRoAAwCQYHKoZIzjgEAwMwADAtAhUAhPCqQG3gKUUPKdwBNCmZfzWDqjsCFAh0\\nzn9HujlXNaTA1OhjmPmcJSxT&#34;\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the dsa.req file:\n *\n * openssl req -newkey dsa:dsaparms -keyout dsakey.pem -keyform PEM -out dsa.req -outform PEM\n */\n#define US2174_PKCS10_ECDSA256 &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ29yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n#define US2174_PKCS10_CORRUPT &#34;MIIBMTCB2gIBADB4MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTkMxDDAKBgNVBAcM\\nA1JUUDESMBAGA1UECgwJRUNDb21wYW55MQ4wDAYDVQQLDAVFQ39yZzEPMA0GA1UE\\nAwwGRUMgZG9lMRkwFwYJKoZIhvcNAQkBFgplY0Bkb2UuY29tMFkwEwYHKoZIzj0C\\nAQYIKoZIzj0DAQcDQgAEO1uszCKdXNFzygNLNeS8azQKod1516GT9qdDddt9iJN4\\nLpBTnv+7K7+tji5kts1kWSYyvqLxvnq8Q/TU1iQJ56AAMAkGByqGSM49BAEDRwAw\\nRAIgP6qda+0TEKZFPopgUfwFMRsxcNmuQUe2yuz16460/SQCIBfLvmuMeyYOqbbD\\nX0Ifde9yzkROVBCEPvK0hcU5KsTO&#34;\n\n/*\n * The following is a valid CSR that already contains a PoP\n * challengePassword.  This was collected using estserver with\n * the dumpbin() function.  This CSR should never work since\n * the PoP value in it will be stale.\n */\n#define US2174_PKCS10_STALE_POP &#34;MIIBcjCB3AIBADARMQ8wDQYDVQQDEwZURVNUQ04wgZ8wDQYJKoZIhvcNAQEBBQAD\\ngY0AMIGJAoGBAPDHvrkVB3+rFHl+KuIsrZGixldRYRD50S2vFs8mW5wWVxDS3xFR\\nzcKtqg7JUyW8NYOFNWX0ozhCe87XP2h7tUpHyHlL/8N/84zuMtAtKTLU3Bjgq1xg\\nuu8a1ht10wiy8u2r/uEKMhQwpvt56UY5pHzuqmqlO0qlmE+M58WN49IhAgMBAAGg\\nIjAgBgkqhkiG9w0BCQcxExYRUjdGN1ZUNUwyd2VueWtMcAowDQYJKoZIhvcNAQEF\\nBQADgYEAyenrskmfRIXcpeKBvL3VnW5N4HcLTwI9Hcbr744SWFQaw/R+ru+UXd2j\\n99AGBr/GvTkTghINWg2C7vzGF/zhIuG6Ok9FtiMnNr9hZ+5SLYhfSFJbuIv65rWH\\nvfLR9N9M2Q9jlf7p4AYfWXD2qD2XOTZw2t4trGZGKA2JR/OiB40=&#34;\n\n#define US2174_ENROLL_URL_BA    &#34;https://127.0.0.1:62175/.well-known/est/simpleenroll&#34;\n#define US2174_PKCS10_CT        &#34;Content-Type: application/pkcs10&#34; \n#define US2174_UIDPWD_GOOD      &#34;estuser:estpwd&#34;\n\nstatic EVP_PKEY * generate_private_key (void)\n{\n    RSA *rsa = RSA_new();\n    BIGNUM *bn = BN_new();\n    EVP_PKEY *pkey;\n\n    /*\n     * create an RSA keypair and assign them to a PKEY and return it.\n     */\n    BN_set_word(bn, 0x10001);\n    RSA_generate_key_ex(rsa, 1024, bn, NULL);\n\n    pkey = EVP_PKEY_new();\n    if (pkey == NULL) {\n        printf(&#34;\\nError allocating PKEY structure for new key pair\\n&#34;);\n        return NULL;\n    }\n    if (!EVP_PKEY_set1_RSA(pkey, rsa)) {\n        printf(&#34;\\nError assigning RSA key pair to PKEY structure\\n&#34;);\n        return NULL;\n    }\n\n    RSA_free(rsa);\n    BN_free(bn);\n\n    return (pkey);\n}\n\n#define GOOD_TOKEN &#34;WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=&#34;\n#define DIFFERENT_TOKEN &#34;V2VsbCwgSSd2ZSBnb3QgdG8gcnVuIHRvIGtlZXAgZnJvbSBoaWRpbicNCkFuZCBJJ20gYm91bmQgdG8ga2VlcCBvbiByaWRpbicNCkFuZCBJJ3ZlIGdvdCBvbmUgbW9yZSBzaWx2ZXIgZG9sbGFyDQpCdXQgSSdtIG5vdCBnb25uYSBsZXQgJ2VtIGNhdGNoIG1lLCBubw0KTm90IGdvbm5hIGxldCAnZW0gY2F0Y2ggdGhlIG1pZG5pZ2h0IHJpZGVy&#34;\n#define NULL_TOKEN NULL;\n#define LONG_TOKEN &#34;SSBjYW4ndCBhZ3JlZSB0byBkaXNhZ3JlZSANCkZpZ2h0aW5nIGxpa2UgSSdtIGZpZ2h0aW5nIGZvciBsaWZlIA0KVGhleSdyZSBvbmx5IHdvcmRzIGJ1dCB0aGV5IGN1dCBsaWtlIGEgYmxhZGUgDQpTd2luZ2luZyB3aWRlIHdpdGggYWxsIG9mIG15IG1pZ2h0IA0KDQpBaCB5ZWFoLCBJIGd1ZXNzIGl0J3MgYWxsIG9mIHRoYXQgY29mZmVlLCB0aGF0J3MgZ290IG15IG1pbmQgaW4gYSB3aGlybCANCkknbSBzdGlsbCBjdXNzaW5nIGFuZCBiaXRjaGluZyBhbmQgdGhlcmUgYWluJ3Qgbm9ib2R5IGhlcmUgDQoNCk9oIHllYWgsIHlvdSBkb24ndCBoYXZlIHRvIGhvbGxlciBJIGhlYXIgeW91IA0KSSdtIHN0YW5kaW5nIHJpZ2h0IGhlcmUgYmVzaWRlIHlvdSANCk9oLCA5OSBzaGFkZXMgb2YgY3JhenksIEknbSA5OSBzaGFkZXMgb2YgY3JhenkgDQpDcmF6eSwgY3JhenksIGNyYXp5LCBjcmF6eSANCg0KUG91ciBhbm90aGVyIGRyaW5rLCBtYWtlIGl0IGEgZG91YmxlIGZvciBtZSANCk1heWJlIEkgY2FuIGRyaW5rIHRoaXMgYXdheSANCkl0J3MgbmV2ZXIgZnVuIHdoZW4gdGhleSBwdWxsIG91dCB0aGUgZ3VuIA0KQmVhdCB5b3UgYmxhY2sgYW5kIGJsdWUsIGJveSANCllvdSBnb3R0YSBwYXksIHlvdSBnb3R0YSBwYXkgDQoNCk9oLCB3aGVyZSB0aGUgaGVsbCBhbSBJPyBJIGhvcGUgYXQgbGVhc3QgSSBoYWQgZnVuIA0KSSdtIHN0dW1ibGluZyB0aHJvdWdoIE5ldyBPcmxlYW5zIG9oLCB0byB0aGUgcmlzaW5nIHN1biANCg0KT2ggeWVhaCwgeW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3UgDQpJJ20gc3RhbmRpbmcgcmlnaHQgaGVyZSBiZXNpZGUgeW91IA0KT2gsIDk5IHNoYWRlcyBvZiBjcmF6eSwgSSdtIDk5IHNoYWRlcyBvZiBjcmF6eSANCkNyYXp5LCBjcmF6eSwgY3JhenksIGNyYXp5IA0KDQpMb3JkIGhhdmUgbWVyY3kgb24gbWUgDQpOb3ZlbnRhIG51ZXZhIHRvbm9zIGRlIGxvY28gDQoNCkkgbmVlZCBzb21lIHBlYWNlLCBqdXN0IHNvbWUgcmVsaWVmIA0KRnJvbSB0aGlzIHZvaWNlLCBraWxsaW5nIG1lIA0KWW91IHN0YXJlIGF0IG1lLCBhbmQgeW91IGdsYXJlIGF0IG1lIA0KQWxsIHRoaXMgcGFpbiBpdCdzIGFsbCB0aGUgc2FtZSwgaXQncyBhbGwgaW5zYW5lIA0KKHlvdSBzZWUpIA0KDQpJcyB0aGlzIHJlYWxseSBoYXBwZW5pbmcgb3IgZGlkIEkgbWFrZSBpdCBhbGwgdXA/IA0KSSdtIGJvdW5kIGZvciBDaGF0dGFob29jaGVlIG9uIGEgdHVybmlwIHRydWNrIA0KDQpPaCB5ZWFoLCB5b3UgZG9uJ3QgaGF2ZSB0byBob2xsZXIgSSBoZWFyIHlvdSANCkknbSBzdGFuZGluZyByaWdodCBoZXJlIGJlc2lkZSB5b3UgDQpPaCwgOTkgc2hhZGVzIG9mIGNyYXp5LCBJJ20gOTkgc2hhZGVzIG9mIGNyYXp5IA0KQ3JhenksIGNyYXp5LCBjcmF6eSwgY3JhenkgDQoNCkFoIHlvdSdyZSBjcmF6eSB5b3UncmUgY3JhenkgDQpIb2xkIG15IGZlZXQsIGZlZXQgdG8gdGhlIGZpcmUgDQpZb3UgaG9sZCBteSBmZWV0IHRvIHRoZSBmaXJlIA0KSSBuZXZlciBzYWlkIEkgd2FzIGRvd24gd2l0aCB5b3U=&#34;\nstatic char *test_token = &#34;WW91IGRvbid0IGhhdmUgdG8gaG9sbGVyIEkgaGVhciB5b3U=&#34;;\n\nstatic int auth_cred_callback_called = 0;\nstatic int auth_cred_force_error = 0;\n\n/*\n * auth_credentials_token_cb() is the application layer callback function that will\n * return a token based authentication credential when called.  It\&#39;s registered\n * with the EST Client using the est_client_set_auth_cred_cb().\n * The test function is required to set some global values in order to make this\n * callback operate the way that the test case wants.\n * - auth_cred_force_error = tell this function to force a response code error\n * - test_token = pointer to a hard coded string that is the token string to return\n *\n * This callback must provide the token credentials in a heap based buffer, and\n * ownership of that buffer is implicitly transferred to the ET client library upon\n * return.\n */\nstatic EST_HTTP_AUTH_CRED_RC auth_credentials_token_cb (\n        EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    char *token_ptr = NULL;\n    int token_len = 0;\n\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_TOKEN);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials-&gt;mode == AUTH_TOKEN) {\n        /*\n         * If the test_token is set to anything, then we need to allocate\n         * space from the heap and copy in the value.\n         */\n        if (test_token != NULL) {\n            token_len = strlen(test_token); /* use strlen() so that the string can be as large\n             as needed to test the EST client */\n            if (token_len == 0) {\n                printf(\n                    &#34;\\nError determining length of token string used for credentials\\n&#34;);\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }\n            token_ptr = malloc(token_len + 1);\n            if (token_ptr == NULL) {\n                printf(\n                    &#34;\\nError allocating token string used for credentials\\n&#34;);\n                return EST_HTTP_AUTH_CRED_NOT_AVAILABLE;\n            }\n            strncpy(token_ptr, test_token, strlen(test_token));\n            token_ptr[token_len] = \&#39;\\0\&#39;;\n        }\n        /*\n         * If we made it this far, token_ptr is pointing to a string\n         * containing the token to be returned. Assign it and return success\n         */\n        auth_credentials-&gt;auth_token = token_ptr;\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n/*\n * auth_credentials_basic_cb() is the same as the token based one above, but\n * instead returns the basic credentials of userid and password\n */\nstatic EST_HTTP_AUTH_CRED_RC auth_credentials_basic_cb (\n        EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_BASIC);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials-&gt;mode == AUTH_BASIC) {\n\n        auth_credentials-&gt;user = malloc(sizeof(&#34;estuser&#34;));\n        strncpy(auth_credentials-&gt;user, &#34;estuser&#34;, sizeof(&#34;estuser&#34;));\n        auth_credentials-&gt;pwd = malloc(sizeof(&#34;estpwd&#34;));\n        strncpy(auth_credentials-&gt;pwd, &#34;estpwd&#34;, sizeof(&#34;estpwd&#34;));\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n\n#if 0\n/*\n * auth_credentials_digest_cb() is the same as the basic based one above, but\n * instead verfies that the auth_mode passed is digest\n */\nstatic\nEST_HTTP_AUTH_CRED_RC auth_credentials_digest_cb(EST_HTTP_AUTH_HDR *auth_credentials)\n{\n    CU_ASSERT(auth_credentials-&gt;mode == AUTH_DIGEST);\n\n    /*\n     * report that the callback has been called.\n     */\n    auth_cred_callback_called = 1;\n\n    /*\n     * See if the test is requesting to force an error response code from the\n     * callback\n     */\n    if (auth_cred_force_error) {\n        return(EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n    }\n\n    if (auth_credentials-&gt;mode == AUTH_DIGEST) {\n\n        auth_credentials-&gt;user = malloc(sizeof(&#34;estuser&#34;));\n        strncpy(auth_credentials-&gt;user, &#34;estuser&#34;, sizeof(&#34;estuser&#34;));\n        auth_credentials-&gt;pwd = malloc(sizeof(&#34;estpwd&#34;));\n        strncpy(auth_credentials-&gt;pwd, &#34;estpwd&#34;, sizeof(&#34;estpwd&#34;));\n\n        return (EST_HTTP_AUTH_CRED_SUCCESS);\n    }\n\n    return (EST_HTTP_AUTH_CRED_NOT_AVAILABLE);\n}\n#endif\n\n/*\n * Callback function passed to est_client_init()\n */\nstatic int client_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__, openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * us2174_simple_enroll() is used by test cases to perform a simple enroll.\n */\nstatic void us2174_simple_enroll (char *cn, char *server,\n                                  EST_ERROR expected_enroll_rv,\n                                  auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    EST_ERROR e_rc;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\nstatic\nvoid us2174_simple_reenroll (char *cn, char *server,\n                             EST_ERROR expected_enroll_rv,\n                             auth_credentials_cb callback)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    EST_ERROR rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n\n    PKCS7 *p7 = NULL;\n    BIO *b64, *out;\n    X509 *cert = NULL;\n    STACK_OF(X509) * certs = NULL;\n    int i;\n\n    EST_ERROR e_rc;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PROXY_PORT, NULL);\n\n    /*\n     * generate a private key\n     */\n    key = generate_private_key();\n    CU_ASSERT(key != NULL);\n\n    /*\n     * Use the simplified API to enroll a CSR\n     */\n    rv = est_client_enroll(ectx, cn, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    est_destroy(ectx);\n    ectx = NULL;\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM,\n        client_manual_cert_verify);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Now that we have the cert, switch the server over to token mode\n     */\n    st_enable_http_token_auth();\n\n    e_rc = est_client_set_auth_cred_cb(ectx, callback);\n    CU_ASSERT(e_rc == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, server, US2174_TCP_PORT, NULL);\n\n    /*\n     * And attempt a reenroll while in token mode\n     *\n     * Convert the cert to an X509.  Be warned this is\n     * pure hackery.\n     * PDB: This conversion code comes from other test cases.\n     */\n    b64 = BIO_new(BIO_f_base64());\n    out = BIO_new_mem_buf(new_cert, pkcs7_len);\n    out = BIO_push(b64, out);\n    p7 = d2i_PKCS7_bio(out, NULL);\n    CU_ASSERT(p7 != NULL);\n    BIO_free_all(out);\n    i = OBJ_obj2nid(p7-&gt;type);\n    switch (i) {\n    case NID_pkcs7_signed:\n        certs = p7-&gt;d.sign-&gt;cert;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        certs = p7-&gt;d.signed_and_enveloped-&gt;cert;\n        break;\n    default:\n        break;\n    }\n    CU_ASSERT(certs != NULL);\n    if (!certs)\n        return;\n    /* our new cert should be the one and only\n     * cert in the pkcs7 blob.  We shouldn\&#39;t have to\n     * iterate through the full list to find it. */\n    cert = sk_X509_value(certs, 0);\n    CU_ASSERT(cert != NULL);\n\n    /*\n     * PDB NOTE: At the moment, this is expected to fail since\n     * the server does not yet understand requests with token authentication.\n     * Once 1884 is complete, the below ASSERT will begin to fail and will need\n     * to be changed to a passing response.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == expected_enroll_rv);\n\n    /*\n     * Cleanup\n     */\n    EVP_PKEY_free(key);\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\nstatic void us2174_clean (void)\n{\n}\n\nstatic int us2174_start_server (int manual_enroll, int nid)\n{\n    int rv = 0;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US2174_TCP_SERVER_PORT,\n                  US2174_SERVER_CERT,\n                  US2174_SERVER_KEY,\n                  &#34;estrealm&#34;,\n                  US2174_CACERT,\n                  US2174_TRUSTED_CERTS,\n                  &#34;US2174/estExampleCA.cnf&#34;,\n                  manual_enroll, // manual enroll\n                  0,  // disable PoP\n                  nid); // ecdhe nid info\n    SLEEP(1);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy acting as an RA with the server side\n     * operating in token auth mode.\n     */\n    rv = st_proxy_start_token(US2174_TCP_PROXY_PORT,\n                              US2174_PROXY_CERT,\n                              US2174_PROXY_KEY, &#34;estrealm&#34;,\n                              US2174_CACERT,\n                              US2174_TRUSTED_CERTS,\n                              &#34;estuser&#34;,\n                              &#34;estpwd&#34;,\n                              &#34;127.0.0.1&#34;,\n                              US2174_TCP_SERVER_PORT,\n                              0); //  disable PoP\n\n    SLEEP(1);\n\n    return rv;\n}\n\nvoid us2174_stop_server ()\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us2174_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US2174_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us2174_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us2174_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us2174_destroy_suite (void)\n{\n    us2174_stop_server();\n    free(cacerts);\n    return 0;\n}\n\n#if 0\n/*\n * Simple enroll -\n * proxy - BASIC\n * server - BASIC\n *\n * Make sure token auth mode did not break anything.\n *\n */\nstatic void us2174_test1(void)\n{\n    long rv;\n\n    LOG_FUNC_NM;\n\n    rv = curl_http_post(US2174_ENROLL_URL_BA, US2174_PKCS10_CT,\n            US2174_PKCS10_RSA2048,\n            US2174_UIDPWD_GOOD, US2174_CACERTS, CURLAUTH_BASIC,\n            NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n#endif\n\n/*\n * Simple enroll -\n * proxy - TOKEN\n * server - TOKEN\n *\n */\nstatic void us2174_test2 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(&#34;TC2174-4&#34;, US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple enroll -\n * proxy - TOKEN\n * server - BASIC\n */\nstatic void us2174_test3 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do BASIC auth challenges\n     */\n    st_enable_http_basic_auth();\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(&#34;TC2174-4&#34;, US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple enroll -\n * proxy - BASIC\n * server - TOKEN\n */\nstatic void us2174_test4 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do BASIC auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_basic_auth();\n    /*     st_proxy_set_srv_valid_token(GOOD_TOKEN); */\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple enroll.\n     *\n     * Enroll should succeed.\n     */\n    us2174_simple_enroll(&#34;TC2174-4&#34;, US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_basic_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/*\n * Simple RE-enroll -\n * proxy - TOKEN\n * server - TOKEN\n *\n */\nstatic void us2174_test5 (void)\n{\n    LOG_FUNC_NM\n    ;\n\n    auth_cred_callback_called = 0;\n    auth_cred_force_error = 0;\n\n    /*\n     * set server to do token auth challenges\n     * tell the server which tokens to accept\n     */\n    st_enable_http_token_auth();\n    st_set_token(GOOD_TOKEN);\n    /*\n     * set the proxy to do token auth challenges and\n     * tell it what tokens to accept.\n     */\n    st_proxy_enable_http_token_auth();\n    st_proxy_set_srv_valid_token(GOOD_TOKEN);\n    /*\n     * tell the client side of proxy which token credential to\n     * use\n     */\n    st_proxy_set_clnt_token_cred(GOOD_TOKEN);\n\n    /*\n     * Set up the EST Client and have it perform a simple RE-enroll.\n     *\n     * RE-enroll should succeed.\n     */\n    us2174_simple_reenroll(&#34;TC2174-4&#34;, US2174_SERVER_IP, EST_ERR_NONE,\n        auth_credentials_token_cb);\n\n    /*\n     * callback should have been called\n     */\n    CU_ASSERT(auth_cred_callback_called == 1);\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us2174_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us2174_token_proxy&#34;,\n            us2174_init_suite,\n            us2174_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if (/* (NULL == CU_add_test(pSuite, &#34;Proxy Enroll basic sanity test&#34;, us2174_test1)) || */\n        (NULL == CU_add_test(pSuite, &#34;Proxy Enroll token auth, both proxy and server&#34;, us2174_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;Proxy Enroll token auth, proxy token/server basic&#34;, us2174_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;Proxy Enroll token auth, proxy basic/server token&#34;, us2174_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;Proxy RE-Enroll token auth, proxy basic/server token&#34;, us2174_test5))\n        )\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us893.c&#39;: [&#39;/*------------------------------------------------------------------\n * us893.c - Unit Tests for User Story 893 - proxy reenroll\n *\n * October, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US893_TCP_SERVER_PORT       29893\n#define US893_TCP_PROXY_PORT        29093\n\n/*\n * The following CSR was generated using the following openssl command and then\n * using cat on the rsa.req file:\n *\n * openssl req -newkey rsa:2048 -keyout rsakey.pem -keyform PEM -out rsa.req -outform PEM\n */\n#define US893_PKCS10_RSA2048 &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDJA9mdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n#define US893_PKCS10_CORRUPT &#34;MIICvTCCAaUCAQAweDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5DMQwwCgYDVQQH\\nDANSVFAxEjAQBgNVBAoMCVJTQWNlcnRjbzEMMAoGA1UECwwDcnNhMRAwDgYDVQQD\\nDAdyc2EgZG9lMRowGAYJKoZIhvcNAQkBFgtyc2FAZG9lLmNvbTCCASIwDQYJKoZI\\nhvcNAQEBBQADggEPADCCAQoCggEBAN6pCTBrK7T029Bganq0QHXHyNL8opvxc7JY\\nXaQz39R3J9BoBE72XZ0QXsBtUEYGNhHOLaISASNzs2ZKWpvMHJWmPYNt39OCi48Y\\nFOgLDbAn83mAOKSfcMLbibCcsh4HOlhaaFrWskRTAsew16MUOzFu6vBkw/AhI82J\\nKPYws0dYOxuWFIgE1HL+m/gplbzq7FrBIdrqkNL+ddgyXoDd5NuLMJGDAK7vB1Ww\\n9/Baw/6Ai9V5psye1v8fWDr6HW2gg9XnVtMwB4pCg1rl1lSYstumTGYbM6cxJywe\\nLuMnDjj1ZwDsZ1wIXaBAXZaxEIS/rXOX0HnZMTefxY/gpFk1Kv0CAwEAAaAAMA0G\\nCSqGSIb3DQEBBQUAA4IBAQB6rIwNjE8l8jFKR1hQ/qeSvee/bAQa58RufZ4USKuK\\nlsih7UCf8bkQvgljnhscQuczIbnJzeqEPqSdnomFW6CvMc/ah+QfX87FGYxJgpwF\\nutnUifjDiZhrWgf/jNNbtHrkecw/Zex4sZ/HC127jtE3cyEkDsrA1oBxYRCq93tC\\nW2q9PLVmLlyjcZcS1KHVD2nya79kfS0YGMocsw1GelVL2iz/ocayAS5GB9Y2sEBw\\nRkCaYZw6vhj5qjpCUzJ3E8Cl3VD4Kpi3j3bZGDfffmdmd8j5ZyPY56eAuxarWssD\\nciUM/h6E99w3tmrUZbLljkjJ7pBXRnontgm5WZmQFH4X&#34;\n\n#define US893_SERVER_IP         &#34;127.0.0.1&#34; \n#define US893_REENROLL_URL_BA   &#34;https://127.0.0.1:29093/.well-known/est/simplereenroll&#34;\n#define US893_PKCS10_CT         &#34;Content-Type: application/pkcs10&#34; \n#define US893_UIDPWD_GOOD       &#34;estuser:estpwd&#34;\n#define US893_UID               &#34;estuser&#34;\n#define US893_PWD               &#34;estpwd&#34;\n#ifndef WIN32\n#define US893_CACERTS           &#34;CA/estCA/cacert.crt&#34;\n#define US893_TRUSTED_CERTS     &#34;CA/trustedcerts.crt&#34;\n#define US893_SERVER_CERTKEY    &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#define US893_PROXY_CERT        &#34;US893/cert.pem&#34;\n#define US893_PROXY_KEY         &#34;US893/key.pem&#34;\n#define US893_UNTRUSTED_CERT    &#34;US893/cert-untrusted.pem&#34;\n#define US893_UNTRUSTED_KEY     &#34;US893/key-untrusted.pem&#34;\n#define US893_EXPIRED_KEY       &#34;US893/key-expired.pem&#34;\n#define US893_EXPIRED_CERT      &#34;US893/cert-expired.pem&#34;\n\n#define US893_TC2_CERT_TXT      &#34;US893/tc2-new-cert.txt&#34;\n#define US893_TC2_CERT_B64      &#34;US893/tc2-new-cert.pkcs7b64&#34;\n#define US893_TC2_CERT_PK7      &#34;US893/tc2-new-cert.pkcs7&#34;\n#define US893_TC2_CERT_PEM      &#34;US893/tc2-new-cert.pem&#34;\n#else\n#define US893_CACERTS           &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US893_TRUSTED_CERTS     &#34;CA\\\\trustedcerts.crt&#34;\n#define US893_SERVER_CERTKEY    &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#define US893_PROXY_CERT        &#34;US893\\\\cert.pem&#34;\n#define US893_PROXY_KEY         &#34;US893\\\\key.pem&#34;\n#define US893_UNTRUSTED_CERT    &#34;US893\\\\cert-untrusted.pem&#34;\n#define US893_UNTRUSTED_KEY     &#34;US893\\\\key-untrusted.pem&#34;\n#define US893_EXPIRED_KEY       &#34;US893\\\\key-expired.pem&#34;\n#define US893_EXPIRED_CERT      &#34;US893\\\\cert-expired.pem&#34;\n\n#define US893_TC2_CERT_TXT      &#34;US893\\\\tc2-new-cert.txt&#34;\n#define US893_TC2_CERT_B64      &#34;US893\\\\tc2-new-cert.pkcs7b64&#34;\n#define US893_TC2_CERT_PK7      &#34;US893\\\\tc2-new-cert.pkcs7&#34;\n#define US893_TC2_CERT_PEM      &#34;US893\\\\tc2-new-cert.pem&#34;\n#endif\n\nstatic void us893_clean (void)\n{\n    char cmd[200];\n\n    /*\n     * These are all temporary files created\n     * by the various test cases.\n     */\n#ifndef WIN32\n    sprintf(cmd, &#34;rm %s&#34;, US893_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US893_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US893_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, &#34;rm %s&#34;, US893_TC2_CERT_PEM);\n    system(cmd);\n#else\n    sprintf(cmd, &#34;del %s&#34;, US893_TC2_CERT_TXT);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US893_TC2_CERT_B64);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US893_TC2_CERT_PK7);\n    system(cmd);\n    sprintf(cmd, &#34;del %s&#34;, US893_TC2_CERT_PEM);\n    system(cmd);\n#endif\n}\n\nstatic int us893_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    /*\n     * First we start an EST server acting as the CA\n     */\n    rv = st_start(US893_TCP_SERVER_PORT,\n                  US893_SERVER_CERTKEY,\n                  US893_SERVER_CERTKEY,\n                  &#34;US893 test realm&#34;,\n                  US893_CACERTS,\n                  US893_TRUSTED_CERTS,\n                  &#34;US893/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  0,\n                  nid);\n    if (rv != EST_ERR_NONE)\n        return rv;\n\n    /*\n     * Next we start an EST proxy actging as an RA\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        nid);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us893_init_suite (void)\n{\n    int rv;\n\n    est_init_logger(EST_LOG_LVL_INFO, NULL);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US893_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    us893_clean();\n\n    /*\n     * Start an instance of the EST server with\n     * automatic enrollment enabled.\n     */\n    rv = us893_start_server(0, 0);\n\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us893_destory_suite (void)\n{\n    st_stop();\n    st_proxy_stop();\n    free(cacerts);\n    return 0;\n}\n\n/*\n * Simple reenroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * reenroll of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.\n */\nstatic void us893_test1 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_RSA2048,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a valid userID/password,\n     * we expect the server to respond with 200\n     */\n    CU_ASSERT(rv == 200);\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  The expired certs contains\n * several X509 extensions. We verify the new issued\n * cert preserves these extensions using grep.  Note,\n * preserving these extensions requires the OpenSSL CA\n * to enable the &#34;copy_extensions&#34; knob in the OpenSSL\n * config file.  This is why this test suite uses a\n * unique copy of estExampleCA.cnf.\n */\nstatic void us893_test2 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    unsigned char *new_cert = NULL;\n    X509 *cert = NULL;\n    BIO *in;\n    char cmd[200];\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Retrieve the cert that was given to us by the EST server\n     */\n    if (rv == EST_ERR_NONE) {\n        new_cert = malloc(pkcs7_len);\n        CU_ASSERT(new_cert != NULL);\n        rv = est_client_copy_enrolled_cert(ectx, new_cert);\n        CU_ASSERT(rv == EST_ERR_NONE);\n    }\n\n    /*\n     * Save the cert to a local file\n     */\n    rv = write_binary_file(US893_TC2_CERT_B64, new_cert, pkcs7_len);\n    CU_ASSERT(rv == 1);\n\n    /*\n     * Base 64 decode the cert response\n     */\n    sprintf(cmd, &#34;openssl base64 -d -in %s -out %s&#34;, US893_TC2_CERT_B64,\n    US893_TC2_CERT_PK7);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert the pkcs7 cert to a PEM cert\n     */\n    sprintf(cmd, &#34;openssl pkcs7 -in %s -inform DER -print_certs -out %s&#34;,\n    US893_TC2_CERT_PK7,\n    US893_TC2_CERT_PEM);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Convert PEM cert to a textual representation of the cert\n     */\n    sprintf(cmd, &#34;openssl x509 -text -in %s &gt; %s&#34;, US893_TC2_CERT_PEM,\n    US893_TC2_CERT_TXT);\n    rv = system(cmd);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the jimbob DNS extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, &#34;jimbob&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the bobcat DNS extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, &#34;bobcat&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the IP address extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, &#34;172&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the Repudiation key usage extension was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT, &#34;Repudiation&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Verify the public key was preserved\n     */\n    rv = grep(US893_TC2_CERT_TXT,\n        &#34;00:e3:ca:38:65:fb:9c:46:a6:22:b1:be:17:bc:50&#34;);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Clean up\n     */\n    if (new_cert)\n        free(new_cert);\n    est_destroy(ectx);\n}\n\n/*\n * Simple reenroll - Corrupt CSR\n *\n * Use libcurl to send a reenroll request containing\n * a corrupted CSR.\n */\nstatic void us893_test3 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_CORRUPT,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * Since we passed in a bad CSR,\n     * we expect the server to respond with 400\n     */\n    CU_ASSERT(rv == 400);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured for manual\n * approval.  The server will send back a retry-after\n * response.  This verifies the proxy propagates the\n * retry-after response to the client.\n */\nstatic void us893_test4 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int rv;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    int retry_val = 0;\n    time_t time_val;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n    st_proxy_stop();\n\n    /*\n     * Restart the server with manual approval enabled\n     */\n    rv = us893_start_server(1, 0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_CA_ENROLL_RETRY);\n\n    /*\n     * The server should be configured with a retry-after\n     * value of 3600 seconds, which is the default.\n     */\n    rv = est_client_copy_retry_after(ectx, &amp;retry_val, &amp;time_val);\n    CU_ASSERT(rv == EST_ERR_NONE);\n    CU_ASSERT(retry_val == 3600);\n\n    /*\n     * Clean up\n     */\n    est_destroy(ectx);\n\n    /*\n     * Stop the server.\n     */\n    st_stop();\n    st_proxy_stop();\n\n    /*\n     * Restart the server with manual approval disabled\n     */\n    rv = us893_start_server(0, 0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * enabled, but the proxy server is using a cert\n * that doesn\&#39;t contain id-kp-cmcRA.  This should\n * result in a failure.\n */\nstatic void us893_test5 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is enabled on the server\n     */\n    st_enable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA,\n                        US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD,\n                        US893_CACERTS,\n                        CURLAUTH_BASIC,\n                        NULL,\n                        NULL,\n                        NULL);\n    /*\n     * The PoP check should fail\n     */\n    CU_ASSERT(rv == 400);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;, &#34;estpwd&#34;, &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * disabled, but the proxy server is using a cert\n * that doesn\&#39;t contain id-kp-cmcRA.  This should\n * result in a successful reenroll.\n */\nstatic void us893_test6 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n    US893_PKCS10_RSA2048,\n    US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC, NULL, NULL, NULL);\n    /*\n     * The reenroll should work since PoP is not enabled anywhere.\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test attempts to re-enroll an expired cert\n * while the EST server is configured with PoP\n * disabled, but the proxy server is using a cert\n * that doesn\&#39;t contain id-kp-cmcRA.  The CSR will\n * contain the PoP, which forces it to be checked.\n * This should result in a failure since the RA\n * cert doesn\&#39;t contain id-kp-cmcRA.\n */\n//The following include should never be used by an application\n//be we use it here to hack the EST_CTX values mid-way\n//through this test\n#include &#34;../../src/est/est_locl.h&#34;\nstatic void us893_test7 (void)\n{\n    int rv;\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    int pkcs7_len = 0;\n    X509 *cert = NULL;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_SERVER_CERTKEY,\n                        US893_SERVER_CERTKEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    ectx-&gt;csr_pop_required = 1; //This is a hack for testing only, do not attempt this \n    //We need to force the challengePassword into the CSR\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_HTTP_BAD_REQ);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n\n    est_destroy(ectx);\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  PoP is disabled on\n * the EST server.\n */\nstatic void us893_test8 (void)\n{\n    EST_CTX *ectx;\n    EVP_PKEY *key;\n    unsigned char *key_raw;\n    int key_len;\n    unsigned char *cert_raw;\n    int cert_len;\n    X509 *cert = NULL;\n    int rv;\n    int pkcs7_len = 0;\n    BIO *in;\n    unsigned char *attr_data = NULL;\n    int attr_len;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Create a client context\n     */\n    ectx = est_client_init(cacerts, cacerts_len, EST_CERT_FORMAT_PEM, NULL);\n    CU_ASSERT(ectx != NULL);\n\n    /*\n     * Set the authentication mode to use a user id/password\n     */\n    rv = est_client_set_auth(ectx, US893_UID, US893_PWD, NULL, NULL);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Set the EST server address/port\n     */\n    est_client_set_server(ectx, US893_SERVER_IP, US893_TCP_PROXY_PORT, NULL);\n\n    /*\n     * Read in the private key\n     */\n    key_len = read_binary_file(US893_EXPIRED_KEY, &amp;key_raw);\n    CU_ASSERT(key_len &gt; 0);\n    key = est_load_key(key_raw, key_len, EST_FORMAT_PEM);\n    CU_ASSERT(key != NULL);\n    free(key_raw);\n\n    /*\n     * Read in the old cert\n     */\n    cert_len = read_binary_file(US893_EXPIRED_CERT, &amp;cert_raw);\n    CU_ASSERT(cert_len &gt; 0);\n    in = BIO_new_mem_buf(cert_raw, cert_len);\n    CU_ASSERT(in != NULL);\n    if (!in)\n        return;\n    cert = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\n    CU_ASSERT(cert != NULL);\n    if (!cert)\n        return;\n    BIO_free_all(in);\n    free(cert_raw);\n\n    /*\n     * Get the latest CSR attributes\n     */\n    rv = est_client_get_csrattrs(ectx, &amp;attr_data, &amp;attr_len);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    /*\n     * Enroll an expired cert that contains x509 extensions.\n     */\n    rv = est_client_reenroll(ectx, cert, &amp;pkcs7_len, key);\n    CU_ASSERT(rv == EST_ERR_NONE);\n\n    est_destroy(ectx);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test case uses an existing expired cert and\n * attempts to re-enroll it.  PoP is disabled on\n * the EST server.  The CSR does not contain a PoP.\n */\nstatic void us893_test9 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Make sure PoP is disabled on the server\n     */\n    st_disable_pop();\n\n    /*\n     * Use libcurl to send an enroll request.  We use libcurl\n     * because it will not include the PoP.\n     */\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * The reenroll should work since PoP is not enabled anywhere.\n     */\n    CU_ASSERT(rv == 200);\n\n    /*\n     * Re-enable PoP on the server for the forthcoming test cases.\n     */\n    st_enable_pop();\n}\n\n/*\n * This test case uses a bad password configured on\n * the EST proxy context.  This should cause the EST\n * server to reject the reenroll request.\n */\nstatic void us893_test10 (void)\n{\n    int rv;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;bogus&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    CU_ASSERT(rv == 401);\n\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\nstatic void us893_test11 (void)\n{\n    int rv;\n    long http_code = 0;\n    CURL *hnd;\n    struct curl_slist *slist1;\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Stop the proxy server so we can restart\n     * it using a different identity cert.\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using an untrusted cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_UNTRUSTED_CERT,\n                        US893_UNTRUSTED_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n\n    /*\n     * We don\&#39;t use the normal curl util API here because\n     * we need to disable TLS peer verification for this\n     * special test case.\n     */\n    /*\n     * Set the Content-Type header in the HTTP request\n     */\n    slist1 = NULL;\n    slist1 = curl_slist_append(slist1, US893_PKCS10_CT);\n\n    /*\n     * Setup all the other fields that CURL requires\n     */\n    hnd = curl_easy_init();\n    curl_easy_setopt(hnd, CURLOPT_URL, US893_REENROLL_URL_BA);\n    curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);\n    curl_easy_setopt(hnd, CURLOPT_USERPWD, US893_UIDPWD_GOOD);\n    curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, US893_PKCS10_RSA2048);\n    curl_easy_setopt(hnd, CURLOPT_POSTFIELDSIZE_LARGE, (curl_off_t)strlen(US893_PKCS10_RSA2048));\n    curl_easy_setopt(hnd, CURLOPT_USERAGENT, &#34;curl/7.27.0&#34;);\n    curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, slist1);\n    curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L);\n    curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);\n    curl_easy_setopt(hnd, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n    curl_easy_setopt(hnd, CURLOPT_CAINFO, US893_CACERTS);\n    curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);\n    curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L);\n    curl_easy_setopt(hnd, CURLOPT_FORBID_REUSE, 1L);\n\n    /*\n     * Issue the HTTP request\n     */\n    curl_easy_perform(hnd);\n\n    /*\n     * Get the HTTP reponse status code from the server\n     */\n    curl_easy_getinfo(hnd, CURLINFO_RESPONSE_CODE, &amp;http_code);\n    curl_easy_cleanup(hnd);\n    hnd = NULL;\n    curl_slist_free_all(slist1);\n    slist1 = NULL;\n\n    CU_ASSERT(http_code == 400);\n\n    /*\n     * Stop the proxy server\n     */\n    st_proxy_stop();\n\n    /*\n     * Restart the proxy server using the other cert\n     */\n    rv = st_proxy_start(US893_TCP_PROXY_PORT,\n                        US893_PROXY_CERT,\n                        US893_PROXY_KEY,\n                        &#34;US893 test realm&#34;,\n                        US893_CACERTS,\n                        US893_TRUSTED_CERTS,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US893_TCP_SERVER_PORT,\n                        0,\n                        0);\n    CU_ASSERT(rv == 0);\n}\n\n/*\n * Simple reenroll - RSA 2048\n *\n * This test case uses libcurl to test simple\n * reenroll of a 2048 bit RSA CSR.  HTTP Basic\n * authentication is used.  However, PoP is now\n * enabled on the proxy, which should cause a\n * failure since libcurl doesn\&#39;t include the PoP.\n */\nstatic void us893_test12 (void)\n{\n    long rv;\n\n    LOG_FUNC_NM\n    ;\n\n    st_proxy_enable_pop();\n\n    rv = curl_http_post(US893_REENROLL_URL_BA, US893_PKCS10_CT,\n                        US893_PKCS10_RSA2048,\n                        US893_UIDPWD_GOOD, US893_CACERTS, CURLAUTH_BASIC,\n                        NULL, NULL, NULL);\n    /*\n     * Should fail since the proxy will fail the PoP check\n     */\n    CU_ASSERT(rv == 400);\n\n    st_proxy_disable_pop();\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us893_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us893_proxy_simpreenroll&#34;,\n                           us893_init_suite,\n                           us893_destory_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;ReEnroll RSA cert&#34;, us893_test1)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll expired cert&#34;, us893_test2)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll corrupt CSR&#34;, us893_test3)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll expired cert with retry-after&#34;, us893_test4)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll no proxy id-kp-cmcRA with srv PoP&#34;, us893_test5)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll no proxy id-kp-cmcRA w/o srv PoP&#34;, us893_test6)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll no proxy id-kp-cmcRA w/o srv PoP CSR PoP&#34;, us893_test7)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll expired cert w/o srv PoP CSR PoP&#34;, us893_test8)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll expired cert w/o srv PoP no CSR PoP&#34;, us893_test9)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll proxy misconfigured HTTP auth&#34;, us893_test10)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll proxy untrusted identity cert&#34;, us893_test11)) ||\n        (NULL == CU_add_test(pSuite, &#34;ReEnroll PoP enabled proxy no CSR PoP&#34;, us893_test12)))\n    {\n       CU_cleanup_registry();\n       return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;],
 &#39;test_data/LibEST_semeru_format/test/us895.c&#39;: [&#39;/*------------------------------------------------------------------\n * us895.c - Unit Tests for User Story 895 - Proxy CSR Attributes\n *\n * November, 2013\n *\n * Copyright (c) 2013, 2016 by cisco Systems, Inc.\n * All rights reserved.\n *------------------------------------------------------------------\n */\n#include &lt;stdio.h&gt;\n#ifndef WIN32\n#include &lt;unistd.h&gt;\n#endif\n#include &lt;est.h&gt;\n#include &lt;curl/curl.h&gt;\n#include &#34;curl_utils.h&#34;\n#include &#34;test_utils.h&#34;\n#include &#34;st_server.h&#34;\n#include &#34;st_proxy.h&#34;\n#include &lt;openssl/ssl.h&gt;\n\n#ifdef HAVE_CUNIT\n#include &#34;CUnit/Basic.h&#34;\n#include &#34;CUnit/Automated.h&#34;\n#endif\n\nstatic unsigned char *cacerts = NULL;\nstatic int cacerts_len = 0;\n\n#define US895_SERVER_PORT   29895\n#define US895_PROXY_PORT   29095\n\n#ifndef WIN32\n#define US895_CACERT        &#34;CA/estCA/cacert.crt&#34;\n#define US895_TRUSTED_CERT  &#34;CA/trustedcerts.crt&#34;\n#define SERVER_UT_CACERT    &#34;CA/estCA/cacert.crt&#34;\n#define SERVER_UT_PUBKEY    &#34;./est_client_ut_keypair&#34;\n\n#define US895_SERVER_IP     &#34;127.0.0.1&#34; \n#define US895_CACERTS       &#34;CA/estCA/cacert.crt&#34;\n#define US895_TRUST_CERTS   &#34;CA/trustedcerts.crt&#34;\n#define US895_SERVER_CERTKEY &#34;CA/estCA/private/estservercertandkey.pem&#34;\n#else\n#define US895_CACERT        &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US895_TRUSTED_CERT  &#34;CA\\\\trustedcerts.crt&#34;\n#define SERVER_UT_CACERT     &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define SERVER_UT_PUBKEY    &#34;est_client_ut_keypair&#34;\n\n#define US895_SERVER_IP     &#34;127.0.0.1&#34; \n#define US895_CACERTS       &#34;CA\\\\estCA\\\\cacert.crt&#34;\n#define US895_TRUST_CERTS   &#34;CA\\\\trustedcerts.crt&#34;\n#define US895_SERVER_CERTKEY &#34;CA\\\\estCA\\\\private\\\\estservercertandkey.pem&#34;\n#endif\n\n#define TEST_ATTR_POP &#34;MAsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR_NOPOP &#34;MHEwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR_NOPOPPOP &#34;MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n#define TEST_ATTR_POPADDED &#34;MHwwLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n#define TEST_ATTR1 &#34;MCYGBysGAQEBARYGCSqGSIb3DQEJBwYFK4EEACIGCWCGSAFlAwQCAg==\\0&#34;\n#define TEST_ATTR2 &#34;MAA=\\0&#34;\n#define TEST_ATTR7 &#34;MA==\\0&#34;\n#define TEST_ATTR2_POP &#34;MAsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR8 &#34;MAthisis badsGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR3 &#34;MIGSMFgGA4g3AjFRExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuMyBkYXRhExlQYXJzZSBTRVQgYXMgMi45OTkuNCBkYXRhBgkqhkiG9w0BCQcwIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR4_122 &#34;MHowLAYDiDcCMSUGA4g3AwYDiDcEExlQYXJzZSBTRVQgYXMgMi45OTkuMiBkYXRhBglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR4_122POP &#34;MIGFMCwGA4g3AjElBgOINwMGA4g3BBMZUGFyc2UgU0VUIGFzIDIuOTk5LjIgZGF0YQYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARYGCSqGSIb3DQEJBw==\\0&#34;\n#define TEST_ATTR5_117 &#34;MHUwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIgYDiDcBMRsTGVBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR5_117POP &#34;MIGAMCcGA4g3AjEgBgOINwMGA4g3BBMUUGFyc2UgU0VUIGFzIDIuOTk5LjIGCWCGSAFlAwQCAgYJKyQDAwIIAQELMCIGA4g3ATEbExlQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhBgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0&#34;\n#define TEST_ATTR6_116 &#34;MHQwJwYDiDcCMSAGA4g3AwYDiDcEExRQYXJzZSBTRVQgYXMgMi45OTkuMgYJYIZIAWUDBAICBgkrJAMDAggBAQswIQYDiDcBMRoTGFBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdAYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n#define TEST_ATTR_244 &#34;MIH1MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBlBgOINwExXhNcUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR_245 &#34;MIH2MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBmBgOINwExXxNdUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0&#34;\n#define TEST_ATTR_250 &#34;MIH7MGQGA4g3AjFdBgOINwMGA4g3BBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_ATTR_250POP &#34;MIIBBjBkBgOINwIxXQYDiDcDBgOINwQTUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEWBgkqhkiG9w0BCQc=\\0&#34;\n#define TEST_ALL_ATTR &#34;MIHTMIGBBgOINwIxegEB/wICAP8GA4g3AwYDiDcECgECEhAxMjM0NTY3ODkwQUJDREVGExRQYXJzZSBTRVQgYXMgMi45OTkuMhQFMTIzNDUUBTEyMzQ1FgUxMjM0NRoFMTIzNDUcFAAAADEAAAAyAAAAMwAAADQAAAA1HgoAMQAyADMANAA1BglghkgBZQMEAgIGCSskAwMCCAEBCzAiBgOINwExGxMZUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YQYHKwYBAQEBFgYHKwYBAQEBFgEBAA==\\0&#34;\n#define TEST_1024_NOPOP &#34;MIID/DCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFg==\\0&#34;\n\n#define TEST_1025_NOPOP &#34;MIID/TCCA2QGA4g3AjGCA1sGA4g3AwYDiDcEEisxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBNRUGFyc2UgU0VUIGFzIDIuOTk5LjIgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwBglghkgBZQMEAgIGCSskAwMCCAEBCzBrBgOINwExZBNiUGFyc2UgU0VUIGFzIDIuOTk5LjEgZGF0YSAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBhYjEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1MTIzNDUGBysGAQEBARYGBysGAQEBARY=\\0&#34;\n#define TEST_1024_POP &#34;MIIEBzCCA2MGA4g3AjGCA1oGA4g3AwYDiDcEEioxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTISZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwE1FQYXJzZSBTRVQgYXMgMi45OTkuMiAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAGCWCGSAFlAwQCAgYJKyQDAwIIAQELMGsGA4g3ATFkE2JQYXJzZSBTRVQgYXMgMi45OTkuMSBkYXRhIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MGFiMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDUxMjM0NQYHKwYBAQEBFgYHKwYBAQEBFgYJKoZIhvcNAQkH\\0&#34;\n\n#define TEST_LONG_ATTR &#34;MIIENzCCA54GA4g3AjGCA5UGA4g3AwYDiDcEEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTASZTEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDAxMjM0NTY3ODkwEmUxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAwMTIzNDU2Nzg5MBJlMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMDEyMzQ1Njc4OTATUVBhcnNlIFNFVCBhcyAyLjk5OS4yIDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MAYJYIZIAWUDBAICBgkrJAMDAggBAQswawYDiDcBMWQTYlBhcnNlIFNFVCBhcyAyLjk5OS4xIGRhdGEgMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwYWIxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTEyMzQ1BgcrBgEBAQEWBgcrBgEBAQEW\\0&#34;\n\n#define EST_UT_MAX_CMD_LEN 255\nextern EST_CTX *ectx;\n\nstatic void us895_clean (void)\n{\n}\n\nstatic int us895_start_server (int manual_enroll, int nid)\n{\n    int rv;\n\n    rv = st_start(US895_SERVER_PORT,\n                  US895_SERVER_CERTKEY,\n                  US895_SERVER_CERTKEY,\n                  &#34;US895 test realm&#34;,\n                  US895_CACERT,\n                  US895_TRUSTED_CERT,\n                  &#34;CA/estExampleCA.cnf&#34;,\n                  manual_enroll,\n                  0,\n                  nid);\n\n    if (rv) {\n        return (rv);\n    }\n\n    /*\n     * Next we start an EST proxy acting as an RA\n     */\n    rv = st_proxy_start(US895_PROXY_PORT,\n                        US895_SERVER_CERTKEY,\n                        US895_SERVER_CERTKEY,\n                        &#34;US895 test realm&#34;,\n                        US895_CACERT,\n                        US895_TRUSTED_CERT,\n                        &#34;estuser&#34;,\n                        &#34;estpwd&#34;,\n                        &#34;127.0.0.1&#34;,\n                        US895_SERVER_PORT,\n                        0,\n                        nid);\n\n    SLEEP(1);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit initializes this test\n * suite.  This can be used to allocate data or open any\n * resources required for all the test cases.\n */\nstatic int us895_init_suite (void)\n{\n    int rv = 0;\n    char cmd[EST_UT_MAX_CMD_LEN];\n\n    printf(&#34;Starting EST Server CSR attributes unit tests.\\n&#34;);\n\n    /*\n     * gen the keypair to be used for EST Proxy testing\n     */\n    snprintf(\n        cmd,\n        EST_UT_MAX_CMD_LEN,\n        &#34;openssl ecparam -name prime256v1 -genkey -out %s&#34;,\n        SERVER_UT_PUBKEY);\n    printf(&#34;%s\\n&#34;, cmd);\n\n    rv = system(cmd);\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(US895_CACERTS, &amp;cacerts);\n    if (cacerts_len &lt;= 0) {\n        return 1;\n    }\n\n    /*\n     * start the server for the tests that need to talk to a server\n     */\n    us895_clean();\n\n    /*\n     * Start an instance of the EST server\n     */\n    rv = us895_start_server(0, 0);\n    return rv;\n}\n\n/*\n * This routine is called when CUnit uninitializes this test\n * suite.  This can be used to deallocate data or close any\n * resources that were used for the test cases.\n */\nstatic int us895_destroy_suite (void)\n{\n    st_stop();\n    st_proxy_stop();\n    SLEEP(2);\n    return 0;\n}\n\nstatic unsigned char * handle_short_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR7);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR7, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_corrupt_csrattrs_request (int *csr_len,\n                                                        char *path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR8);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR8, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_long_csrattrs_request (int *csr_len,\n                                                     char *path_seg,\n                                                     void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_LONG_ATTR);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_LONG_ATTR, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_correct_csrattrs_request (int *csr_len,\n                                                        char * path_seg,\n                                                        void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR1);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR1, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_nopop_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = strlen(TEST_ATTR_NOPOP);\n    csr_data = malloc(*csr_len + 1);\n    strncpy((char *) csr_data, TEST_ATTR_NOPOP, *csr_len);\n    csr_data[*csr_len] = 0;\n    return (csr_data);\n}\n\nstatic unsigned char * handle_empty_csrattrs_request (int *csr_len,\n                                                      char *path_seg,\n                                                      void *app_data)\n{\n    unsigned char *csr_data;\n\n    *csr_len = 0;\n    csr_data = NULL;\n    return (csr_data);\n}\n\n/*\n * Callback function passed to est_proxy_init()\n */\nstatic int proxy_manual_cert_verify (X509 *cur_cert, int openssl_cert_error)\n{\n    BIO * bio_err;\n    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\n    int approve = 0;\n\n    /*\n     * Print out the specifics of this cert\n     */\n    printf(\n        &#34;%s: OpenSSL/EST server cert verification failed with the following error: openssl_cert_error = %d (%s)\\n&#34;,\n        __FUNCTION__,\n        openssl_cert_error,\n        X509_verify_cert_error_string(openssl_cert_error));\n\n    printf(&#34;Failing Cert:\\n&#34;);\n    X509_print_fp(stdout, cur_cert);\n    /*\n     * Next call prints out the signature which can be used as the fingerprint\n     * This fingerprint can be checked against the anticipated value to determine\n     * whether or not the server\&#39;s cert should be approved.\n     */\n    X509_signature_print(bio_err, cur_cert-&gt;sig_alg, cur_cert-&gt;signature);\n\n    if (openssl_cert_error == X509_V_ERR_UNABLE_TO_GET_CRL) {\n        approve = 1;\n    }\n\n    BIO_free(bio_err);\n\n    return approve;\n}\n\n/*\n * Test1 - exercise the server side variations triggered\n *         by est_client_get_csrattrs()\n */\nstatic void us895_test1 (void)\n{\n    EST_CTX *ctx;\n    unsigned char *pkey = NULL;\n    unsigned char *cacerts = NULL;\n    int cacerts_len = 0;\n    EST_ERROR rc = EST_ERR_NONE;\n    EVP_PKEY * priv_key;\n    int csr_len;\n    unsigned char *csr_data = NULL;\n\n    SLEEP(1);\n\n    LOG_FUNC_NM\n    ;\n\n    /*\n     * Read in the CA certificates\n     */\n    cacerts_len = read_binary_file(SERVER_UT_CACERT, &amp;cacerts);\n    CU_ASSERT(cacerts_len &gt; 0);\n\n    /*\n     * Read in the private key file\n     */\n    priv_key = read_private_key(SERVER_UT_PUBKEY);\n    if (priv_key == NULL) {\n        printf(&#34;\\nError while reading private key file %s\\n&#34;, SERVER_UT_PUBKEY);\n        return;\n    }\n\n    ctx = est_client_init(\n        cacerts,\n        cacerts_len,\n        EST_CERT_FORMAT_PEM,\n        proxy_manual_cert_verify);\n    CU_ASSERT(ctx != NULL);\n\n    rc = est_client_set_auth(ctx, &#34;&#34;, &#34;&#34;, NULL, priv_key);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    est_client_set_server(ctx, US895_SERVER_IP, US895_PROXY_PORT, NULL);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    /* should get 204 with no data */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n    CU_ASSERT(csr_data == NULL);\n\n    /* Real base64 string - should pass */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_short_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_corrupt_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_long_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_correct_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n    /* callback should supersede init csrattrs */\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* Setting the smallest base64 size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2));\n    CU_ASSERT(strncmp(TEST_ATTR2, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR3, strlen(TEST_ATTR3));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR3));\n    CU_ASSERT(strncmp(TEST_ATTR3, (const char *) csr_data, csr_len) == 0);\n\n    /* clear csrattrs */\n    rc = est_server_init_csrattrs(ectx, NULL, 0);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_NOPOP));\n    CU_ASSERT(strncmp(TEST_1024_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Enable PoP and test responses with PoP added */\n    st_enable_pop();\n\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_POP, strlen(TEST_ATTR_POP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_data != NULL);\n    CU_ASSERT(csr_len = 20);\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_1024_NOPOP,\n        strlen(TEST_1024_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_1024_POP));\n    CU_ASSERT(strncmp(TEST_1024_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 122 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR4_122, strlen(TEST_ATTR4_122));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR4_122POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR4_122POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 117 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR5_117, strlen(TEST_ATTR5_117));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR5_117POP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR5_117POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Real base64 string needs PoP added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* Not a real base64 string - should fail */\n    rc = est_server_init_csrattrs(ectx, &#34;US900 test1&#34;, 11);\n    CU_ASSERT(rc != EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_POP));\n    CU_ASSERT(strncmp(TEST_ATTR_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the smallest size */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR2, strlen(TEST_ATTR2));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* Setting the size 116 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR6_116, strlen(TEST_ATTR6_116));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 244 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_244, strlen(TEST_ATTR_244));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 245 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_245, strlen(TEST_ATTR_245));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n\n    /* Setting the size 250 */\n    rc = est_server_init_csrattrs(ectx, TEST_ATTR_250, strlen(TEST_ATTR_250));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_250POP));\n    CU_ASSERT(strncmp(TEST_ATTR_250POP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_correct_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR1));\n    CU_ASSERT(strncmp(TEST_ATTR1, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_nopop_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOPPOP));\n    CU_ASSERT(\n        strncmp(TEST_ATTR_NOPOPPOP, (const char *) csr_data, csr_len) == 0);\n\n    if (est_set_csr_cb(ectx, &amp;handle_empty_csrattrs_request)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR2_POP));\n    CU_ASSERT(strncmp(TEST_ATTR2_POP, (const char *) csr_data, csr_len) == 0);\n\n    /* disable PoP */\n    st_disable_pop();\n\n    /* clear callback */\n    if (est_set_csr_cb(ectx, NULL)) {\n        printf(&#34;\\nUnable to set EST CSR Attributes callback.  Aborting!!!\\n&#34;);\n        exit(1);\n    }\n\n    /* Real base64 string PoP should not be added - should pass */\n    rc = est_server_init_csrattrs(\n        ectx,\n        TEST_ATTR_NOPOP,\n        strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ATTR_NOPOP));\n    CU_ASSERT(strncmp(TEST_ATTR_NOPOP, (const char *) csr_data, csr_len) == 0);\n\n    /* All ASN.1 types supported by CiscoSSL */\n    rc = est_server_init_csrattrs(ectx, TEST_ALL_ATTR, strlen(TEST_ALL_ATTR));\n    CU_ASSERT(rc == EST_ERR_NONE);\n    rc = est_client_get_csrattrs(ctx, &amp;csr_data, &amp;csr_len);\n    CU_ASSERT(rc == EST_ERR_NONE);\n    CU_ASSERT(csr_len == strlen(TEST_ALL_ATTR));\n    CU_ASSERT(strncmp(TEST_ALL_ATTR, (const char *) csr_data, csr_len) == 0);\n\n    if (ctx) {\n        est_destroy(ctx);\n    }\n    if (cacerts) {\n        free(cacerts);\n    }\n    if (pkey) {\n        free(pkey);\n    }\n}\n\n/* The main() function for setting up and running the tests.\n * Returns a CUE_SUCCESS on successful running, another\n * CUnit error code on failure.\n */\nint us895_add_suite (void)\n{\n#ifdef HAVE_CUNIT\n    CU_pSuite pSuite = NULL;\n\n    /* add a suite to the registry */\n    pSuite = CU_add_suite(&#34;us895_proxy_csrattrs&#34;,\n            us895_init_suite,\n            us895_destroy_suite);\n    if (NULL == pSuite) {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    /* add the tests to the suite */\n    if ((NULL == CU_add_test(pSuite, &#34;CSR Proxy Attributes API1&#34;, us895_test1)))\n    {\n        CU_cleanup_registry();\n        return CU_get_error();\n    }\n\n    return CUE_SUCCESS;\n#endif\n}\n\n&#39;]}</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z\s]&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s2">&quot;Ho:;&lt;le_C$%&amp;\oMe_estTa?@[</span><span class="se">\\</span><span class="s2">is34~&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#ToDo Transforme it into a For-Comprenhension</span>
<span class="k">def</span> <span class="nf">clean_punctuation</span><span class="p">(</span><span class="n">token</span><span class="p">):</span> 
    <span class="c1">#remove terms !&quot;#$%&amp;\&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~0123456789</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z\s]&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">split_camel_case_token</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;([a-z])([A-Z])&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1 \2&#39;</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">remove_terms</span><span class="p">(</span><span class="n">filtered_tokens</span><span class="p">):</span>
    <span class="n">remove_terms</span> <span class="o">=</span> <span class="n">punctuation</span> <span class="o">+</span> <span class="s1">&#39;0123456789&#39;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">token</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">filtered_tokens</span> <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_terms</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">21</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">stemmer</span><span class="p">(</span><span class="n">filtered_tokens</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">englishStemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">filtered_tokens</span> <span class="p">]</span>

<span class="k">def</span> <span class="nf">stop_words</span><span class="p">(</span><span class="n">filtered_tokens</span><span class="p">):</span>
    <span class="n">stop_words</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">token</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">filtered_tokens</span> <span class="k">if</span> <span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">remove_terms</span><span class="p">(</span><span class="n">clean_punctuation</span><span class="p">(</span><span class="s2">&quot;their corresponding URIs:</span><span class="se">\n\n\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | Operation              |Operation path   | Details           |</span><span class="se">\n</span><span class="s2">   +========================+=================+===================+</span><span class="se">\n</span><span class="s2">   | Distribution of CA     | /cacerts        | Section 4.1       |</span><span class="se">\n</span><span class="s2">   | Certificates (MUST)    |                 |                   |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | Enrollment of          | /simpleenroll   | Section 4.2       |</span><span class="se">\n</span><span class="s2">   | Clients (MUST)         |                 |                   |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | Re-enrollment of       | /simplereenroll | Section 4.2.2     |</span><span class="se">\n</span><span class="s2">   | Clients (MUST)         |                 |                   |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | Full CMC (OPTIONAL)    | /fullcmc        | Section 4.3       |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | Server-Side Key        | /serverkeygen   | Section 4.4       |</span><span class="se">\n</span><span class="s2">   | Generation (OPTIONAL)  |                 |                   |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n</span><span class="s2">   | CSR Attributes         | /csrattrs       | Section 4.5       |</span><span class="se">\n</span><span class="s2">   | (OPTIONAL)             |                 |                   |</span><span class="se">\n</span><span class="s2">   +------------------------+-----------------+-------------------+</span><span class="se">\n\n</span><span class="s2">  &quot;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">remove_terms</span><span class="p">(</span><span class="n">split_camel_case_token</span><span class="p">(</span><span class="n">dict_filenames</span><span class="p">[</span><span class="s1">&#39;test_data/LibEST_semeru_format/requirements/RQ17.txt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pre_process</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;-pre.txt&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">clean_punctuation</span><span class="p">(</span><span class="n">dict_filenames</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_filenames</span><span class="p">]</span>
<span class="n">pre_process</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">split_camel_case_token</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="p">)</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process</span><span class="p">]</span>
<span class="n">pre_process</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="p">)</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process</span><span class="p">]</span>
<span class="n">pre_process</span> <span class="o">=</span> <span class="p">[(</span> <span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process</span><span class="p">]</span> <span class="c1"># Leading whitepsace are removed</span>
<span class="n">pre_process_tokens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">nltk</span><span class="o">.</span><span class="n">WordPunctTokenizer</span><span class="p">()</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process</span><span class="p">]</span>
<span class="n">filtered_tokens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stop_words</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process_tokens</span><span class="p">]</span> <span class="c1">#Stop Words</span>
<span class="n">filtered_tokens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stemmer</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">filtered_tokens</span><span class="p">]</span> <span class="c1">#Filtering Stemmings</span>
<span class="n">filtered_tokens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">remove_terms</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">filtered_tokens</span><span class="p">]</span> <span class="c1">#Filtering remove-terms</span>
<span class="n">pre_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">filtered_tokens</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">pre_process</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[(&#39;test_data/LibEST_semeru_format/test/us903.c&#39;,
  &#39;unit test user stori server simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif ifndef win static char test outfil filenam max test hdr defin cacert est cacert crt defin explicit_cert us903 cert pem defin us903_explicit_key us903 key pem defin us903_cacert est cacert crt defin us903_trusted_cert trustedcert crt defin est privat estservercertandkey pem els static char test5_outfil filename_max us903 test5 hdr defin us903_cacert est cacert crt defin us903_explicit_cert us903 cert pem defin us903_explicit_key us903 key pem defin us903_cacert est cacert crt defin us903_trusted_cert trustedcert crt defin est privat estservercertandkey pem endif static unsign char cacert null static int cacerts_len defin us903_retry_interv 3600 defin us903_tcp_port 29001 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us903_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin us903_pkcs10_dsa1024 miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin us903_pkcs10_corrupt miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us903_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us903_pkcs10_ct content type applic pkcs10 defin us903_uidpwd_good estus estpwd static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written static void us903_clean void static int us903_start_serv int manual_enrol int nid int st_start us903_tcp_port us903 test realm us903_cacert us903_trusted_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us903_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us903_cacert cacert cacerts_len return us903_clean (); start instanc est server automat enrol enabl us903_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us903_destory_suit void st_stop (); free cacert return simpl enrol rsa 2048 test case use libcurl test simpl enrol 2048 bit rsa csr http basic authent use static void us903_test1 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol prime 256 test case use libcurl test simpl enrol 256 bit csr http basic authent use static void us903_test2 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol dsa prime 1024 test case use libcurl test simpl enrol 1024 bit dsa csr http basic authent use static void us903_test3 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_dsa1024 us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol corrupt pkcs10 test case use libcurl test simpl enrol usinga corrupt csr http basic authent use static void us903_test4 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_corrupt us903_uidpwd_good us903_cacert curlauth_bas null null null sinc csr valid server respond 400 cu_assert 400 simpl enrol manual enrol test case verifi server send appropri retri respons static void us903_test5 void long log_func_nm stop est server st_stop (); restart server manual enrol enabl us903_start_serv outfil fopen test5_outfil &#34;); curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null write_func fclose outfil sinc server seen csr past respond retri 202 respons cu_assert 202 verifi retri valu grep test5_outfil retri 3600 &#34;); cu_assert avoid wait full retri period sinc simul manual enrol wait second tri enrol cert sleep curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null enrol request succeed time simul manual enrol automat enrol second attempt cu_assert 200 stop est server st_stop (); restart server manual enrol disabl us903_start_serv simpl enrol check fail curl test case verifi server verifi client csr sinc curl set est enrol fail static void us903_test6 void long log_func_nm st_enable_pop (); send valid enrol request use curl curl includ curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null server respond failur code cu_assert 400 st_disable_pop (); simpl enrol check succeed estclient test case verifi server verifi client csr use estclient sinc support static void us903_test7 void long est_ctx c_ctx evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len int http_status log_func_nm test case requir enabl st_enable_pop (); creat client context c_ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert c_ctx null c_ctx return specifi user password sinc server run basic authent mode est_client_set_auth c_ctx estus estpwd null null cu_assert est_err_non est_client_set_serv c_ctx 127 us903_tcp_port null get keypair use enrol new_pkey generate_private_key (); c_ctx attr_data attr_len cu_assert est_err_non attempt enrol csr est_client_enrol c_ctx us903 test7 pkcs7_len new_pkey cu_assert est_err_non check http status code receiv server 200 http_status c_ctx cu_assert http_status 200 client librari obtain new client certif retriev librari pkcs7 malloc pkcs7_len pkcs7 return c_ctx pkcs7 cu_assert est_err_non clean est_destroy c_ctx evp_pkey_fre new_pkey free pkcs7 disabl futur test case st_disable_pop (); simpl enrol use non default ecdh curv test case verifi function work static void us903_test8 void long log_func_nm stop est server st_stop (); restart server use secp384r1 curv us903_start_serv nid_secp384r1 curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas ecdh ecdsa aes256 gcm sha384 null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol disabl csr contain valid test case ensur server handl scenario csr includ valid even server request use cisco est client generat csr contain valid way includ valid use curl sinc tls channel bind inform known advanc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us903_test9 void est_ctx ctx int unsign char cacert int caclen evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm make sure est server disabl st_disable_pop (); read cert caclen read_binary_fil us903_cacert cacert cu_assert cacerts_len init client context ctx est_client_init cacert caclen est_cert_format_pem use simpl http auth identifi est_client_set_auth ctx estus estpwd null null cu_assert est_err_non est_client_set_serv ctx 127 us903_tcp_port null creat space hold cert generat privat key new_pkey generate_private_key (); ctx attr_data attr_len cu_assert est_err_non attempt enrol ctx csr_pop_requir hack test attempt need forc challeng password csr est_client_enrol ctx test case9 pkcs7_len new_pkey cu_assert est_err_non pkcs7 malloc pkcs7_len ctx pkcs7 free pkcs7 est_destroy ctx simpl enrol disabl csr contain invalid test case ensur server handl scenario csr includ invalid even server request static void us903_test10 void long log_func_nm make sure est server disabl st_disable_pop (); curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_cacert curlauth_bas null null null enrol request fail sinc invalid expect 400 respons cu_assert 400 simpl enrol enabl csr contain invalid client use cert contain cmc test case ensur server disabl check client use cert contain cmc indic client static void us903_test11 void long log_func_nm make sure est server disabl st_enable_pop (); us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_explicit_cert us903_explicit_key us903_cacert null even though valu match csr enrol succeed sinc client use certif expect 200 respons cu_assert 200 main function set run test return cue_success success run anoth cunit error code failur int us903_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us903_srv_simpenrol us903_init_suit us903_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us903_test1 null cu_add_test suit enrol ecdsa cert us903_test2 null cu_add_test suit enrol dsa cert us903_test3 null cu_add_test suit enrol corrupt ecdsa cert us903_test4 null cu_add_test suit enrol retri manual approv us903_test5 null cu_add_test suit enrol fail curl us903_test6 null cu_add_test suit enrol succeed estclient us903_test7 null cu_add_test suit non default ecdh curv us903_test8 null cu_add_test suit enrol disabl csr includ valid us903_test9 null cu_add_test suit enrol disabl csr includ invalid us903_test10 null cu_add_test suit enrol enabl use cert csr includ invalid us903_test11 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us3496.c&#39;,
  &#39;unit test uri path segment extens support march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server includ src est est locl extern char tst srvr path seg enrol extern char tst srvr path seg auth static int path segment support max command line length generat system command defin est max cmd_len 256 certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey &#34;./ defin us3496_server_port 29496 defin us3496_server_ip 127 defin us3496_uidpwd_good estus estpwd defin us3496_uid estus defin us3496_pwd estpwd ifndef win32 defin us3496_cacert est cacert crt defin us3496_trust_cert trustedcert crt defin est privat estservercertandkey pem els defin us3496_cacert est cacert crt defin us3496_trust_cert trustedcert crt defin est privat estservercertandkey pem static critical_sect logger_critical_sect static void us3496_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif defin us3496_enroll_url_ba https :// 127 29496 well known est cacert somestr simpleenrol defin us3496_pkcs10_ct content type applic pkcs10 defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x static int x509 cur_cert int openssl_cert_error static void us3496_clean void static int us3496_start_serv int manual_enrol int nid int st_start us3496_server_port us3496 test realm us3496_cacert us3496_trust_cert est exampl cnf manual_enrol nid sleep return static int path_seg_support void est_ctx ectx unsign char cacert null int cacerts_len est_error est_err_non sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_serv ectx us3496_server_ip us3496_server_port test_seg &#34;); est_err_non return els return return routin call cunit initi test suit generat keypair use est client suit static int us3496_init_suit void int char cmd est_ut_max_cmd_len printf start est client proxi path segment unit test &#34;); check see path segment support compil path_segment_support printf uri path segment support build est rebuild use uripars dir &#34;); return gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us3496_clean (); start instanc est server us3496_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3496_destroy_suit void st_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test case test set server valid paramet path segment static void us3496_test1 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port null cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment valid static void us3496_test2 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port somestr &#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain segment fail static void us3496_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port somestring1 somestring2 &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey valid charact defin &#34;@% ~!$&amp;\&#39;()*+,;=&#34; static void us3496_test4 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment invalid invalid charact static void us3496_test5 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port someinvalid string &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment long 129 defin static void us3496_test6 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment equal oper cacert static void us3496_test7 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cacert &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain oper cacert case front string static void us3496_test8 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cacert server &#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment empti string fail static void us3496_test9 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port &#34;&#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain :\&#39;. pass static void us3496_test10 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port &#34;-. ~:@!$&amp;\&#39;()*+,;=&#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment long 129 defin path_segment_max static void us3496_test11 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port path_segment_max cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us3496_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3496_init_suit us3496_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us3496_logger_stderr endif check see path segment support compil path_seg_support ()) printf uri path segment support build est rebuild use uripars dir &#34;); path_segment_support return path_segment_support path_segment_support add test suit note order import must test fread fprintf null cu_add_test suit est client set server correct paramet path segment us3496_test1 null cu_add_test suit est client set server correct paramet valid path segment us3496_test2 null cu_add_test suit est client set server correct paramet multi segment path segment us3496_test3 null cu_add_test suit est client set server correct paramet valid path segment valid char us3496_test4 null cu_add_test suit est client set server correct paramet invalid path segment us3496_test5 null cu_add_test suit est client set server correct paramet path segment long us3496_test6 null cu_add_test suit est client set server correct paramet path segment equal oper string us3496_test7 null cu_add_test suit est client set server correct paramet path segment contain oper string us3496_test8 null cu_add_test suit est client set server correct paramet path segment empti string us3496_test9 null cu_add_test suit est client set server correct paramet path segment contain colon us3496_test10 null cu_add_test suit est client set server correct paramet path segment max length us3496_test11 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us899.c&#39;,
  &#39;unit test user stori client simpl enrol septemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin server defin us899_uid estus defin us899_pwd estpwd follow cert use fqdn test ifndef win32 defin us899_cacert est cacert crt defin us899_trust_cert trustedcert crt defin us899_server_certkey est privat estservercertandkey pem defin us899 cert_cn_mismatch pem defin us899 key_cn_mismatch pem defin us899 cert_cn_mismatch_ip pem defin us899 key_cn_mismatch_ip pem defin us899 cert_cn_match_wc pem defin us899 key_cn_match_wc pem defin us899 cert_cn_mismatch_wc pem defin us899 key_cn_mismatch_wc pem defin us899 cert_san_match pem defin us899 key_san_match pem defin us899 cert_san_mismatch pem defin us899 key_san_mismatch pem defin us899 cert_san_mismatch_ip pem defin us899 key_san_mismatch_ip pem defin us899 cert_san_match_ip pem defin us899 key_san_match_ip pem defin us899 cert_san_match_wc pem defin us899 key_san_match_wc pem defin us899 cert_san_mismatch_wc pem defin us899 key_san_mismatch_wc pem els defin us899_cacert est cacert crt defin us899_trust_cert trustedcert crt defin us899_server_certkey est privat estservercertandkey pem defin us899 cert_cn_mismatch pem defin us899 key_cn_mismatch pem defin us899 cert_cn_mismatch_ip pem defin us899 key_cn_mismatch_ip pem defin us899 cert_cn_match_wc pem defin us899 key_cn_match_wc pem defin us899 cert_cn_mismatch_wc pem defin us899 key_cn_mismatch_wc pem defin us899 cert_san_match pem defin us899 key_san_match pem defin us899 cert_san_mismatch pem defin us899 key_san_mismatch pem defin us899 cert_san_mismatch_ip pem defin us899 key_san_mismatch_ip pem defin us899 cert_san_match_ip pem defin us899 key_san_match_ip pem defin us899 cert_san_match_wc pem defin us899 key_san_match_wc pem defin us899 cert_san_mismatch_wc pem defin us899 key_san_mismatch_wc pem static critical_sect logger_critical_sect static void us899_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif defin us899_valid_csr_pem &#34;----- begin certif request -----\\ miibh dcb7g ibadbfmqsw cqydvqqgew jbvtetmbega1uecaw ku29t zs1td gf0zteh mb8ga1uecgw ysw50zxju zxqg v2lk z2l0ci bqd hkg thrk migf ma0gcsq gsib3dqeb aquaa4gnadcbi qkbg qc13w eg36v by8mq uu80skvkx0zct0lc18ka msdlw ml2ir clezbj jye sxw z9q xy4rt1v fdrrtl57 qtg t5kz ki2d2yuz dg6w qqx 4t99s lxc utf ipiaq atuqx h7fo0ti9w lsw6aqft9hib yprjz6z ha24l xwd7w aqabo aaw dqyjko zihvc naqefbqadg yeajw fazo pga4gkn7aeitep 3qj n45lszr vjmw4jl8ovm patn frqym82r vkb7sq4ddo9n dj9tg z450oq iwbuj geu uux jsj3v gxi 8ne ty4gmm nwiwh skmkqh7yvl bvgkw nfu q8m d90pr fmld hbzxcaekr ----- end certif request -----&#34; note array generat use xdd req der req static unsign char us899_valid_csr_d 0x30 0x82 0x01 0xa8 0x30 0x82 0x01 0x11 0x02 0x01 0x00 0x30 0x68 0x31 0x0b 0x30 0x09 0x06 0x03 0x55 0x04 0x06 0x13 0x02 0x55 0x53 0x31 0x0b 0x30 0x09 0x06 0x03 0x55 0x04 0x08 0x0c 0x02 0x6e 0x63 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x07 0x0c 0x03 0x73 0x73 0x73 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x0a 0x0c 0x03 0x64 0x64 0x64 0x31 0x0d 0x30 0x0b 0x06 0x03 0x55 0x04 0x0b 0x0c 0x04 0x66 0x6a 0x6a 0x64 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x03 0x0c 0x03 0x31 0x32 0x37 0x31 0x13 0x30 0x11 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x09 0x01 0x16 0x04 0x6e 0x6f 0x6e 0x65 0x30 0x81 0x9f 0x30 0x0d 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x01 0x01 0x05 0x00 0x03 0x81 0x8d 0x00 0x30 0x81 0x89 0x02 0x81 0x81 0x00 0xb9 0x9f 0xdd 0xd0 0xa4 0xdf 0x06 0x50 0xf5 0x4e 0x85 0x80 0xeb 0x2a 0x1e 0xff 0x3c 0x0f 0x0d 0x98 0x6e 0xfe 0x08 0x74 0xf4 0xce 0xf5 0xfd 0xf9 0x2f 0x86 0x20 0xf7 0xcc 0x08 0x05 0xce 0x98 0x69 0x5c 0x8c 0xbd 0x20 0xa7 0x28 0xf7 0xe4 0x22 0xfa 0xaf 0xe4 0x15 0xc4 0xb9 0x85 0xcb 0x0f 0x11 0xc6 0x55 0x0d 0x31 0x5c 0xfb 0x5e 0xcf 0x8e 0xd1 0xde 0x77 0x15 0x2c 0x8c 0x4e 0x88 0x4e 0x21 0xb6 0x69 0x9c 0xa7 0x7d 0x06 0xc5 0x75 0x3f 0xdc 0x18 0xf6 0x00 0x51 0xd5 0x00 0x47 0x62 0xfc 0x95 0xc8 0xd4 0xef 0x31 0x4a 0xb0 0x15 0xa9 0x50 0x04 0x6e 0x13 0x14 0xd4 0xbb 0x56 0x22 0x6f 0x3b 0x91 0xb6 0xeb 0xba 0x25 0x8f 0x12 0xea 0xfd 0xd4 0xd0 0x6d 0x02 0x03 0x01 0x00 0x01 0xa0 0x00 0x30 0x0d 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x01 0x05 0x05 0x00 0x03 0x81 0x81 0x00 0x3b 0xa5 0xb4 0x97 0x6c 0xea 0xe4 0x9f 0xeb 0x56 0xca 0x7a 0x7f 0xfa 0x53 0x8d 0xee 0x6f 0x7e 0xa1 0x08 0x65 0xe0 0x05 0x5b 0x0e 0x5a 0x92 0xdb 0x3c 0xc5 0x6d 0x0d 0xcd 0x2c 0xcd 0x4d 0x10 0x2a 0x92 0x78 0x1d 0xfb 0x92 0x66 0x33 0x18 0xdd 0xf8 0x78 0xc5 0x1a 0x03 0xf9 0x58 0x9f 0x32 0x49 0xde 0xd2 0x26 0x78 0x80 0x87 0x18 0xf3 0x6d 0xc3 0x35 0x5d 0x21 0x8b 0x4c 0x8c 0x87 0xef 0xb1 0xfc 0x2c 0xec 0xdb 0xd6 0x00 0xe5 0x21 0xfa 0x34 0x5a 0x3c 0xc3 0x82 0x52 0x6f 0x81 0x2a 0x05 0xcc 0xdc 0x8a 0x51 0xf6 0x65 0x1d 0xc5 0x64 0x86 0xc1 0x28 0xf5 0x0c 0x8f 0x09 0xd4 0x84 0x8f 0x69 0x04 0x24 0x65 0xf4 0x47 0x6c 0x90 0x57 0x3c 0x04 0x4d 0x52 static unsign int 428 leav may need test case static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written endif static void us899_clean void static int us899_start_serv int manual_enrol int nid int st_start us899_server_port us899_server_certkey us899_server_certkey us899 test realm us899_cacert us899_trust_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us899_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us899_logger_stderr endif read certif cacerts_len read_binary_fil us899_cacert cacert cacerts_len return us899_clean (); start instanc est server automat enrol enabl us899_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us899_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey static int populate_x509_csr x509_req req evp_pkey pkey char x509_name subj setup version number x509_req_set_vers req printf (&#34;\\ unabl set x509 version &#34;); return add common name entri subj req subj mbstring_asc unsign char printf (&#34;\\ unabl creat x509 common name entri &#34;); return set public key request x509_req_set_pubkey req pkey printf (&#34;\\ unabl set x509 public key &#34;); return return sign x509 certif request use digest key pass return open ssl error code x509_req_sign_ctx (); static int sign_x509_req x509_req evp_pkey pkey const evp_md int evp_pkey_ctx pkctx null evp_md_ctx mctx evp_md_ctx_init mctx evp_digest sign init mctx pkctx null pkey return encod use der asn set modifi flag x509_req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req_info enc modifi x509_req_sign_ctx mctx evp_md_ctx_cleanup mctx return function perform basic simpl enrol use uid pwd identifi client server use varieti test case modul static void us899_simple_enrol char char server est_error expected_enroll_rv est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx server us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert expected_enroll_rv use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol basic test perform simpleenrol use user password identifi client server ident certif use client static void us899_test1 void log_func_nm us899_simple_enrol tc899 us899_server_ip est_err_non simpl enrol csr basic test perform simpleenrol use user password identifi client server ident certif use client test case use altern enrol method csr provid applic layer rather libest generat csr static void us899_test2 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null x509_req csr unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null generat csr csr x509_req_new (); cu_assert csr null populate_x509_csr csr key us899 tc2 &#34;); get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use altern api enrol exist csr ectx csr pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup x509_req_fre csr evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr null basic test perform simpleenrol use user password identifi client server ident certif use client test case use altern enrol method csr provid applic layer rather libest generat csr attempt pass null csr fail static void us899_test3 void est_ctx ectx evp_pkey key int int pkcs7_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null use altern api enrol null csr ectx null pkcs7_len key cu_assert est_err_no_csr cleanup evp_pkey_fre key est_destroy ectx simpl enrol csr corrupt test check x509_req helper function work propleri static void us899_test4 void x509_req csr unsign char badreq bogus request log_func_nm first tri pem decod csr badreq est_cert_format_pem cu_assert csr null next tri der decod csr badreq est_cert_format_d cu_assert csr null next tri invalid format csr badreq 999 cu_assert csr null next tri invalid csr length csr badreq 999999 est_cert_format_pem cu_assert csr null next tri valid pem encod csr csr unsign char us899_valid_csr_pem strlen us899_valid_csr_pem est_cert_format_pem cu_assert csr null csr x509_req_fre csr next tri valid der encod csr csr unsign char us899_valid_csr_d est_cert_format_d cu_assert csr null csr x509_req_fre csr attempt enrol newli creat csr alreadi sign via static void us899_test5 void est_ctx ectx evp_pkey key int int pkcs7_len x509_req csr unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null generat new csr csr x509_req_new (); cu_assert csr null populate_x509_csr csr key us899 tc5 &#34;); cu_assert csr null sign csr sign_x509_req csr key evp_sha256 ()); get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use altern api enrol exist csr pass ectx csr pkcs7_len key cu_assert est_err_non cleanup x509_req_fre csr evp_pkey_fre key est_destroy ectx simpl enrol fqdn mismatch hostnam test confirm mismatch host name server cert result auth failur tls layer client side static void us899_test6 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn mismatch ipv4 address test confirm mismatch address server cert result auth failur tls layer client side note test may redund sinc address match logic occur nsname use instead common name static void us899_test7 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn match wildcard test confirm wildcard match logic work cert use wildcard pattern cisco com server address localhost cisco com static void us899_test8 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch wildcard test confirm wildcard match logic work cert use wildcard pattern googl com server address localhost cisco com static void us899_test9 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol fqdn match hostnam subject alt name test confirm match host name server cert subject alt name ext result auth success static void us899_test10 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch hostnam subject alt name test confirm mismatch host name server cert subject alt name ext result auth failur static void us899_test11 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol fqdn mismatch ipv4 address subject alt name test confirm mismatch ipv4 address server cert subject alt name ext result auth failur static void us899_test12 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn match ipv4 address subject alt name test confirm match ipv4 address server cert subject alt name ext result auth success static void us899_test13 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip est_err_non simpl enrol fqdn match hostnam subject alt name wildcard test confirm hostnam match wildcard pattern server cert subject alt name ext result auth success static void us899_test14 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch hostnam subject alt name wildcard test confirm hostnam mismatch wildcard pattern server cert subject alt name ext result auth fail static void us899_test15 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol crl check enabl client enabl crl check client side generat crl server cert revok enrol succeed static void us899_test16 void int est_ctx ectx evp_pkey key int pkcs7_len unsign char new_cert null unsign char cacrlcert null int cacrlcerts_len unsign char attr_data null int attr_len log_func_nm stop exist server test case need server use differ cert st_stop (); fqdn test complet start normal server us899_start_serv cu_assert generat crl append chain use client side ifndef win32 system openssl config est exampl cnf gencrl us899 test16_crl pem &#34;); sleep system cat trustedcert crt us899 test16trust crt &#34;); sleep system cat us899 test16_crl pem us899 test16trust crt &#34;); sleep els system openssl config est exampl cnf gencrl us899 test16_crl pem &#34;); sleep system type trustedcert crt us899 test16trust crt &#34;); sleep system type us899 test16_crl pem us899 test16trust crt &#34;); sleep endif read certif cacrlcerts_len read_binary_fil us899 test16trust crt cacrlcert cu_assert cacrlcert cacrlcerts_len return creat client context ectx est_client_init cacrlcert cacrlcerts_len est_cert_format_pem cu_assert ectx null enabl crl check client est_enable_crl ectx cu_assert est_err_non set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx test16 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx free cacrlcert simpl enrol crl check enabl client enabl crl check client side generat crl server cert revok enrol fail static void us899_test17 void int est_ctx ectx evp_pkey key int pkcs7_len unsign char cacrlcert null int cacrlcerts_len unsign char attr_data null int attr_len log_func_nm revok server cert generat crl append chain use client side ifndef win32 system est index txt est index txt save &#34;); sleep system openssl config est exampl cnf revok est privat estservercertandkey pem &#34;); sleep system openssl config est exampl cnf gencrl us899 test17_crl pem &#34;); sleep system cat trustedcert crt us899 test17trust crt &#34;); sleep system cat us899 test17_crl pem us899 test17trust crt &#34;); sleep system est index txt save est index txt &#34;); sleep els system copi est index txt est index txt save &#34;); sleep system openssl config est exampl cnf revok est privat estservercertandkey pem &#34;); sleep system openssl config est exampl cnf gencrl us899 test17_crl pem &#34;); sleep system type trustedcert crt us899 test17trust crt &#34;); sleep system type us899 test17_crl pem us899 test17trust crt &#34;); sleep system copi est index txt save est index txt &#34;); sleep endif read certif cacrlcerts_len read_binary_fil us899 test17trust crt cacrlcert cu_assert cacrlcert cacrlcerts_len return creat client context ectx est_client_init cacrlcert cacrlcerts_len est_cert_format_pem cu_assert ectx null enabl crl check client est_enable_crl ectx cu_assert est_err_non set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_ssl_connect use simplifi api enrol csr est_client_enrol ectx test17 pkcs7_len key cu_assert est_err_ssl_connect cleanup evp_pkey_fre key est_destroy ectx free cacrlcert simpl enrol receiv retri respons client issu enrol request receiv retri respons ensur retri valu obtain client static void us899_test18 void int est_ctx ectx evp_pkey key int pkcs7_len int delay_sec time_t retry_d unsign char attr_data null int attr_len log_func_nm stop exist server test case need server manual enrol mode st_stop (); start server manual enrol mode us899_start_serv cu_assert creat client context use default cert ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx test18 pkcs7_len key cu_assert get retri durat make sure set default valu ectx delay_sec retry_d cu_assert est_err_non cu_assert delay_sec 3600 cleanup evp_pkey_fre key est_destroy ectx auth http basic auth enabl server enrol csr use valid cert uid enrol csr use valid cert valid uid enrol csr use valid cert invalid uid enrol csr use invalid cert uid enrol csr use invalid cert valid uid enrol csr use invalid cert invalid uid auth http digest auth enabl server enrol csr use valid cert uid enrol csr use valid cert valid uid enrol csr use valid cert invalid uid enrol csr use invalid cert uid enrol csr use invalid cert valid uid enrol csr use invalid cert invalid uid int us899_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us899_init_suit us899_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit simpl enrol us899_test1 null cu_add_test suit simpl enrol csr us899_test2 null cu_add_test suit simpl enrol null csr us899_test3 null cu_add_test suit simpl enrol corrupt csr us899_test4 null cu_add_test suit simpl enrol sign csr us899_test5 null cu_add_test suit simpl enrol hostnam mismatch fqdn us899_test6 null cu_add_test suit simpl enrol ipv4 mismatch fqdn us899_test7 null cu_add_test suit simpl enrol wildcard match fqdn us899_test8 null cu_add_test suit simpl enrol wildcard mismatch fqdn us899_test9 null cu_add_test suit simpl enrol hostnam match fqdn san us899_test10 null cu_add_test suit simpl enrol hostnam mismatch fqdn san us899_test11 null cu_add_test suit simpl enrol ipv4 mismatch fqdn san us899_test12 null cu_add_test suit simpl enrol ipv4 match fqdn san us899_test13 null cu_add_test suit simpl enrol wildcard match fqdn san us899_test14 null cu_add_test suit simpl enrol wildcard mismatch fqdn san us899_test15 null cu_add_test suit simpl enrol crl enabl valid server cert us899_test16 null cu_add_test suit simpl enrol crl enabl revok server cert us899_test17 null cu_add_test suit simpl enrol retri receiv us899_test18 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us4020.c&#39;,
  &#39;unit test user stori unit test client proxi mode test new api function verifi correct oper client proxi mode octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno includ fcntl defin max cmds static unsign char cacert null static int cacert len defin server_domain_nam localhost cisco com defin us4020_server_ip 127 defin 40200 defin us4020_proxy_ip 127 defin 40208 defin us4020_uid estus defin us4020_pwd estpwd ifndef win32 defin us4020_cacert est cacert crt defin us4020_cacert est cacert crt defin us4020_server_cert est privat estservercertandkey pem defin us4020_server_key est privat estservercertandkey pem defin us4020_client_cert est privat estservercertandkey pem defin us4020_client_key est privat estservercertandkey pem els defin us4020_cacert est cacert crt defin us4020_cacert est cacert crt defin us4020_server_cert est privat estservercertandkey pem defin us4020_server_key est privat estservercertandkey pem defin us4020_client_cert est privat estservercertandkey pem defin us4020_client_key est privat estservercertandkey pem static critical_sect logger_critical_sect static void us4020_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey static void us4020_clean void int us4020_start_serv int manual_enrol int nid int st_start est privat estservercertandkey pem est privat estservercertandkey pem estrealm est cacert crt trustedcert crt est exampl cnf manual_enrol nid return defin max_cmd_buf 256 defin max_pid_buf 128 static void shutdown_antinat void int char read_pid max_pid_buf char cmd max_cmd_buf int open (&#34;./ antinat pid o_rdwr 0666 void read read_pid max_pid_buf printf pid read back read_pid snprintf cmd max_cmd_buf kill read_pid system cmd printf fail termin antinat &#34;); static void shutdown_haproxi void int int readbyte_count char read_pid max_pid_buf char cmd max_cmd_buf int open (&#34;./ haproxi pid o_rdwr 0666 readbyte_count read read_pid max_pid_buf void read read_pid max_pid_buf printf pid read back read_pid snprintf cmd max_cmd_buf kill read_pid system cmd printf fail termin haproxi &#34;); routin call cunit initi test suit use alloc data open resourc requir test case static int us4020_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us4020_logger_stderr els est_init_logg est_log_lvl_info null endif read certif cacerts_len read_binary_fil us4020_cacert cacert cacerts_len return us4020_clean (); start instanc est server automat enrol enabl us4020_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us4020_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv error check paramet api static void us4020_test1 void est_error e_rc est_ctx ectx null log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null attempt call api without context e_rc est_client_set_proxi null us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_no_ctx valid call e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set server e_rc est_client_set_proxi ectx null estus estpwd &#34;); cu_assert e_rc server empti string e_rc est_client_set_proxi ectx &#34;&#34;, estus estpwd &#34;); cu_assert e_rc max server name char max_server_nam 123456789012345 e_rc est_client_set_proxi ectx max_server_nam estus estpwd &#34;); cu_assert e_rc est_err_non server name long char long_server_nam 1234567890123456 e_rc est_client_set_proxi ectx long_server_nam estus estpwd &#34;); cu_assert e_rc set port e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi protocol invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi protocol invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi auth invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc max userid char max_userid 123456789012345 e_rc est_client_set_proxi ectx us4020_proxy_ip max_userid estpwd &#34;); cu_assert e_rc est_err_non userid long char long_userid 1234567890123456 e_rc est_client_set_proxi ectx us4020_proxy_ip long_userid estpwd &#34;); cu_assert e_rc userid empti string e_rc est_client_set_proxi ectx us4020_proxy_ip &#34;&#34;, estpwd &#34;); cu_assert e_rc max pwd char max_pwd 123456789012345 e_rc est_client_set_proxi ectx us4020_proxy_ip estus max_pwd cu_assert e_rc est_err_non pwd long char long_pwd 1234567890123456 e_rc est_client_set_proxi ectx us4020_proxy_ip estus long_pwd cu_assert e_rc password empti string e_rc est_client_set_proxi ectx us4020_proxy_ip estus &#34;&#34;); cu_assert e_rc est_destroy ectx test sock mode credenti pass static void us4020_test2 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode credenti pass static void us4020_test3 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode static void us4020_test4 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode static void us4020_test5 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode credenti static void us4020_test6 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode good credenti static void us4020_test7 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg goodcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode good credenti forgotten static void us4020_test8 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg goodcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_ip_connect shutdown_antinat (); est_destroy ectx test sock mode bad credenti static void us4020_test9 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg badcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_ip_connect shutdown_antinat (); est_destroy ectx could test need certifc updat test sock mode domain name static void us4020_test8 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx endif test http proxi mode note non tunnel mode test tunnel mode work cisco est server static void us4020_test10 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set http proxi server local snprintf cmd max_4020_cmd haproxi us4020 haproxi cfg haproxi pid &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_haproxi (); est_destroy ectx indic whether client proxi support built librari static int client_proxy_en void est_error e_rc e_rc est_client_set_proxi null null null null e_rc return els return main function set run test return cue_success success run anoth cunit error code failur int us4020_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us4020_tok_auth_cli us4020_init_suit us4020_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); ifndef win32 client proxi mode support libcurl specifi client_proxy_en ()){ add test suit null cu_add_test suit paramet check api us4020_test1 null cu_add_test suit sock mode us4020_test2 null cu_add_test suit sock mode credenti us4020_test3 null cu_add_test suit sock mode us4020_test4 null cu_add_test suit sock mode us4020_test5 null cu_add_test suit sock mode credenti us4020_test6 null cu_add_test suit sock mode good credenti us4020_test7 null cu_add_test suit sock mode forgotten credenti us4020_test8 null cu_add_test suit sock mode bad credenti us4020_test9 null cu_add_test suit sock mode domain name instead address us4020_test7 null cu_add_test suit http proxi us4020_test10 cu_cleanup_registri (); return cu_get_error (); endif return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us897.c&#39;,
  &#39;unit test user stori client cacert june copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server max command line length generat system command defin est max cmd len defin est max certif use verifi est server grab server directori defin client cacert exampl server est cacert crt defin us897_server_port 29897 defin client_ut_pubkey &#34;./ defin us897_server_ip 127 defin us897_uid estus defin us897_pwd estpwd ifndef win32 defin client_ut_cacert est cacert crt defin us897_cacert est cacert crt defin us897_trust_cert trustedcert crt defin us897_server_certkey est privat estservercertandkey pem defin us897 crt defin us897 crt defin us897 singlechain_expir crt defin us897 trust chain10revok crt els defin client_ut_cacert est cacert crt defin us897_cacert est cacert crt defin us897_trust_cert trustedcert crt defin us897_server_certkey est privat estservercertandkey pem defin us897 crt defin us897 crt defin us897 singlechain_expir crt defin us897 trust chain10revok crt endif static void us897_clean void static int us897_start_serv int manual_enrol int nid int st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_cacert us897_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit generat keypair use est client suit static int us897_init_suit void int char cmd est_ut_max_cmd_len printf start est client unit test pdb &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us897_clean (); start instanc est server us897_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us897_destroy_suit void st_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test case initi est client context use local cert client cert valid public key userid password static void us897_test1 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return est_init_logg est_log_lvl_info null ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use local cert expect success initi sinc local trust anchor cert mandatori static void us897_test2 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init null est_cert_format_pem cu_assert ectx null ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use local cert client cert valid public key userid password static void us897_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use explict cert client cert valid public key userid password static void us897_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey endif test case initi est client context use explict cert client cert public key userid password static void us897_test6 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx user password null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use explict cert client cert public key userid password static void us897_test7 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx user null null priv_key cu_assert ectx est_destroy ectx ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx null password null priv_key cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test set server valid paramet static void us897_test9 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case test set server invalid paramet static void us897_test10 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non char server_name_too_long evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non null server name est_client_set_serv ectx null us897_server_port null cu_assert server long est_client_set_serv ectx server_name_too_long us897_server_port null cu_assert port num less est_client_set_serv ectx us897_server_ip null cu_assert port num greater max est_client_set_serv ectx us897_server_ip 65536 null cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test get cacert request static void us897_test11 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert make sure context longer valid est client back uniniti state ectx cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test get cacert request invalid input paramet static void us897_test12 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx null success obtain valid buffer contain cert cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl certif static void us897_test13 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_cacert us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert static void us897_test14 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert miss cert chain static void us897_test15 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_cacert_verif cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_no_certif output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert intermedi cert expir static void us897_test16 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_cacert_verif cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_no_certif output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain multipl chain multipl cert crl block crls ignor static void us897_test17 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read startup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_non output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test ssl read set timeout api set min max valu valu beyond max static void us897_test18 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int read startup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null ectx cu_assert est_err_non ectx cu_assert est_err_non ectx cu_assert ectx cu_assert est_err_non proceed get cacert verifi noth get broken issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_non output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us897_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us897_client_cacert us897_init_suit us897_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit est client init local privat key us897_test1 null cu_add_test suit est client init local us897_test2 null cu_add_test suit est client init local explicit privat key us897_test3 null cu_add_test suit est client init local explicit client privat key us897_test4 null cu_add_test suit est client init local userid password us897_test6 null cu_add_test suit est client init local userid password us897_test7 null cu_add_test suit est client init local userid password us897_test8 null cu_add_test suit est client set server correct paramet us897_test9 null cu_add_test suit est client set server paramet us897_test10 null cu_add_test suit est client cert ca_cert valid paramet us897_test11 null cu_add_test suit est client cert miss ca_cert pointer us897_test12 null cu_add_test suit est client cert verifi chain simpl chain success us897_test13 null cu_add_test suit est client cert verifi chain multipl cert success us897_test14 null cu_add_test suit est client cert verifi chain broken chain fail us897_test15 null cu_add_test suit est client cert verifi chain bad date fail us897_test16 null cu_add_test suit est client cert verifi chain multipl chain success us897_test17 null cu_add_test suit est client ssl read timeout api us897_test18 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us1060.c&#39;,
  &#39;unit test user stori tls srp support server proxi may copyright cisco system inc right reserv includ stdio includ string ifndef win includ unistd includ pthread endif includ est includ curl curl includ test util includ curl util includ server includ proxi includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif defin server_port 31060 defin us1060_server_ip 127 defin us1060_uid estus defin us1060_pwd estpwd ifndef win32 defin us1060_cacert est cacert crt defin us1060_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1060_vfil us1060 passwd srpv defin us1060_explicit_cert us1060 explicit cert pem defin us1060_explicit_key us1060 explicit key pem defin us1060_selfsign_cert us1060 selfsign cert pem defin us1060_selfsign_key us1060 selfsign key pem els defin us1060_cacert est cacert crt defin us1060_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1060_vfil us1060 passwd srpv defin us1060_explicit_cert us1060 explicit cert pem defin us1060_explicit_key us1060 explicit key pem defin us1060_selfsign_cert us1060 selfsign cert pem defin us1060_selfsign_key us1060 selfsign key pem endif defin us1060_enroll_url https :// 127 31060 well known est simpleenrol defin us1060_uidpwd_good estus estpwd defin us1060_uidpwd_bad estus xxx111222 defin us1060_pkcs10_ct content type applic pkcs10 defin https :// 127 41060 well known est simpleenrol defin us1060_proxy_port 41060 defin us1060_pkcs10_req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w static char log_search_target null static int search_target_found static unsign char cacert null static int cacerts_len static srp_vbase srpdb null ifdef win32 critical_sect logger_critical_sect endif simpl callback use overrid default log facil libest use look specif debug output static void us1060_logger_stderr char format va_list char t_log 1024 ifndef win32 flockfil stderr els enter critic section logger_critical_sect endif log_search_target vsnprintf t_log 1024 format strstr t_log log_search_target search_target_found fprintf stderr t_log els vfprintf stderr format fflush stderr ifndef win32 funlockfil stderr els leav critic section logger_critical_sect endif static int us1060_start_serv char cert char key int no_http_auth int enable_pop int enable_srp int enable_srp st_start_srp us1060_server_port cert key us1060 test realm us1060_cacert us1060_trust_cert est exampl cnf enable_pop us1060_vfil els st_start us1060_server_port cert key us1060 test realm us1060_cacert us1060_trust_cert est exampl cnf enable_pop no_http_auth st_disable_http_auth (); return routin call cunit initi test suit use alloc data open resourc requir test case static int us1060_init_suit void int ifdef win32 initi critic section window initi critic section logger_critical_sect endif est_init_logg est_log_lvl_info us1060_logger_stderr start instanc est server automat enrol enabl us1060_start_serv start instanc proxi srp enabl st_proxy_start_srp us1060_proxy_port us1060 proxi realm us1060_cacert us1060_trust_cert us1060_uid us1060_pwd us1060_server_ip us1060_server_port us1060_vfil read certif use client side api test cacerts_len read_binary_fil us1060_cacert cacert cacerts_len return srpdb srp_vbase_new null srpdb printf (&#34;\\ unabl alloc srp verifi databas abort !!!\\ &#34;); srp_vbase_init srpdb us1060_vfil srp_no_error printf (&#34;\\ unabl initi srp verifi databas abort !!!\\ &#34;); return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1060_destroy_suit void srpdb srp_vbase_fre srpdb st_stop (); st_proxy_stop (); free cacert return typedef enum srp_off srp_on server_srp_mod typedef enum srp_good srp_bad srp_none client_srp_mod typedef enum http_off http_option http_requir server_http_mod typedef struct char test_nam char curl_cert char curl_key char curl_http_auth client_srp_mod curl_srp server_http_mod server_http server_srp_mod server_srp int expected_http_result us1060_matrix unit test matrix server side srp support curl use est client disabl server test case tri cover varieti configur potenti scenario client side variat includ curl_cert certif curl use may null curl_key key curl use may null curl_http_auth http auth credenti use curl client_srp_mod either good bad none determin srp credenti use curl server side configur server use follow variat server_http_mod http auth requir option disabl option mean occur tls auth fail server_srp_mod srp either enabl disabl server expected_http_result expect http status code receiv curl srp fail result fail tls session curl return zero case sinc http layer communic tls succeed http auth fail server return http 401 respons client enrol succeed server send http 200 respons static us1060_matrix test_matrix null null us1060_uidpwd_good srp_good http_requir srp_on 200 null null us1060_uidpwd_good srp_bad http_requir srp_on null null us1060_uidpwd_good srp_none http_requir srp_on 200 null null us1060_uidpwd_good srp_good http_option srp_on 200 null null us1060_uidpwd_good srp_bad http_option srp_on null null us1060_uidpwd_good srp_none http_option srp_on 200 null null us1060_uidpwd_good srp_good http_off srp_on 200 null null us1060_uidpwd_good srp_bad http_off srp_on null null us1060_uidpwd_good srp_none http_off srp_on 401 null null us1060_uidpwd_bad srp_good http_requir srp_on 401 null null us1060_uidpwd_bad srp_bad http_requir srp_on null null us1060_uidpwd_bad srp_none http_requir srp_on 401 null null us1060_uidpwd_bad srp_good http_option srp_on 200 null null us1060_uidpwd_bad srp_bad http_option srp_on null null us1060_uidpwd_bad srp_none http_option srp_on 401 null null us1060_uidpwd_bad srp_good http_off srp_on 200 null null us1060_uidpwd_bad srp_bad http_off srp_on null null us1060_uidpwd_bad srp_none http_off srp_on 401 null null us1060_uidpwd_good srp_good http_requir srp_off null null us1060_uidpwd_good srp_bad http_requir srp_off null null us1060_uidpwd_good srp_none http_requir srp_off 200 null null us1060_uidpwd_good srp_good http_option srp_off null null us1060_uidpwd_good srp_bad http_option srp_off null null us1060_uidpwd_good srp_none http_option srp_off 200 null null us1060_uidpwd_good srp_good http_off srp_off null null us1060_uidpwd_good srp_bad http_off srp_off null null us1060_uidpwd_good srp_none http_off srp_off 401 null null us1060_uidpwd_bad srp_good http_requir srp_off null null us1060_uidpwd_bad srp_bad http_requir srp_off null null us1060_uidpwd_bad srp_none http_requir srp_off 401 null null us1060_uidpwd_bad srp_good http_option srp_off null null us1060_uidpwd_bad srp_bad http_option srp_off null null us1060_uidpwd_bad srp_none http_option srp_off 401 null null us1060_uidpwd_bad srp_good http_off srp_off null null us1060_uidpwd_bad srp_bad http_off srp_off null null us1060_uidpwd_bad srp_none http_off srp_off 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_requir srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_requir srp_on 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_option srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_option srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_off srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_off srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_requir srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_requir srp_off 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_option srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_option srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_off srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_off srp_off 200 us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_requir srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_requir srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_option srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_option srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_off srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_off srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_requir srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_requir srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_option srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_option srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_off srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_off srp_off worker entri test matrix read configur entri configur server client need attempt simpl enrol use curl client argument index entri tabl static void int long log_func_nm printf (&#34;\\ run matrix test test_matrix test_nam stop server restart make sure correct mode st_stop (); sleep test_matrix server_srp srp_on us1060_start_serv els us1060_start_serv cu_assert set server http auth configur switch test_matrix server_http case http_off st_disable_http_auth (); break case http_option st_enable_http_auth (); st_set_http_auth_opt (); break case http_requir st_enable_http_auth (); (); break switch test_matrix curl_srp case srp_good curl_http_post_srp us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth null curlauth_bas null srp_user srp_pwd null null break case srp_bad curl_http_post_srp us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth null curlauth_bas null srp_user boguspwd null null break case srp_none srp disabl test case use client certif test_matrix curl_cert us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth test_matrix curl_cert test_matrix curl_key us1060_cacert null els curl_http_post us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth us1060_cacert curlauth_bas null null null break cu_assert test_matrix expected_http_result test_matrix expected_http_result printf (&#34;\\ matrix test fail test_matrix test_nam int test case run test matrix static void us1060_test0 void int int test_cnt sizeof test_matrix sizeof test_matrix ]); test_cnt ++) test case verifi happi path est proxi configur srp mode client attempt use srp connect proxi server use srp perform simpl enrol oper static void us1060_test200 void long log_func_nm restart est server srp disabl st_stop (); sleep us1060_start_serv cu_assert curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_good null curlauth_bas null srp_user srp_pwd null null sinc pass valid srp user password expect server respond success cu_assert 200 test case verifi simpl enrol fail est client provid bad srp password connect proxi server use srp static void us1060_test201 void long log_func_nm curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_good null curlauth_bas null srp_user boguspwd null null cu_assert test case verifi simpl enrol fail est client provid bad http password srp use connect proxi server use srp static void us1060_test202 void long log_func_nm curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_bad null curlauth_bas null srp_user srp_pwd null null cu_assert 401 test case verifi simpl enrol work est client provid http password srp use connect proxi server use srp http auth disabl proxi static void us1060_test203 void long log_func_nm st_proxy_http_dis curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req null null curlauth_non null srp_user srp_pwd null null cu_assert 200 int us1060_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1060_tls_srp server proxi )&#34;, us1060_init_suit us1060_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit tls srp server matrix master us1060_test0 null cu_add_test suit tls srp proxi enrol srp us1060_test200 null cu_add_test suit tls srp proxi enrol bad srp pwd us1060_test201 null cu_add_test suit tls srp proxi enrol bad http pwd us1060_test202 null cu_add_test suit tls srp proxi enrol http auth us1060_test203 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us900.c&#39;,
  &#39;unit test user stori server csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif defin server port defin server ifndef win defin client ut_cacert est cacert crt defin client_ut_pubkey &#34;./ defin us900_cacert est cacert crt defin us900_trust_cert trustedcert crt defin us900_server_certkey est privat estservercertandkey pem els defin client_ut_cacert est cacert crt defin client_ut_pubkey defin us900_cacert est cacert crt defin us900_trust_cert trustedcert crt defin us900_server_certkey est privat estservercertandkey pem endif defin test_attr_pop mas gcsq gsib3dqejbw ==\\ defin test_attr_nopop mhew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg ==\\ defin test_attr_nopoppop mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr_popad mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr1 mcygbi gaqebarygcsq gsib3dqejbw yfk4eeacigcwcgsafl qcag ==\\ defin test_attr2 maa defin test_attr7 ==\\ defin test_attr2_pop mas gcsq gsib3dqejbw ==\\ defin test_attr8 mathisi bad gcsq gsib3dqejbw ==\\ defin test_attr3 migsmfg ga4g3aj frexl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku ncbk yxrh bgkqhki g9w0bcqcw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebari defin test_attr4_122 mhow laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr4_122pop migfmcw ga4g3aj oinw mga4g3bbmzugfyc2ug u0vuigfz idiu otk5lj jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebarygcsq gsib3dqejbw ==\\ defin test_attr5_117 mhuw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebari defin test_attr5_117pop migamcc ga4g3aj oinw mga4g3bbmuugfyc2ug u0vuigfz idiu otk5lj igcwcgsafl qcag yjki qdaw iiaqelmciga4g3ateb exl qyxjz zsbtrvqg yxmg mi45otku msbk yxrh bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_attr6_116 mhqw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw iqydi bmro tgfbhcn ifnfvcbhci ljk5os4x igrhd ayhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr_244 mih1mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey qgbys gaqebarygbi gaqebari defin test_attr_245 mih2mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1bgcr ebaqewbgcr ebaqew defin test_attr_250 mih7mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_attr_250pop miibbj oinw xqydi dbg oinw qtuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_all_attr mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfmtiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin test_1024_nopop miid dcca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_1025_nopop miid tcca2qga4g3aj gca1 ga4g3aw ydi eeisx m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_1024_pop miiebz cca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg yjko zihvc naqk defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin est_ut_max_cmd_len 255 extern est_ctx ectx static void us900_clean void static int us900_start_serv int manual_enrol int nid int st_start us900_server_port us900_server_certkey us900_server_certkey us900 test realm us900_cacert us900_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us900_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us900_clean (); start instanc est server us900_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us900_destroy_suit void st_stop (); sleep return static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr1 csr_data malloc csr_len strncpi char csr_data test_attr1 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr8 csr_data malloc csr_len strncpi char csr_data test_attr8 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr7 csr_data malloc csr_len strncpi char csr_data test_attr7 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_long_attr csr_data malloc csr_len strncpi char csr_data test_long_attr csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr_nopop csr_data malloc csr_len strncpi char csr_data test_attr_nopop csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len csr_data null return csr_data callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis api static void us900_test1 void int log_func_nm null ctx fail null us900 test1 cu_assert est_err_non null string pass ectx null cu_assert est_err_non zero length fail ectx us900 test1 cu_assert est_err_non length long fail ectx us900 test1 max_csrattr cu_assert est_err_non real base64 string fail ectx us900 test1 cu_assert est_err_non real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non set smallest base64 size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non set illeg small base64 size ectx test_attr7 strlen test_attr7 )); cu_assert est_err_non set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non enabl st_enable_pop (); real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non real base64 string fail ectx us900 test1 cu_assert est_err_non set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non disabl st_disable_pop (); asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non test2 exercis server side variat trigger static void us900_test2 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key int csr_len unsign char csr_data null sleep log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us900_server_ip us900_server_port null issu get cert request ctx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ctx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit clear csrattr ectx null cu_assert est_err_non get 204 data ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2 )); cu_assert strncmp test_attr2 const char csr_data csr_len ectx test_attr3 strlen test_attr3 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr3 )); cu_assert strncmp test_attr3 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_nopop )); cu_assert strncmp test_1024_nopop const char csr_data csr_len enabl test respons st_enable_pop (); ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_data null cu_assert csr_len cu_assert strncmp test_attr_pop const char csr_data csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_pop )); cu_assert strncmp test_1024_pop const char csr_data csr_len set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr4_122pop )); cu_assert strncmp test_attr4_122pop const char csr_data csr_len set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr5_117pop )); cu_assert strncmp test_attr5_117pop const char csr_data csr_len real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len real base64 string fail ectx us900 test1 cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_250pop )); cu_assert strncmp test_attr_250pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len disabl st_disable_pop (); clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopop )); cu_assert strncmp test_attr_nopop const char csr_data csr_len asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_all_attr )); cu_assert strncmp test_all_attr const char csr_data csr_len ectx test_1025_nopop strlen test_1025_nopop )); cu_assert est_err_non ectx test_long_attr strlen test_long_attr )); cu_assert est_err_non ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us900_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us900_srv_csrattr us900_init_suit us900_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr server attribut api1 us900_test1 null cu_add_test suit csr server attribut api2 us900_test2 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us896.c&#39;,
  &#39;unit test user stori client csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif ifndef win defin client cacert est cacert crt defin cacert est cacert crt defin trust cert trustedcert crt defin 96_server_certkey est privat estservercertandkey pem els defin client_ut_cacert est cacert crt defin us896_cacert est cacert crt defin us896_trust_cert trustedcert crt defin us896_server_certkey est privat estservercertandkey pem endif defin client_ut_pubkey &#34;./ defin us896_server_port 29896 defin us896_server_ip 127 defin test_short_attr ==\\ defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin test_corrupt_attr1 mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oiex mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_corrupt_attr2 mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfm12345tiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin est_ut_max_cmd_len 255 static void us896_clean void static int us896_start_serv int manual_enrol int nid int st_start us896_server_port us896_server_certkey us896_server_certkey us896 test realm us896_cacert us896_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us896_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us896_clean (); start instanc est server us896_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us896_destroy_suit void st_stop (); sleep return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis api static void us896_test1 void int unsign char csr_data int csr_len est_ctx ctx null log_func_nm ctx csr_data csr_len cu_assert est_err_non ctx null csr_len cu_assert est_err_non ctx csr_data null cu_assert est_err_non test2 exercis respons variat trigger static void us896_test2 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key sleep log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us896_server_ip us896_server_port null issu get cert request ctx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ctx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert negat test requir code est server modifi allow bad corrupt attribut initi sent client ifdef negative_unit_test unsign char csr_data int csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ectx test_corrupt_attr1 strlen test_corrupt_attr1 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_corrupt_attr2 strlen test_corrupt_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_short_attr strlen test_short_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_long_attr strlen test_long_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null endif ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us896_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us896_client_csrattr us896_init_suit us896_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr client attribut api1 us896_test1 null cu_add_test suit csr client attribut api2 us896_test2 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us894.c&#39;,
  &#39;unit test user stori proxi cacert novemb copyright cisco system inc right reserv proxi mode primarili server mode process certain request client pass long upstream server use client mode function case get cacert proxi mode function almost ident server mode cert respons chain pass sent repli get cacert request downstream client test code taken larg server get cacert includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ openssl ssl includ server includ proxi ifdef cunit includ cunit basic includ cunit autom endif defin pkcs req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w defin us894_pkcs10_ct content type applic pkcs10 defin us894_uidpwd_good estus estpwd defin us894_uidpwd_bad estus bogus ifndef win32 defin us894_cacert est cacert crt defin us894_trusted_cert trustedcert crt defin us894 trustedcertsandcrl crt defin us894_explicit_cert us894 explicit cert pem defin us894_explicit_key us894 explicit key pem defin us894_implicit_cert us894 implicit cert pem defin us894_implicit_key us894 implicit key pem defin us894_revoked_cert us894 revok cert pem defin us894_revoked_key us894 revok key pem defin us894_selfsign_cert us894 selfsign cert pem defin us894_selfsign_key us894 selfsign key pem defin us894_cacert est cacert crt defin us894_extcert ext cacert crt defin us894_server_cert est privat estservercertandkey pem defin us894_server_key est privat estservercertandkey pem defin us894_proxy_cert est privat estservercertandkey pem chang dedic one defin us894_proxy_key est privat estservercertandkey pem static char test5_outfil filename_max us894 test5 crt static char test26_outfil filename_max us894 test26 crt static char test27_outfil filename_max us894 test27 crt els defin us894_cacert est cacert crt defin us894_trusted_cert trustedcert crt defin us894 trustedcertsandcrl crt defin us894_explicit_cert us894 explicit cert pem defin us894_explicit_key us894 explicit key pem defin us894_implicit_cert us894 implicit cert pem defin us894_implicit_key us894 implicit key pem defin us894_revoked_cert us894 revok cert pem defin us894_revoked_key us894 revok key pem defin us894_selfsign_cert us894 selfsign cert pem defin us894_selfsign_key us894 selfsign key pem defin us894_cacert est cacert crt defin us894_extcert ext cacert crt defin us894_server_cert est privat estservercertandkey pem defin us894_server_key est privat estservercertandkey pem defin us894_proxy_cert est privat estservercertandkey pem chang dedic one defin us894_proxy_key est privat estservercertandkey pem static char test5_outfil filename_max us894 test5 crt static char test26_outfil filename_max us894 test26 crt static char test27_outfil filename_max us894 test27 crt endif defin 12894 defin us894_enroll_url https :// 127 16894 well known est simpleenrol defin us894_cacert_url https :// 127 16894 well known est cacert defin 13894 defin 14894 defin 15894 defin us894_tcp_proxy_port 16894 static void us894_clean void char cmd 200 ifndef win32 sprintf cmd test5_outfil system cmd sprintf cmd test26_outfil system cmd sprintf cmd test27_outfil system cmd els sprintf cmd del test5_outfil system cmd sprintf cmd del test26_outfil system cmd sprintf cmd del test27_outfil system cmd endif int us894_start_serv int first start est server act st_start us894_server_cert us894_server_key estrealm us894_cacert us894_trusted_cert us894 est exampl cnf manual enrol disabl ecdh nid info sleep est_err_non return next start est proxi act st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us894_init_suit void int us894_clean (); printf (&#34;\\ start est proxi get cacert unit test &#34;); start instanc est server automat enrol enabl us894_start_serv (); return void us894_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit uniniti test suit use dealloc data close resourc use test case static int us894_destroy_suit void us894_stop_serv (); printf complet est proxi get cacert unit test &#34;); return http basic auth test case use libcurl test http basic authent work est proxi server must use simpleenrol messag sinc cacert messag requir client authent static void us894_test1 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 http basic auth failur bad password test case use libcurl test http basic authent work est proxi server use bogus password must use simpleenrol messag sinc cacert messag requir client authent static void us894_test2 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 400 cu_assert 401 http digest auth test case use libcurl test http digest authent work est proxi server must use simpleenrol messag sinc cacert messag requir client authent test also test correct oper est_proxy_set_auth static void us894_test3 void long log_func_nm st_proxy_set_auth auth_digest sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_digest null null null sinc pass valid user password expect server respond success cu_assert 200 st_proxy_set_auth auth_bas http digest auth fail test case use libcurl test http digest authent work est proxi server negat test case digest auth must use simpleenrol messag sinc cacert messag requir client authent est proxi server run listen port 8087 prior test run static void us894_test4 void long log_func_nm st_proxy_set_auth auth_digest sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_cacert curlauth_digest null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_proxy_set_auth auth_bas static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written test case simpl cacert request look http 200 respons code static void us894_test5 void long char cmd 200 log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_get us894_cacert_url us894_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test5_outfil system cmd cu_assert static void us894_test_sslvers const ssl_method int expect_fail bio conn ssl ssl ssl_ctx ssl_ctx null int ssl_ctx ssl_ctx_new cu_assert ssl_ctx null ssl context readi open socket server bind socket context conn open_tcp_socket_ipv4 127 16894 &#34;); cu_assert conn null creat ssl session context ssl ssl_new ssl_ctx ssl_set_bio ssl conn conn everyth readi let initi tls handshak ssl_connect ssl expect_fail cu_assert els cu_assert cleanup data ssl_shutdown ssl ssl_free ssl ssl_ctx_free ssl_ctx test attempt creat ssl connect est server fail tls allow static void us894_test6 void log_func_nm us894_test_sslvers sslv3_client_method (), test attempt creat tls connect est server fail tls allow static void us894_test7 void log_func_nm us894_test_sslvers tlsv1_client_method (), test attempt creat tls connect est server succeed static void us894_test8 void log_func_nm us894_test_sslvers (), test attempt creat tls connect est server succeed static void us894_test9 void log_func_nm us894_test_sslvers (), test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain succeed static void us894_test10 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_explicit_cert us894_explicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_proxy_http_dis printf could set http authent callback &#34;); return test attempt use client certif verifi tls client authent work certif use sign implicit cert chain succeed static void us894_test11 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_implicit_cert us894_implicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_proxy_http_dis printf could set http authent callback &#34;); return test attempt use revok client certif verifi crl check work tls layer fail static void us894_test12 void long log_func_nm st_proxy_stop (); st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert estus estpwd 127 disabl ecdh nid info sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_revoked_cert us894_revoked_key us894_cacert null sinc client cert revok tls handshak fail est server return 401 respons cu_assert st_proxy_stop (); st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info test attempt use self sign client certif verifi cert chain reject cert sign valid fail static void us894_test13 void long log_func_nm sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_selfsign_cert us894_selfsign_key us894_cacert null sinc client cert sign either local extern tls handshak fail receiv http status messag server cu_assert tls anonym cipher suit disabl test case use libcurl test est server accept anonym cipher suit client test singl cipher suit attempt simpl enrol server static void us894_test14 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas adh aes128 sha256 null null tls handshak fail curl return cu_assert null http realm initi server static void us894_test15 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null realm est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem null priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key null server certif initi server static void us894_test16 void unsign char cacert null int cacerts_len bio keyin evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null server key est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null priv_key estus estpwd &#34;); cu_assert ctx null evp_pkey_fre priv_key null server certif privat key initi server static void us894_test17 void unsign char cacert null int cacerts_len bio certin x509 int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin attempt init est proxi use null privat key est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null estus estpwd &#34;); cu_assert ctx null x509_free null trust chain initi server static void us894_test18 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null local chain est_init_logg est_log_lvl_info null ctx est_proxy_init null null est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key corrupt chain initi server static void us894_test19 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi corrupt chain est_init_logg est_log_lvl_info null ctx est_proxy_init unsign char bogus chain unsign char bogus chain est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key test case attempt simpl cacert request use post instead get fail static void us894_test20 void long log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_post us894_cacert_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null fclose outfil expect server respond 400 cu_assert 400 test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain valid http authent credenti also provid succeed static void us894_test21 void long log_func_nm sleep us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_explicit_cert us894_explicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain invalid http authent credenti also provid fail 401 respons static void us894_test22 void long log_func_nm sleep us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_explicit_cert us894_explicit_key us894_cacert null sinc pass invalid user password expect server respond 401 cu_assert 401 test attempt enrol without use certif ident client use good user pwd howev est server setup perform certif authent http auth disabl fail 401 respons static void us894_test23 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 401 cu_assert 401 st_proxy_http_dis printf could set http authent callback &#34;); return test paramet est_proxy_set_serv static void us894_test24 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est proxi mode est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null est_rv est_proxy_set_serv null 127 8080 cu_assert est_rv est_err_no_ctx est_rv est_proxy_set_serv ctx null 8080 cu_assert est_rv est_rv est_proxy_set_serv ctx 127 65536 cu_assert est_rv x509_free evp_pkey_fre priv_key test paramet static void us894_test25 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est proxi mode est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null est_rv ctx auth_non cu_assert est_rv est_err_bad_mod est_rv ctx auth_bas cu_assert est_rv est_err_non est_rv ctx auth_digest cu_assert est_rv est_err_non est_rv ctx 0xffffffff cu_assert est_rv est_err_bad_mod est_rv null auth_bas cu_assert est_rv est_err_no_ctx x509_free evp_pkey_fre priv_key test option set cert respons chain est_proxy_init test passthrough cach disabl mode cert respons chain static void us894_test26 void long char cmd 200 log_func_nm st_proxy_stop (); sleep restart proxi without pass cert respons chang paramet param st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm null us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep outfil fopen test26_outfil &#34;); curl_http_get us894_cacert_url us894_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test26_outfil system cmd cu_assert restart proxi includ cert respons chain st_proxy_stop (); sleep st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep test pass bad userid password valu est_proxy_init make sure error check static void us894_test27 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null userid est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem estrealm priv_key null estpwd &#34;); cu_assert ctx null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem estrealm priv_key estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key main function set run test return cue_success success run anoth cunit error code failur int us894_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us894_proxy_cacert us894_init_suit us894_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit http basic auth us894_test1 null cu_add_test suit http basic auth fail us894_test2 null cu_add_test suit http digest auth us894_test3 null cu_add_test suit http digest auth fail us894_test4 null cu_add_test suit get certif us894_test5 null cu_add_test suit ssl fail us894_test6 null cu_add_test suit tls fail us894_test7 null cu_add_test suit tls us894_test8 null cu_add_test suit tls us894_test9 null cu_add_test suit certif auth explicit cert chain us894_test10 null cu_add_test suit certif auth implicit cert chain us894_test11 null cu_add_test suit certif auth revok cert us894_test12 null cu_add_test suit certif auth self sign cert us894_test13 null cu_add_test suit anon cipher suit disabl us894_test14 null cu_add_test suit null realm us894_test15 null cu_add_test suit null server cert us894_test16 null cu_add_test suit null server key us894_test17 null cu_add_test suit null local chain us894_test18 null cu_add_test suit corrupt local chain us894_test19 null cu_add_test suit http post cacert us894_test20 null cu_add_test suit simpl enrol good http auth good cert us894_test21 null cu_add_test suit simpl enrol bad http auth good cert us894_test22 null cu_add_test suit simpl enrol http auth cert us894_test23 null cu_add_test suit set server invalid paramet us894_test24 null cu_add_test suit set auth mode invalid paramet us894_test25 null cu_add_test suit option chain respons us894_test26 null cu_add_test suit bad userid password proxi init us894_test27 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us1005.c&#39;,
  &#39;unit test user stori client easi provis novemb copyright cisco system inc right reserv includ stdio includ string ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif ifdef win static critic section logger critic section endif static unsign char cacert null static int cacert len defin server port defin us1005_server_ip 127 defin us1005_uid estus defin us1005_pwd estpwd ifndef win32 defin us1005_cacert est cacert crt defin us1005_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1005_client_key us1005 implicit key pem defin us1005_client_cert us1005 implicit cert pem els defin us1005_cacert est cacert crt defin us1005_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1005_client_key us1005 implicit key pem defin us1005_client_cert us1005 implicit cert pem endif defin us1005_csr_nopop mbqgbys gaqebarygcwcgsafl qcag ==\\ static char log_search_target null static int search_target_found simpl callback use overrid default log facil libest use look specif debug output static void us1005_logger_stderr char format va_list char t_log 1024 ifndef win32 flockfil stderr els enter critic section logger_critical_sect endif log_search_target vsnprintf t_log 1024 format strstr t_log log_search_target search_target_found fprintf stderr t_log els vfprintf stderr format fflush stderr ifndef win32 funlockfil stderr els leav critic section logger_critical_sect endif static void us1005_clean void static int us1005_start_serv int manual_enrol int nid int no_http_auth int enable_pop int st_start us1005_server_port us1005 test realm us1005_cacert us1005_trust_cert est exampl cnf manual_enrol enable_pop nid no_http_auth st_disable_http_auth (); return routin call cunit initi test suit use alloc data open resourc requir test case static int us1005_init_suit void int ifdef win32 initi critic section window initi critic section logger_critical_sect endif est_init_logg est_log_lvl_info us1005_logger_stderr read certif cacerts_len read_binary_fil us1005_cacert cacert cacerts_len return us1005_clean (); start instanc est server automat enrol enabl us1005_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1005_destroy_suit void st_stop (); free cacert return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function perform easi provis oper use uid pwd identifi client server use varieti test case modul static void us1005_easy_provis char char server int ba_hint int use_cert est_ctx ectx evp_pkey new_key int int pkcs7_len int ca_certs_len unsign char new_cert null evp_pkey key null unsign char key_raw int key_len unsign char cert_raw int cert_len x509 cert null bio creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null use_cert read privat key key_len read_binary_fil us1005_client_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us1005_client_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use user password est_client_set_auth ectx us1005_uid us1005_pwd cert key cu_assert est_err_non ba_hint ectx cu_assert est_err_non set est server address port est_client_set_serv ectx server us1005_server_port null generat new privat key new_key generate_private_key (); cu_assert new_key null attempt provis new cert ectx pkcs7_len ca_certs_len new_key cu_assert est_err_non evp_pkey_fre new_key retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non new_cert free new_cert els est_destroy ectx return retriev copi new cert est_err_non new_cert malloc ca_certs_len cu_assert new_cert null ectx new_cert cu_assert est_err_non new_cert free new_cert els est_destroy ectx return evp_pkey_fre key x509_free cert cleanup est_destroy ectx easi provis http basic auth client cert basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test1 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis http basic auth hint enabl client cert basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test2 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test3 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth hint enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test4 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip null pointer test static void us1005_test5 void int p7len int calen evp_pkey key int est_ctx ectx log_func_nm creat valid context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us1005_uid us1005_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us1005_server_ip us1005_server_port null creat valid key pair key generate_private_key (); cu_assert key null tri null context null test2 p7len calen key cu_assert est_err_no_ctx tri null length ectx test2 null calen key cu_assert tri null cacert length ectx test2 p7len null key cu_assert tri null key ectx test2 p7len calen null cu_assert est_err_no_key evp_pkey_fre key est_destroy ectx enabl pop server enabl csr attribut server challeng password oid static void us1005_test6 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut valu includ challeng password oid st_set_csrattr us1005_csr_nopop search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server enabl csr attribut server challeng password oid static void us1005_test7 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut valu includ challeng password oid st_set_csrattr us1005_csr_nopop search debug appropri output confirm behavior work desir log_search_target cert request contain search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null enabl pop server enabl csr attribut server challeng password oid static void us1005_test8 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server enabl csr attribut server challeng password oid static void us1005_test9 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null enabl pop server disabl csr attribut server static void us1005_test10 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null st_disable_csr_cb (); search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server disabl csr attribut server static void us1005_test11 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null st_disable_csr_cb (); search debug appropri output confirm behavior work desir log_search_target cert request contain search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null next two test cae repeat test http auth disabl server easi provis client cert http basic auth disabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test93 void log_func_nm restart server http auth disabl st_stop (); us1005_start_serv us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth hint enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test94 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip int us1005_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1005_init_suit us1005_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit easi provis cert us1005_test1 null cu_add_test suit easi provis cert http hint us1005_test2 null cu_add_test suit easi provis cert us1005_test3 null cu_add_test suit easi provis cert http hint us1005_test4 null cu_add_test suit null pointer us1005_test5 null cu_add_test suit enabl challeng password us1005_test6 null cu_add_test suit disabl challeng password us1005_test7 null cu_add_test suit enabl challeng password us1005_test8 null cu_add_test suit disabl challeng password us1005_test9 null cu_add_test suit enabl csr disabl us1005_test10 null cu_add_test suit disabl csr disabl us1005_test11 null cu_add_test suit easi provis cert server auth us1005_test93 null cu_add_test suit easi provis cert http hint server auth us1005_test94 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us898.c&#39;,
  &#39;unit test user stori client enrol octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ est ossl util includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin server defin us898_uid estus defin us898_pwd estpwd ifndef win32 defin us898_cacert est cacert crt defin us898_trust_cert trustedcert crt defin us898_server_certkey est privat estservercertandkey pem defin us898_tc2_cert_txt us898 tc2 new cert txt defin us898_tc2_cert_b64 us898 tc2 new cert pkcs7b64 defin us898_tc2_cert_pk7 us898 tc2 new cert pkcs7 defin us898_tc2_cert_pem us898 tc2 new cert pem defin us898_tc10_csr us898 tc10_csr pem defin us898_tc10_key us898 tc10_key pem defin us898_tc10_cert us898 tc10_cert pem defin us898_tc11_key us898 tc11_key pem defin us898_tc11_cert us898 tc11_cert pem els defin us898_cacert est cacert crt defin us898_trust_cert trustedcert crt defin us898_server_certkey est privat estservercertandkey pem defin us898_tc2_cert_txt us898 tc2 new cert txt defin us898_tc2_cert_b64 us898 tc2 new cert pkcs7b64 defin us898_tc2_cert_pk7 us898 tc2 new cert pkcs7 defin us898_tc2_cert_pem us898 tc2 new cert pem defin us898_tc10_csr us898 tc10_csr pem defin us898_tc10_key us898 tc10_key pem defin us898_tc10_cert us898 tc10_cert pem defin us898_tc11_key us898 tc11_key pem defin us898_tc11_cert us898 tc11_cert pem static critical_sect logger_critical_sect static void us898_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static void us898_clean void char cmd 200 temporari file creat various test case ifndef win32 sprintf cmd us898_tc2_cert_txt system cmd sprintf cmd us898_tc2_cert_b64 system cmd sprintf cmd us898_tc2_cert_pk7 system cmd sprintf cmd us898_tc2_cert_pem system cmd sprintf cmd us898_tc10_cert system cmd sprintf cmd us898_tc10_key system cmd sprintf cmd us898_tc10_csr system cmd els sprintf cmd del us898_tc2_cert_txt system cmd sprintf cmd del us898_tc2_cert_b64 system cmd sprintf cmd del us898_tc2_cert_pk7 system cmd sprintf cmd del us898_tc2_cert_pem system cmd sprintf cmd del us898_tc10_cert system cmd sprintf cmd del us898_tc10_key system cmd sprintf cmd del us898_tc10_csr system cmd endif start instanc est server run separ thread use test client side api modul static int us898_start_serv int manual_enrol int nid int st_start us898_server_port us898_server_certkey us898_server_certkey estrealm us898_cacert us898_trust_cert us898 est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us898_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us898_logger_stderr endif read certif cacerts_len read_binary_fil us898_cacert cacert cacerts_len return us898_clean (); start instanc est server automat enrol enabl us898_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us898_destroy_suit void st_stop (); free cacert return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv openssl_cert_error return print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur bio_fre bio_err return approv function perform basic simpl enrol use uid pwd identifi client server use variet test case modul static void us898_test1 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_non est_err_non return retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non convert cert x509 warn pure hackeri b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null wow lot work final x509 love open ssl !!!) x509 represent cert let tri enrol cert est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx test case use exist expir cert attempt enrol expir cert contain sever x509 extens verifi new issu cert preserv extens use grep note preserv extens requir open ssl enabl copy_extens knob open ssl config file test suit use uniqu copi est exampl cnf static void us898_test2 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len unsign char new_cert null x509 cert null bio char cmd 200 unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non save cert local file write_binary_fil us898_tc2_cert_b64 new_cert pkcs7_len cu_assert base decod cert respons sprintf cmd openssl base64 us898_tc2_cert_b64 us898_tc2_cert_pk7 system cmd cu_assert convert pkcs7 cert pem cert sprintf cmd openssl pkcs7 inform der print_cert us898_tc2_cert_pk7 us898_tc2_cert_pem system cmd cu_assert convert pem cert textual represent cert sprintf cmd openssl x509 text us898_tc2_cert_pem us898_tc2_cert_txt system cmd cu_assert verifi jimbob dns extens preserv grep us898_tc2_cert_txt jimbob &#34;); cu_assert verifi bobcat dns extens preserv grep us898_tc2_cert_txt bobcat &#34;); cu_assert verifi address extens preserv grep us898_tc2_cert_txt 172 &#34;); cu_assert verifi repudi key usag extens preserv grep us898_tc2_cert_txt repudi &#34;); cu_assert verifi public key preserv grep us898_tc2_cert_txt &#34;); cu_assert clean new_cert free new_cert est_destroy ectx test enrol api ensur grace handl null x509 cert pointer static void us898_test3 void est_ctx ectx evp_pkey key int pkcs7_len int unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol use null x509 pointer est_client_reenrol ectx null pkcs7_len key cu_assert est_err_no_cert clean evp_pkey_fre key est_destroy ectx test enrol api ensur grace handl null evp_pkey pointer static void us898_test4 void est_ctx ectx int pkcs7_len int x509 cert null unsign char cert_raw int cert_len bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read old cert use enrol cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol use null evp_key pointer est_client_reenrol ectx cert pkcs7_len null cu_assert est_err_no_key clean x509_free cert est_destroy ectx test attempt enrol corrupt cert public key cert corrupt static void us898_test5 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key corrupt pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert corrupt pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert clean est_destroy ectx test attempt enrol expir cert est server configur manual approv server send back retri respons static void us898_test6 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm stop server st_stop (); restart server manual approv enabl us898_start_serv cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert clean est_destroy ectx stop server st_stop (); restart server manual approv disabl us898_start_serv cu_assert verifi bogus user password fail use http basic auth static void us898_test7 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx hoagi chili null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_auth_fail est_destroy ectx verifi good user password pass use http digest auth static void us898_test8 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm enabl http digest authent (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx enabl http basic authent (); verifi bogus user password fail use http digest auth static void us898_test9 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len int http_status log_func_nm enabl http digest authent (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx jdoe panther null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_auth_fail check http status code reenrol oper http_status ectx cu_assert http_status 401 est_destroy ectx enabl http basic authent (); verifi server fail authent client send valid ident cert provid http auth credenti static void us898_test10 void char cmd 200 int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat csr sprintf cmd openssl req new node newkey rsa 2048 keyout subj 127 config est exampl cnf us898_tc10_csr us898_tc10_key system cmd cu_assert sign csr use local sprintf cmd openssl batch config est exampl cnf infil us898_tc10_cert us898_tc10_csr system cmd cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null read privat key key_len read_binary_fil us898_tc10_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898_tc10_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use certif http auth credenti provid est_client_set_auth ectx null null cert key cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol cert fail provid valid http auth credenti est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_auth_fail enrol cert work sinc provid valid cert identifi http auth requir enrol even server enabl http auth est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx verifi server fail authent client send expir identi cert use valid http auth credenti static void us898_test11 void int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null read privat key key_len read_binary_fil us898_tc11_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898_tc11_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use expir certif valid http auth credenti est_client_set_auth ectx us898_uid us898_pwd cert key cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null get latest csr attribut ectx attr_data attr_len cu_assert est_err_ssl_connect enrol cert est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_ssl_connect est_destroy ectx int us898_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us898_client_reenrol us898_init_suit us898_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit simpl enrol enrol us898_test1 null cu_add_test suit enrol expir cert extens us898_test2 null cu_add_test suit enrol use null cert us898_test3 null cu_add_test suit enrol use null key us898_test4 null cu_add_test suit enrol use corrupt x509 cert us898_test5 null cu_add_test suit enrol retri us898_test6 null cu_add_test suit enrol invalid uid pwd basic us898_test7 null cu_add_test suit enrol valid uid pwd digest us898_test8 null cu_add_test suit enrol invalid uid pwd digest us898_test9 null cu_add_test suit enrol valid certif http auth us898_test10 null cu_add_test suit enrol expir certif http auth us898_test11 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us3512.c&#39;,
  &#39;unit test uri path segment support server april copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server includ proxi includ src est est locl extern char tst srvr path seg enrol extern char tst srvr path seg cacert extern char tst srvr path seg csrattr extern char []; extern char []; static int path_segment_support max command line length generat system command defin est_ut_max_cmd_len 256 defin us3512_server_port 29496 defin us3512_server_ip 127 defin us3512_uidpwd_good estus estpwd defin us3512_uid estus defin us3512_pwd estpwd ifndef win32 defin us3512_cacert est cacert crt defin us3512_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3512_proxy_cert est privat estservercertandkey pem defin us3512_proxy_key est privat estservercertandkey pem defin us3512_cacert est cacert crt certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey &#34;./ els defin us3512_cacert est cacert crt defin us3512_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3512_proxy_cert est privat estservercertandkey pem defin us3512_proxy_key est privat estservercertandkey pem defin us3512_cacert est cacert crt certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey endif defin us3512_enroll_url_ba https :// 127 29496 well known est cacert somestr simpleenrol defin https :// 127 29496 well known est cacert -\\\\ somestr simpleenrol defin https :// 127 29496 well known est simpleenrol defin us3512_pkcs10_ct content type applic pkcs10 defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin 16894 defin path_seg_valid somestr defin somestring1 somestring2 defin path_seg_is_oper cacert defin cacertssomestr defin path_seg_max defin path_seg_too_long defin https :// 127 16894 well known est path_seg_valid simpleenrol defin https :// 127 16894 well known est path_seg_too_long simpleenrol defin https :// 127 16894 well known est path_seg_max simpleenrol defin https :// 127 16894 well known est simpleenrol defin https :// 127 16894 well known est path_seg_is_oper simpleenrol defin https :// 127 16894 well known est simpleenrol defin https :// 127 16894 well known est path_seg_valid cacert defin us3512_pkcs10_req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w static int x509 cur_cert int openssl_cert_error static void us3512_clean void static int us3512_start_serv int manual_enrol int nid int st_start_nocacert us3512_server_port us3512 test realm us3512_cacert us3512_trust_cert est exampl cnf manual_enrol nid sleep next start est proxi act us3512_proxy_cert us3512_proxy_key estrealm us3512_cacert us3512_trust_cert estus estpwd 127 us3512_server_port disabl ecdh nid info sleep return static int path_seg_support void est_ctx ectx unsign char cacert null int cacerts_len est_error est_err_non sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_serv ectx us3512_server_ip us3512_server_port test_seg &#34;); est_err_non return els return return routin call cunit initi test suit generat keypair use est client suit static int us3512_init_suit void int est_init_logg est_log_lvl_info null char cmd est_ut_max_cmd_len printf start est server path segment unit test &#34;); path_segment_support printf uri path segment support build est rebuild use uripars dir &#34;); return gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us3512_clean (); start instanc est server us3512_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3512_destroy_suit void st_stop (); st_proxy_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv saniti check server side path segment process simpl enrol direct server path segment outcom pass static void us3512_test1 void long log_func_nm curl_http_post us3512_pkcs10_ct us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function perform basic simpl enrol use uid pwd identifi client server use varieti test case modul static void us3512_simple_enrol char char server est_error expected_enroll_rv char path_seg est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len unsign char cacert null int cacerts_len read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx server us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert expected_enroll_rv use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx taken us899 test1 simpl enrol includ path segment uri path segment test verifi client includ configur path segment proper send verifi server correct pars valid path segment pass simpl enrol static void us3512_test2 void log_func_nm char path_seg path_seg memset memset us3512_simple_enrol tc3512 us3512_server_ip est_err_non path_seg cu_assert strcmp path_seg cu_assert strcmp path_seg taken us898 test1 simpl enrol includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass simpl enrol well auth callback static void us3512_test3 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int unsign char attr_data null int attr_len char path_seg unsign char cacert null int cacerts_len log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_non est_err_non return retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non convert cert x509 warn pure hackeri b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null wow lot work final x509 love open ssl !!!) x509 represent cert let tri enrol cert memset memset est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non cu_assert strcmp path_seg cu_assert strcmp path_seg cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx taken us897 test11 cacert server includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass cert callback static void us3512_test4 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key char path_seg sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg clear global prove path segment made applic layer cal back function memset issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert verifi path segment made way callback function applic layer cu_assert strcmp path_seg retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey taken us898 test1 csrattribut includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass csr attribut callback static void us3512_test5 void est_ctx ectx evp_pkey key int unsign char new_cert null x509 cert null unsign char attr_data null int attr_len char path_seg unsign char cacert null int cacerts_len log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null clear global prove path segment made applic layer cal back function memset issu get cert request ectx attr_data attr_len success obtain valid buffer contain cert cu_assert est_err_non verifi path segment made way callback function applic layer cu_assert strcmp path_seg cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx test flow path segment proxi mode valid path segment simpl enrol static void us3512_test6 void long log_func_nm sleep memset curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null cu_assert strcmp path_seg_valid sinc pass valid user password expect server respond 200 cu_assert 200 test flow path segment proxi mode path segment set maximum size static void us3512_test7 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment long get caught proxi 400 return cu_assert 200 test flow path segment proxi mode path segment larg static void us3512_test8 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment long get caught proxi 400 return cu_assert 400 test segment oper path static void us3512_test9 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment equal oper get 400 return cu_assert 400 test segment oper path static void us3512_test10 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment equal oper get 400 return cu_assert 400 test segment contain valid oper string within case front valid path segment test pass static void us3512_test11 void long log_func_nm sleep memset memset curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null cu_assert strcmp cu_assert strcmp sinc pass path segment equal oper get 400 return cu_assert 200 taken us897 test11 cacert server includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass cert callback static void us3512_test12 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key char path_seg sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3512_server_ip path_seg clear global prove path segment made applic layer cal back function memset issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert verifi path segment made way callback function applic layer cu_assert strcmp path_seg retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us3512_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3512_init_suit us3512_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); check see path segment support compil path_seg_support ()) printf uri path segment support build est rebuild use uripars dir &#34;); path_segment_support return path_segment_support path_segment_support add test suit note order import must test fread fprintf null cu_add_test suit est client simpl enrol path segment us3512_test1 null cu_add_test suit est server simpl enrol path segment us3512_test2 null cu_add_test suit est server simpl enrol path segment us3512_test3 null cu_add_test suit est server cacert path segment us3512_test4 null cu_add_test suit est server csrattr path segment us3512_test5 null cu_add_test suit est server est proxi path segment us3512_test6 null cu_add_test suit est server est proxi path segment max us3512_test7 null cu_add_test suit est server est proxi path segment long us3512_test8 null cu_add_test suit est server est proxi path segment oper us3512_test9 null cu_add_test suit est server est proxi path segment contain mani segment us3512_test10 null cu_add_test suit est server est proxi path segment contain oper us3512_test11 null cu_add_test suit est server est proxi path segment valid cacert us3512_test12 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us1883.c&#39;,
  &#39;unit test user stori enabl token auth mode est client march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno static unsign char cacert null static int cacert len defin server defin us1883_tcp_port 29001 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin miiezj ccak4caqaw itepma0ga1ueaww gskp uzxn0mq4w daydvqqfew mdaw mtcc dqyjko zihvc naqebbqadgg ipadccago cgg ibalf hxqz obi kwdf x8sa z4l3 n1jyr cp4xmi qit y2p iigl ht7t1wz0lo9uo0u b7b xki8fgq sm1j roe5lw dih tjd g4b705c6xm d3mh436de9d4gzpj a2qur si9 gvnvg u0zowjfu9g y3i ndfsj o9u0e2mf zwwr8m72g bqzvb ddpn4bdw la9tk q2rsxf3h2d7b n2dnsh nsyx ix89d9u c6feg hqx hinuod zze an3yu qmbu fwoh el9ub8qu9gub2mjur ynrqnii7 nduvq5 ujkhj nwz ih7labda ce0ju kbay uzzkrqo vk6b wzz fs4d ytn95 vvov95md5d1eok xw3iih7grjygt wn5e4 yo68lonbf7ue24vg eie f6j0b falxw n15s7p ialk gf7cubit rhb b3k udr8yp kdqx hnm wbxy7zvk4t8k7168c nwsol net tk4bto ujbn wp8uq38yoi6389u24gm jeet dy1mj8ha4pz ftm uwq etox2kub gwc9v wfi5bx e2vvet gnsy2eqezpvwsc cy0 o3fu06co etr7ekr ngap ddez vti p9npe5q18azu t9ngo ox3pqr cpg1bdn6z1ue2t sdd knfmnmwq yin zp9mxh tz8ra kvsclv9jag mbaagg adanbgkqhki g9w0baqufaaocag eajmw z4iub ush5w qbfs yt4sxt ztvun6qx0 nmtzz quoq o79kx dkpzs lnv hkm fqcx a7g ngb ap5 md92dghc xoq gkcl zdm gj2o req zwzv tdro4z p1yen5vg yz7sa nxze8w pg2whl qvk vcp hn3euif bgi2reo f7xq5cau4ut q1h4g hax67yww8 jmypi gga0ad0z8ruicl qtlu el1f nsr4zll opwn rdxvff xo7g xvir4ihvhnwj6km dzyk0ovat2ms5a guc mdn6jm8kib nbvh5fgk bvqopsngkwn eoj0rsa ksx t5efm oxm9p ae3r vog o4t8w z6dquqy budmg kig8o r5hawber8yw qdi bgg pkzdpm yi2tef zvp g7qlj nsj5twe rknggh ucu3u 1s0r gqg y1s9ggi dsif xj4nci rgq xpnrf syv3ki ixt ab6tjk ubt vfo2krfq nxu4lb es7w es7 zzpzn gsq whn efevi5c5wprnpv vn6r kh0f auk 9ek4knzwf yf8 xn5q otgd4o luusg fdjsq nh6a1mlmx6cn defin us1883_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us1883_pkcs10_ct content type applic pkcs10 defin us1883_uidpwd_good estus estpwd ifndef win32 defin us1883_cacert est cacert crt defin us1883_cacert est cacert crt defin us1883_server_cert est privat estservercertandkey pem defin us1883_server_key est privat estservercertandkey pem defin us1883_client_cert est privat estservercertandkey pem defin us1883_client_key est privat estservercertandkey pem els defin us1883_cacert est cacert crt defin us1883_cacert est cacert crt defin us1883_server_cert est privat estservercertandkey pem defin us1883_server_key est privat estservercertandkey pem defin us1883_client_cert est privat estservercertandkey pem defin us1883_client_key est privat estservercertandkey pem static critical_sect logger_critical_sect static void us1883_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static void us1883_clean void static int us1883_start_serv int manual_enrol int nid int st_start us1883_tcp_port est privat estservercertandkey pem est privat estservercertandkey pem estrealm est cacert crt trustedcert crt est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us1883_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us1883_logger_stderr endif read certif cacerts_len read_binary_fil us1883_cacert cacert cacerts_len return us1883_clean (); start instanc est server automat enrol enabl us1883_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1883_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey defin good_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u defin different_token v2vsb cwg ssd2zsbnb3qgd g8gcn ihrv igtl zxag jvb sboa wrpbic nck zcbjj20g ym91bm qgd g8ga2vlc cbvbi bya wrpbic nck zcbjj3zl igdvd cbvbm ugb w9i zsbza wx2zxig zg9sb gfi dqp xqg ssdt ig5vd cbnb25u ysbs zxqg j2vt ignhd gno ig1l lcbubw0ktm90igdvbm5h igxld zw0g y2f0y2ggd ghl ig1p zg5p z2h0ihjp zgvi defin null_token null defin long_token ssbj yw4nd cbh z3jl zsb0bi bka xnh z3jl zsanck z2h0a w5n igxpa2ug ssdt igzp z2h0a w5n igzvci bsa wzl ia0kvghl sdi zsbvbmx5ihdvcm igj1d cb0a gv5ign1d cbsa wtl igeg ymxh zgug dqp td2lu z2lu b3a wrl ihdpd ggg ywxs ig9m ig15ig1p z2h0ia0kdqp cb5zwfo lcbjigd1zxnz igl0j3mg ywxs ig9m ihro yxqg y29m lcb0a gf0j3mg z290ig15ig1pbm qga w4g ysb3a glyb canckknb sbzd glsb cbjd xnza w5n igfu zcbia xrja glu bhbm qgd ghlcm ywlu j3qgbm9ib2r5ighlcm dqo nck9o ihll ywgs ihlvd sbkb24nd cbo yxzl ihrv ighvb gxlci bjighl yxige w91ia0kssdt ihn0yw5ka w5n ihjp z2h0ighlcm vza wrl ihlvd sanck9o lca5osbza gfk zxmgb2yg y3jhenk ieknb sa5osbza gfk zxmgb2yg y3jhenkg dqp dcm f6e swg y3jhenk igni yxp5lcbjcm f6e sancg0kug91ci bhbm90a gvi igrya w5r lcbt ywtl igl0igeg zg91ymxl igzvci zsanck1h wjl iekg y2fu igrya w5r ihroa xmg yxdhe sanckl0j3mgbm v2zxig ihdo zw4gd ghle sbwd wxs ig91d cb0a gug z3vu ia0kqm vhd cb5b3ug ymxh y2sg yw5k igjsd wus igjv sancllvd sbnb3r0ysbw yxks ihlvd sbnb3r0ysbw yxkg dqo nck9o lcb3a gvi zsb0a guga gvsb cbhb sbjpi bjighvc gug yxqgb gvhc3qg ssbo ywqg ia0kssdt ihn0d w1ib glu b0a hjvd wdo ie5ldi bpcmxl yw5z ig9o lcb0bi b0a gugcmlza w5n ihn1bi ancg0kt2gg wvha cwge w91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3ug dqp jj20gc3rhbm rpbmcgcmlna hqga gvi zsbi zxnp zguge w91ia0kt2g idk5ihno ywrlci bjcm f6e swg ssdt idk5ihno ywrlci bjcm f6e sanck yxp5lcbjcm f6e swg y3jhenk igni yxp5ia0kdqp mb3jk ighhdm ugb wvi y3kgb24gb wug dqp ob3zlbn ig51zxzh ihrvbm9z igrl igxv y28g dqo nckkgbm zcbzb21l ihbl ywnl lcbqd xn0ihnvb wugcm vsa wvm ia0krn jvb sb0a glz ihzva wnl lcbra wxsa w5n ig1l ia0kww91ihn0yxjl igf0ig1l lcbhbm qge w91igd yxjl igf0ig1l ia0kqwx ihroa xmgc gfpbi bpd cdz igfsb cb0a gugc2ft zswga xqnci bhb gwga w5z yw5l ia0kkhlvd sbz zwup ia0kdqp jci b0a glz ihjl ywxse sbo yxbw zw5pbmcgb3ig zglk iekgb wfr zsbpd cbhb gwgd ia0kssdt igjvd w5k igzvci bda gf0d gfob29ja gvl ig9u igegd hvybmlw ihryd wnr ia0kdqp cb5zwfo lcb5b3ug zg9u j3qga gf2zsb0bi bob2x zxig ssbo zwfi ihlvd sanckknb sbzd gfu zglu bya wdod cbo zxjl igjlc2lk zsb5b3ug dqp cwg otkgc2hh zgvz ig9m igni yxp5lcbjj20g otkgc2hh zgvz ig9m igni yxp5ia0kq3jhenk igni yxp5lcbjcm f6e swg y3jhenkg dqo nck ihlvd sdi zsbjcm f6e sb5b3uncm y3jhenkg dqp ib2xk ig15igzl zxqs igzl zxqgd g8gd ghl igzpcm dqp zb3uga g9s zcbte sbm zwv0ihrv ihro zsbma xjl ia0kssbu zxzlci ywlk iekgd2fz igrvd24gd2l0a cb5b3u char test_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u =&#34;; int int applic layer callback function return token base authent credenti call regist est client use (). test function requir set global valu order make callback oper way test case want tell function forc respons code error test_token pointer hard code string token string return callback must provid token credenti heap base buffer ownership buffer implicit transfer client librari upon return est_http_auth_hdr auth_credenti char token_ptr null int token_len cu_assert auth_credenti mode auth_token report callback call see test request forc error respons code callback return auth_credenti mode auth_token test_token set anyth need alloc space heap copi valu test_token null token_len strlen test_token use strlen string larg need test est client token_len printf (&#34;\\ error determin length token string use credenti &#34;); return token_ptr malloc token_len token_ptr null printf (&#34;\\ error alloc token string use credenti &#34;); return strncpi token_ptr test_token strlen test_token )); token_ptr token_len made far token_ptr point string contain token return assign return success auth_credenti auth_token token_ptr return return token base one instead return basic credenti userid password est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_bas report callback call see test request forc error respons code callback return auth_credenti mode auth_bas auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return basic base one instead verfi auth_mod pass digest est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_digest report callback call see test request forc error respons code callback return auth_credenti mode auth_digest auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return test api exercis paramet static void us1883_test1 void est_error e_rc est_ctx ectx null log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null forgot specifi paramet context get caught e_rc null null cu_assert e_rc est_err_no_ctx valid call e_rc ectx cu_assert e_rc est_err_non attempt reset callback function e_rc ectx null cu_assert e_rc est_err_non est_destroy ectx us1883_simple_enrol use test case perform simpl enrol static void us1883_simple_enrol char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx perform simpl enrol first order get valid cert perform reenrol simpl enrol need success current done use basic mode est server yet token base support pdb note server side token support implement function option updat token mode first enrol absolut necessari sinc purpos test reenrol initi enrol need get cert static void char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null make sure server current basic auth mode (); e_rc ectx cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non est_destroy ectx ectx null creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null cert switch server token mode (); e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null attempt reenrol token mode convert cert x509 warn pure hackeri pdb convers code come test case b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null pdb note moment expect fail sinc server yet understand request token authent 1884 complet assert begin fail need chang pass respons est_client_reenrol ectx cert pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx test2 applic layer regist callback caus http aithent header empti token credenti test applic layer regist callback est client get challeng find callback regist goe credenti store context noth note way preload credenti flow alway work enrol sent token credenti server fail give certif static void us1883_test2 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token set est client perform simpl enrol pass callback function catch handl request token auth enrol better fail due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail null callback never regist invok cu_assert test3 applic layer regist callback set credenti invok result previous test test applic layer regist callback est client get challeng call callback get back empti credenti structur end send http auth header credenti note way preload credenti flow alway work enrol sent token credenti server fail give certif static void us1883_test3 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token test_token null_token set est client perform simpl enrol regist token base callback set pass back token enrol better fail due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test4 good token sent server accept cert generat return test applic layer regist callback respond valid token enrol sent token credenti server set match token send back cert static void us1883_test4 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token test_token good_token set est client perform simpl enrol enrol succeed us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test est client receiv token auth challeng test applic layer regist callback respond fail return code static void us1883_test5 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); forc callback give fail return code test_token good_token set est client perform simpl enrol enrol better fail due credenti suppli applic layer eventu failur server due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test6 saniti test basic auth mode test server basic mode client applic regist basic base callback client send estus estpwd credenti get cert static void us1883_test6 void log_func_nm switch server basic mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); set est client perform simpl enrol pass callback function catch handl request token auth enrol pass basic mode fulli work make sure callback call ensur credenti came callback us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test7 make sure enrol work credenti callback flow obtain credenti test server token mode client applic regist token base callback client send valid token credenti get cert static void us1883_test7 void log_func_nm test_token good_token (); tell server token check st_set_token good_token set est client perform simpl enrol enrol succeed tc1883 us1883_server_ip est_err_non callback call cu_assert test7 token credenti long test server token mode told match good token client applic regist token base callback told give back token long client send corrupt token match good token static void us1883_test8 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token forc callback give fail return code test_token long_token set est client perform simpl enrol pass callback function catch handl request token auth us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test7 test digest mode demand credenti flow test server digest mode note mean server expect estus &#34;/&#34; estpwd estrealm valu hardcod data st_server st_server must start estrealm return realm client client return request client applic regist digest base callback client send valid digest get cert static void us1883_test9 void log_func_nm switch server digest mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); set est client perform simpl enrol pass callback function catch handl request token auth enrol pass digest mode fulli work make sure callback call ensur credenti came callback us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test4 valid token provid appliact callback wrong token test applic layer regist callback respond valid token server set token mode differ token enrol sent token credenti server set match token send back cert static void us1883_test10 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token different_token test_token good_token set est client perform simpl enrol enrol fail token match us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert main function set run test return cue_success success run anoth cunit error code failur int us1883_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1883_tok_auth_cli us1883_init_suit us1883_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit pars respons us1883_test1 null cu_add_test suit simpl enrol us1883_test2 null cu_add_test suit simpl enrol reg token us1883_test3 null cu_add_test suit simpl enrol reg good token us1883_test4 null cu_add_test suit simpl enrol reg bad us1883_test5 null cu_add_test suit simpl enrol reg basic mode us1883_test6 null cu_add_test suit simpl enrol reg good token us1883_test7 null cu_add_test suit simpl enrol reg token long us1883_test8 null cu_add_test suit simpl enrol reg digest mode us1883_test9 null cu_add_test suit simpl enrol reg mismatch valid token us1883_test10 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us748.c&#39;,
  &#39;unit test user stori proxi simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin retri interv defin tcp port defin 15748 defin us748_tcp_proxy_port 16748 ifndef win32 static char test5_outfil filename_max us748 test5 hdr defin us748_server_cert est privat estservercertandkey pem defin us748_server_key est privat estservercertandkey pem defin us748_proxy_cert est privat estservercertandkey pem defin us748_proxy_key est privat estservercertandkey pem defin us748_proxy_cert us748 cert pem defin us748_proxy_key us748 key pem defin us748_cacert est cacert crt defin us748_trusted_cert trustedcert crt els static char test5_outfil filename_max us748 test5 hdr defin us748_server_cert est privat estservercertandkey pem defin us748_server_key est privat estservercertandkey pem defin us748_proxy_cert est privat estservercertandkey pem defin us748_proxy_key est privat estservercertandkey pem defin us748_proxy_cert us748 cert pem defin us748_proxy_key us748 key pem defin us748_cacert est cacert crt defin us748_trusted_cert trustedcert crt endif follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us748_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin us748_pkcs10_dsa1024 miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin us748_pkcs10_corrupt miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us748_enroll_url_ba https :// 127 15748 well known est simpleenrol defin us748_pkcs10_ct content type applic pkcs10 defin us748_uidpwd_good estus estpwd defin us748_cacert est cacert crt defin us748_explicit_cert us748 cert pem defin us748_explicit_key us748 key pem static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written static void us748_clean void static int us748_start_serv int manual_enrol int nid int first start est server act st_start us748_server_cert us748_server_key estrealm us748_cacert us748_trusted_cert us748 est exampl cnf manual_enrol manual enrol disabl nid ecdh nid info sleep est_err_non return next start est proxi act st_proxy_start us748_tcp_proxy_port us748_proxy_cert us748_proxy_key estrealm us748_cacert us748_trusted_cert estus estpwd 127 disabl nid ecdh nid info sleep return void us748_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit initi test suit use alloc data open resourc requir test case static int us748_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us748_cacert cacert cacerts_len return us748_clean (); start instanc est server automat enrol enabl us748_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us748_destroy_suit void us748_stop_serv (); free cacert return simpl enrol rsa 2048 test case use libcurl test simpl enrol 2048 bit rsa csr http basic authent use static void us748_test1 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol prime 256 test case use libcurl test simpl enrol 256 bit csr http basic authent use static void us748_test2 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol dsa prime 1024 test case use libcurl test simpl enrol 1024 bit dsa csr http basic authent use static void us748_test3 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_dsa1024 us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol corrupt pkcs10 test case use libcurl test simpl enrol usinga corrupt csr http basic authent use static void us748_test4 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_corrupt us748_uidpwd_good us748_cacert curlauth_bas null null null sinc csr valid server respond 400 cu_assert 400 simpl enrol manual enrol test case verifi server send appropri retri respons static void us748_test5 void long log_func_nm stop est server us748_stop_serv (); restart server manual enrol enabl us748_start_serv outfil fopen test5_outfil &#34;); curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null write_func fclose outfil sinc server seen csr past respond retri 202 respons cu_assert 202 verifi retri valu sprintf cmd grep retri grep test5_outfil us748_retry_interv system cmd grep test5_outfil retri 3600 &#34;); cu_assert avoid wait full retri period sinc simul manual enrol wait second tri enrol cert sleep curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null enrol request succeed time simul manual enrol automat enrol second attempt cu_assert 200 stop est server us748_stop_serv (); restart server manual enrol disabl us748_start_serv simpl enrol check fail curl test case verifi server verifi client csr sinc curl set est enrol fail static void us748_test6 void long log_func_nm st_enable_pop (); send valid enrol request use curl curl includ curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null server respond failur code cu_assert 400 st_disable_pop (); simpl enrol check succeed estclient test case verifi proxi verifi client csr use estclient sinc support static void us748_test7 void long est_ctx c_ctx evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm test case requir enabl st_enable_pop (); creat client context c_ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert c_ctx null c_ctx return specifi user password sinc server run basic authent mode est_client_set_auth c_ctx estus estpwd null null cu_assert est_err_non est_client_set_serv c_ctx 127 us748_tcp_proxy_port null get keypair use enrol new_pkey generate_private_key (); c_ctx attr_data attr_len cu_assert est_err_non attempt enrol csr est_client_enrol c_ctx us748 test7 pkcs7_len new_pkey cu_assert est_err_non client librari obtain new client certif retriev librari pkcs7 malloc pkcs7_len pkcs7 return c_ctx pkcs7 cu_assert est_err_non clean est_destroy c_ctx evp_pkey_fre new_pkey free pkcs7 disabl futur test case st_disable_pop (); simpl enrol disabl csr contain valid test case ensur server handl scenario csr includ valid even server request use cisco est client generat csr contain valid way includ valid use curl sinc tls channel bind inform known advanc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us748_test9 void est_ctx ctx int unsign char cacert int caclen evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm make sure est server disabl st_disable_pop (); read cert caclen read_binary_fil us748_cacert cacert cu_assert cacerts_len init client context ctx est_client_init cacert caclen est_cert_format_pem use simpl http auth identifi est_client_set_auth ctx estus estpwd null null cu_assert est_err_non est_client_set_serv ctx 127 us748_tcp_proxy_port null creat space hold cert generat privat key new_pkey generate_private_key (); ctx attr_data attr_len cu_assert est_err_non attempt enrol ctx csr_pop_requir hack test attempt need forc challeng password csr est_client_enrol ctx test case9 pkcs7_len new_pkey cu_assert est_err_non pkcs7 malloc pkcs7_len ctx pkcs7 free pkcs7 est_destroy ctx simpl enrol disabl csr contain invalid test case ensur server handl scenario csr includ invalid even server request static void us748_test10 void long log_func_nm make sure est server disabl st_disable_pop (); curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_uidpwd_good us748_cacert curlauth_bas null null null enrol request fail sinc invalid expect 400 respons cu_assert 400 main function set run test return cue_success success run anoth cunit error code failur int us748_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us748_srv_simpenrol us748_init_suit us748_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us748_test1 null cu_add_test suit enrol ecdsa cert us748_test2 null cu_add_test suit enrol dsa cert us748_test3 null cu_add_test suit enrol corrupt ecdsa cert us748_test4 null cu_add_test suit enrol retri manual approv us748_test5 null cu_add_test suit enrol fail curl us748_test6 null cu_add_test suit enrol succeed estclient us748_test7 null cu_add_test suit enrol disabl csr includ valid us748_test9 null cu_add_test suit enrol disabl csr includ invalid us748_test10 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us3612.c&#39;,
  &#39;unit test user stori encrypt privat key support juli copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static char key password null static int cacert len defin server port defin server defin us3612_uid estus defin us3612_pwd estpwd defin us3612_good_pwd us3612 defin us3612_bad_pwd thiscantpossiblywork defin rsa_keys 4096 key wrap algorithm option use protect privat key defin est_private_key_enc evp_aes_128_cbc follow cert use fqdn test ifndef win32 defin us3612_cacert est cacert crt defin us3612_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3612 us3612_key pem els defin us3612_cacert est cacert crt defin us3612_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3612 us3612_key pem static critical_sect logger_critical_sect static void us3612_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif unsign char bio_copy_data bio int data_lenp unsign char data tdata int data_len data_len bio_get_mem_data tdata data malloc data_len data memcpi data tdata data_len data data_len ]=\&#39;\\ make sure termin case use string data_lenp data_lenp data_len els printf malloc fail &#34;); return data char int key_siz pem_password_cb char key_data null rsa rsa rsa_new (); rsa return null bignum bn_new (); rsa_fre rsa return null bn_set_word 0x10001 rsa_generate_key_ex rsa key_siz null bio bio_new bio_s_mem ()); break key rsa est_private_key_enc null null null key_data char bio_copy_data null bio_fre key_data key_data happen passphras enter via stdin verifi less charact free key_data key_data null key_data rsa_fre rsa bn_free return key_data char int curve_nid pem_password_cb ec_key eckey ec_group group null char key_data null int asn1_flag form generat key eckey ec_key_new (); eckey return null group curve_nid group asn1_flag group form ec_key_set_group eckey group ec_key_generate_key eckey return null bio bio_new bio_s_mem ()); break group pem_write_bio_ecpriv key eckey est_private_key_enc null null null key_data char bio_copy_data null bio_fre key_data strstr key_data &#34;----- begin privat key -----&#34;)) happen passphras enter via stdin verifi less charact free key_data key_data null key_data ec_key_fre eckey return key_data static int string_password_cb char buf int size int wflag void data hard code password suit strncpi buf key_password size return strnlen buf size )); static void us3612_clean void static int us3612_start_serv int manual_enrol int nid int st_start us3612_server_port us3612 test realm us3612_cacert us3612_trust_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us3612_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us3612_logger_stderr endif read certif cacerts_len read_binary_fil us3612_cacert cacert cacerts_len return us3612_clean (); start instanc est server automat enrol enabl us3612_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3612_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv simpl enrol client load password prortect privat key correct passphras attempt enrol certif static void us3612_test1 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_good_pwd key string_password_cb cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tcus3612 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr load password protect privat key incorrect password attempt enrol certif fail static void us3612_test2 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_bad_pwd key string_password_cb cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tc3612 pkcs7_len key cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr chang password use callback read protect privat key file static void us3612_test3 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_good_pwd key string_password_cb cu_assert key null chang password evp_pkey remain unaffect key_password us3612_bad_pwd get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tcus3612 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx test key generat util function associ password callback static void us3612_test4 void char new_pkey null generat rsa key without password new_pkey rsa_keys null cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat rsa key password key_password us3612_good_pwd new_pkey rsa_keys string_password_cb cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat key without password new_pkey obj_sn2nid char prime256v1 &#34;), null cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat key password new_pkey obj_sn2nid char prime256v1 &#34;), string_password_cb cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null int us3612_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3612_init_suit us3612_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit client simpl enrol correct pwd us3612_test1 null cu_add_test suit client simpl enrol incorrect pwd us3612_test2 null cu_add_test suit client simpl enrol incorrect pwd us3612_test3 null cu_add_test suit keygen test us3612_test4 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us901.c&#39;,
  &#39;unit test user stori server cacert june copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif defin pkcs req miichj ccaw caqaw qtel mcmga ueax mccm igj ignsa wvud cbpbi ihn zxag eymbyga uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki baqef aaocaq amiibcg kcaqea juwp xxdw ckv wpdwo andqz fmxro leih nwf rsg ngc efc hzom memgp npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w defin us901_enroll_url https :// 127 29901 well known est simpleenrol defin us901_cacert_url https :// 127 29901 well known est cacert defin us901_pkcs10_ct content type applic pkcs10 defin us901_uidpwd_good estus estpwd defin us901_uidpwd_bad estus bogus defin us901_server_port 29901 ifndef win32 defin us901_cacert est cacert crt defin us901_explicit_cert us901 explicit cert pem defin us901_explicit_key us901 explicit key pem defin us901_implicit_cert us901 implicit cert pem defin us901_implicit_key us901 implicit key pem defin us901_revoked_cert us901 revok cert pem defin us901_revoked_key us901 revok key pem defin us901_selfsign_cert us901 selfsign cert pem defin us901_selfsign_key us901 selfsign key pem defin us901_cacert est cacert crt defin us901_extcert ext cacert crt defin us901_server_cert est privat estservercertandkey pem defin us901_server_key est privat estservercertandkey pem defin us901_server_certkey est privat estservercertandkey pem static char test5_outfil filename_max us901 test5 crt els defin us901_cacert est cacert crt defin us901_explicit_cert us901 explicit cert pem defin us901_explicit_key us901 explicit key pem defin us901_implicit_cert us901 implicit cert pem defin us901_implicit_key us901 implicit key pem defin us901_revoked_cert us901 revok cert pem defin us901_revoked_key us901 revok key pem defin us901_selfsign_cert us901 selfsign cert pem defin us901_selfsign_key us901 selfsign key pem defin us901_cacert est cacert crt defin us901_extcert ext cacert crt defin us901_server_cert est privat estservercertandkey pem defin us901_server_key est privat estservercertandkey pem defin us901_server_certkey est privat estservercertandkey pem static char test5_outfil filename_max us901 test5 crt endif static void us901_clean void char cmd 200 sprintf cmd test5_outfil system cmd routin call cunit initi test suit use alloc data open resourc requir test case static int us901_init_suit void us901_clean (); est_init_logg est_log_lvl_info null return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us901_destory_suit void return start appropri flavor st_server base charact specifi basic auth digest auth crl check auth static int us901_start_serv char server_typ int switch server_typ case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf (); break case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf (); break case system openssl config est exampl cnf gencrl est crl pem &#34;); sleep system cat trustedcert crt est crl pem us901 trustedcertsandcrl crt &#34;); sleep st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt us901 trustedcertsandcrl crt est exampl cnf st_enable_crl (); st_disable_http_auth (); break case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf st_disable_http_auth (); break default break return http basic auth test case use libcurl test http basic authent work est server must use simpleenrol messag sinc cacert messag requir client authent est server run list port 8088 prior test run static void us901_test1 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep http basic auth failur test case use libcurl test http basic authent work est server use bogus password must use simpleenrol messag sinc cacert messag requir client authent est server run prior test run static void us901_test2 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_stop (); sleep http digest auth test case use libcurl test http digest authent work est server must use simpleenrol messag sinc cacert messag requir client authent est server run listen port 8087 prior test run static void us901_test3 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_digest null null null sinc pass valid user password expect server respond success cu_assert 200 st_stop (); sleep http digest auth fail test case use libcurl test http digest authent work est server negat test case digest auth must use simpleenrol messag sinc cacert messag requir client authent est server run listen port 8087 prior test run static void us901_test4 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_cacert curlauth_digest null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_stop (); sleep static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written test case simpl cacert request look http 200 respons code static void us901_test5 void long char cmd 200 int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_get us901_cacert_url us901_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test5_outfil system cmd cu_assert st_stop (); sleep static void us901_test_sslvers const ssl_method int expect_fail bio conn ssl ssl ssl_ctx ssl_ctx null int int st_rv st_rv us901_start_serv st_rv return log_func_nm ssl_ctx ssl_ctx_new cu_assert ssl_ctx null ssl context readi open socket server bind socket context conn open_tcp_socket_ipv4 127 29901 &#34;); cu_assert conn null creaea ssl session context ssl ssl_new ssl_ctx ssl_set_bio ssl conn conn everyth readi let initi tls handshak ssl_connect ssl expect_fail cu_assert els cu_assert cleanup data ssl_shutdown ssl ssl_free ssl ssl_ctx_free ssl_ctx st_stop (); sleep test attempt creat ssl connect est server fail tls allow static void us901_test6 void log_func_nm us901_test_sslvers sslv3_client_method (), test attempt creat tls connect est server fail tls allow static void us901_test7 void log_func_nm us901_test_sslvers tlsv1_client_method (), test attempt creat tls connect est server succeed static void us901_test8 void log_func_nm us901_test_sslvers (), test attempt creat tls connect est server succeed static void us901_test9 void log_func_nm us901_test_sslvers (), test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain succeed static void us901_test10 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_explicit_cert us901_explicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign implicit cert chain succeed static void us901_test11 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_implicit_cert us901_implicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use revok client certif verifi crl check work tls layer fail static void us901_test12 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_revoked_cert us901_revoked_key us901_cacert null sinc client cert revok tls handshak fail est server return 401 respons cu_assert st_stop (); test attempt use self sign client certif verifi cert chain reject cert sign valid fail static void us901_test13 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_selfsign_cert us901_selfsign_key us901_cacert null sinc client cert sign either local extern tls handshak fail receiv http status messag server cu_assert st_stop (); tls anonym cipher suit disabl test case use libcurl test est server accept anonym cipher suit client test singl cipher suit attempt simpl enrol server static void us901_test14 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas adh aes128 sha256 null null tls handshak fail curl return cu_assert st_stop (); sleep null http realm initi server static void us901_test15 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null realm est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem null priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key null server certif initi server static void us901_test16 void unsign char cacert null int cacerts_len bio keyin evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null server key est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null priv_key cu_assert ctx null evp_pkey_fre priv_key null server certif privat key initi server static void us901_test17 void unsign char cacert null int cacerts_len bio certin x509 int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin attempt init est server use null privat key est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null cu_assert ctx null x509_free null trust chain initi server static void us901_test18 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null local chain est_init_logg est_log_lvl_info null ctx est_server_init null null est_cert_format_pem testrealm priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key corrupt chain initi server static void us901_test19 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server corrupt chain est_init_logg est_log_lvl_info null ctx est_server_init unsign char bogus chain unsign char bogus chain est_cert_format_pem testrealm priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key test case attempt simpl cacert request use post instead get fail static void us901_test20 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_post us901_cacert_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null fclose outfil expect server respond 400 cu_assert 400 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain valid http authent credenti also provid succeed static void us901_test21 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_explicit_cert us901_explicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain invalid http authent credenti also provid fail 401 respons static void us901_test22 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_explicit_cert us901_explicit_key us901_cacert null sinc pass invalid user password expect server respond 401 cu_assert 401 st_stop (); sleep test attempt enrol without use certif ident client use good user pwd howev est server setup perform certif authent http auth disabl fail 401 respons static void us901_test23 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 401 cu_assert 401 st_stop (); sleep main function set run test return cue_success success run anoth cunit error code failur int us901_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us901_srv_cacert us901_init_suit us901_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit http basic auth us901_test1 null cu_add_test suit http basic auth fail us901_test2 null cu_add_test suit http digest auth us901_test3 null cu_add_test suit http digest auth fail us901_test4 null cu_add_test suit get certif us901_test5 null cu_add_test suit ssl fail us901_test6 null cu_add_test suit tls fail us901_test7 null cu_add_test suit tls us901_test8 null cu_add_test suit tls us901_test9 null cu_add_test suit certif auth explicit cert chain us901_test10 null cu_add_test suit certif auth implicit cert chain us901_test11 null cu_add_test suit certif auth revok cert us901_test12 null cu_add_test suit certif auth self sign cert us901_test13 null cu_add_test suit anon cipher suit disabl us901_test14 null cu_add_test suit null realm us901_test15 null cu_add_test suit null server cert us901_test16 null cu_add_test suit null server key us901_test17 null cu_add_test suit null local chain us901_test18 null cu_add_test suit corrupt local chain us901_test19 null cu_add_test suit http post cacert us901_test20 null cu_add_test suit simpl enrol good http auth good cert us901_test21 null cu_add_test suit simpl enrol bad http auth good cert us901_test22 null cu_add_test suit simpl enrol http auth cert us901_test23 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us1864.c&#39;,
  &#39;unit test user stori enabl token auth mode server march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno static unsign char cacert null static int cacert len defin tcp port follow csr generat use follow openssl command theng use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin miiezj ccak4caqaw itepma0ga1ueaww gskp uzxn0mq4w daydvqqfew mdaw mtcc dqyjko zihvc naqebbqadgg ipadccago cgg ibalf hxqz obi kwdf x8sa z4l3 n1jyr cp4xmi qit y2p iigl ht7t1wz0lo9uo0u b7b xki8fgq sm1j roe5lw dih tjd g4b705c6xm d3mh436de9d4gzpj a2qur si9 gvnvg u0zowjfu9g y3i ndfsj o9u0e2mf zwwr8m72g bqzvb ddpn4bdw la9tk q2rsxf3h2d7b n2dnsh nsyx ix89d9u c6feg hqx hinuod zze an3yu qmbu fwoh el9ub8qu9gub2mjur ynrqnii7 nduvq5 ujkhj nwz ih7labda ce0ju kbay uzzkrqo vk6b wzz fs4d ytn95 vvov95md5d1eok xw3iih7grjygt wn5e4 yo68lonbf7ue24vg eie f6j0b falxw n15s7p ialk gf7cubit rhb b3k udr8yp kdqx hnm wbxy7zvk4t8k7168c nwsol net tk4bto ujbn wp8uq38yoi6389u24gm jeet dy1mj8ha4pz ftm uwq etox2kub gwc9v wfi5bx e2vvet gnsy2eqezpvwsc cy0 o3fu06co etr7ekr ngap ddez vti p9npe5q18azu t9ngo ox3pqr cpg1bdn6z1ue2t sdd knfmnmwq yin zp9mxh tz8ra kvsclv9jag mbaagg adanbgkqhki g9w0baqufaaocag eajmw z4iub ush5w qbfs yt4sxt ztvun6qx0 nmtzz quoq o79kx dkpzs lnv hkm fqcx a7g ngb ap5 md92dghc xoq gkcl zdm gj2o req zwzv tdro4z p1yen5vg yz7sa nxze8w pg2whl qvk vcp hn3euif bgi2reo f7xq5cau4ut q1h4g hax67yww8 jmypi gga0ad0z8ruicl qtlu el1f nsr4zll opwn rdxvff xo7g xvir4ihvhnwj6km dzyk0ovat2ms5a guc mdn6jm8kib nbvh5fgk bvqopsngkwn eoj0rsa ksx t5efm oxm9p ae3r vog o4t8w z6dquqy budmg kig8o r5hawber8yw qdi bgg pkzdpm yi2tef zvp g7qlj nsj5twe rknggh ucu3u 1s0r gqg y1s9ggi dsif xj4nci rgq xpnrf syv3ki ixt ab6tjk ubt vfo2krfq nxu4lb es7w es7 zzpzn gsq whn efevi5c5wprnpv vn6r kh0f auk 9ek4knzwf yf8 xn5q otgd4o luusg fdjsq nh6a1mlmx6cn defin us1864_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us1864_pkcs10_ct content type applic pkcs10 defin us1864_uidpwd_good estus estpwd ifndef win32 defin us1864_cacert est cacert crt defin us1864_cacert est cacert crt defin us1864_trusted_cert trustedcert crt defin us1864_server_cert est privat estservercertandkey pem defin us1864_server_key est privat estservercertandkey pem defin us1864_client_cert est privat estservercertandkey pem defin us1864_client_key est privat estservercertandkey pem els defin us1864_cacert est cacert crt defin us1864_cacert est cacert crt defin us1864_trusted_cert trustedcert crt defin us1864_server_cert est privat estservercertandkey pem defin us1864_server_key est privat estservercertandkey pem defin us1864_client_cert est privat estservercertandkey pem defin us1864_client_key est privat estservercertandkey pem endif curl_data_cb pass curl call curl whenev data receiv function specifi retriev http header test use retriev http header look bearer token author challeng static int bearer_found static size_t curl_data_cb void ptr size_t size size_t nmemb void userdata void bearer_found warn strstr danger assum null termin string case http header came est server know null termin strstr ptr www authent bearer &#34;); bearer_found return size nmemb static void us1864_clean void static int us1864_start_serv int manual_enrol int nid int st_start us1864_tcp_port us1864_server_cert us1864_server_key us1864 test realm us1864_cacert us1864_trusted_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us1864_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us1864_cacert cacert cacerts_len return us1864_clean (); start instanc est server automat enrol enabl us1864_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1864_destroy_suit void st_stop (); free cacert return unit test first test paramet static void us1864_test1 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us1864_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us1864_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us1864_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est server mode est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key cu_assert ctx null est_rv ctx auth_non cu_assert est_rv est_err_bad_mod est_rv ctx auth_bas cu_assert est_rv est_err_non est_rv ctx auth_digest cu_assert est_rv est_err_non est_rv ctx auth_token cu_assert est_rv est_err_non est_rv ctx 0xffffffff cu_assert est_rv est_err_bad_mod make sure allow digest mode fip mode fips_mode_set est_rv ctx auth_digest cu_assert est_rv est_err_bad_mod fips_mode_set x509_free evp_pkey_fre priv_key est_destroy ctx simpl enrol token auth mode goal test verifi est server respond correct auth challeng configur token auth mode first perform saniti check perform http basic request server still default mode http basic auth test configur server token auth mode issu request contain auth header forc server respond token auth challeng header static void us1864_test2 void long log_func_nm curl_http_post us1864_enroll_url_ba us1864_pkcs10_ct us1864_uidpwd_good us1864_cacert curlauth_bas null null null sinc specifi basic server still basic expect server respond 200 cu_assert 200 switch server token mode note see done numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); bearer_found us1864_enroll_url_ba us1864_pkcs10_ct us1864_client_cert us1864_client_key us1864_cacert curl_data_cb curl_data_cb sinc chang auth mode server expect fail captur actual auth challeng expect server respond 200 cu_assert 401 cu_assert bearer_found main function set run test return cue_success success run anoth cunit error code failur int us1864_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1864_cfg_tok_auth us1864_init_suit us1864_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit check parm us1864_test1 null cu_add_test suit attempt enrol basic pass us1864_test2 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us1159.c&#39;,
  &#39;unit test user stori csr attribut enforc octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ openssl ssl includ openssl includ server ifdef cunit includ cunit basic includ cunit autom endif ifndef win defin cacert est cacert crt defin cacert est cacert crt defin server cert est privat estservercertandkey pem defin us1159_server_key est privat estservercertandkey pem els defin us1159_cacert est cacert crt defin us1159_cacert est cacert crt defin us1159_server_cert est privat estservercertandkey pem defin us1159_server_key est privat estservercertandkey pem endif defin us1159_uid estus defin us1159_pwd estpwd defin us1159_server_port 15897 defin us1159_server_ip 127 defin us1159_attr_pop_on mas gcsq gsib3dqejbw ==\\ defin us1159_attr_cn_on mauga1ueaw ==\\ defin us1159_attr_test mhegbi gaqebaryw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh urg qqaig ydvqqdbggqhkj opqqdag ==\\ extern est_ctx ectx static unsign char cacert null static int cacerts_len static char attr static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen attr csr_data malloc csr_len strncpi char csr_data attr csr_len csr_data csr_len return csr_data static void us1159_clean void int us1159_start_serv int start est server act st_start us1159_server_port us1159_server_cert us1159_server_key estrealm us1159_cacert trustedcert crt est exampl cnf manual enrol disabl ecdh nid info est_err_non printf (&#34;\\ unabl start est server us1159 &#34;); return (); est_set_csr_cb ectx est_err_non printf (&#34;\\ unabl set est csr attribut callback us1159 &#34;); return sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us1159_init_suit void int us1159_clean (); printf start server csr attribut enforc unit test us1159 ).\\ &#34;); attr us1159_attr_pop_on est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us1159_cacert cacert cacerts_len return start instanc est server automat enrol enabl us1159_start_serv (); return void us1159_stop_serv st_stop (); sleep routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1159_destroy_suit void us1159_stop_serv (); free cacert printf complet csr attribut enforc unit test &#34;); return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function generat public privat key pair use certif provis static evp_pkey int nid ec_key eckey ec_group group null bio unsign char tdata unsign char key_data int key_len bio keyin evp_pkey new_priv_key int asn1_flag form generat key group nid nid_x9_62_prime256v1 */); group asn1_flag group form eckey ec_key_new (); ec_key_set_group eckey group ec_key_generate_key eckey printf fail generat key &#34;); return null bio_new bio_s_mem ()); group pem_write_bio_ecpriv key eckey null null null null key_len bio_get_mem_data tdata key_data malloc key_len memcpi key_data tdata key_len ec_key_fre eckey bio_fre read back evp_pkey struct keyin bio_new bio_s_mem ()); keyin bio_new_mem_buf key_data key_len read privat key file expect pem encod privat key use der encod would invok d2i_priv key_bio instead new_priv_key pem_read_bio_priv key keyin null null null new_priv_key null printf (&#34;\\ error read pem encod privat key &#34;); err_print_errors_fp stderr return null bio_fre keyin free key_data return new_priv_key test attempt simpl enrol client provid csr attribut challeng password enrol succeed static void us1159_test1 void est_ctx ctx evp_pkey key int int pkcs7_len unsign char new_cert null log_func_nm creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ctx test pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ctx routin build pkcs10 csr static est_error x509_req req evp_pkey pkey char x509_name subj int setup version number x509_req_set_vers req cu_assert err_print_errors_fp stderr return est_err_x509_v add common name entri subj req subj mbstring_asc const unsign char cu_assert err_print_errors_fp stderr return est_err_x509_cn add serial number name entri subj nid_seri number mbstring_asc unsign char 12349999b cu_assert err_print_errors_fp stderr return est_err_x509_cn add attribut server expect req mbstring_asc const unsign char dummymac cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 840 10045 mbstring_asc const unsign char 132 cu_assert err_print_errors_fp stderr return est_err_unknown req 840 10045 mbstring_asc const unsign char &#34;&#34;, cu_assert err_print_errors_fp stderr return est_err_unknown req nid_seri number mbstring_asc const unsign char 123456789a cu_assert err_print_errors_fp stderr return est_err_unknown set public key request x509_req_set_pubkey req pkey cu_assert err_print_errors_fp stderr return est_err_x509_pubkey x509_req_print_fp stderr req return est_err_non sign x509 certif request use digest key pass return open ssl error code x509_req_sign_ctx (); static int sign_x509_req x509_req evp_pkey pkey const evp_md int evp_pkey_ctx pkctx null evp_md_ctx mctx evp_md_ctx_init mctx evp_digest sign init mctx pkctx null pkey return encod use der asn set modifi flag x509_req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req_info enc modifi x509_req_sign_ctx mctx evp_md_ctx_cleanup mctx return endif test attempt simpl enrol client provid requir csr attribut csr enrol succeed static void us1159_test2 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non sign request ossl_rv sign_x509_req req key evp_sha256 ()); cu_assert ossl_rv ossl_rv err_print_errors_fp stderr endif creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr except 521 bit curv use enrol fail sinc server csr attr specifi use 384 bit curv static void us1159_test3 void x509_req req null evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp521r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_http_bad_req cleanup ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr except sha 384 use signatur enrol fail sinc server csr attr requir sha 256 static void us1159_test4 void x509_req req null evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non chang sha 384 signatur ctx nid_sha384 cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_http_bad_req cleanup ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol server csr attribut configur requir common name csr attribut server configur static api callback static void us1159_test10 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non configur static csr attribut valu ectx us1159_attr_cn_on strlen us1159_attr_cn_on )); cu_assert est_err_non generat privat key key generate_private_key (); cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non est_client_force_pop ctx cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr client also provid larg quantiti addit attriut static void us1159_test20 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null int char t_attr_str log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non jam anoth attribut request could caus failur est server base64 decod csr due safe constraint max string size safe default 4096 byte ++) sprintf t_attr_str 899 req t_attr_str mbstring_asc const unsign char whatev cu_assert err_print_errors_fp stderr creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr client also provid attribut long name valu static void us1159_test21 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non add attribut long valu req 993 mbstring_asc const unsign char attribut long valu could potenti caus problem est server cu_assert err_print_errors_fp stderr add attribut long name req 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 mbstring_asc const unsign char cu_assert err_print_errors_fp stderr creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol server csr attribut configur enabl static void us1159_test50 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm st_enable_pop (); disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non generat privat key key nid_secp384r1 cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key test attempt simpl enrol server csr attribut configur disabl static void us1159_test51 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm st_disable_pop (); disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non generat privat key key nid_secp384r1 cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key main function set run test return cue_success success run anoth cunit error code failur int us1159_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1159_init_suit us1159_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit attribut requir pop us1159_test1 null cu_add_test suit attribut provid pop us1159_test2 null cu_add_test suit public key wrong curv pop us1159_test3 null cu_add_test suit wrong hash algorithm signatur pop us1159_test4 null cu_add_test suit use static config pop us1159_test10 null cu_add_test suit lot attribut pop us1159_test20 null cu_add_test suit long attribut pop us1159_test21 null cu_add_test suit csr attr server pop us1159_test50 null cu_add_test suit csr attr server pop us1159_test51 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us2174.c&#39;,
  &#39;unit test user stori proxi simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin retri interv defin tcp_port 29001 defin 52174 defin 62174 ifndef win32 defin us2174_server_cert est privat estservercertandkey pem defin us2174_server_key est privat estservercertandkey pem defin us2174_proxy_cert est privat estservercertandkey pem defin us2174_proxy_key est privat estservercertandkey pem defin us2174_proxy_cert us2174 cert pem defin us2174_proxy_key us2174 key pem defin us2174_cacert est cacert crt defin us2174_cacert est cacert crt defin us2174_trusted_cert trustedcert crt defin us2174_explicit_cert us2174 cert pem defin us2174_explicit_key us2174 key pem els defin us2174_server_cert est privat estservercertandkey pem defin us2174_server_key est privat estservercertandkey pem defin us2174_proxy_cert est privat estservercertandkey pem defin us2174_proxy_key est privat estservercertandkey pem defin us2174_proxy_cert us2174 cert pem defin us2174_proxy_key us2174 key pem defin us2174_cacert est cacert crt defin us2174_cacert est cacert crt defin us2174_trusted_cert trustedcert crt defin us2174_explicit_cert us2174 cert pem defin us2174_explicit_key us2174 key pem endif defin us2174_server_ip 127 defin us2174_tcp_port follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us2174_enroll_url_ba https :// 127 62175 well known est simpleenrol defin us2174_pkcs10_ct content type applic pkcs10 defin us2174_uidpwd_good estus estpwd static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey defin good_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u defin different_token v2vsb cwg ssd2zsbnb3qgd g8gcn ihrv igtl zxag jvb sboa wrpbic nck zcbjj20g ym91bm qgd g8ga2vlc cbvbi bya wrpbic nck zcbjj3zl igdvd cbvbm ugb w9i zsbza wx2zxig zg9sb gfi dqp xqg ssdt ig5vd cbnb25u ysbs zxqg j2vt ignhd gno ig1l lcbubw0ktm90igdvbm5h igxld zw0g y2f0y2ggd ghl ig1p zg5p z2h0ihjp zgvi defin null_token null defin long_token ssbj yw4nd cbh z3jl zsb0bi bka xnh z3jl zsanck z2h0a w5n igxpa2ug ssdt igzp z2h0a w5n igzvci bsa wzl ia0kvghl sdi zsbvbmx5ihdvcm igj1d cb0a gv5ign1d cbsa wtl igeg ymxh zgug dqp td2lu z2lu b3a wrl ihdpd ggg ywxs ig9m ig15ig1p z2h0ia0kdqp cb5zwfo lcbjigd1zxnz igl0j3mg ywxs ig9m ihro yxqg y29m lcb0a gf0j3mg z290ig15ig1pbm qga w4g ysb3a glyb canckknb sbzd glsb cbjd xnza w5n igfu zcbia xrja glu bhbm qgd ghlcm ywlu j3qgbm9ib2r5ighlcm dqo nck9o ihll ywgs ihlvd sbkb24nd cbo yxzl ihrv ighvb gxlci bjighl yxige w91ia0kssdt ihn0yw5ka w5n ihjp z2h0ighlcm vza wrl ihlvd sanck9o lca5osbza gfk zxmgb2yg y3jhenk ieknb sa5osbza gfk zxmgb2yg y3jhenkg dqp dcm f6e swg y3jhenk igni yxp5lcbjcm f6e sancg0kug91ci bhbm90a gvi igrya w5r lcbt ywtl igl0igeg zg91ymxl igzvci zsanck1h wjl iekg y2fu igrya w5r ihroa xmg yxdhe sanckl0j3mgbm v2zxig ihdo zw4gd ghle sbwd wxs ig91d cb0a gug z3vu ia0kqm vhd cb5b3ug ymxh y2sg yw5k igjsd wus igjv sancllvd sbnb3r0ysbw yxks ihlvd sbnb3r0ysbw yxkg dqo nck9o lcb3a gvi zsb0a guga gvsb cbhb sbjpi bjighvc gug yxqgb gvhc3qg ssbo ywqg ia0kssdt ihn0d w1ib glu b0a hjvd wdo ie5ldi bpcmxl yw5z ig9o lcb0bi b0a gugcmlza w5n ihn1bi ancg0kt2gg wvha cwge w91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3ug dqp jj20gc3rhbm rpbmcgcmlna hqga gvi zsbi zxnp zguge w91ia0kt2g idk5ihno ywrlci bjcm f6e swg ssdt idk5ihno ywrlci bjcm f6e sanck yxp5lcbjcm f6e swg y3jhenk igni yxp5ia0kdqp mb3jk ighhdm ugb wvi y3kgb24gb wug dqp ob3zlbn ig51zxzh ihrvbm9z igrl igxv y28g dqo nckkgbm zcbzb21l ihbl ywnl lcbqd xn0ihnvb wugcm vsa wvm ia0krn jvb sb0a glz ihzva wnl lcbra wxsa w5n ig1l ia0kww91ihn0yxjl igf0ig1l lcbhbm qge w91igd yxjl igf0ig1l ia0kqwx ihroa xmgc gfpbi bpd cdz igfsb cb0a gugc2ft zswga xqnci bhb gwga w5z yw5l ia0kkhlvd sbz zwup ia0kdqp jci b0a glz ihjl ywxse sbo yxbw zw5pbmcgb3ig zglk iekgb wfr zsbpd cbhb gwgd ia0kssdt igjvd w5k igzvci bda gf0d gfob29ja gvl ig9u igegd hvybmlw ihryd wnr ia0kdqp cb5zwfo lcb5b3ug zg9u j3qga gf2zsb0bi bob2x zxig ssbo zwfi ihlvd sanckknb sbzd gfu zglu bya wdod cbo zxjl igjlc2lk zsb5b3ug dqp cwg otkgc2hh zgvz ig9m igni yxp5lcbjj20g otkgc2hh zgvz ig9m igni yxp5ia0kq3jhenk igni yxp5lcbjcm f6e swg y3jhenkg dqo nck ihlvd sdi zsbjcm f6e sb5b3uncm y3jhenkg dqp ib2xk ig15igzl zxqs igzl zxqgd g8gd ghl igzpcm dqp zb3uga g9s zcbte sbm zwv0ihrv ihro zsbma xjl ia0kssbu zxzlci ywlk iekgd2fz igrvd24gd2l0a cb5b3u static char test_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u =&#34;; static int static int applic layer callback function return token base authent credenti call regist est client use (). test function requir set global valu order make callback oper way test case want tell function forc respons code error test_token pointer hard code string token string return callback must provid token credenti heap base buffer ownership buffer implicit transfer client librari upon return static est_http_auth_hdr auth_credenti char token_ptr null int token_len cu_assert auth_credenti mode auth_token report callback call see test request forc error respons code callback return auth_credenti mode auth_token test_token set anyth need alloc space heap copi valu test_token null token_len strlen test_token use strlen string larg need test est client token_len printf error determin length token string use credenti &#34;); return token_ptr malloc token_len token_ptr null printf error alloc token string use credenti &#34;); return strncpi token_ptr test_token strlen test_token )); token_ptr token_len made far token_ptr point string contain token return assign return success auth_credenti auth_token token_ptr return return token base one instead return basic credenti userid password static est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_bas report callback call see test request forc error respons code callback return auth_credenti mode auth_bas auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return basic base one instead verfi auth_mod pass digest static est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_digest report callback call see test request forc error respons code callback return auth_credenti mode auth_digest auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return endif callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv us2174_simple_enrol use test case perform simpl enrol static void us2174_simple_enrol char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx static void char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non est_destroy ectx ectx null creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null cert switch server token mode (); e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us2174_tcp_port null attempt reenrol token mode convert cert x509 warn pure hackeri pdb convers code come test case b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null pdb note moment expect fail sinc server yet understand request token authent 1884 complet assert begin fail need chang pass respons est_client_reenrol ectx cert pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx static void us2174_clean void static int us2174_start_serv int manual_enrol int nid int first start est server act st_start us2174_server_cert us2174_server_key estrealm us2174_cacert us2174_trusted_cert us2174 est exampl cnf manual_enrol manual enrol disabl nid ecdh nid info sleep est_err_non return next start est proxi act server side oper token auth mode st_proxy_start_token us2174_proxy_cert us2174_proxy_key estrealm us2174_cacert us2174_trusted_cert estus estpwd 127 disabl sleep return void us2174_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit initi test suit use alloc data open resourc requir test case static int us2174_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us2174_cacert cacert cacerts_len return us2174_clean (); start instanc est server automat enrol enabl us2174_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us2174_destroy_suit void us2174_stop_serv (); free cacert return simpl enrol proxi basic server basic make sure token auth mode break anyth static void us2174_test1 void long log_func_nm curl_http_post us2174_enroll_url_ba us2174_pkcs10_ct us2174_uidpwd_good us2174_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 endif simpl enrol proxi token server token static void us2174_test2 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi token server basic static void us2174_test3 void log_func_nm set server basic auth challeng (); set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi basic server token static void us2174_test4 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi basic auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi token server token static void us2174_test5 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed tc2174 us2174_server_ip est_err_non callback call cu_assert main function set run test return cue_success success run anoth cunit error code failur int us2174_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us2174_token_proxi us2174_init_suit us2174_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit (/* null cu_add_test suit proxi enrol basic saniti test us2174_test1 null cu_add_test suit proxi enrol token auth proxi server us2174_test2 null cu_add_test suit proxi enrol token auth proxi token server basic us2174_test3 null cu_add_test suit proxi enrol token auth proxi basic server token us2174_test4 null cu_add_test suit proxi enrol token auth proxi basic server token us2174_test5 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us893.c&#39;,
  &#39;unit test user stori proxi reenrol octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin tcp server port defin tcp proxi port 093 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us893_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin us893_pkcs10_corrupt miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdfffmdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin us893_server_ip 127 defin https :// 127 29093 well known est simplereenrol defin us893_pkcs10_ct content type applic pkcs10 defin us893_uidpwd_good estus estpwd defin us893_uid estus defin us893_pwd estpwd ifndef win32 defin us893_cacert est cacert crt defin us893_trusted_cert trustedcert crt defin us893_server_certkey est privat estservercertandkey pem defin us893_proxy_cert us893 cert pem defin us893_proxy_key us893 key pem defin us893_untrusted_cert us893 cert untrust pem defin us893_untrusted_key us893 key untrust pem defin us893_expired_key us893 key expir pem defin us893_expired_cert us893 cert expir pem defin us893_tc2_cert_txt us893 tc2 new cert txt defin us893_tc2_cert_b64 us893 tc2 new cert pkcs7b64 defin us893_tc2_cert_pk7 us893 tc2 new cert pkcs7 defin us893_tc2_cert_pem us893 tc2 new cert pem els defin us893_cacert est cacert crt defin us893_trusted_cert trustedcert crt defin us893_server_certkey est privat estservercertandkey pem defin us893_proxy_cert us893 cert pem defin us893_proxy_key us893 key pem defin us893_untrusted_cert us893 cert untrust pem defin us893_untrusted_key us893 key untrust pem defin us893_expired_key us893 key expir pem defin us893_expired_cert us893 cert expir pem defin us893_tc2_cert_txt us893 tc2 new cert txt defin us893_tc2_cert_b64 us893 tc2 new cert pkcs7b64 defin us893_tc2_cert_pk7 us893 tc2 new cert pkcs7 defin us893_tc2_cert_pem us893 tc2 new cert pem endif static void us893_clean void char cmd 200 temporari file creat various test case ifndef win32 sprintf cmd us893_tc2_cert_txt system cmd sprintf cmd us893_tc2_cert_b64 system cmd sprintf cmd us893_tc2_cert_pk7 system cmd sprintf cmd us893_tc2_cert_pem system cmd els sprintf cmd del us893_tc2_cert_txt system cmd sprintf cmd del us893_tc2_cert_b64 system cmd sprintf cmd del us893_tc2_cert_pk7 system cmd sprintf cmd del us893_tc2_cert_pem system cmd endif static int us893_start_serv int manual_enrol int nid int first start est server act st_start us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert us893 est exampl cnf manual_enrol nid est_err_non return next start est proxi actg st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us893_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us893_cacert cacert cacerts_len return us893_clean (); start instanc est server automat enrol enabl us893_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us893_destory_suit void st_stop (); st_proxy_stop (); free cacert return simpl reenrol rsa 2048 test case use libcurl test simpl reenrol 2048 bit rsa csr http basic authent use static void us893_test1 void long log_func_nm curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 test case use exist expir cert attempt enrol expir cert contain sever x509 extens verifi new issu cert preserv extens use grep note preserv extens requir open ssl enabl copy_extens knob open ssl config file test suit use uniqu copi est exampl cnf static void us893_test2 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len unsign char new_cert null x509 cert null bio char cmd 200 unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non save cert local file write_binary_fil us893_tc2_cert_b64 new_cert pkcs7_len cu_assert base decod cert respons sprintf cmd openssl base64 us893_tc2_cert_b64 us893_tc2_cert_pk7 system cmd cu_assert convert pkcs7 cert pem cert sprintf cmd openssl pkcs7 inform der print_cert us893_tc2_cert_pk7 us893_tc2_cert_pem system cmd cu_assert convert pem cert textual represent cert sprintf cmd openssl x509 text us893_tc2_cert_pem us893_tc2_cert_txt system cmd cu_assert verifi jimbob dns extens preserv grep us893_tc2_cert_txt jimbob &#34;); cu_assert verifi bobcat dns extens preserv grep us893_tc2_cert_txt bobcat &#34;); cu_assert verifi address extens preserv grep us893_tc2_cert_txt 172 &#34;); cu_assert verifi repudi key usag extens preserv grep us893_tc2_cert_txt repudi &#34;); cu_assert verifi public key preserv grep us893_tc2_cert_txt &#34;); cu_assert clean new_cert free new_cert est_destroy ectx simpl reenrol corrupt csr use libcurl send reenrol request contain corrupt csr static void us893_test3 void long log_func_nm curl_http_post us893_pkcs10_ct us893_pkcs10_corrupt us893_uidpwd_good us893_cacert curlauth_bas null null null sinc pass bad csr expect server respond 400 cu_assert 400 test attempt enrol expir cert est server configur manual approv server send back retri respons verifi proxi propag retri respons client static void us893_test4 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio int retry_v time_t time_v unsign char attr_data null int attr_len log_func_nm stop server st_stop (); st_proxy_stop (); restart server manual approv enabl us893_start_serv cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert server configur retri valu 3600 second default ectx retry_v time_v cu_assert est_err_non cu_assert retry_v 3600 clean est_destroy ectx stop server st_stop (); st_proxy_stop (); restart server manual approv disabl us893_start_serv cu_assert test attempt enrol expir cert est server configur enabl proxi server use cert contain cmc result failur static void us893_test5 void int log_func_nm make sure enabl server st_enable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null check fail cu_assert 400 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert test attempt enrol expir cert est server configur disabl proxi server use cert contain cmc result success reenrol static void us893_test6 void int log_func_nm make sure disabl server st_disable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null reenrol work sinc enabl anywher cu_assert 200 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert enabl server forthcom test case st_enable_pop (); test attempt enrol expir cert est server configur disabl proxi server use cert contain cmc csr contain forc check result failur sinc cert contain cmc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us893_test7 void int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm make sure disabl server st_disable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens ectx csr_pop_requir hack test attempt need forc challeng password csr est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_http_bad_req stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert enabl server forthcom test case st_enable_pop (); est_destroy ectx test case use exist expir cert attempt enrol disabl est server static void us893_test8 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len x509 cert null int int pkcs7_len bio unsign char attr_data null int attr_len log_func_nm make sure disabl server st_disable_pop (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx enabl server forthcom test case st_enable_pop (); test case use exist expir cert attempt enrol disabl est server csr contain static void us893_test9 void int log_func_nm make sure disabl server st_disable_pop (); use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null reenrol work sinc enabl anywher cu_assert 200 enabl server forthcom test case st_enable_pop (); test case use bad password configur est proxi context caus est server reject reenrol request static void us893_test10 void int log_func_nm stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus bogus 127 cu_assert curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null cu_assert 401 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert static void us893_test11 void int long http_code curl hnd struct curl_slist slist1 log_func_nm stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use untrust cert st_proxy_start us893_tcp_proxy_port us893_untrusted_cert us893_untrusted_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use normal curl util api need disabl tls peer verif special test case set content type header http request slist1 null slist1 curl_slist_append slist1 us893_pkcs10_ct setup field curl requir hnd curl_easy_init (); curl_easy_setopt hnd curlopt_url curl_easy_setopt hnd curlopt_noprogress curl_easy_setopt hnd curlopt_userpwd us893_uidpwd_good curl_easy_setopt hnd curlopt_postfield us893_pkcs10_rsa2048 curl_easy_setopt hnd curl_off_t strlen us893_pkcs10_rsa2048 )); curl_easy_setopt hnd curlopt_userag curl &#34;); curl_easy_setopt hnd curlopt_httphead slist1 curl_easy_setopt hnd curlopt_maxredir 50l curl_easy_setopt hnd curlopt_ssl_verifyp curl_easy_setopt hnd curlopt_httpauth curlauth_bas curl_easy_setopt hnd curlopt_cainfo us893_cacert curl_easy_setopt hnd curlopt_verbos curl_easy_setopt hnd curlopt_tcp_keepal curl_easy_setopt hnd curlopt_forbid_reus issu http request curl_easy_perform hnd get http repons status code server curl_easy_getinfo hnd http_code curl_easy_cleanup hnd hnd null curl_slist_free_al slist1 slist1 null cu_assert http_code 400 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert simpl reenrol rsa 2048 test case use libcurl test simpl reenrol 2048 bit rsa csr http basic authent use howev enabl proxi caus failur sinc libcurl includ static void us893_test12 void long log_func_nm st_proxy_enable_pop (); curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null fail sinc proxi fail check cu_assert 400 st_proxy_disable_pop (); main function set run test return cue_success success run anoth cunit error code failur int us893_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us893_init_suit us893_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us893_test1 null cu_add_test suit enrol expir cert us893_test2 null cu_add_test suit enrol corrupt csr us893_test3 null cu_add_test suit enrol expir cert retri us893_test4 null cu_add_test suit enrol proxi cmc srv us893_test5 null cu_add_test suit enrol proxi cmc srv us893_test6 null cu_add_test suit enrol proxi cmc srv csr us893_test7 null cu_add_test suit enrol expir cert srv csr us893_test8 null cu_add_test suit enrol expir cert srv csr us893_test9 null cu_add_test suit enrol proxi misconfigur http auth us893_test10 null cu_add_test suit enrol proxi untrust ident cert us893_test11 null cu_add_test suit enrol enabl proxi csr us893_test12 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;),
 (&#39;test_data/LibEST_semeru_format/test/us895.c&#39;,
  &#39;unit test user stori proxi csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin proxi port ifndef win32 defin us895_cacert est cacert crt defin us895_trusted_cert trustedcert crt defin server_ut_cacert est cacert crt defin server_ut_pubkey &#34;./ defin us895_server_ip 127 defin us895_cacert est cacert crt defin us895_trust_cert trustedcert crt defin us895_server_certkey est privat estservercertandkey pem els defin us895_cacert est cacert crt defin us895_trusted_cert trustedcert crt defin server_ut_cacert est cacert crt defin server_ut_pubkey defin us895_server_ip 127 defin us895_cacert est cacert crt defin us895_trust_cert trustedcert crt defin us895_server_certkey est privat estservercertandkey pem endif defin test_attr_pop mas gcsq gsib3dqejbw ==\\ defin test_attr_nopop mhew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg ==\\ defin test_attr_nopoppop mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr_popad mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr1 mcygbi gaqebarygcsq gsib3dqejbw yfk4eeacigcwcgsafl qcag ==\\ defin test_attr2 maa defin test_attr7 ==\\ defin test_attr2_pop mas gcsq gsib3dqejbw ==\\ defin test_attr8 mathisi bad gcsq gsib3dqejbw ==\\ defin test_attr3 migsmfg ga4g3aj frexl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku ncbk yxrh bgkqhki g9w0bcqcw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebari defin test_attr4_122 mhow laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr4_122pop migfmcw ga4g3aj oinw mga4g3bbmzugfyc2ug u0vuigfz idiu otk5lj jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebarygcsq gsib3dqejbw ==\\ defin test_attr5_117 mhuw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebari defin test_attr5_117pop migamcc ga4g3aj oinw mga4g3bbmuugfyc2ug u0vuigfz idiu otk5lj igcwcgsafl qcag yjki qdaw iiaqelmciga4g3ateb exl qyxjz zsbtrvqg yxmg mi45otku msbk yxrh bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_attr6_116 mhqw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw iqydi bmro tgfbhcn ifnfvcbhci ljk5os4x igrhd ayhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr_244 mih1mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey qgbys gaqebarygbi gaqebari defin test_attr_245 mih2mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1bgcr ebaqewbgcr ebaqew defin test_attr_250 mih7mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_attr_250pop miibbj oinw xqydi dbg oinw qtuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_all_attr mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfmtiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin test_1024_nopop miid dcca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_1025_nopop miid tcca2qga4g3aj gca1 ga4g3aw ydi eeisx m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_1024_pop miiebz cca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg yjko zihvc naqk defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin est_ut_max_cmd_len 255 extern est_ctx ectx static void us895_clean void static int us895_start_serv int manual_enrol int nid int st_start us895_server_port us895_server_certkey us895_server_certkey us895 test realm us895_cacert us895_trusted_cert est exampl cnf manual_enrol nid return next start est proxi act st_proxy_start us895_proxy_port us895_server_certkey us895_server_certkey us895 test realm us895_cacert us895_trusted_cert estus estpwd 127 us895_server_port nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us895_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est proxi test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey server_ut_pubkey printf (&#34;% cmd system cmd read certif cacerts_len read_binary_fil us895_cacert cacert cacerts_len return start server test need talk server us895_clean (); start instanc est server us895_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us895_destroy_suit void st_stop (); st_proxy_stop (); sleep return static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr7 csr_data malloc csr_len strncpi char csr_data test_attr7 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr8 csr_data malloc csr_len strncpi char csr_data test_attr8 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_long_attr csr_data malloc csr_len strncpi char csr_data test_long_attr csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr1 csr_data malloc csr_len strncpi char csr_data test_attr1 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr_nopop csr_data malloc csr_len strncpi char csr_data test_attr_nopop csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len csr_data null return csr_data callback function pass est_proxy_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis server side variat trigger static void us895_test1 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key int csr_len unsign char csr_data null sleep log_func_nm read certif cacerts_len read_binary_fil server_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key server_ut_pubkey priv_key null printf (&#34;\\ error read privat key file server_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us895_server_ip us895_proxy_port null clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit clear csrattr ectx null cu_assert est_err_non get 204 data ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit set smallest base64 size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2 )); cu_assert strncmp test_attr2 const char csr_data csr_len ectx test_attr3 strlen test_attr3 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr3 )); cu_assert strncmp test_attr3 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_nopop )); cu_assert strncmp test_1024_nopop const char csr_data csr_len enabl test respons st_enable_pop (); ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_data null cu_assert csr_len cu_assert strncmp test_attr_pop const char csr_data csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_pop )); cu_assert strncmp test_1024_pop const char csr_data csr_len set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr4_122pop )); cu_assert strncmp test_attr4_122pop const char csr_data csr_len set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr5_117pop )); cu_assert strncmp test_attr5_117pop const char csr_data csr_len real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len real base64 string fail ectx us900 test1 cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_250pop )); cu_assert strncmp test_attr_250pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len disabl st_disable_pop (); clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopop )); cu_assert strncmp test_attr_nopop const char csr_data csr_len asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_all_attr )); cu_assert strncmp test_all_attr const char csr_data csr_len ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us895_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us895_proxy_csrattr us895_init_suit us895_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr proxi attribut api1 us895_test1 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;)]</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Writing Into A File</span>
<span class="n">df_pre_processed</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pre_process</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">])</span> 
<span class="c1">#/.../benchmarking/traceability/testbeds/nltk</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_pre_processed</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>filename</th>
      <th>text</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>test_data/LibEST_semeru_format/test/us903.c</td>
      <td>unit test user stori server simpl enrol august...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>test_data/LibEST_semeru_format/test/us3496.c</td>
      <td>unit test uri path segment extens support marc...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>test_data/LibEST_semeru_format/test/us899.c</td>
      <td>unit test user stori client simpl enrol septem...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>test_data/LibEST_semeru_format/test/us4020.c</td>
      <td>unit test user stori unit test client proxi mo...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>test_data/LibEST_semeru_format/test/us897.c</td>
      <td>unit test user stori client cacert june copyri...</td>
    </tr>
    <tr>
      <th>5</th>
      <td>test_data/LibEST_semeru_format/test/us1060.c</td>
      <td>unit test user stori tls srp support server pr...</td>
    </tr>
    <tr>
      <th>6</th>
      <td>test_data/LibEST_semeru_format/test/us900.c</td>
      <td>unit test user stori server csr attribut novem...</td>
    </tr>
    <tr>
      <th>7</th>
      <td>test_data/LibEST_semeru_format/test/us896.c</td>
      <td>unit test user stori client csr attribut novem...</td>
    </tr>
    <tr>
      <th>8</th>
      <td>test_data/LibEST_semeru_format/test/us894.c</td>
      <td>unit test user stori proxi cacert novemb copyr...</td>
    </tr>
    <tr>
      <th>9</th>
      <td>test_data/LibEST_semeru_format/test/us1005.c</td>
      <td>unit test user stori client easi provis novemb...</td>
    </tr>
    <tr>
      <th>10</th>
      <td>test_data/LibEST_semeru_format/test/us898.c</td>
      <td>unit test user stori client enrol octob copyri...</td>
    </tr>
    <tr>
      <th>11</th>
      <td>test_data/LibEST_semeru_format/test/us3512.c</td>
      <td>unit test uri path segment support server apri...</td>
    </tr>
    <tr>
      <th>12</th>
      <td>test_data/LibEST_semeru_format/test/us1883.c</td>
      <td>unit test user stori enabl token auth mode est...</td>
    </tr>
    <tr>
      <th>13</th>
      <td>test_data/LibEST_semeru_format/test/us748.c</td>
      <td>unit test user stori proxi simpl enrol august ...</td>
    </tr>
    <tr>
      <th>14</th>
      <td>test_data/LibEST_semeru_format/test/us3612.c</td>
      <td>unit test user stori encrypt privat key suppor...</td>
    </tr>
    <tr>
      <th>15</th>
      <td>test_data/LibEST_semeru_format/test/us901.c</td>
      <td>unit test user stori server cacert june copyri...</td>
    </tr>
    <tr>
      <th>16</th>
      <td>test_data/LibEST_semeru_format/test/us1864.c</td>
      <td>unit test user stori enabl token auth mode ser...</td>
    </tr>
    <tr>
      <th>17</th>
      <td>test_data/LibEST_semeru_format/test/us1159.c</td>
      <td>unit test user stori csr attribut enforc octob...</td>
    </tr>
    <tr>
      <th>18</th>
      <td>test_data/LibEST_semeru_format/test/us2174.c</td>
      <td>unit test user stori proxi simpl enrol august ...</td>
    </tr>
    <tr>
      <th>19</th>
      <td>test_data/LibEST_semeru_format/test/us893.c</td>
      <td>unit test user stori proxi reenrol octob copyr...</td>
    </tr>
    <tr>
      <th>20</th>
      <td>test_data/LibEST_semeru_format/test/us895.c</td>
      <td>unit test user stori proxi csr attribut novemb...</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
<span class="n">pre_path</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-pre-tc].csv&#39;</span>
<span class="n">final_path</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-vocab-tc].csv&#39;</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_pre_processed</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">pre_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">save_dict</span><span class="p">(</span><span class="n">a_dict</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="n">a_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

    <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">a_file</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">a_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">])</span>
    <span class="n">a_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#1-Building the corpus vocabulary</span>
<span class="n">tokenizer_corpora</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Tokenizer</span><span class="p">()</span>
<span class="n">tokenizer_corpora</span><span class="o">.</span><span class="n">fit_on_texts</span><span class="p">([</span><span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">pre_process</span><span class="p">])</span>

<span class="n">word2id</span> <span class="o">=</span> <span class="n">tokenizer_corpora</span><span class="o">.</span><span class="n">word_index</span>
<span class="n">id2word</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">word2id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">save_dict</span><span class="p">(</span><span class="n">id2word</span><span class="p">,</span><span class="n">final_path</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">id2word</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Merging All the Vocabulary</span>
<span class="n">vocab_path_tc</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-vocab-tc].csv&#39;</span>
<span class="n">df_read_vocab_tc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">vocab_path_tc</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_read_vocab_tc</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab_path_src</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-vocab-src].csv&#39;</span>
<span class="n">df_read_vocab_src</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">vocab_path_src</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_read_vocab_src</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab_path_req</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-vocab-req].csv&#39;</span>
<span class="n">df_read_vocab_req</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">vocab_path_req</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_read_vocab_req</span><span class="o">.</span><span class="n">shape</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">super_vocab_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_read_vocab_tc</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_read_vocab_src</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_read_vocab_req</span><span class="p">[</span><span class="s1">&#39;text&#39;</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">super_vocab_set</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_all_vocab</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">super_vocab_set</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_all_vocab</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_all_vocab</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-vocab-all].csv&#39;</span><span class="p">,</span> 
                    <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span> 
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#Merging all the corpuses</span>
<span class="n">pre_doc_path_tc</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-pre-tc].csv&#39;</span>
<span class="n">pre_doc_path_req</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-pre-req].csv&#39;</span>
<span class="n">pre_doc_path_src</span> <span class="o">=</span> <span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-pre-src].csv&#39;</span>

<span class="c1">#df_read_pre_tc = pd.read_csv(pre_doc_path_tc, header=None, sep=&#39; &#39;) #Need to inclide sep </span>
<span class="n">pre_doc_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">pre_doc_path_tc</span><span class="p">,</span> <span class="n">pre_doc_path_req</span><span class="p">,</span> <span class="n">pre_doc_path_src</span><span class="p">]</span>
<span class="n">lis</span><span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">df_read</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">df_read</span> <span class="ow">in</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pre_doc_path</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lis</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>    
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>21 52 14
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">lis</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="p">:</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="n">lis</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">lis</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&#39;unit test user stori server simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif ifndef win static char test outfil filenam max test hdr defin cacert est cacert crt defin explicit_cert us903 cert pem defin us903_explicit_key us903 key pem defin us903_cacert est cacert crt defin us903_trusted_cert trustedcert crt defin est privat estservercertandkey pem els static char test5_outfil filename_max us903 test5 hdr defin us903_cacert est cacert crt defin us903_explicit_cert us903 cert pem defin us903_explicit_key us903 key pem defin us903_cacert est cacert crt defin us903_trusted_cert trustedcert crt defin est privat estservercertandkey pem endif static unsign char cacert null static int cacerts_len defin us903_retry_interv 3600 defin us903_tcp_port 29001 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us903_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin us903_pkcs10_dsa1024 miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin us903_pkcs10_corrupt miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us903_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us903_pkcs10_ct content type applic pkcs10 defin us903_uidpwd_good estus estpwd static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written static void us903_clean void static int us903_start_serv int manual_enrol int nid int st_start us903_tcp_port us903 test realm us903_cacert us903_trusted_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us903_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us903_cacert cacert cacerts_len return us903_clean (); start instanc est server automat enrol enabl us903_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us903_destory_suit void st_stop (); free cacert return simpl enrol rsa 2048 test case use libcurl test simpl enrol 2048 bit rsa csr http basic authent use static void us903_test1 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol prime 256 test case use libcurl test simpl enrol 256 bit csr http basic authent use static void us903_test2 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol dsa prime 1024 test case use libcurl test simpl enrol 1024 bit dsa csr http basic authent use static void us903_test3 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_dsa1024 us903_uidpwd_good us903_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol corrupt pkcs10 test case use libcurl test simpl enrol usinga corrupt csr http basic authent use static void us903_test4 void long log_func_nm curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_corrupt us903_uidpwd_good us903_cacert curlauth_bas null null null sinc csr valid server respond 400 cu_assert 400 simpl enrol manual enrol test case verifi server send appropri retri respons static void us903_test5 void long log_func_nm stop est server st_stop (); restart server manual enrol enabl us903_start_serv outfil fopen test5_outfil &#34;); curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null write_func fclose outfil sinc server seen csr past respond retri 202 respons cu_assert 202 verifi retri valu grep test5_outfil retri 3600 &#34;); cu_assert avoid wait full retri period sinc simul manual enrol wait second tri enrol cert sleep curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null enrol request succeed time simul manual enrol automat enrol second attempt cu_assert 200 stop est server st_stop (); restart server manual enrol disabl us903_start_serv simpl enrol check fail curl test case verifi server verifi client csr sinc curl set est enrol fail static void us903_test6 void long log_func_nm st_enable_pop (); send valid enrol request use curl curl includ curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas null null null server respond failur code cu_assert 400 st_disable_pop (); simpl enrol check succeed estclient test case verifi server verifi client csr use estclient sinc support static void us903_test7 void long est_ctx c_ctx evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len int http_status log_func_nm test case requir enabl st_enable_pop (); creat client context c_ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert c_ctx null c_ctx return specifi user password sinc server run basic authent mode est_client_set_auth c_ctx estus estpwd null null cu_assert est_err_non est_client_set_serv c_ctx 127 us903_tcp_port null get keypair use enrol new_pkey generate_private_key (); c_ctx attr_data attr_len cu_assert est_err_non attempt enrol csr est_client_enrol c_ctx us903 test7 pkcs7_len new_pkey cu_assert est_err_non check http status code receiv server 200 http_status c_ctx cu_assert http_status 200 client librari obtain new client certif retriev librari pkcs7 malloc pkcs7_len pkcs7 return c_ctx pkcs7 cu_assert est_err_non clean est_destroy c_ctx evp_pkey_fre new_pkey free pkcs7 disabl futur test case st_disable_pop (); simpl enrol use non default ecdh curv test case verifi function work static void us903_test8 void long log_func_nm stop est server st_stop (); restart server use secp384r1 curv us903_start_serv nid_secp384r1 curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_pkcs10_rsa2048 us903_uidpwd_good us903_cacert curlauth_bas ecdh ecdsa aes256 gcm sha384 null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol disabl csr contain valid test case ensur server handl scenario csr includ valid even server request use cisco est client generat csr contain valid way includ valid use curl sinc tls channel bind inform known advanc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us903_test9 void est_ctx ctx int unsign char cacert int caclen evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm make sure est server disabl st_disable_pop (); read cert caclen read_binary_fil us903_cacert cacert cu_assert cacerts_len init client context ctx est_client_init cacert caclen est_cert_format_pem use simpl http auth identifi est_client_set_auth ctx estus estpwd null null cu_assert est_err_non est_client_set_serv ctx 127 us903_tcp_port null creat space hold cert generat privat key new_pkey generate_private_key (); ctx attr_data attr_len cu_assert est_err_non attempt enrol ctx csr_pop_requir hack test attempt need forc challeng password csr est_client_enrol ctx test case9 pkcs7_len new_pkey cu_assert est_err_non pkcs7 malloc pkcs7_len ctx pkcs7 free pkcs7 est_destroy ctx simpl enrol disabl csr contain invalid test case ensur server handl scenario csr includ invalid even server request static void us903_test10 void long log_func_nm make sure est server disabl st_disable_pop (); curl_http_post us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_cacert curlauth_bas null null null enrol request fail sinc invalid expect 400 respons cu_assert 400 simpl enrol enabl csr contain invalid client use cert contain cmc test case ensur server disabl check client use cert contain cmc indic client static void us903_test11 void long log_func_nm make sure est server disabl st_enable_pop (); us903_enroll_url_ba us903_pkcs10_ct us903_uidpwd_good us903_explicit_cert us903_explicit_key us903_cacert null even though valu match csr enrol succeed sinc client use certif expect 200 respons cu_assert 200 main function set run test return cue_success success run anoth cunit error code failur int us903_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us903_srv_simpenrol us903_init_suit us903_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us903_test1 null cu_add_test suit enrol ecdsa cert us903_test2 null cu_add_test suit enrol dsa cert us903_test3 null cu_add_test suit enrol corrupt ecdsa cert us903_test4 null cu_add_test suit enrol retri manual approv us903_test5 null cu_add_test suit enrol fail curl us903_test6 null cu_add_test suit enrol succeed estclient us903_test7 null cu_add_test suit non default ecdh curv us903_test8 null cu_add_test suit enrol disabl csr includ valid us903_test9 null cu_add_test suit enrol disabl csr includ invalid us903_test10 null cu_add_test suit enrol enabl use cert csr includ invalid us903_test11 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test uri path segment extens support march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server includ src est est locl extern char tst srvr path seg enrol extern char tst srvr path seg auth static int path segment support max command line length generat system command defin est max cmd_len 256 certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey &#34;./ defin us3496_server_port 29496 defin us3496_server_ip 127 defin us3496_uidpwd_good estus estpwd defin us3496_uid estus defin us3496_pwd estpwd ifndef win32 defin us3496_cacert est cacert crt defin us3496_trust_cert trustedcert crt defin est privat estservercertandkey pem els defin us3496_cacert est cacert crt defin us3496_trust_cert trustedcert crt defin est privat estservercertandkey pem static critical_sect logger_critical_sect static void us3496_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif defin us3496_enroll_url_ba https :// 127 29496 well known est cacert somestr simpleenrol defin us3496_pkcs10_ct content type applic pkcs10 defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x static int x509 cur_cert int openssl_cert_error static void us3496_clean void static int us3496_start_serv int manual_enrol int nid int st_start us3496_server_port us3496 test realm us3496_cacert us3496_trust_cert est exampl cnf manual_enrol nid sleep return static int path_seg_support void est_ctx ectx unsign char cacert null int cacerts_len est_error est_err_non sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_serv ectx us3496_server_ip us3496_server_port test_seg &#34;); est_err_non return els return return routin call cunit initi test suit generat keypair use est client suit static int us3496_init_suit void int char cmd est_ut_max_cmd_len printf start est client proxi path segment unit test &#34;); check see path segment support compil path_segment_support printf uri path segment support build est rebuild use uripars dir &#34;); return gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us3496_clean (); start instanc est server us3496_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3496_destroy_suit void st_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test case test set server valid paramet path segment static void us3496_test1 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port null cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment valid static void us3496_test2 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port somestr &#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain segment fail static void us3496_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port somestring1 somestring2 &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey valid charact defin &#34;@% ~!$&amp;\&#39;()*+,;=&#34; static void us3496_test4 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment invalid invalid charact static void us3496_test5 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port someinvalid string &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment long 129 defin static void us3496_test6 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment equal oper cacert static void us3496_test7 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cacert &#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain oper cacert case front string static void us3496_test8 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port cacert server &#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment empti string fail static void us3496_test9 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port &#34;&#34;); cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment contain :\&#39;. pass static void us3496_test10 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port &#34;-. ~:@!$&amp;\&#39;()*+,;=&#34;); cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey pass path segment long 129 defin path_segment_max static void us3496_test11 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3496_server_ip us3496_server_port path_segment_max cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us3496_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3496_init_suit us3496_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us3496_logger_stderr endif check see path segment support compil path_seg_support ()) printf uri path segment support build est rebuild use uripars dir &#34;); path_segment_support return path_segment_support path_segment_support add test suit note order import must test fread fprintf null cu_add_test suit est client set server correct paramet path segment us3496_test1 null cu_add_test suit est client set server correct paramet valid path segment us3496_test2 null cu_add_test suit est client set server correct paramet multi segment path segment us3496_test3 null cu_add_test suit est client set server correct paramet valid path segment valid char us3496_test4 null cu_add_test suit est client set server correct paramet invalid path segment us3496_test5 null cu_add_test suit est client set server correct paramet path segment long us3496_test6 null cu_add_test suit est client set server correct paramet path segment equal oper string us3496_test7 null cu_add_test suit est client set server correct paramet path segment contain oper string us3496_test8 null cu_add_test suit est client set server correct paramet path segment empti string us3496_test9 null cu_add_test suit est client set server correct paramet path segment contain colon us3496_test10 null cu_add_test suit est client set server correct paramet path segment max length us3496_test11 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori client simpl enrol septemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin server defin us899_uid estus defin us899_pwd estpwd follow cert use fqdn test ifndef win32 defin us899_cacert est cacert crt defin us899_trust_cert trustedcert crt defin us899_server_certkey est privat estservercertandkey pem defin us899 cert_cn_mismatch pem defin us899 key_cn_mismatch pem defin us899 cert_cn_mismatch_ip pem defin us899 key_cn_mismatch_ip pem defin us899 cert_cn_match_wc pem defin us899 key_cn_match_wc pem defin us899 cert_cn_mismatch_wc pem defin us899 key_cn_mismatch_wc pem defin us899 cert_san_match pem defin us899 key_san_match pem defin us899 cert_san_mismatch pem defin us899 key_san_mismatch pem defin us899 cert_san_mismatch_ip pem defin us899 key_san_mismatch_ip pem defin us899 cert_san_match_ip pem defin us899 key_san_match_ip pem defin us899 cert_san_match_wc pem defin us899 key_san_match_wc pem defin us899 cert_san_mismatch_wc pem defin us899 key_san_mismatch_wc pem els defin us899_cacert est cacert crt defin us899_trust_cert trustedcert crt defin us899_server_certkey est privat estservercertandkey pem defin us899 cert_cn_mismatch pem defin us899 key_cn_mismatch pem defin us899 cert_cn_mismatch_ip pem defin us899 key_cn_mismatch_ip pem defin us899 cert_cn_match_wc pem defin us899 key_cn_match_wc pem defin us899 cert_cn_mismatch_wc pem defin us899 key_cn_mismatch_wc pem defin us899 cert_san_match pem defin us899 key_san_match pem defin us899 cert_san_mismatch pem defin us899 key_san_mismatch pem defin us899 cert_san_mismatch_ip pem defin us899 key_san_mismatch_ip pem defin us899 cert_san_match_ip pem defin us899 key_san_match_ip pem defin us899 cert_san_match_wc pem defin us899 key_san_match_wc pem defin us899 cert_san_mismatch_wc pem defin us899 key_san_mismatch_wc pem static critical_sect logger_critical_sect static void us899_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif defin us899_valid_csr_pem &#34;----- begin certif request -----\\ miibh dcb7g ibadbfmqsw cqydvqqgew jbvtetmbega1uecaw ku29t zs1td gf0zteh mb8ga1uecgw ysw50zxju zxqg v2lk z2l0ci bqd hkg thrk migf ma0gcsq gsib3dqeb aquaa4gnadcbi qkbg qc13w eg36v by8mq uu80skvkx0zct0lc18ka msdlw ml2ir clezbj jye sxw z9q xy4rt1v fdrrtl57 qtg t5kz ki2d2yuz dg6w qqx 4t99s lxc utf ipiaq atuqx h7fo0ti9w lsw6aqft9hib yprjz6z ha24l xwd7w aqabo aaw dqyjko zihvc naqefbqadg yeajw fazo pga4gkn7aeitep 3qj n45lszr vjmw4jl8ovm patn frqym82r vkb7sq4ddo9n dj9tg z450oq iwbuj geu uux jsj3v gxi 8ne ty4gmm nwiwh skmkqh7yvl bvgkw nfu q8m d90pr fmld hbzxcaekr ----- end certif request -----&#34; note array generat use xdd req der req static unsign char us899_valid_csr_d 0x30 0x82 0x01 0xa8 0x30 0x82 0x01 0x11 0x02 0x01 0x00 0x30 0x68 0x31 0x0b 0x30 0x09 0x06 0x03 0x55 0x04 0x06 0x13 0x02 0x55 0x53 0x31 0x0b 0x30 0x09 0x06 0x03 0x55 0x04 0x08 0x0c 0x02 0x6e 0x63 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x07 0x0c 0x03 0x73 0x73 0x73 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x0a 0x0c 0x03 0x64 0x64 0x64 0x31 0x0d 0x30 0x0b 0x06 0x03 0x55 0x04 0x0b 0x0c 0x04 0x66 0x6a 0x6a 0x64 0x31 0x0c 0x30 0x0a 0x06 0x03 0x55 0x04 0x03 0x0c 0x03 0x31 0x32 0x37 0x31 0x13 0x30 0x11 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x09 0x01 0x16 0x04 0x6e 0x6f 0x6e 0x65 0x30 0x81 0x9f 0x30 0x0d 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x01 0x01 0x05 0x00 0x03 0x81 0x8d 0x00 0x30 0x81 0x89 0x02 0x81 0x81 0x00 0xb9 0x9f 0xdd 0xd0 0xa4 0xdf 0x06 0x50 0xf5 0x4e 0x85 0x80 0xeb 0x2a 0x1e 0xff 0x3c 0x0f 0x0d 0x98 0x6e 0xfe 0x08 0x74 0xf4 0xce 0xf5 0xfd 0xf9 0x2f 0x86 0x20 0xf7 0xcc 0x08 0x05 0xce 0x98 0x69 0x5c 0x8c 0xbd 0x20 0xa7 0x28 0xf7 0xe4 0x22 0xfa 0xaf 0xe4 0x15 0xc4 0xb9 0x85 0xcb 0x0f 0x11 0xc6 0x55 0x0d 0x31 0x5c 0xfb 0x5e 0xcf 0x8e 0xd1 0xde 0x77 0x15 0x2c 0x8c 0x4e 0x88 0x4e 0x21 0xb6 0x69 0x9c 0xa7 0x7d 0x06 0xc5 0x75 0x3f 0xdc 0x18 0xf6 0x00 0x51 0xd5 0x00 0x47 0x62 0xfc 0x95 0xc8 0xd4 0xef 0x31 0x4a 0xb0 0x15 0xa9 0x50 0x04 0x6e 0x13 0x14 0xd4 0xbb 0x56 0x22 0x6f 0x3b 0x91 0xb6 0xeb 0xba 0x25 0x8f 0x12 0xea 0xfd 0xd4 0xd0 0x6d 0x02 0x03 0x01 0x00 0x01 0xa0 0x00 0x30 0x0d 0x06 0x09 0x2a 0x86 0x48 0x86 0xf7 0x0d 0x01 0x01 0x05 0x05 0x00 0x03 0x81 0x81 0x00 0x3b 0xa5 0xb4 0x97 0x6c 0xea 0xe4 0x9f 0xeb 0x56 0xca 0x7a 0x7f 0xfa 0x53 0x8d 0xee 0x6f 0x7e 0xa1 0x08 0x65 0xe0 0x05 0x5b 0x0e 0x5a 0x92 0xdb 0x3c 0xc5 0x6d 0x0d 0xcd 0x2c 0xcd 0x4d 0x10 0x2a 0x92 0x78 0x1d 0xfb 0x92 0x66 0x33 0x18 0xdd 0xf8 0x78 0xc5 0x1a 0x03 0xf9 0x58 0x9f 0x32 0x49 0xde 0xd2 0x26 0x78 0x80 0x87 0x18 0xf3 0x6d 0xc3 0x35 0x5d 0x21 0x8b 0x4c 0x8c 0x87 0xef 0xb1 0xfc 0x2c 0xec 0xdb 0xd6 0x00 0xe5 0x21 0xfa 0x34 0x5a 0x3c 0xc3 0x82 0x52 0x6f 0x81 0x2a 0x05 0xcc 0xdc 0x8a 0x51 0xf6 0x65 0x1d 0xc5 0x64 0x86 0xc1 0x28 0xf5 0x0c 0x8f 0x09 0xd4 0x84 0x8f 0x69 0x04 0x24 0x65 0xf4 0x47 0x6c 0x90 0x57 0x3c 0x04 0x4d 0x52 static unsign int 428 leav may need test case static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written endif static void us899_clean void static int us899_start_serv int manual_enrol int nid int st_start us899_server_port us899_server_certkey us899_server_certkey us899 test realm us899_cacert us899_trust_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us899_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us899_logger_stderr endif read certif cacerts_len read_binary_fil us899_cacert cacert cacerts_len return us899_clean (); start instanc est server automat enrol enabl us899_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us899_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey static int populate_x509_csr x509_req req evp_pkey pkey char x509_name subj setup version number x509_req_set_vers req printf (&#34;\\ unabl set x509 version &#34;); return add common name entri subj req subj mbstring_asc unsign char printf (&#34;\\ unabl creat x509 common name entri &#34;); return set public key request x509_req_set_pubkey req pkey printf (&#34;\\ unabl set x509 public key &#34;); return return sign x509 certif request use digest key pass return open ssl error code x509_req_sign_ctx (); static int sign_x509_req x509_req evp_pkey pkey const evp_md int evp_pkey_ctx pkctx null evp_md_ctx mctx evp_md_ctx_init mctx evp_digest sign init mctx pkctx null pkey return encod use der asn set modifi flag x509_req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req_info enc modifi x509_req_sign_ctx mctx evp_md_ctx_cleanup mctx return function perform basic simpl enrol use uid pwd identifi client server use varieti test case modul static void us899_simple_enrol char char server est_error expected_enroll_rv est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx server us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert expected_enroll_rv use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol basic test perform simpleenrol use user password identifi client server ident certif use client static void us899_test1 void log_func_nm us899_simple_enrol tc899 us899_server_ip est_err_non simpl enrol csr basic test perform simpleenrol use user password identifi client server ident certif use client test case use altern enrol method csr provid applic layer rather libest generat csr static void us899_test2 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null x509_req csr unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null generat csr csr x509_req_new (); cu_assert csr null populate_x509_csr csr key us899 tc2 &#34;); get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use altern api enrol exist csr ectx csr pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup x509_req_fre csr evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr null basic test perform simpleenrol use user password identifi client server ident certif use client test case use altern enrol method csr provid applic layer rather libest generat csr attempt pass null csr fail static void us899_test3 void est_ctx ectx evp_pkey key int int pkcs7_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null use altern api enrol null csr ectx null pkcs7_len key cu_assert est_err_no_csr cleanup evp_pkey_fre key est_destroy ectx simpl enrol csr corrupt test check x509_req helper function work propleri static void us899_test4 void x509_req csr unsign char badreq bogus request log_func_nm first tri pem decod csr badreq est_cert_format_pem cu_assert csr null next tri der decod csr badreq est_cert_format_d cu_assert csr null next tri invalid format csr badreq 999 cu_assert csr null next tri invalid csr length csr badreq 999999 est_cert_format_pem cu_assert csr null next tri valid pem encod csr csr unsign char us899_valid_csr_pem strlen us899_valid_csr_pem est_cert_format_pem cu_assert csr null csr x509_req_fre csr next tri valid der encod csr csr unsign char us899_valid_csr_d est_cert_format_d cu_assert csr null csr x509_req_fre csr attempt enrol newli creat csr alreadi sign via static void us899_test5 void est_ctx ectx evp_pkey key int int pkcs7_len x509_req csr unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null generat new csr csr x509_req_new (); cu_assert csr null populate_x509_csr csr key us899 tc5 &#34;); cu_assert csr null sign csr sign_x509_req csr key evp_sha256 ()); get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use altern api enrol exist csr pass ectx csr pkcs7_len key cu_assert est_err_non cleanup x509_req_fre csr evp_pkey_fre key est_destroy ectx simpl enrol fqdn mismatch hostnam test confirm mismatch host name server cert result auth failur tls layer client side static void us899_test6 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn mismatch ipv4 address test confirm mismatch address server cert result auth failur tls layer client side note test may redund sinc address match logic occur nsname use instead common name static void us899_test7 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn match wildcard test confirm wildcard match logic work cert use wildcard pattern cisco com server address localhost cisco com static void us899_test8 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch wildcard test confirm wildcard match logic work cert use wildcard pattern googl com server address localhost cisco com static void us899_test9 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol fqdn match hostnam subject alt name test confirm match host name server cert subject alt name ext result auth success static void us899_test10 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch hostnam subject alt name test confirm mismatch host name server cert subject alt name ext result auth failur static void us899_test11 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol fqdn mismatch ipv4 address subject alt name test confirm mismatch ipv4 address server cert subject alt name ext result auth failur static void us899_test12 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip simpl enrol fqdn match ipv4 address subject alt name test confirm match ipv4 address server cert subject alt name ext result auth success static void us899_test13 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 us899_server_ip est_err_non simpl enrol fqdn match hostnam subject alt name wildcard test confirm hostnam match wildcard pattern server cert subject alt name ext result auth success static void us899_test14 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com est_err_non simpl enrol fqdn mismatch hostnam subject alt name wildcard test confirm hostnam mismatch wildcard pattern server cert subject alt name ext result auth fail static void us899_test15 void int log_func_nm stop exist server test case need server use differ cert st_stop (); spin new instanc est server use certif contain bogus hostnam st_start us899_server_port us899 test realm us899_cacert us899_trust_cert est exampl cnf cu_assert return us899_simple_enrol tc899 localhost cisco com simpl enrol crl check enabl client enabl crl check client side generat crl server cert revok enrol succeed static void us899_test16 void int est_ctx ectx evp_pkey key int pkcs7_len unsign char new_cert null unsign char cacrlcert null int cacrlcerts_len unsign char attr_data null int attr_len log_func_nm stop exist server test case need server use differ cert st_stop (); fqdn test complet start normal server us899_start_serv cu_assert generat crl append chain use client side ifndef win32 system openssl config est exampl cnf gencrl us899 test16_crl pem &#34;); sleep system cat trustedcert crt us899 test16trust crt &#34;); sleep system cat us899 test16_crl pem us899 test16trust crt &#34;); sleep els system openssl config est exampl cnf gencrl us899 test16_crl pem &#34;); sleep system type trustedcert crt us899 test16trust crt &#34;); sleep system type us899 test16_crl pem us899 test16trust crt &#34;); sleep endif read certif cacrlcerts_len read_binary_fil us899 test16trust crt cacrlcert cu_assert cacrlcert cacrlcerts_len return creat client context ectx est_client_init cacrlcert cacrlcerts_len est_cert_format_pem cu_assert ectx null enabl crl check client est_enable_crl ectx cu_assert est_err_non set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx test16 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx free cacrlcert simpl enrol crl check enabl client enabl crl check client side generat crl server cert revok enrol fail static void us899_test17 void int est_ctx ectx evp_pkey key int pkcs7_len unsign char cacrlcert null int cacrlcerts_len unsign char attr_data null int attr_len log_func_nm revok server cert generat crl append chain use client side ifndef win32 system est index txt est index txt save &#34;); sleep system openssl config est exampl cnf revok est privat estservercertandkey pem &#34;); sleep system openssl config est exampl cnf gencrl us899 test17_crl pem &#34;); sleep system cat trustedcert crt us899 test17trust crt &#34;); sleep system cat us899 test17_crl pem us899 test17trust crt &#34;); sleep system est index txt save est index txt &#34;); sleep els system copi est index txt est index txt save &#34;); sleep system openssl config est exampl cnf revok est privat estservercertandkey pem &#34;); sleep system openssl config est exampl cnf gencrl us899 test17_crl pem &#34;); sleep system type trustedcert crt us899 test17trust crt &#34;); sleep system type us899 test17_crl pem us899 test17trust crt &#34;); sleep system copi est index txt save est index txt &#34;); sleep endif read certif cacrlcerts_len read_binary_fil us899 test17trust crt cacrlcert cu_assert cacrlcert cacrlcerts_len return creat client context ectx est_client_init cacrlcert cacrlcerts_len est_cert_format_pem cu_assert ectx null enabl crl check client est_enable_crl ectx cu_assert est_err_non set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_ssl_connect use simplifi api enrol csr est_client_enrol ectx test17 pkcs7_len key cu_assert est_err_ssl_connect cleanup evp_pkey_fre key est_destroy ectx free cacrlcert simpl enrol receiv retri respons client issu enrol request receiv retri respons ensur retri valu obtain client static void us899_test18 void int est_ctx ectx evp_pkey key int pkcs7_len int delay_sec time_t retry_d unsign char attr_data null int attr_len log_func_nm stop exist server test case need server manual enrol mode st_stop (); start server manual enrol mode us899_start_serv cu_assert creat client context use default cert ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us899_uid us899_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us899_server_ip us899_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx test18 pkcs7_len key cu_assert get retri durat make sure set default valu ectx delay_sec retry_d cu_assert est_err_non cu_assert delay_sec 3600 cleanup evp_pkey_fre key est_destroy ectx auth http basic auth enabl server enrol csr use valid cert uid enrol csr use valid cert valid uid enrol csr use valid cert invalid uid enrol csr use invalid cert uid enrol csr use invalid cert valid uid enrol csr use invalid cert invalid uid auth http digest auth enabl server enrol csr use valid cert uid enrol csr use valid cert valid uid enrol csr use valid cert invalid uid enrol csr use invalid cert uid enrol csr use invalid cert valid uid enrol csr use invalid cert invalid uid int us899_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us899_init_suit us899_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit simpl enrol us899_test1 null cu_add_test suit simpl enrol csr us899_test2 null cu_add_test suit simpl enrol null csr us899_test3 null cu_add_test suit simpl enrol corrupt csr us899_test4 null cu_add_test suit simpl enrol sign csr us899_test5 null cu_add_test suit simpl enrol hostnam mismatch fqdn us899_test6 null cu_add_test suit simpl enrol ipv4 mismatch fqdn us899_test7 null cu_add_test suit simpl enrol wildcard match fqdn us899_test8 null cu_add_test suit simpl enrol wildcard mismatch fqdn us899_test9 null cu_add_test suit simpl enrol hostnam match fqdn san us899_test10 null cu_add_test suit simpl enrol hostnam mismatch fqdn san us899_test11 null cu_add_test suit simpl enrol ipv4 mismatch fqdn san us899_test12 null cu_add_test suit simpl enrol ipv4 match fqdn san us899_test13 null cu_add_test suit simpl enrol wildcard match fqdn san us899_test14 null cu_add_test suit simpl enrol wildcard mismatch fqdn san us899_test15 null cu_add_test suit simpl enrol crl enabl valid server cert us899_test16 null cu_add_test suit simpl enrol crl enabl revok server cert us899_test17 null cu_add_test suit simpl enrol retri receiv us899_test18 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori unit test client proxi mode test new api function verifi correct oper client proxi mode octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno includ fcntl defin max cmds static unsign char cacert null static int cacert len defin server_domain_nam localhost cisco com defin us4020_server_ip 127 defin 40200 defin us4020_proxy_ip 127 defin 40208 defin us4020_uid estus defin us4020_pwd estpwd ifndef win32 defin us4020_cacert est cacert crt defin us4020_cacert est cacert crt defin us4020_server_cert est privat estservercertandkey pem defin us4020_server_key est privat estservercertandkey pem defin us4020_client_cert est privat estservercertandkey pem defin us4020_client_key est privat estservercertandkey pem els defin us4020_cacert est cacert crt defin us4020_cacert est cacert crt defin us4020_server_cert est privat estservercertandkey pem defin us4020_server_key est privat estservercertandkey pem defin us4020_client_cert est privat estservercertandkey pem defin us4020_client_key est privat estservercertandkey pem static critical_sect logger_critical_sect static void us4020_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey static void us4020_clean void int us4020_start_serv int manual_enrol int nid int st_start est privat estservercertandkey pem est privat estservercertandkey pem estrealm est cacert crt trustedcert crt est exampl cnf manual_enrol nid return defin max_cmd_buf 256 defin max_pid_buf 128 static void shutdown_antinat void int char read_pid max_pid_buf char cmd max_cmd_buf int open (&#34;./ antinat pid o_rdwr 0666 void read read_pid max_pid_buf printf pid read back read_pid snprintf cmd max_cmd_buf kill read_pid system cmd printf fail termin antinat &#34;); static void shutdown_haproxi void int int readbyte_count char read_pid max_pid_buf char cmd max_cmd_buf int open (&#34;./ haproxi pid o_rdwr 0666 readbyte_count read read_pid max_pid_buf void read read_pid max_pid_buf printf pid read back read_pid snprintf cmd max_cmd_buf kill read_pid system cmd printf fail termin haproxi &#34;); routin call cunit initi test suit use alloc data open resourc requir test case static int us4020_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us4020_logger_stderr els est_init_logg est_log_lvl_info null endif read certif cacerts_len read_binary_fil us4020_cacert cacert cacerts_len return us4020_clean (); start instanc est server automat enrol enabl us4020_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us4020_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv error check paramet api static void us4020_test1 void est_error e_rc est_ctx ectx null log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null attempt call api without context e_rc est_client_set_proxi null us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_no_ctx valid call e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set server e_rc est_client_set_proxi ectx null estus estpwd &#34;); cu_assert e_rc server empti string e_rc est_client_set_proxi ectx &#34;&#34;, estus estpwd &#34;); cu_assert e_rc max server name char max_server_nam 123456789012345 e_rc est_client_set_proxi ectx max_server_nam estus estpwd &#34;); cu_assert e_rc est_err_non server name long char long_server_nam 1234567890123456 e_rc est_client_set_proxi ectx long_server_nam estus estpwd &#34;); cu_assert e_rc set port e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi protocol invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi protocol invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc proxi auth invalid e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc max userid char max_userid 123456789012345 e_rc est_client_set_proxi ectx us4020_proxy_ip max_userid estpwd &#34;); cu_assert e_rc est_err_non userid long char long_userid 1234567890123456 e_rc est_client_set_proxi ectx us4020_proxy_ip long_userid estpwd &#34;); cu_assert e_rc userid empti string e_rc est_client_set_proxi ectx us4020_proxy_ip &#34;&#34;, estpwd &#34;); cu_assert e_rc max pwd char max_pwd 123456789012345 e_rc est_client_set_proxi ectx us4020_proxy_ip estus max_pwd cu_assert e_rc est_err_non pwd long char long_pwd 1234567890123456 e_rc est_client_set_proxi ectx us4020_proxy_ip estus long_pwd cu_assert e_rc password empti string e_rc est_client_set_proxi ectx us4020_proxy_ip estus &#34;&#34;); cu_assert e_rc est_destroy ectx test sock mode credenti pass static void us4020_test2 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode credenti pass static void us4020_test3 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode static void us4020_test4 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode static void us4020_test5 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode credenti static void us4020_test6 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode good credenti static void us4020_test7 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg goodcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx test sock mode good credenti forgotten static void us4020_test8 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg goodcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_ip_connect shutdown_antinat (); est_destroy ectx test sock mode bad credenti static void us4020_test9 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg badcr xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_ip_connect shutdown_antinat (); est_destroy ectx could test need certifc updat test sock mode domain name static void us4020_test8 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set sock proxi server local snprintf cmd max_4020_cmd antinat us4020 antinat cfg xml &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null socks4 e_rc est_client_set_proxi ectx us4020_proxy_ip null null cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_antinat (); est_destroy ectx endif test http proxi mode note non tunnel mode test tunnel mode work cisco est server static void us4020_test10 void int sys_rc est_error e_rc est_ctx ectx null char cmd max_4020_cmd evp_pkey key int pkcs7_len log_func_nm set http proxi server local snprintf cmd max_4020_cmd haproxi us4020 haproxi cfg haproxi pid &#34;); sys_rc system cmd cu_assert sys_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc est_client_set_proxi ectx us4020_proxy_ip estus estpwd &#34;); cu_assert e_rc est_err_non set authent mode use user password e_rc est_client_set_auth ectx us4020_uid us4020_pwd null null cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx us4020_server_ip null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr e_rc est_client_enrol ectx tc4020 pkcs7_len key cu_assert e_rc est_err_non shutdown_haproxi (); est_destroy ectx indic whether client proxi support built librari static int client_proxy_en void est_error e_rc e_rc est_client_set_proxi null null null null e_rc return els return main function set run test return cue_success success run anoth cunit error code failur int us4020_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us4020_tok_auth_cli us4020_init_suit us4020_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); ifndef win32 client proxi mode support libcurl specifi client_proxy_en ()){ add test suit null cu_add_test suit paramet check api us4020_test1 null cu_add_test suit sock mode us4020_test2 null cu_add_test suit sock mode credenti us4020_test3 null cu_add_test suit sock mode us4020_test4 null cu_add_test suit sock mode us4020_test5 null cu_add_test suit sock mode credenti us4020_test6 null cu_add_test suit sock mode good credenti us4020_test7 null cu_add_test suit sock mode forgotten credenti us4020_test8 null cu_add_test suit sock mode bad credenti us4020_test9 null cu_add_test suit sock mode domain name instead address us4020_test7 null cu_add_test suit http proxi us4020_test10 cu_cleanup_registri (); return cu_get_error (); endif return cue_success endif&#39;,
 &#39;unit test user stori client cacert june copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server max command line length generat system command defin est max cmd len defin est max certif use verifi est server grab server directori defin client cacert exampl server est cacert crt defin us897_server_port 29897 defin client_ut_pubkey &#34;./ defin us897_server_ip 127 defin us897_uid estus defin us897_pwd estpwd ifndef win32 defin client_ut_cacert est cacert crt defin us897_cacert est cacert crt defin us897_trust_cert trustedcert crt defin us897_server_certkey est privat estservercertandkey pem defin us897 crt defin us897 crt defin us897 singlechain_expir crt defin us897 trust chain10revok crt els defin client_ut_cacert est cacert crt defin us897_cacert est cacert crt defin us897_trust_cert trustedcert crt defin us897_server_certkey est privat estservercertandkey pem defin us897 crt defin us897 crt defin us897 singlechain_expir crt defin us897 trust chain10revok crt endif static void us897_clean void static int us897_start_serv int manual_enrol int nid int st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_cacert us897_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit generat keypair use est client suit static int us897_init_suit void int char cmd est_ut_max_cmd_len printf start est client unit test pdb &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us897_clean (); start instanc est server us897_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us897_destroy_suit void st_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test case initi est client context use local cert client cert valid public key userid password static void us897_test1 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return est_init_logg est_log_lvl_info null ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use local cert expect success initi sinc local trust anchor cert mandatori static void us897_test2 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init null est_cert_format_pem cu_assert ectx null ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use local cert client cert valid public key userid password static void us897_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use explict cert client cert valid public key userid password static void us897_test3 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey endif test case initi est client context use explict cert client cert public key userid password static void us897_test6 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx user password null priv_key cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case initi est client context use explict cert client cert public key userid password static void us897_test7 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx user null null priv_key cu_assert ectx est_destroy ectx ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx null password null priv_key cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test set server valid paramet static void us897_test9 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null cu_assert est_err_non ectx est_destroy ectx cacert free cacert pkey free pkey test case test set server invalid paramet static void us897_test10 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non char server_name_too_long evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non null server name est_client_set_serv ectx null us897_server_port null cu_assert server long est_client_set_serv ectx server_name_too_long us897_server_port null cu_assert port num less est_client_set_serv ectx us897_server_ip null cu_assert port num greater max est_client_set_serv ectx us897_server_ip 65536 null cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test get cacert request static void us897_test11 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert make sure context longer valid est client back uniniti state ectx cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test get cacert request invalid input paramet static void us897_test12 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx null success obtain valid buffer contain cert cu_assert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl certif static void us897_test13 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_cacert us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert static void us897_test14 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert miss cert chain static void us897_test15 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_cacert_verif cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_no_certif output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain singl chain multipl cert intermedi cert expir static void us897_test16 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read thestartup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_cacert_verif cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_no_certif output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test cert respons verif function verifi cacert respons contain multipl chain multipl cert crl block crls ignor static void us897_test17 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int stop exist server need ensur server use specif cert chain st_stop (); sleep spin new instanc est server use cert chain contain one cert st_start us897_server_port us897_server_certkey us897_server_certkey us897 test realm us897_trust_cert est exampl cnf cu_assert return sleep read startup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_non output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey test case test ssl read set timeout api set min max valu valu beyond max static void us897_test18 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key unsign char retrieved_cacert null int read startup certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us897_server_ip us897_server_port null ectx cu_assert est_err_non ectx cu_assert est_err_non ectx cu_assert ectx cu_assert est_err_non proceed get cacert verifi noth get broken issu get cert request ectx success obtain valid length size cert buffer cu_assert est_err_non cu_assert malloc call retrieved_cacert malloc ectx retrieved_cacert est fail indic cert provid cu_assert est_err_non output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us897_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us897_client_cacert us897_init_suit us897_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit est client init local privat key us897_test1 null cu_add_test suit est client init local us897_test2 null cu_add_test suit est client init local explicit privat key us897_test3 null cu_add_test suit est client init local explicit client privat key us897_test4 null cu_add_test suit est client init local userid password us897_test6 null cu_add_test suit est client init local userid password us897_test7 null cu_add_test suit est client init local userid password us897_test8 null cu_add_test suit est client set server correct paramet us897_test9 null cu_add_test suit est client set server paramet us897_test10 null cu_add_test suit est client cert ca_cert valid paramet us897_test11 null cu_add_test suit est client cert miss ca_cert pointer us897_test12 null cu_add_test suit est client cert verifi chain simpl chain success us897_test13 null cu_add_test suit est client cert verifi chain multipl cert success us897_test14 null cu_add_test suit est client cert verifi chain broken chain fail us897_test15 null cu_add_test suit est client cert verifi chain bad date fail us897_test16 null cu_add_test suit est client cert verifi chain multipl chain success us897_test17 null cu_add_test suit est client ssl read timeout api us897_test18 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori tls srp support server proxi may copyright cisco system inc right reserv includ stdio includ string ifndef win includ unistd includ pthread endif includ est includ curl curl includ test util includ curl util includ server includ proxi includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif defin server_port 31060 defin us1060_server_ip 127 defin us1060_uid estus defin us1060_pwd estpwd ifndef win32 defin us1060_cacert est cacert crt defin us1060_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1060_vfil us1060 passwd srpv defin us1060_explicit_cert us1060 explicit cert pem defin us1060_explicit_key us1060 explicit key pem defin us1060_selfsign_cert us1060 selfsign cert pem defin us1060_selfsign_key us1060 selfsign key pem els defin us1060_cacert est cacert crt defin us1060_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1060_vfil us1060 passwd srpv defin us1060_explicit_cert us1060 explicit cert pem defin us1060_explicit_key us1060 explicit key pem defin us1060_selfsign_cert us1060 selfsign cert pem defin us1060_selfsign_key us1060 selfsign key pem endif defin us1060_enroll_url https :// 127 31060 well known est simpleenrol defin us1060_uidpwd_good estus estpwd defin us1060_uidpwd_bad estus xxx111222 defin us1060_pkcs10_ct content type applic pkcs10 defin https :// 127 41060 well known est simpleenrol defin us1060_proxy_port 41060 defin us1060_pkcs10_req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w static char log_search_target null static int search_target_found static unsign char cacert null static int cacerts_len static srp_vbase srpdb null ifdef win32 critical_sect logger_critical_sect endif simpl callback use overrid default log facil libest use look specif debug output static void us1060_logger_stderr char format va_list char t_log 1024 ifndef win32 flockfil stderr els enter critic section logger_critical_sect endif log_search_target vsnprintf t_log 1024 format strstr t_log log_search_target search_target_found fprintf stderr t_log els vfprintf stderr format fflush stderr ifndef win32 funlockfil stderr els leav critic section logger_critical_sect endif static int us1060_start_serv char cert char key int no_http_auth int enable_pop int enable_srp int enable_srp st_start_srp us1060_server_port cert key us1060 test realm us1060_cacert us1060_trust_cert est exampl cnf enable_pop us1060_vfil els st_start us1060_server_port cert key us1060 test realm us1060_cacert us1060_trust_cert est exampl cnf enable_pop no_http_auth st_disable_http_auth (); return routin call cunit initi test suit use alloc data open resourc requir test case static int us1060_init_suit void int ifdef win32 initi critic section window initi critic section logger_critical_sect endif est_init_logg est_log_lvl_info us1060_logger_stderr start instanc est server automat enrol enabl us1060_start_serv start instanc proxi srp enabl st_proxy_start_srp us1060_proxy_port us1060 proxi realm us1060_cacert us1060_trust_cert us1060_uid us1060_pwd us1060_server_ip us1060_server_port us1060_vfil read certif use client side api test cacerts_len read_binary_fil us1060_cacert cacert cacerts_len return srpdb srp_vbase_new null srpdb printf (&#34;\\ unabl alloc srp verifi databas abort !!!\\ &#34;); srp_vbase_init srpdb us1060_vfil srp_no_error printf (&#34;\\ unabl initi srp verifi databas abort !!!\\ &#34;); return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1060_destroy_suit void srpdb srp_vbase_fre srpdb st_stop (); st_proxy_stop (); free cacert return typedef enum srp_off srp_on server_srp_mod typedef enum srp_good srp_bad srp_none client_srp_mod typedef enum http_off http_option http_requir server_http_mod typedef struct char test_nam char curl_cert char curl_key char curl_http_auth client_srp_mod curl_srp server_http_mod server_http server_srp_mod server_srp int expected_http_result us1060_matrix unit test matrix server side srp support curl use est client disabl server test case tri cover varieti configur potenti scenario client side variat includ curl_cert certif curl use may null curl_key key curl use may null curl_http_auth http auth credenti use curl client_srp_mod either good bad none determin srp credenti use curl server side configur server use follow variat server_http_mod http auth requir option disabl option mean occur tls auth fail server_srp_mod srp either enabl disabl server expected_http_result expect http status code receiv curl srp fail result fail tls session curl return zero case sinc http layer communic tls succeed http auth fail server return http 401 respons client enrol succeed server send http 200 respons static us1060_matrix test_matrix null null us1060_uidpwd_good srp_good http_requir srp_on 200 null null us1060_uidpwd_good srp_bad http_requir srp_on null null us1060_uidpwd_good srp_none http_requir srp_on 200 null null us1060_uidpwd_good srp_good http_option srp_on 200 null null us1060_uidpwd_good srp_bad http_option srp_on null null us1060_uidpwd_good srp_none http_option srp_on 200 null null us1060_uidpwd_good srp_good http_off srp_on 200 null null us1060_uidpwd_good srp_bad http_off srp_on null null us1060_uidpwd_good srp_none http_off srp_on 401 null null us1060_uidpwd_bad srp_good http_requir srp_on 401 null null us1060_uidpwd_bad srp_bad http_requir srp_on null null us1060_uidpwd_bad srp_none http_requir srp_on 401 null null us1060_uidpwd_bad srp_good http_option srp_on 200 null null us1060_uidpwd_bad srp_bad http_option srp_on null null us1060_uidpwd_bad srp_none http_option srp_on 401 null null us1060_uidpwd_bad srp_good http_off srp_on 200 null null us1060_uidpwd_bad srp_bad http_off srp_on null null us1060_uidpwd_bad srp_none http_off srp_on 401 null null us1060_uidpwd_good srp_good http_requir srp_off null null us1060_uidpwd_good srp_bad http_requir srp_off null null us1060_uidpwd_good srp_none http_requir srp_off 200 null null us1060_uidpwd_good srp_good http_option srp_off null null us1060_uidpwd_good srp_bad http_option srp_off null null us1060_uidpwd_good srp_none http_option srp_off 200 null null us1060_uidpwd_good srp_good http_off srp_off null null us1060_uidpwd_good srp_bad http_off srp_off null null us1060_uidpwd_good srp_none http_off srp_off 401 null null us1060_uidpwd_bad srp_good http_requir srp_off null null us1060_uidpwd_bad srp_bad http_requir srp_off null null us1060_uidpwd_bad srp_none http_requir srp_off 401 null null us1060_uidpwd_bad srp_good http_option srp_off null null us1060_uidpwd_bad srp_bad http_option srp_off null null us1060_uidpwd_bad srp_none http_option srp_off 401 null null us1060_uidpwd_bad srp_good http_off srp_off null null us1060_uidpwd_bad srp_bad http_off srp_off null null us1060_uidpwd_bad srp_none http_off srp_off 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_requir srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_requir srp_on 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_option srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_option srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_off srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_off srp_on 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_requir srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_requir srp_off 401 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_option srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_option srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_good srp_none http_off srp_off 200 us1060_explicit_cert us1060_explicit_key us1060_uidpwd_bad srp_none http_off srp_off 200 us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_requir srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_requir srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_option srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_option srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_off srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_off srp_on us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_requir srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_requir srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_option srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_option srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_good srp_none http_off srp_off us1060_selfsign_cert us1060_selfsign_key us1060_uidpwd_bad srp_none http_off srp_off worker entri test matrix read configur entri configur server client need attempt simpl enrol use curl client argument index entri tabl static void int long log_func_nm printf (&#34;\\ run matrix test test_matrix test_nam stop server restart make sure correct mode st_stop (); sleep test_matrix server_srp srp_on us1060_start_serv els us1060_start_serv cu_assert set server http auth configur switch test_matrix server_http case http_off st_disable_http_auth (); break case http_option st_enable_http_auth (); st_set_http_auth_opt (); break case http_requir st_enable_http_auth (); (); break switch test_matrix curl_srp case srp_good curl_http_post_srp us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth null curlauth_bas null srp_user srp_pwd null null break case srp_bad curl_http_post_srp us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth null curlauth_bas null srp_user boguspwd null null break case srp_none srp disabl test case use client certif test_matrix curl_cert us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth test_matrix curl_cert test_matrix curl_key us1060_cacert null els curl_http_post us1060_enroll_url us1060_pkcs10_ct us1060_pkcs10_req test_matrix curl_http_auth us1060_cacert curlauth_bas null null null break cu_assert test_matrix expected_http_result test_matrix expected_http_result printf (&#34;\\ matrix test fail test_matrix test_nam int test case run test matrix static void us1060_test0 void int int test_cnt sizeof test_matrix sizeof test_matrix ]); test_cnt ++) test case verifi happi path est proxi configur srp mode client attempt use srp connect proxi server use srp perform simpl enrol oper static void us1060_test200 void long log_func_nm restart est server srp disabl st_stop (); sleep us1060_start_serv cu_assert curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_good null curlauth_bas null srp_user srp_pwd null null sinc pass valid srp user password expect server respond success cu_assert 200 test case verifi simpl enrol fail est client provid bad srp password connect proxi server use srp static void us1060_test201 void long log_func_nm curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_good null curlauth_bas null srp_user boguspwd null null cu_assert test case verifi simpl enrol fail est client provid bad http password srp use connect proxi server use srp static void us1060_test202 void long log_func_nm curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req us1060_uidpwd_bad null curlauth_bas null srp_user srp_pwd null null cu_assert 401 test case verifi simpl enrol work est client provid http password srp use connect proxi server use srp http auth disabl proxi static void us1060_test203 void long log_func_nm st_proxy_http_dis curl_http_post_srp us1060_pkcs10_ct us1060_pkcs10_req null null curlauth_non null srp_user srp_pwd null null cu_assert 200 int us1060_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1060_tls_srp server proxi )&#34;, us1060_init_suit us1060_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit tls srp server matrix master us1060_test0 null cu_add_test suit tls srp proxi enrol srp us1060_test200 null cu_add_test suit tls srp proxi enrol bad srp pwd us1060_test201 null cu_add_test suit tls srp proxi enrol bad http pwd us1060_test202 null cu_add_test suit tls srp proxi enrol http auth us1060_test203 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori server csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif defin server port defin server ifndef win defin client ut_cacert est cacert crt defin client_ut_pubkey &#34;./ defin us900_cacert est cacert crt defin us900_trust_cert trustedcert crt defin us900_server_certkey est privat estservercertandkey pem els defin client_ut_cacert est cacert crt defin client_ut_pubkey defin us900_cacert est cacert crt defin us900_trust_cert trustedcert crt defin us900_server_certkey est privat estservercertandkey pem endif defin test_attr_pop mas gcsq gsib3dqejbw ==\\ defin test_attr_nopop mhew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg ==\\ defin test_attr_nopoppop mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr_popad mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr1 mcygbi gaqebarygcsq gsib3dqejbw yfk4eeacigcwcgsafl qcag ==\\ defin test_attr2 maa defin test_attr7 ==\\ defin test_attr2_pop mas gcsq gsib3dqejbw ==\\ defin test_attr8 mathisi bad gcsq gsib3dqejbw ==\\ defin test_attr3 migsmfg ga4g3aj frexl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku ncbk yxrh bgkqhki g9w0bcqcw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebari defin test_attr4_122 mhow laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr4_122pop migfmcw ga4g3aj oinw mga4g3bbmzugfyc2ug u0vuigfz idiu otk5lj jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebarygcsq gsib3dqejbw ==\\ defin test_attr5_117 mhuw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebari defin test_attr5_117pop migamcc ga4g3aj oinw mga4g3bbmuugfyc2ug u0vuigfz idiu otk5lj igcwcgsafl qcag yjki qdaw iiaqelmciga4g3ateb exl qyxjz zsbtrvqg yxmg mi45otku msbk yxrh bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_attr6_116 mhqw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw iqydi bmro tgfbhcn ifnfvcbhci ljk5os4x igrhd ayhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr_244 mih1mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey qgbys gaqebarygbi gaqebari defin test_attr_245 mih2mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1bgcr ebaqewbgcr ebaqew defin test_attr_250 mih7mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_attr_250pop miibbj oinw xqydi dbg oinw qtuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_all_attr mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfmtiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin test_1024_nopop miid dcca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_1025_nopop miid tcca2qga4g3aj gca1 ga4g3aw ydi eeisx m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_1024_pop miiebz cca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg yjko zihvc naqk defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin est_ut_max_cmd_len 255 extern est_ctx ectx static void us900_clean void static int us900_start_serv int manual_enrol int nid int st_start us900_server_port us900_server_certkey us900_server_certkey us900 test realm us900_cacert us900_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us900_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us900_clean (); start instanc est server us900_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us900_destroy_suit void st_stop (); sleep return static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr1 csr_data malloc csr_len strncpi char csr_data test_attr1 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr8 csr_data malloc csr_len strncpi char csr_data test_attr8 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr7 csr_data malloc csr_len strncpi char csr_data test_attr7 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_long_attr csr_data malloc csr_len strncpi char csr_data test_long_attr csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr_nopop csr_data malloc csr_len strncpi char csr_data test_attr_nopop csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len csr_data null return csr_data callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis api static void us900_test1 void int log_func_nm null ctx fail null us900 test1 cu_assert est_err_non null string pass ectx null cu_assert est_err_non zero length fail ectx us900 test1 cu_assert est_err_non length long fail ectx us900 test1 max_csrattr cu_assert est_err_non real base64 string fail ectx us900 test1 cu_assert est_err_non real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non set smallest base64 size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non set illeg small base64 size ectx test_attr7 strlen test_attr7 )); cu_assert est_err_non set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non enabl st_enable_pop (); real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non real base64 string fail ectx us900 test1 cu_assert est_err_non set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non disabl st_disable_pop (); asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non test2 exercis server side variat trigger static void us900_test2 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key int csr_len unsign char csr_data null sleep log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us900_server_ip us900_server_port null issu get cert request ctx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ctx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit clear csrattr ectx null cu_assert est_err_non get 204 data ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2 )); cu_assert strncmp test_attr2 const char csr_data csr_len ectx test_attr3 strlen test_attr3 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr3 )); cu_assert strncmp test_attr3 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_nopop )); cu_assert strncmp test_1024_nopop const char csr_data csr_len enabl test respons st_enable_pop (); ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_data null cu_assert csr_len cu_assert strncmp test_attr_pop const char csr_data csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_pop )); cu_assert strncmp test_1024_pop const char csr_data csr_len set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr4_122pop )); cu_assert strncmp test_attr4_122pop const char csr_data csr_len set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr5_117pop )); cu_assert strncmp test_attr5_117pop const char csr_data csr_len real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len real base64 string fail ectx us900 test1 cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_250pop )); cu_assert strncmp test_attr_250pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len disabl st_disable_pop (); clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopop )); cu_assert strncmp test_attr_nopop const char csr_data csr_len asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_all_attr )); cu_assert strncmp test_all_attr const char csr_data csr_len ectx test_1025_nopop strlen test_1025_nopop )); cu_assert est_err_non ectx test_long_attr strlen test_long_attr )); cu_assert est_err_non ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us900_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us900_srv_csrattr us900_init_suit us900_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr server attribut api1 us900_test1 null cu_add_test suit csr server attribut api2 us900_test2 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori client csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif ifndef win defin client cacert est cacert crt defin cacert est cacert crt defin trust cert trustedcert crt defin 96_server_certkey est privat estservercertandkey pem els defin client_ut_cacert est cacert crt defin us896_cacert est cacert crt defin us896_trust_cert trustedcert crt defin us896_server_certkey est privat estservercertandkey pem endif defin client_ut_pubkey &#34;./ defin us896_server_port 29896 defin us896_server_ip 127 defin test_short_attr ==\\ defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin test_corrupt_attr1 mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oiex mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_corrupt_attr2 mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfm12345tiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin est_ut_max_cmd_len 255 static void us896_clean void static int us896_start_serv int manual_enrol int nid int st_start us896_server_port us896_server_certkey us896_server_certkey us896 test realm us896_cacert us896_trust_cert est exampl cnf manual_enrol nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us896_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us896_clean (); start instanc est server us896_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us896_destroy_suit void st_stop (); sleep return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis api static void us896_test1 void int unsign char csr_data int csr_len est_ctx ctx null log_func_nm ctx csr_data csr_len cu_assert est_err_non ctx null csr_len cu_assert est_err_non ctx csr_data null cu_assert est_err_non test2 exercis respons variat trigger static void us896_test2 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key sleep log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us896_server_ip us896_server_port null issu get cert request ctx success obtain valid buffer contain cert cu_assert est_err_non cu_assert retrieved_cacert malloc ctx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert negat test requir code est server modifi allow bad corrupt attribut initi sent client ifdef negative_unit_test unsign char csr_data int csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ectx test_corrupt_attr1 strlen test_corrupt_attr1 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_corrupt_attr2 strlen test_corrupt_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_short_attr strlen test_short_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null ectx test_long_attr strlen test_long_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null endif ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us896_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us896_client_csrattr us896_init_suit us896_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr client attribut api1 us896_test1 null cu_add_test suit csr client attribut api2 us896_test2 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori proxi cacert novemb copyright cisco system inc right reserv proxi mode primarili server mode process certain request client pass long upstream server use client mode function case get cacert proxi mode function almost ident server mode cert respons chain pass sent repli get cacert request downstream client test code taken larg server get cacert includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ openssl ssl includ server includ proxi ifdef cunit includ cunit basic includ cunit autom endif defin pkcs req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w defin us894_pkcs10_ct content type applic pkcs10 defin us894_uidpwd_good estus estpwd defin us894_uidpwd_bad estus bogus ifndef win32 defin us894_cacert est cacert crt defin us894_trusted_cert trustedcert crt defin us894 trustedcertsandcrl crt defin us894_explicit_cert us894 explicit cert pem defin us894_explicit_key us894 explicit key pem defin us894_implicit_cert us894 implicit cert pem defin us894_implicit_key us894 implicit key pem defin us894_revoked_cert us894 revok cert pem defin us894_revoked_key us894 revok key pem defin us894_selfsign_cert us894 selfsign cert pem defin us894_selfsign_key us894 selfsign key pem defin us894_cacert est cacert crt defin us894_extcert ext cacert crt defin us894_server_cert est privat estservercertandkey pem defin us894_server_key est privat estservercertandkey pem defin us894_proxy_cert est privat estservercertandkey pem chang dedic one defin us894_proxy_key est privat estservercertandkey pem static char test5_outfil filename_max us894 test5 crt static char test26_outfil filename_max us894 test26 crt static char test27_outfil filename_max us894 test27 crt els defin us894_cacert est cacert crt defin us894_trusted_cert trustedcert crt defin us894 trustedcertsandcrl crt defin us894_explicit_cert us894 explicit cert pem defin us894_explicit_key us894 explicit key pem defin us894_implicit_cert us894 implicit cert pem defin us894_implicit_key us894 implicit key pem defin us894_revoked_cert us894 revok cert pem defin us894_revoked_key us894 revok key pem defin us894_selfsign_cert us894 selfsign cert pem defin us894_selfsign_key us894 selfsign key pem defin us894_cacert est cacert crt defin us894_extcert ext cacert crt defin us894_server_cert est privat estservercertandkey pem defin us894_server_key est privat estservercertandkey pem defin us894_proxy_cert est privat estservercertandkey pem chang dedic one defin us894_proxy_key est privat estservercertandkey pem static char test5_outfil filename_max us894 test5 crt static char test26_outfil filename_max us894 test26 crt static char test27_outfil filename_max us894 test27 crt endif defin 12894 defin us894_enroll_url https :// 127 16894 well known est simpleenrol defin us894_cacert_url https :// 127 16894 well known est cacert defin 13894 defin 14894 defin 15894 defin us894_tcp_proxy_port 16894 static void us894_clean void char cmd 200 ifndef win32 sprintf cmd test5_outfil system cmd sprintf cmd test26_outfil system cmd sprintf cmd test27_outfil system cmd els sprintf cmd del test5_outfil system cmd sprintf cmd del test26_outfil system cmd sprintf cmd del test27_outfil system cmd endif int us894_start_serv int first start est server act st_start us894_server_cert us894_server_key estrealm us894_cacert us894_trusted_cert us894 est exampl cnf manual enrol disabl ecdh nid info sleep est_err_non return next start est proxi act st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us894_init_suit void int us894_clean (); printf (&#34;\\ start est proxi get cacert unit test &#34;); start instanc est server automat enrol enabl us894_start_serv (); return void us894_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit uniniti test suit use dealloc data close resourc use test case static int us894_destroy_suit void us894_stop_serv (); printf complet est proxi get cacert unit test &#34;); return http basic auth test case use libcurl test http basic authent work est proxi server must use simpleenrol messag sinc cacert messag requir client authent static void us894_test1 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 http basic auth failur bad password test case use libcurl test http basic authent work est proxi server use bogus password must use simpleenrol messag sinc cacert messag requir client authent static void us894_test2 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 400 cu_assert 401 http digest auth test case use libcurl test http digest authent work est proxi server must use simpleenrol messag sinc cacert messag requir client authent test also test correct oper est_proxy_set_auth static void us894_test3 void long log_func_nm st_proxy_set_auth auth_digest sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_digest null null null sinc pass valid user password expect server respond success cu_assert 200 st_proxy_set_auth auth_bas http digest auth fail test case use libcurl test http digest authent work est proxi server negat test case digest auth must use simpleenrol messag sinc cacert messag requir client authent est proxi server run listen port 8087 prior test run static void us894_test4 void long log_func_nm st_proxy_set_auth auth_digest sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_cacert curlauth_digest null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_proxy_set_auth auth_bas static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written test case simpl cacert request look http 200 respons code static void us894_test5 void long char cmd 200 log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_get us894_cacert_url us894_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test5_outfil system cmd cu_assert static void us894_test_sslvers const ssl_method int expect_fail bio conn ssl ssl ssl_ctx ssl_ctx null int ssl_ctx ssl_ctx_new cu_assert ssl_ctx null ssl context readi open socket server bind socket context conn open_tcp_socket_ipv4 127 16894 &#34;); cu_assert conn null creat ssl session context ssl ssl_new ssl_ctx ssl_set_bio ssl conn conn everyth readi let initi tls handshak ssl_connect ssl expect_fail cu_assert els cu_assert cleanup data ssl_shutdown ssl ssl_free ssl ssl_ctx_free ssl_ctx test attempt creat ssl connect est server fail tls allow static void us894_test6 void log_func_nm us894_test_sslvers sslv3_client_method (), test attempt creat tls connect est server fail tls allow static void us894_test7 void log_func_nm us894_test_sslvers tlsv1_client_method (), test attempt creat tls connect est server succeed static void us894_test8 void log_func_nm us894_test_sslvers (), test attempt creat tls connect est server succeed static void us894_test9 void log_func_nm us894_test_sslvers (), test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain succeed static void us894_test10 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_explicit_cert us894_explicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_proxy_http_dis printf could set http authent callback &#34;); return test attempt use client certif verifi tls client authent work certif use sign implicit cert chain succeed static void us894_test11 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_implicit_cert us894_implicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_proxy_http_dis printf could set http authent callback &#34;); return test attempt use revok client certif verifi crl check work tls layer fail static void us894_test12 void long log_func_nm st_proxy_stop (); st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert estus estpwd 127 disabl ecdh nid info sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_revoked_cert us894_revoked_key us894_cacert null sinc client cert revok tls handshak fail est server return 401 respons cu_assert st_proxy_stop (); st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info test attempt use self sign client certif verifi cert chain reject cert sign valid fail static void us894_test13 void long log_func_nm sleep curl_http_post_cert us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_selfsign_cert us894_selfsign_key us894_cacert null sinc client cert sign either local extern tls handshak fail receiv http status messag server cu_assert tls anonym cipher suit disabl test case use libcurl test est server accept anonym cipher suit client test singl cipher suit attempt simpl enrol server static void us894_test14 void long log_func_nm sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas adh aes128 sha256 null null tls handshak fail curl return cu_assert null http realm initi server static void us894_test15 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null realm est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem null priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key null server certif initi server static void us894_test16 void unsign char cacert null int cacerts_len bio keyin evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null server key est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null priv_key estus estpwd &#34;); cu_assert ctx null evp_pkey_fre priv_key null server certif privat key initi server static void us894_test17 void unsign char cacert null int cacerts_len bio certin x509 int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin attempt init est proxi use null privat key est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null estus estpwd &#34;); cu_assert ctx null x509_free null trust chain initi server static void us894_test18 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null local chain est_init_logg est_log_lvl_info null ctx est_proxy_init null null est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key corrupt chain initi server static void us894_test19 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi corrupt chain est_init_logg est_log_lvl_info null ctx est_proxy_init unsign char bogus chain unsign char bogus chain est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key test case attempt simpl cacert request use post instead get fail static void us894_test20 void long log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_post us894_cacert_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null fclose outfil expect server respond 400 cu_assert 400 test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain valid http authent credenti also provid succeed static void us894_test21 void long log_func_nm sleep us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_explicit_cert us894_explicit_key us894_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain invalid http authent credenti also provid fail 401 respons static void us894_test22 void long log_func_nm sleep us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_bad us894_explicit_cert us894_explicit_key us894_cacert null sinc pass invalid user password expect server respond 401 cu_assert 401 test attempt enrol without use certif ident client use good user pwd howev est server setup perform certif authent http auth disabl fail 401 respons static void us894_test23 void long log_func_nm st_proxy_http_dis printf could set http authent callback &#34;); return sleep curl_http_post us894_enroll_url us894_pkcs10_ct us894_pkcs10_req us894_uidpwd_good us894_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 401 cu_assert 401 st_proxy_http_dis printf could set http authent callback &#34;); return test paramet est_proxy_set_serv static void us894_test24 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est proxi mode est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null est_rv est_proxy_set_serv null 127 8080 cu_assert est_rv est_err_no_ctx est_rv est_proxy_set_serv ctx null 8080 cu_assert est_rv est_rv est_proxy_set_serv ctx 127 65536 cu_assert est_rv x509_free evp_pkey_fre priv_key test paramet static void us894_test25 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est proxi mode est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key estus estpwd &#34;); cu_assert ctx null est_rv ctx auth_non cu_assert est_rv est_err_bad_mod est_rv ctx auth_bas cu_assert est_rv est_err_non est_rv ctx auth_digest cu_assert est_rv est_err_non est_rv ctx 0xffffffff cu_assert est_rv est_err_bad_mod est_rv null auth_bas cu_assert est_rv est_err_no_ctx x509_free evp_pkey_fre priv_key test option set cert respons chain est_proxy_init test passthrough cach disabl mode cert respons chain static void us894_test26 void long char cmd 200 log_func_nm st_proxy_stop (); sleep restart proxi without pass cert respons chang paramet param st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm null us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep outfil fopen test26_outfil &#34;); curl_http_get us894_cacert_url us894_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test26_outfil system cmd cu_assert restart proxi includ cert respons chain st_proxy_stop (); sleep st_proxy_start us894_tcp_proxy_port us894_proxy_cert us894_proxy_key estrealm us894_cacert us894_trusted_cert estus estpwd 127 disabl ecdh nid info sleep test pass bad userid password valu est_proxy_init make sure error check static void us894_test27 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us894_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us894_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us894_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est proxi use null userid est_init_logg est_log_lvl_info null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem estrealm priv_key null estpwd &#34;); cu_assert ctx null ctx est_proxy_init cacert cacerts_len cacert cacerts_len est_cert_format_pem estrealm priv_key estpwd &#34;); cu_assert ctx null x509_free evp_pkey_fre priv_key main function set run test return cue_success success run anoth cunit error code failur int us894_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us894_proxy_cacert us894_init_suit us894_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit http basic auth us894_test1 null cu_add_test suit http basic auth fail us894_test2 null cu_add_test suit http digest auth us894_test3 null cu_add_test suit http digest auth fail us894_test4 null cu_add_test suit get certif us894_test5 null cu_add_test suit ssl fail us894_test6 null cu_add_test suit tls fail us894_test7 null cu_add_test suit tls us894_test8 null cu_add_test suit tls us894_test9 null cu_add_test suit certif auth explicit cert chain us894_test10 null cu_add_test suit certif auth implicit cert chain us894_test11 null cu_add_test suit certif auth revok cert us894_test12 null cu_add_test suit certif auth self sign cert us894_test13 null cu_add_test suit anon cipher suit disabl us894_test14 null cu_add_test suit null realm us894_test15 null cu_add_test suit null server cert us894_test16 null cu_add_test suit null server key us894_test17 null cu_add_test suit null local chain us894_test18 null cu_add_test suit corrupt local chain us894_test19 null cu_add_test suit http post cacert us894_test20 null cu_add_test suit simpl enrol good http auth good cert us894_test21 null cu_add_test suit simpl enrol bad http auth good cert us894_test22 null cu_add_test suit simpl enrol http auth cert us894_test23 null cu_add_test suit set server invalid paramet us894_test24 null cu_add_test suit set auth mode invalid paramet us894_test25 null cu_add_test suit option chain respons us894_test26 null cu_add_test suit bad userid password proxi init us894_test27 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori client easi provis novemb copyright cisco system inc right reserv includ stdio includ string ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif ifdef win static critic section logger critic section endif static unsign char cacert null static int cacert len defin server port defin us1005_server_ip 127 defin us1005_uid estus defin us1005_pwd estpwd ifndef win32 defin us1005_cacert est cacert crt defin us1005_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1005_client_key us1005 implicit key pem defin us1005_client_cert us1005 implicit cert pem els defin us1005_cacert est cacert crt defin us1005_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us1005_client_key us1005 implicit key pem defin us1005_client_cert us1005 implicit cert pem endif defin us1005_csr_nopop mbqgbys gaqebarygcwcgsafl qcag ==\\ static char log_search_target null static int search_target_found simpl callback use overrid default log facil libest use look specif debug output static void us1005_logger_stderr char format va_list char t_log 1024 ifndef win32 flockfil stderr els enter critic section logger_critical_sect endif log_search_target vsnprintf t_log 1024 format strstr t_log log_search_target search_target_found fprintf stderr t_log els vfprintf stderr format fflush stderr ifndef win32 funlockfil stderr els leav critic section logger_critical_sect endif static void us1005_clean void static int us1005_start_serv int manual_enrol int nid int no_http_auth int enable_pop int st_start us1005_server_port us1005 test realm us1005_cacert us1005_trust_cert est exampl cnf manual_enrol enable_pop nid no_http_auth st_disable_http_auth (); return routin call cunit initi test suit use alloc data open resourc requir test case static int us1005_init_suit void int ifdef win32 initi critic section window initi critic section logger_critical_sect endif est_init_logg est_log_lvl_info us1005_logger_stderr read certif cacerts_len read_binary_fil us1005_cacert cacert cacerts_len return us1005_clean (); start instanc est server automat enrol enabl us1005_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1005_destroy_suit void st_stop (); free cacert return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function perform easi provis oper use uid pwd identifi client server use varieti test case modul static void us1005_easy_provis char char server int ba_hint int use_cert est_ctx ectx evp_pkey new_key int int pkcs7_len int ca_certs_len unsign char new_cert null evp_pkey key null unsign char key_raw int key_len unsign char cert_raw int cert_len x509 cert null bio creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null use_cert read privat key key_len read_binary_fil us1005_client_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us1005_client_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use user password est_client_set_auth ectx us1005_uid us1005_pwd cert key cu_assert est_err_non ba_hint ectx cu_assert est_err_non set est server address port est_client_set_serv ectx server us1005_server_port null generat new privat key new_key generate_private_key (); cu_assert new_key null attempt provis new cert ectx pkcs7_len ca_certs_len new_key cu_assert est_err_non evp_pkey_fre new_key retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non new_cert free new_cert els est_destroy ectx return retriev copi new cert est_err_non new_cert malloc ca_certs_len cu_assert new_cert null ectx new_cert cu_assert est_err_non new_cert free new_cert els est_destroy ectx return evp_pkey_fre key x509_free cert cleanup est_destroy ectx easi provis http basic auth client cert basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test1 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis http basic auth hint enabl client cert basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test2 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test3 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth hint enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test4 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip null pointer test static void us1005_test5 void int p7len int calen evp_pkey key int est_ctx ectx log_func_nm creat valid context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us1005_uid us1005_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us1005_server_ip us1005_server_port null creat valid key pair key generate_private_key (); cu_assert key null tri null context null test2 p7len calen key cu_assert est_err_no_ctx tri null length ectx test2 null calen key cu_assert tri null cacert length ectx test2 p7len null key cu_assert tri null key ectx test2 p7len calen null cu_assert est_err_no_key evp_pkey_fre key est_destroy ectx enabl pop server enabl csr attribut server challeng password oid static void us1005_test6 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut valu includ challeng password oid st_set_csrattr us1005_csr_nopop search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server enabl csr attribut server challeng password oid static void us1005_test7 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut valu includ challeng password oid st_set_csrattr us1005_csr_nopop search debug appropri output confirm behavior work desir log_search_target cert request contain search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null enabl pop server enabl csr attribut server challeng password oid static void us1005_test8 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server enabl csr attribut server challeng password oid static void us1005_test9 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null enabl pop server disabl csr attribut server static void us1005_test10 void log_func_nm restart server enabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null st_disable_csr_cb (); search debug appropri output confirm behavior work desir log_search_target client includ challeng password csr search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null disabl pop server disabl csr attribut server static void us1005_test11 void log_func_nm restart server disabl st_stop (); us1005_start_serv set csr attribut default valu includ challeng password oid st_set_csrattr null st_disable_csr_cb (); search debug appropri output confirm behavior work desir log_search_target cert request contain search_target_found provis new cert us1005_easy_provis tc1005 us1005_server_ip cu_assert search_target_found set csr attribut back default valu st_set_csrattr null next two test cae repeat test http auth disabl server easi provis client cert http basic auth disabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test93 void log_func_nm restart server http auth disabl st_stop (); us1005_start_serv us1005_easy_provis tc1005 us1005_server_ip easi provis client cert http basic auth hint enabl basic test perform full trust enrol sequenc cacert csrattr simpleenrol use user password identifi client server ident certif use client static void us1005_test94 void log_func_nm us1005_easy_provis tc1005 us1005_server_ip int us1005_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1005_init_suit us1005_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit ******************** import chang order test test stop est server restart use differ cert chang order fals negat may occur null cu_add_test suit easi provis cert us1005_test1 null cu_add_test suit easi provis cert http hint us1005_test2 null cu_add_test suit easi provis cert us1005_test3 null cu_add_test suit easi provis cert http hint us1005_test4 null cu_add_test suit null pointer us1005_test5 null cu_add_test suit enabl challeng password us1005_test6 null cu_add_test suit disabl challeng password us1005_test7 null cu_add_test suit enabl challeng password us1005_test8 null cu_add_test suit disabl challeng password us1005_test9 null cu_add_test suit enabl csr disabl us1005_test10 null cu_add_test suit disabl csr disabl us1005_test11 null cu_add_test suit easi provis cert server auth us1005_test93 null cu_add_test suit easi provis cert http hint server auth us1005_test94 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori client enrol octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ est ossl util includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin server defin us898_uid estus defin us898_pwd estpwd ifndef win32 defin us898_cacert est cacert crt defin us898_trust_cert trustedcert crt defin us898_server_certkey est privat estservercertandkey pem defin us898_tc2_cert_txt us898 tc2 new cert txt defin us898_tc2_cert_b64 us898 tc2 new cert pkcs7b64 defin us898_tc2_cert_pk7 us898 tc2 new cert pkcs7 defin us898_tc2_cert_pem us898 tc2 new cert pem defin us898_tc10_csr us898 tc10_csr pem defin us898_tc10_key us898 tc10_key pem defin us898_tc10_cert us898 tc10_cert pem defin us898_tc11_key us898 tc11_key pem defin us898_tc11_cert us898 tc11_cert pem els defin us898_cacert est cacert crt defin us898_trust_cert trustedcert crt defin us898_server_certkey est privat estservercertandkey pem defin us898_tc2_cert_txt us898 tc2 new cert txt defin us898_tc2_cert_b64 us898 tc2 new cert pkcs7b64 defin us898_tc2_cert_pk7 us898 tc2 new cert pkcs7 defin us898_tc2_cert_pem us898 tc2 new cert pem defin us898_tc10_csr us898 tc10_csr pem defin us898_tc10_key us898 tc10_key pem defin us898_tc10_cert us898 tc10_cert pem defin us898_tc11_key us898 tc11_key pem defin us898_tc11_cert us898 tc11_cert pem static critical_sect logger_critical_sect static void us898_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static void us898_clean void char cmd 200 temporari file creat various test case ifndef win32 sprintf cmd us898_tc2_cert_txt system cmd sprintf cmd us898_tc2_cert_b64 system cmd sprintf cmd us898_tc2_cert_pk7 system cmd sprintf cmd us898_tc2_cert_pem system cmd sprintf cmd us898_tc10_cert system cmd sprintf cmd us898_tc10_key system cmd sprintf cmd us898_tc10_csr system cmd els sprintf cmd del us898_tc2_cert_txt system cmd sprintf cmd del us898_tc2_cert_b64 system cmd sprintf cmd del us898_tc2_cert_pk7 system cmd sprintf cmd del us898_tc2_cert_pem system cmd sprintf cmd del us898_tc10_cert system cmd sprintf cmd del us898_tc10_key system cmd sprintf cmd del us898_tc10_csr system cmd endif start instanc est server run separ thread use test client side api modul static int us898_start_serv int manual_enrol int nid int st_start us898_server_port us898_server_certkey us898_server_certkey estrealm us898_cacert us898_trust_cert us898 est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us898_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us898_logger_stderr endif read certif cacerts_len read_binary_fil us898_cacert cacert cacerts_len return us898_clean (); start instanc est server automat enrol enabl us898_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us898_destroy_suit void st_stop (); free cacert return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv openssl_cert_error return print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur bio_fre bio_err return approv function perform basic simpl enrol use uid pwd identifi client server use variet test case modul static void us898_test1 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_non est_err_non return retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non convert cert x509 warn pure hackeri b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null wow lot work final x509 love open ssl !!!) x509 represent cert let tri enrol cert est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx test case use exist expir cert attempt enrol expir cert contain sever x509 extens verifi new issu cert preserv extens use grep note preserv extens requir open ssl enabl copy_extens knob open ssl config file test suit use uniqu copi est exampl cnf static void us898_test2 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len unsign char new_cert null x509 cert null bio char cmd 200 unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non save cert local file write_binary_fil us898_tc2_cert_b64 new_cert pkcs7_len cu_assert base decod cert respons sprintf cmd openssl base64 us898_tc2_cert_b64 us898_tc2_cert_pk7 system cmd cu_assert convert pkcs7 cert pem cert sprintf cmd openssl pkcs7 inform der print_cert us898_tc2_cert_pk7 us898_tc2_cert_pem system cmd cu_assert convert pem cert textual represent cert sprintf cmd openssl x509 text us898_tc2_cert_pem us898_tc2_cert_txt system cmd cu_assert verifi jimbob dns extens preserv grep us898_tc2_cert_txt jimbob &#34;); cu_assert verifi bobcat dns extens preserv grep us898_tc2_cert_txt bobcat &#34;); cu_assert verifi address extens preserv grep us898_tc2_cert_txt 172 &#34;); cu_assert verifi repudi key usag extens preserv grep us898_tc2_cert_txt repudi &#34;); cu_assert verifi public key preserv grep us898_tc2_cert_txt &#34;); cu_assert clean new_cert free new_cert est_destroy ectx test enrol api ensur grace handl null x509 cert pointer static void us898_test3 void est_ctx ectx evp_pkey key int pkcs7_len int unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol use null x509 pointer est_client_reenrol ectx null pkcs7_len key cu_assert est_err_no_cert clean evp_pkey_fre key est_destroy ectx test enrol api ensur grace handl null evp_pkey pointer static void us898_test4 void est_ctx ectx int pkcs7_len int x509 cert null unsign char cert_raw int cert_len bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read old cert use enrol cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol use null evp_key pointer est_client_reenrol ectx cert pkcs7_len null cu_assert est_err_no_key clean x509_free cert est_destroy ectx test attempt enrol corrupt cert public key cert corrupt static void us898_test5 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key corrupt pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert corrupt pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert clean est_destroy ectx test attempt enrol expir cert est server configur manual approv server send back retri respons static void us898_test6 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm stop server st_stop (); restart server manual approv enabl us898_start_serv cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert clean est_destroy ectx stop server st_stop (); restart server manual approv disabl us898_start_serv cu_assert verifi bogus user password fail use http basic auth static void us898_test7 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx hoagi chili null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_auth_fail est_destroy ectx verifi good user password pass use http digest auth static void us898_test8 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm enabl http digest authent (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us898_uid us898_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx enabl http basic authent (); verifi bogus user password fail use http digest auth static void us898_test9 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len int http_status log_func_nm enabl http digest authent (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx jdoe panther null null cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null read privat key key_len read_binary_fil us898 key expir pem key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898 cert expir pem cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_auth_fail check http status code reenrol oper http_status ectx cu_assert http_status 401 est_destroy ectx enabl http basic authent (); verifi server fail authent client send valid ident cert provid http auth credenti static void us898_test10 void char cmd 200 int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat csr sprintf cmd openssl req new node newkey rsa 2048 keyout subj 127 config est exampl cnf us898_tc10_csr us898_tc10_key system cmd cu_assert sign csr use local sprintf cmd openssl batch config est exampl cnf infil us898_tc10_cert us898_tc10_csr system cmd cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null read privat key key_len read_binary_fil us898_tc10_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898_tc10_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use certif http auth credenti provid est_client_set_auth ectx null null cert key cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol cert fail provid valid http auth credenti est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_auth_fail enrol cert work sinc provid valid cert identifi http auth requir enrol even server enabl http auth est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx verifi server fail authent client send expir identi cert use valid http auth credenti static void us898_test11 void int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null read privat key key_len read_binary_fil us898_tc11_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us898_tc11_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw set authent mode use expir certif valid http auth credenti est_client_set_auth ectx us898_uid us898_pwd cert key cu_assert est_err_non set est server address port est_client_set_serv ectx us898_server_ip us898_server_port null get latest csr attribut ectx attr_data attr_len cu_assert est_err_ssl_connect enrol cert est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_ssl_connect est_destroy ectx int us898_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us898_client_reenrol us898_init_suit us898_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit simpl enrol enrol us898_test1 null cu_add_test suit enrol expir cert extens us898_test2 null cu_add_test suit enrol use null cert us898_test3 null cu_add_test suit enrol use null key us898_test4 null cu_add_test suit enrol use corrupt x509 cert us898_test5 null cu_add_test suit enrol retri us898_test6 null cu_add_test suit enrol invalid uid pwd basic us898_test7 null cu_add_test suit enrol valid uid pwd digest us898_test8 null cu_add_test suit enrol invalid uid pwd digest us898_test9 null cu_add_test suit enrol valid certif http auth us898_test10 null cu_add_test suit enrol expir certif http auth us898_test11 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test uri path segment support server april copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util ifdef cunit includ cunit basic includ cunit autom endif includ util test util includ server includ proxi includ src est est locl extern char tst srvr path seg enrol extern char tst srvr path seg cacert extern char tst srvr path seg csrattr extern char []; extern char []; static int path_segment_support max command line length generat system command defin est_ut_max_cmd_len 256 defin us3512_server_port 29496 defin us3512_server_ip 127 defin us3512_uidpwd_good estus estpwd defin us3512_uid estus defin us3512_pwd estpwd ifndef win32 defin us3512_cacert est cacert crt defin us3512_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3512_proxy_cert est privat estservercertandkey pem defin us3512_proxy_key est privat estservercertandkey pem defin us3512_cacert est cacert crt certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey &#34;./ els defin us3512_cacert est cacert crt defin us3512_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3512_proxy_cert est privat estservercertandkey pem defin us3512_proxy_key est privat estservercertandkey pem defin us3512_cacert est cacert crt certif use verifi est server grab server directori defin client_ut_cacert &#34;../../ exampl server est cacert crt defin client_ut_cacert est cacert crt defin client_ut_pubkey endif defin us3512_enroll_url_ba https :// 127 29496 well known est cacert somestr simpleenrol defin https :// 127 29496 well known est cacert -\\\\ somestr simpleenrol defin https :// 127 29496 well known est simpleenrol defin us3512_pkcs10_ct content type applic pkcs10 defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin 16894 defin path_seg_valid somestr defin somestring1 somestring2 defin path_seg_is_oper cacert defin cacertssomestr defin path_seg_max defin path_seg_too_long defin https :// 127 16894 well known est path_seg_valid simpleenrol defin https :// 127 16894 well known est path_seg_too_long simpleenrol defin https :// 127 16894 well known est path_seg_max simpleenrol defin https :// 127 16894 well known est simpleenrol defin https :// 127 16894 well known est path_seg_is_oper simpleenrol defin https :// 127 16894 well known est simpleenrol defin https :// 127 16894 well known est path_seg_valid cacert defin us3512_pkcs10_req miichj ccaw4caqaw qtel mcmga1ueax mccm igj5ignsa wvud cbpbi zw1v ihn0 zxag eymbyga1uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki g9w0baqef aaocaq8amiibcg kcaqea 6juwp xxdw ckv wpdwo0i andqz fmxro leih6 nwf rsg ngc0efc l5l4nx hzom o14yq memgp hz7ob3hh npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w static int x509 cur_cert int openssl_cert_error static void us3512_clean void static int us3512_start_serv int manual_enrol int nid int st_start_nocacert us3512_server_port us3512 test realm us3512_cacert us3512_trust_cert est exampl cnf manual_enrol nid sleep next start est proxi act us3512_proxy_cert us3512_proxy_key estrealm us3512_cacert us3512_trust_cert estus estpwd 127 us3512_server_port disabl ecdh nid info sleep return static int path_seg_support void est_ctx ectx unsign char cacert null int cacerts_len est_error est_err_non sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert ectx est_client_init cacert cacerts_len est_cert_format_pem est_client_set_serv ectx us3512_server_ip us3512_server_port test_seg &#34;); est_err_non return els return return routin call cunit initi test suit generat keypair use est client suit static int us3512_init_suit void int est_init_logg est_log_lvl_info null char cmd est_ut_max_cmd_len printf start est server path segment unit test &#34;); path_segment_support printf uri path segment support build est rebuild use uripars dir &#34;); return gen keypair use est client test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey client_ut_pubkey printf (&#34;% cmd system cmd start server test need talk server us3512_clean (); start instanc est server us3512_start_serv sleep return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3512_destroy_suit void st_stop (); st_proxy_stop (); return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv saniti check server side path segment process simpl enrol direct server path segment outcom pass static void us3512_test1 void long log_func_nm curl_http_post us3512_pkcs10_ct us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function perform basic simpl enrol use uid pwd identifi client server use varieti test case modul static void us3512_simple_enrol char char server est_error expected_enroll_rv char path_seg est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len unsign char cacert null int cacerts_len read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx server us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert expected_enroll_rv use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx taken us899 test1 simpl enrol includ path segment uri path segment test verifi client includ configur path segment proper send verifi server correct pars valid path segment pass simpl enrol static void us3512_test2 void log_func_nm char path_seg path_seg memset memset us3512_simple_enrol tc3512 us3512_server_ip est_err_non path_seg cu_assert strcmp path_seg cu_assert strcmp path_seg taken us898 test1 simpl enrol includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass simpl enrol well auth callback static void us3512_test3 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int unsign char attr_data null int attr_len char path_seg unsign char cacert null int cacerts_len log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx us898 pkcs7_len key cu_assert est_err_non est_err_non return retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non convert cert x509 warn pure hackeri b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null wow lot work final x509 love open ssl !!!) x509 represent cert let tri enrol cert memset memset est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non cu_assert strcmp path_seg cu_assert strcmp path_seg cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx taken us897 test11 cacert server includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass cert callback static void us3512_test4 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key char path_seg sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg clear global prove path segment made applic layer cal back function memset issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert verifi path segment made way callback function applic layer cu_assert strcmp path_seg retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey taken us898 test1 csrattribut includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass csr attribut callback static void us3512_test5 void est_ctx ectx evp_pkey key int unsign char new_cert null x509 cert null unsign char attr_data null int attr_len char path_seg unsign char cacert null int cacerts_len log_func_nm read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3512_uid us3512_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3512_server_ip us3512_server_port path_seg generat privat key key generate_private_key (); cu_assert key null clear global prove path segment made applic layer cal back function memset issu get cert request ectx attr_data attr_len success obtain valid buffer contain cert cu_assert est_err_non verifi path segment made way callback function applic layer cu_assert strcmp path_seg cleanup cert x509_free cert evp_pkey_fre key new_cert free new_cert est_destroy ectx test flow path segment proxi mode valid path segment simpl enrol static void us3512_test6 void long log_func_nm sleep memset curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null cu_assert strcmp path_seg_valid sinc pass valid user password expect server respond 200 cu_assert 200 test flow path segment proxi mode path segment set maximum size static void us3512_test7 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment long get caught proxi 400 return cu_assert 200 test flow path segment proxi mode path segment larg static void us3512_test8 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment long get caught proxi 400 return cu_assert 400 test segment oper path static void us3512_test9 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment equal oper get 400 return cu_assert 400 test segment oper path static void us3512_test10 void long log_func_nm sleep curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null sinc pass path segment equal oper get 400 return cu_assert 400 test segment contain valid oper string within case front valid path segment test pass static void us3512_test11 void long log_func_nm sleep memset memset curl_http_post us3512_pkcs10_ct us3512_pkcs10_req us3512_uidpwd_good us3512_cacert curlauth_bas null null null cu_assert strcmp cu_assert strcmp sinc pass path segment equal oper get 400 return cu_assert 200 taken us897 test11 cacert server includ path segment uri path segment test verifi client includ configur path segment verifi server correct pars valid path segment pass cert callback static void us3512_test12 void est_ctx ectx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non unsign char retrieved_cacert null int evp_pkey priv_key char path_seg sleep read certif cacerts_len read_binary_fil client_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key client_ut_pubkey priv_key null printf (&#34;\\ error read privat key file client_ut_pubkey return ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null est_client_set_auth ectx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ectx us3512_server_ip path_seg clear global prove path segment made applic layer cal back function memset issu get cert request ectx success obtain valid buffer contain cert cu_assert est_err_non cu_assert verifi path segment made way callback function applic layer cu_assert strcmp path_seg retrieved_cacert malloc ectx retrieved_cacert output retriev cert compar retrieved_cacert printf (&#34;\\ retriev cert buffer retrieved_cacert printf retriev cert buffer length free retrieved_cacert ectx est_destroy ectx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us3512_add_suit void cu_error code cu_error ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3512_init_suit us3512_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); check see path segment support compil path_seg_support ()) printf uri path segment support build est rebuild use uripars dir &#34;); path_segment_support return path_segment_support path_segment_support add test suit note order import must test fread fprintf null cu_add_test suit est client simpl enrol path segment us3512_test1 null cu_add_test suit est server simpl enrol path segment us3512_test2 null cu_add_test suit est server simpl enrol path segment us3512_test3 null cu_add_test suit est server cacert path segment us3512_test4 null cu_add_test suit est server csrattr path segment us3512_test5 null cu_add_test suit est server est proxi path segment us3512_test6 null cu_add_test suit est server est proxi path segment max us3512_test7 null cu_add_test suit est server est proxi path segment long us3512_test8 null cu_add_test suit est server est proxi path segment oper us3512_test9 null cu_add_test suit est server est proxi path segment contain mani segment us3512_test10 null cu_add_test suit est server est proxi path segment contain oper us3512_test11 null cu_add_test suit est server est proxi path segment valid cacert us3512_test12 cu_error cu_get_error (); printf (&#34;% cu_error cu_cleanup_registri (); printf (&#34;% cu_get_error_msg ()); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori enabl token auth mode est client march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno static unsign char cacert null static int cacert len defin server defin us1883_tcp_port 29001 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin miiezj ccak4caqaw itepma0ga1ueaww gskp uzxn0mq4w daydvqqfew mdaw mtcc dqyjko zihvc naqebbqadgg ipadccago cgg ibalf hxqz obi kwdf x8sa z4l3 n1jyr cp4xmi qit y2p iigl ht7t1wz0lo9uo0u b7b xki8fgq sm1j roe5lw dih tjd g4b705c6xm d3mh436de9d4gzpj a2qur si9 gvnvg u0zowjfu9g y3i ndfsj o9u0e2mf zwwr8m72g bqzvb ddpn4bdw la9tk q2rsxf3h2d7b n2dnsh nsyx ix89d9u c6feg hqx hinuod zze an3yu qmbu fwoh el9ub8qu9gub2mjur ynrqnii7 nduvq5 ujkhj nwz ih7labda ce0ju kbay uzzkrqo vk6b wzz fs4d ytn95 vvov95md5d1eok xw3iih7grjygt wn5e4 yo68lonbf7ue24vg eie f6j0b falxw n15s7p ialk gf7cubit rhb b3k udr8yp kdqx hnm wbxy7zvk4t8k7168c nwsol net tk4bto ujbn wp8uq38yoi6389u24gm jeet dy1mj8ha4pz ftm uwq etox2kub gwc9v wfi5bx e2vvet gnsy2eqezpvwsc cy0 o3fu06co etr7ekr ngap ddez vti p9npe5q18azu t9ngo ox3pqr cpg1bdn6z1ue2t sdd knfmnmwq yin zp9mxh tz8ra kvsclv9jag mbaagg adanbgkqhki g9w0baqufaaocag eajmw z4iub ush5w qbfs yt4sxt ztvun6qx0 nmtzz quoq o79kx dkpzs lnv hkm fqcx a7g ngb ap5 md92dghc xoq gkcl zdm gj2o req zwzv tdro4z p1yen5vg yz7sa nxze8w pg2whl qvk vcp hn3euif bgi2reo f7xq5cau4ut q1h4g hax67yww8 jmypi gga0ad0z8ruicl qtlu el1f nsr4zll opwn rdxvff xo7g xvir4ihvhnwj6km dzyk0ovat2ms5a guc mdn6jm8kib nbvh5fgk bvqopsngkwn eoj0rsa ksx t5efm oxm9p ae3r vog o4t8w z6dquqy budmg kig8o r5hawber8yw qdi bgg pkzdpm yi2tef zvp g7qlj nsj5twe rknggh ucu3u 1s0r gqg y1s9ggi dsif xj4nci rgq xpnrf syv3ki ixt ab6tjk ubt vfo2krfq nxu4lb es7w es7 zzpzn gsq whn efevi5c5wprnpv vn6r kh0f auk 9ek4knzwf yf8 xn5q otgd4o luusg fdjsq nh6a1mlmx6cn defin us1883_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us1883_pkcs10_ct content type applic pkcs10 defin us1883_uidpwd_good estus estpwd ifndef win32 defin us1883_cacert est cacert crt defin us1883_cacert est cacert crt defin us1883_server_cert est privat estservercertandkey pem defin us1883_server_key est privat estservercertandkey pem defin us1883_client_cert est privat estservercertandkey pem defin us1883_client_key est privat estservercertandkey pem els defin us1883_cacert est cacert crt defin us1883_cacert est cacert crt defin us1883_server_cert est privat estservercertandkey pem defin us1883_server_key est privat estservercertandkey pem defin us1883_client_cert est privat estservercertandkey pem defin us1883_client_key est privat estservercertandkey pem static critical_sect logger_critical_sect static void us1883_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif static void us1883_clean void static int us1883_start_serv int manual_enrol int nid int st_start us1883_tcp_port est privat estservercertandkey pem est privat estservercertandkey pem estrealm est cacert crt trustedcert crt est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us1883_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us1883_logger_stderr endif read certif cacerts_len read_binary_fil us1883_cacert cacert cacerts_len return us1883_clean (); start instanc est server automat enrol enabl us1883_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1883_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey defin good_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u defin different_token v2vsb cwg ssd2zsbnb3qgd g8gcn ihrv igtl zxag jvb sboa wrpbic nck zcbjj20g ym91bm qgd g8ga2vlc cbvbi bya wrpbic nck zcbjj3zl igdvd cbvbm ugb w9i zsbza wx2zxig zg9sb gfi dqp xqg ssdt ig5vd cbnb25u ysbs zxqg j2vt ignhd gno ig1l lcbubw0ktm90igdvbm5h igxld zw0g y2f0y2ggd ghl ig1p zg5p z2h0ihjp zgvi defin null_token null defin long_token ssbj yw4nd cbh z3jl zsb0bi bka xnh z3jl zsanck z2h0a w5n igxpa2ug ssdt igzp z2h0a w5n igzvci bsa wzl ia0kvghl sdi zsbvbmx5ihdvcm igj1d cb0a gv5ign1d cbsa wtl igeg ymxh zgug dqp td2lu z2lu b3a wrl ihdpd ggg ywxs ig9m ig15ig1p z2h0ia0kdqp cb5zwfo lcbjigd1zxnz igl0j3mg ywxs ig9m ihro yxqg y29m lcb0a gf0j3mg z290ig15ig1pbm qga w4g ysb3a glyb canckknb sbzd glsb cbjd xnza w5n igfu zcbia xrja glu bhbm qgd ghlcm ywlu j3qgbm9ib2r5ighlcm dqo nck9o ihll ywgs ihlvd sbkb24nd cbo yxzl ihrv ighvb gxlci bjighl yxige w91ia0kssdt ihn0yw5ka w5n ihjp z2h0ighlcm vza wrl ihlvd sanck9o lca5osbza gfk zxmgb2yg y3jhenk ieknb sa5osbza gfk zxmgb2yg y3jhenkg dqp dcm f6e swg y3jhenk igni yxp5lcbjcm f6e sancg0kug91ci bhbm90a gvi igrya w5r lcbt ywtl igl0igeg zg91ymxl igzvci zsanck1h wjl iekg y2fu igrya w5r ihroa xmg yxdhe sanckl0j3mgbm v2zxig ihdo zw4gd ghle sbwd wxs ig91d cb0a gug z3vu ia0kqm vhd cb5b3ug ymxh y2sg yw5k igjsd wus igjv sancllvd sbnb3r0ysbw yxks ihlvd sbnb3r0ysbw yxkg dqo nck9o lcb3a gvi zsb0a guga gvsb cbhb sbjpi bjighvc gug yxqgb gvhc3qg ssbo ywqg ia0kssdt ihn0d w1ib glu b0a hjvd wdo ie5ldi bpcmxl yw5z ig9o lcb0bi b0a gugcmlza w5n ihn1bi ancg0kt2gg wvha cwge w91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3ug dqp jj20gc3rhbm rpbmcgcmlna hqga gvi zsbi zxnp zguge w91ia0kt2g idk5ihno ywrlci bjcm f6e swg ssdt idk5ihno ywrlci bjcm f6e sanck yxp5lcbjcm f6e swg y3jhenk igni yxp5ia0kdqp mb3jk ighhdm ugb wvi y3kgb24gb wug dqp ob3zlbn ig51zxzh ihrvbm9z igrl igxv y28g dqo nckkgbm zcbzb21l ihbl ywnl lcbqd xn0ihnvb wugcm vsa wvm ia0krn jvb sb0a glz ihzva wnl lcbra wxsa w5n ig1l ia0kww91ihn0yxjl igf0ig1l lcbhbm qge w91igd yxjl igf0ig1l ia0kqwx ihroa xmgc gfpbi bpd cdz igfsb cb0a gugc2ft zswga xqnci bhb gwga w5z yw5l ia0kkhlvd sbz zwup ia0kdqp jci b0a glz ihjl ywxse sbo yxbw zw5pbmcgb3ig zglk iekgb wfr zsbpd cbhb gwgd ia0kssdt igjvd w5k igzvci bda gf0d gfob29ja gvl ig9u igegd hvybmlw ihryd wnr ia0kdqp cb5zwfo lcb5b3ug zg9u j3qga gf2zsb0bi bob2x zxig ssbo zwfi ihlvd sanckknb sbzd gfu zglu bya wdod cbo zxjl igjlc2lk zsb5b3ug dqp cwg otkgc2hh zgvz ig9m igni yxp5lcbjj20g otkgc2hh zgvz ig9m igni yxp5ia0kq3jhenk igni yxp5lcbjcm f6e swg y3jhenkg dqo nck ihlvd sdi zsbjcm f6e sb5b3uncm y3jhenkg dqp ib2xk ig15igzl zxqs igzl zxqgd g8gd ghl igzpcm dqp zb3uga g9s zcbte sbm zwv0ihrv ihro zsbma xjl ia0kssbu zxzlci ywlk iekgd2fz igrvd24gd2l0a cb5b3u char test_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u =&#34;; int int applic layer callback function return token base authent credenti call regist est client use (). test function requir set global valu order make callback oper way test case want tell function forc respons code error test_token pointer hard code string token string return callback must provid token credenti heap base buffer ownership buffer implicit transfer client librari upon return est_http_auth_hdr auth_credenti char token_ptr null int token_len cu_assert auth_credenti mode auth_token report callback call see test request forc error respons code callback return auth_credenti mode auth_token test_token set anyth need alloc space heap copi valu test_token null token_len strlen test_token use strlen string larg need test est client token_len printf (&#34;\\ error determin length token string use credenti &#34;); return token_ptr malloc token_len token_ptr null printf (&#34;\\ error alloc token string use credenti &#34;); return strncpi token_ptr test_token strlen test_token )); token_ptr token_len made far token_ptr point string contain token return assign return success auth_credenti auth_token token_ptr return return token base one instead return basic credenti userid password est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_bas report callback call see test request forc error respons code callback return auth_credenti mode auth_bas auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return basic base one instead verfi auth_mod pass digest est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_digest report callback call see test request forc error respons code callback return auth_credenti mode auth_digest auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return test api exercis paramet static void us1883_test1 void est_error e_rc est_ctx ectx null log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null forgot specifi paramet context get caught e_rc null null cu_assert e_rc est_err_no_ctx valid call e_rc ectx cu_assert e_rc est_err_non attempt reset callback function e_rc ectx null cu_assert e_rc est_err_non est_destroy ectx us1883_simple_enrol use test case perform simpl enrol static void us1883_simple_enrol char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx perform simpl enrol first order get valid cert perform reenrol simpl enrol need success current done use basic mode est server yet token base support pdb note server side token support implement function option updat token mode first enrol absolut necessari sinc purpos test reenrol initi enrol need get cert static void char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null make sure server current basic auth mode (); e_rc ectx cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non est_destroy ectx ectx null creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null cert switch server token mode (); e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us1883_tcp_port null attempt reenrol token mode convert cert x509 warn pure hackeri pdb convers code come test case b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null pdb note moment expect fail sinc server yet understand request token authent 1884 complet assert begin fail need chang pass respons est_client_reenrol ectx cert pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx test2 applic layer regist callback caus http aithent header empti token credenti test applic layer regist callback est client get challeng find callback regist goe credenti store context noth note way preload credenti flow alway work enrol sent token credenti server fail give certif static void us1883_test2 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token set est client perform simpl enrol pass callback function catch handl request token auth enrol better fail due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail null callback never regist invok cu_assert test3 applic layer regist callback set credenti invok result previous test test applic layer regist callback est client get challeng call callback get back empti credenti structur end send http auth header credenti note way preload credenti flow alway work enrol sent token credenti server fail give certif static void us1883_test3 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token test_token null_token set est client perform simpl enrol regist token base callback set pass back token enrol better fail due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test4 good token sent server accept cert generat return test applic layer regist callback respond valid token enrol sent token credenti server set match token send back cert static void us1883_test4 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token test_token good_token set est client perform simpl enrol enrol succeed us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test est client receiv token auth challeng test applic layer regist callback respond fail return code static void us1883_test5 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); forc callback give fail return code test_token good_token set est client perform simpl enrol enrol better fail due credenti suppli applic layer eventu failur server due miss credenti us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test6 saniti test basic auth mode test server basic mode client applic regist basic base callback client send estus estpwd credenti get cert static void us1883_test6 void log_func_nm switch server basic mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); set est client perform simpl enrol pass callback function catch handl request token auth enrol pass basic mode fulli work make sure callback call ensur credenti came callback us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test7 make sure enrol work credenti callback flow obtain credenti test server token mode client applic regist token base callback client send valid token credenti get cert static void us1883_test7 void log_func_nm test_token good_token (); tell server token check st_set_token good_token set est client perform simpl enrol enrol succeed tc1883 us1883_server_ip est_err_non callback call cu_assert test7 token credenti long test server token mode told match good token client applic regist token base callback told give back token long client send corrupt token match good token static void us1883_test8 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token good_token forc callback give fail return code test_token long_token set est client perform simpl enrol pass callback function catch handl request token auth us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert test7 test digest mode demand credenti flow test server digest mode note mean server expect estus &#34;/&#34; estpwd estrealm valu hardcod data st_server st_server must start estrealm return realm client client return request client applic regist digest base callback client send valid digest get cert static void us1883_test9 void log_func_nm switch server digest mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); set est client perform simpl enrol pass callback function catch handl request token auth enrol pass digest mode fulli work make sure callback call ensur credenti came callback us1883_simple_enrol tc1883 us1883_server_ip est_err_non callback call cu_assert test4 valid token provid appliact callback wrong token test applic layer regist callback respond valid token server set token mode differ token enrol sent token credenti server set match token send back cert static void us1883_test10 void log_func_nm switch server token mode note see equival call made numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); tell server token check st_set_token different_token test_token good_token set est client perform simpl enrol enrol fail token match us1883_simple_enrol tc1883 us1883_server_ip est_err_auth_fail callback call cu_assert main function set run test return cue_success success run anoth cunit error code failur int us1883_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1883_tok_auth_cli us1883_init_suit us1883_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit pars respons us1883_test1 null cu_add_test suit simpl enrol us1883_test2 null cu_add_test suit simpl enrol reg token us1883_test3 null cu_add_test suit simpl enrol reg good token us1883_test4 null cu_add_test suit simpl enrol reg bad us1883_test5 null cu_add_test suit simpl enrol reg basic mode us1883_test6 null cu_add_test suit simpl enrol reg good token us1883_test7 null cu_add_test suit simpl enrol reg token long us1883_test8 null cu_add_test suit simpl enrol reg digest mode us1883_test9 null cu_add_test suit simpl enrol reg mismatch valid token us1883_test10 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori proxi simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin retri interv defin tcp port defin 15748 defin us748_tcp_proxy_port 16748 ifndef win32 static char test5_outfil filename_max us748 test5 hdr defin us748_server_cert est privat estservercertandkey pem defin us748_server_key est privat estservercertandkey pem defin us748_proxy_cert est privat estservercertandkey pem defin us748_proxy_key est privat estservercertandkey pem defin us748_proxy_cert us748 cert pem defin us748_proxy_key us748 key pem defin us748_cacert est cacert crt defin us748_trusted_cert trustedcert crt els static char test5_outfil filename_max us748 test5 hdr defin us748_server_cert est privat estservercertandkey pem defin us748_server_key est privat estservercertandkey pem defin us748_proxy_cert est privat estservercertandkey pem defin us748_proxy_key est privat estservercertandkey pem defin us748_proxy_cert us748 cert pem defin us748_proxy_key us748 key pem defin us748_cacert est cacert crt defin us748_trusted_cert trustedcert crt endif follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us748_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin us748_pkcs10_dsa1024 miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin us748_pkcs10_corrupt miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us748_enroll_url_ba https :// 127 15748 well known est simpleenrol defin us748_pkcs10_ct content type applic pkcs10 defin us748_uidpwd_good estus estpwd defin us748_cacert est cacert crt defin us748_explicit_cert us748 cert pem defin us748_explicit_key us748 key pem static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written static void us748_clean void static int us748_start_serv int manual_enrol int nid int first start est server act st_start us748_server_cert us748_server_key estrealm us748_cacert us748_trusted_cert us748 est exampl cnf manual_enrol manual enrol disabl nid ecdh nid info sleep est_err_non return next start est proxi act st_proxy_start us748_tcp_proxy_port us748_proxy_cert us748_proxy_key estrealm us748_cacert us748_trusted_cert estus estpwd 127 disabl nid ecdh nid info sleep return void us748_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit initi test suit use alloc data open resourc requir test case static int us748_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us748_cacert cacert cacerts_len return us748_clean (); start instanc est server automat enrol enabl us748_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us748_destroy_suit void us748_stop_serv (); free cacert return simpl enrol rsa 2048 test case use libcurl test simpl enrol 2048 bit rsa csr http basic authent use static void us748_test1 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol prime 256 test case use libcurl test simpl enrol 256 bit csr http basic authent use static void us748_test2 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol dsa prime 1024 test case use libcurl test simpl enrol 1024 bit dsa csr http basic authent use static void us748_test3 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_dsa1024 us748_uidpwd_good us748_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 simpl enrol corrupt pkcs10 test case use libcurl test simpl enrol usinga corrupt csr http basic authent use static void us748_test4 void long log_func_nm curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_corrupt us748_uidpwd_good us748_cacert curlauth_bas null null null sinc csr valid server respond 400 cu_assert 400 simpl enrol manual enrol test case verifi server send appropri retri respons static void us748_test5 void long log_func_nm stop est server us748_stop_serv (); restart server manual enrol enabl us748_start_serv outfil fopen test5_outfil &#34;); curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null write_func fclose outfil sinc server seen csr past respond retri 202 respons cu_assert 202 verifi retri valu sprintf cmd grep retri grep test5_outfil us748_retry_interv system cmd grep test5_outfil retri 3600 &#34;); cu_assert avoid wait full retri period sinc simul manual enrol wait second tri enrol cert sleep curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null enrol request succeed time simul manual enrol automat enrol second attempt cu_assert 200 stop est server us748_stop_serv (); restart server manual enrol disabl us748_start_serv simpl enrol check fail curl test case verifi server verifi client csr sinc curl set est enrol fail static void us748_test6 void long log_func_nm st_enable_pop (); send valid enrol request use curl curl includ curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_pkcs10_rsa2048 us748_uidpwd_good us748_cacert curlauth_bas null null null server respond failur code cu_assert 400 st_disable_pop (); simpl enrol check succeed estclient test case verifi proxi verifi client csr use estclient sinc support static void us748_test7 void long est_ctx c_ctx evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm test case requir enabl st_enable_pop (); creat client context c_ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert c_ctx null c_ctx return specifi user password sinc server run basic authent mode est_client_set_auth c_ctx estus estpwd null null cu_assert est_err_non est_client_set_serv c_ctx 127 us748_tcp_proxy_port null get keypair use enrol new_pkey generate_private_key (); c_ctx attr_data attr_len cu_assert est_err_non attempt enrol csr est_client_enrol c_ctx us748 test7 pkcs7_len new_pkey cu_assert est_err_non client librari obtain new client certif retriev librari pkcs7 malloc pkcs7_len pkcs7 return c_ctx pkcs7 cu_assert est_err_non clean est_destroy c_ctx evp_pkey_fre new_pkey free pkcs7 disabl futur test case st_disable_pop (); simpl enrol disabl csr contain valid test case ensur server handl scenario csr includ valid even server request use cisco est client generat csr contain valid way includ valid use curl sinc tls channel bind inform known advanc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us748_test9 void est_ctx ctx int unsign char cacert int caclen evp_pkey new_pkey unsign char pkcs7 int pkcs7_len unsign char attr_data int attr_len log_func_nm make sure est server disabl st_disable_pop (); read cert caclen read_binary_fil us748_cacert cacert cu_assert cacerts_len init client context ctx est_client_init cacert caclen est_cert_format_pem use simpl http auth identifi est_client_set_auth ctx estus estpwd null null cu_assert est_err_non est_client_set_serv ctx 127 us748_tcp_proxy_port null creat space hold cert generat privat key new_pkey generate_private_key (); ctx attr_data attr_len cu_assert est_err_non attempt enrol ctx csr_pop_requir hack test attempt need forc challeng password csr est_client_enrol ctx test case9 pkcs7_len new_pkey cu_assert est_err_non pkcs7 malloc pkcs7_len ctx pkcs7 free pkcs7 est_destroy ctx simpl enrol disabl csr contain invalid test case ensur server handl scenario csr includ invalid even server request static void us748_test10 void long log_func_nm make sure est server disabl st_disable_pop (); curl_http_post us748_enroll_url_ba us748_pkcs10_ct us748_uidpwd_good us748_cacert curlauth_bas null null null enrol request fail sinc invalid expect 400 respons cu_assert 400 main function set run test return cue_success success run anoth cunit error code failur int us748_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us748_srv_simpenrol us748_init_suit us748_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us748_test1 null cu_add_test suit enrol ecdsa cert us748_test2 null cu_add_test suit enrol dsa cert us748_test3 null cu_add_test suit enrol corrupt ecdsa cert us748_test4 null cu_add_test suit enrol retri manual approv us748_test5 null cu_add_test suit enrol fail curl us748_test6 null cu_add_test suit enrol succeed estclient us748_test7 null cu_add_test suit enrol disabl csr includ valid us748_test9 null cu_add_test suit enrol disabl csr includ invalid us748_test10 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori encrypt privat key support juli copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ server includ openssl ssl includ openssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static char key password null static int cacert len defin server port defin server defin us3612_uid estus defin us3612_pwd estpwd defin us3612_good_pwd us3612 defin us3612_bad_pwd thiscantpossiblywork defin rsa_keys 4096 key wrap algorithm option use protect privat key defin est_private_key_enc evp_aes_128_cbc follow cert use fqdn test ifndef win32 defin us3612_cacert est cacert crt defin us3612_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3612 us3612_key pem els defin us3612_cacert est cacert crt defin us3612_trust_cert trustedcert crt defin est privat estservercertandkey pem defin us3612 us3612_key pem static critical_sect logger_critical_sect static void us3612_logger_stderr char format va_list enter critic section logger_critical_sect vfprintf stderr format fflush stderr leav critic section logger_critical_sect endif unsign char bio_copy_data bio int data_lenp unsign char data tdata int data_len data_len bio_get_mem_data tdata data malloc data_len data memcpi data tdata data_len data data_len ]=\&#39;\\ make sure termin case use string data_lenp data_lenp data_len els printf malloc fail &#34;); return data char int key_siz pem_password_cb char key_data null rsa rsa rsa_new (); rsa return null bignum bn_new (); rsa_fre rsa return null bn_set_word 0x10001 rsa_generate_key_ex rsa key_siz null bio bio_new bio_s_mem ()); break key rsa est_private_key_enc null null null key_data char bio_copy_data null bio_fre key_data key_data happen passphras enter via stdin verifi less charact free key_data key_data null key_data rsa_fre rsa bn_free return key_data char int curve_nid pem_password_cb ec_key eckey ec_group group null char key_data null int asn1_flag form generat key eckey ec_key_new (); eckey return null group curve_nid group asn1_flag group form ec_key_set_group eckey group ec_key_generate_key eckey return null bio bio_new bio_s_mem ()); break group pem_write_bio_ecpriv key eckey est_private_key_enc null null null key_data char bio_copy_data null bio_fre key_data strstr key_data &#34;----- begin privat key -----&#34;)) happen passphras enter via stdin verifi less charact free key_data key_data null key_data ec_key_fre eckey return key_data static int string_password_cb char buf int size int wflag void data hard code password suit strncpi buf key_password size return strnlen buf size )); static void us3612_clean void static int us3612_start_serv int manual_enrol int nid int st_start us3612_server_port us3612 test realm us3612_cacert us3612_trust_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us3612_init_suit void int ifdef win32 initi critic section logger_critical_sect est_init_logg est_log_lvl_info us3612_logger_stderr endif read certif cacerts_len read_binary_fil us3612_cacert cacert cacerts_len return us3612_clean (); start instanc est server automat enrol enabl us3612_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us3612_destroy_suit void st_stop (); free cacert return callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf (&#34;% open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv simpl enrol client load password prortect privat key correct passphras attempt enrol certif static void us3612_test1 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_good_pwd key string_password_cb cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tcus3612 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr load password protect privat key incorrect password attempt enrol certif fail static void us3612_test2 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_bad_pwd key string_password_cb cu_assert key null get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tc3612 pkcs7_len key cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx simpl enrol csr chang password use callback read protect privat key file static void us3612_test3 void est_ctx ectx evp_pkey key int int pkcs7_len unsign char new_cert null unsign char attr_data null int attr_len creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null set authent mode use user password est_client_set_auth ectx us3612_uid us3612_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us3612_server_ip us3612_server_port null read test privat key generat via command openssl genrsa aes128 passout pass us3612 us3612_key pem 4096 key_password us3612_good_pwd key string_password_cb cu_assert key null chang password evp_pkey remain unaffect key_password us3612_bad_pwd get latest csr attribut ectx attr_data attr_len cu_assert est_err_non use simplifi api enrol csr est_client_enrol ectx tcus3612 pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx test key generat util function associ password callback static void us3612_test4 void char new_pkey null generat rsa key without password new_pkey rsa_keys null cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat rsa key password key_password us3612_good_pwd new_pkey rsa_keys string_password_cb cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat key without password new_pkey obj_sn2nid char prime256v1 &#34;), null cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null generat key password new_pkey obj_sn2nid char prime256v1 &#34;), string_password_cb cu_assert new_pkey null printf (&#34;\\ new_pkey free new_pkey new_pkey null int us3612_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us3612_init_suit us3612_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit client simpl enrol correct pwd us3612_test1 null cu_add_test suit client simpl enrol incorrect pwd us3612_test2 null cu_add_test suit client simpl enrol incorrect pwd us3612_test3 null cu_add_test suit keygen test us3612_test4 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori server cacert june copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif defin pkcs req miichj ccaw caqaw qtel mcmga ueax mccm igj ignsa wvud cbpbi ihn zxag eymbyga uebrmpuel eoldp zgdld cbttjoy miibij anbgkqhki baqef aaocaq amiibcg kcaqea juwp xxdw ckv wpdwo andqz fmxro leih nwf rsg ngc efc hzom memgp npu0k81g muz rqzwmm jhxw rqob ni59oqek i1t4rk syzloow sqon mzj t0iq zdi rd8l3gj h3g eibmqfv62nt n1csu9df heg76 jahddd udjdxo3awi5s7z llz plgd4o k5k1wq ee2pqhn zxei nc94wfq xq1kyr w0povl 32mo wtqtfa7sqe2u gbxs rpa flqj e8jhoew x0ngywnvx krp kgu sbic31wvksw ps8e34pjj zavdx qidaqabo aaw dqyjko zihvc aqefbqadgg ebaazxvoor qpi mndp rzhhi d5o2yd7apbbzn rll1hml5dpgnu xy7zcyw qtxw ngyvt kja zci w7d zhvn f5ua3w ur9r2zno vr0z9y5wwn1c jrd 0xbgi6g6f ddim psf8gygc tcchba7uv0i8oi ciwf5uf f3nybo o2z beynq65 w3ygf yp0cr0ni xgkz3qh2xa2e rfe w56oejmc mjq6yx7wac2x nk3w1g6le1uinzuen msc ngnt8fa i43 ailmd ekxc30fjx a12rdh dyi fv0 pd4o5u pkt4j ritv apm ocd yawqiu2w defin us901_enroll_url https :// 127 29901 well known est simpleenrol defin us901_cacert_url https :// 127 29901 well known est cacert defin us901_pkcs10_ct content type applic pkcs10 defin us901_uidpwd_good estus estpwd defin us901_uidpwd_bad estus bogus defin us901_server_port 29901 ifndef win32 defin us901_cacert est cacert crt defin us901_explicit_cert us901 explicit cert pem defin us901_explicit_key us901 explicit key pem defin us901_implicit_cert us901 implicit cert pem defin us901_implicit_key us901 implicit key pem defin us901_revoked_cert us901 revok cert pem defin us901_revoked_key us901 revok key pem defin us901_selfsign_cert us901 selfsign cert pem defin us901_selfsign_key us901 selfsign key pem defin us901_cacert est cacert crt defin us901_extcert ext cacert crt defin us901_server_cert est privat estservercertandkey pem defin us901_server_key est privat estservercertandkey pem defin us901_server_certkey est privat estservercertandkey pem static char test5_outfil filename_max us901 test5 crt els defin us901_cacert est cacert crt defin us901_explicit_cert us901 explicit cert pem defin us901_explicit_key us901 explicit key pem defin us901_implicit_cert us901 implicit cert pem defin us901_implicit_key us901 implicit key pem defin us901_revoked_cert us901 revok cert pem defin us901_revoked_key us901 revok key pem defin us901_selfsign_cert us901 selfsign cert pem defin us901_selfsign_key us901 selfsign key pem defin us901_cacert est cacert crt defin us901_extcert ext cacert crt defin us901_server_cert est privat estservercertandkey pem defin us901_server_key est privat estservercertandkey pem defin us901_server_certkey est privat estservercertandkey pem static char test5_outfil filename_max us901 test5 crt endif static void us901_clean void char cmd 200 sprintf cmd test5_outfil system cmd routin call cunit initi test suit use alloc data open resourc requir test case static int us901_init_suit void us901_clean (); est_init_logg est_log_lvl_info null return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us901_destory_suit void return start appropri flavor st_server base charact specifi basic auth digest auth crl check auth static int us901_start_serv char server_typ int switch server_typ case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf (); break case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf (); break case system openssl config est exampl cnf gencrl est crl pem &#34;); sleep system cat trustedcert crt est crl pem us901 trustedcertsandcrl crt &#34;); sleep st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt us901 trustedcertsandcrl crt est exampl cnf st_enable_crl (); st_disable_http_auth (); break case st_start us901_server_port us901_server_certkey us901_server_certkey estrealm est cacert crt trustedcert crt est exampl cnf st_disable_http_auth (); break default break return http basic auth test case use libcurl test http basic authent work est server must use simpleenrol messag sinc cacert messag requir client authent est server run list port 8088 prior test run static void us901_test1 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep http basic auth failur test case use libcurl test http basic authent work est server use bogus password must use simpleenrol messag sinc cacert messag requir client authent est server run prior test run static void us901_test2 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_stop (); sleep http digest auth test case use libcurl test http digest authent work est server must use simpleenrol messag sinc cacert messag requir client authent est server run listen port 8087 prior test run static void us901_test3 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_digest null null null sinc pass valid user password expect server respond success cu_assert 200 st_stop (); sleep http digest auth fail test case use libcurl test http digest authent work est server negat test case digest auth must use simpleenrol messag sinc cacert messag requir client authent est server run listen port 8087 prior test run static void us901_test4 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_cacert curlauth_digest null null null sinc pass invalid user password expect server respond 400 cu_assert 401 st_stop (); sleep static file outfil static size_t write_func void ptr size_t size size_t nmemb void userdata size_t written written fwrite ptr size nmemb outfil return written test case simpl cacert request look http 200 respons code static void us901_test5 void long char cmd 200 int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_get us901_cacert_url us901_cacert write_func fclose outfil expect server respond 200 cu_assert 200 sprintf cmd openssl base64 openssl pkcs7 inform der text print_cert test5_outfil system cmd cu_assert st_stop (); sleep static void us901_test_sslvers const ssl_method int expect_fail bio conn ssl ssl ssl_ctx ssl_ctx null int int st_rv st_rv us901_start_serv st_rv return log_func_nm ssl_ctx ssl_ctx_new cu_assert ssl_ctx null ssl context readi open socket server bind socket context conn open_tcp_socket_ipv4 127 29901 &#34;); cu_assert conn null creaea ssl session context ssl ssl_new ssl_ctx ssl_set_bio ssl conn conn everyth readi let initi tls handshak ssl_connect ssl expect_fail cu_assert els cu_assert cleanup data ssl_shutdown ssl ssl_free ssl ssl_ctx_free ssl_ctx st_stop (); sleep test attempt creat ssl connect est server fail tls allow static void us901_test6 void log_func_nm us901_test_sslvers sslv3_client_method (), test attempt creat tls connect est server fail tls allow static void us901_test7 void log_func_nm us901_test_sslvers tlsv1_client_method (), test attempt creat tls connect est server succeed static void us901_test8 void log_func_nm us901_test_sslvers (), test attempt creat tls connect est server succeed static void us901_test9 void log_func_nm us901_test_sslvers (), test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain succeed static void us901_test10 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_explicit_cert us901_explicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign implicit cert chain succeed static void us901_test11 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_implicit_cert us901_implicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use revok client certif verifi crl check work tls layer fail static void us901_test12 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_revoked_cert us901_revoked_key us901_cacert null sinc client cert revok tls handshak fail est server return 401 respons cu_assert st_stop (); test attempt use self sign client certif verifi cert chain reject cert sign valid fail static void us901_test13 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post_cert us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_selfsign_cert us901_selfsign_key us901_cacert null sinc client cert sign either local extern tls handshak fail receiv http status messag server cu_assert st_stop (); tls anonym cipher suit disabl test case use libcurl test est server accept anonym cipher suit client test singl cipher suit attempt simpl enrol server static void us901_test14 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas adh aes128 sha256 null null tls handshak fail curl return cu_assert st_stop (); sleep null http realm initi server static void us901_test15 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null realm est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem null priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key null server certif initi server static void us901_test16 void unsign char cacert null int cacerts_len bio keyin evp_pkey priv_key int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null server key est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null priv_key cu_assert ctx null evp_pkey_fre priv_key null server certif privat key initi server static void us901_test17 void unsign char cacert null int cacerts_len bio certin x509 int est_ctx ctx log_func_nm read certif cacerts_len read_binary_fil us901_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin attempt init est server use null privat key est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm null cu_assert ctx null x509_free null trust chain initi server static void us901_test18 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server use null local chain est_init_logg est_log_lvl_info null ctx est_server_init null null est_cert_format_pem testrealm priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key corrupt chain initi server static void us901_test19 void bio certin keyin x509 evp_pkey priv_key int est_ctx ctx log_func_nm read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us901_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us901_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin attempt init est server corrupt chain est_init_logg est_log_lvl_info null ctx est_server_init unsign char bogus chain unsign char bogus chain est_cert_format_pem testrealm priv_key cu_assert ctx null x509_free evp_pkey_fre priv_key test case attempt simpl cacert request use post instead get fail static void us901_test20 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep outfil fopen test5_outfil &#34;); curl_http_post us901_cacert_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null fclose outfil expect server respond 400 cu_assert 400 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain valid http authent credenti also provid succeed static void us901_test21 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_explicit_cert us901_explicit_key us901_cacert null sinc pass valid user password expect server respond 200 cu_assert 200 st_stop (); sleep test attempt use client certif verifi tls client authentiaiton work certif use sign explicit cert chain invalid http authent credenti also provid fail 401 respons static void us901_test22 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_bad us901_explicit_cert us901_explicit_key us901_cacert null sinc pass invalid user password expect server respond 401 cu_assert 401 st_stop (); sleep test attempt enrol without use certif ident client use good user pwd howev est server setup perform certif authent http auth disabl fail 401 respons static void us901_test23 void long int st_rv st_rv us901_start_serv st_rv return log_func_nm sleep curl_http_post us901_enroll_url us901_pkcs10_ct us901_pkcs10_req us901_uidpwd_good us901_cacert curlauth_bas null null null sinc pass invalid user password expect server respond 401 cu_assert 401 st_stop (); sleep main function set run test return cue_success success run anoth cunit error code failur int us901_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us901_srv_cacert us901_init_suit us901_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit http basic auth us901_test1 null cu_add_test suit http basic auth fail us901_test2 null cu_add_test suit http digest auth us901_test3 null cu_add_test suit http digest auth fail us901_test4 null cu_add_test suit get certif us901_test5 null cu_add_test suit ssl fail us901_test6 null cu_add_test suit tls fail us901_test7 null cu_add_test suit tls us901_test8 null cu_add_test suit tls us901_test9 null cu_add_test suit certif auth explicit cert chain us901_test10 null cu_add_test suit certif auth implicit cert chain us901_test11 null cu_add_test suit certif auth revok cert us901_test12 null cu_add_test suit certif auth self sign cert us901_test13 null cu_add_test suit anon cipher suit disabl us901_test14 null cu_add_test suit null realm us901_test15 null cu_add_test suit null server cert us901_test16 null cu_add_test suit null server key us901_test17 null cu_add_test suit null local chain us901_test18 null cu_add_test suit corrupt local chain us901_test19 null cu_add_test suit http post cacert us901_test20 null cu_add_test suit simpl enrol good http auth good cert us901_test21 null cu_add_test suit simpl enrol bad http auth good cert us901_test22 null cu_add_test suit simpl enrol http auth cert us901_test23 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori enabl token auth mode server march copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif includ errno static unsign char cacert null static int cacert len defin tcp port follow csr generat use follow openssl command theng use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin miiezj ccak4caqaw itepma0ga1ueaww gskp uzxn0mq4w daydvqqfew mdaw mtcc dqyjko zihvc naqebbqadgg ipadccago cgg ibalf hxqz obi kwdf x8sa z4l3 n1jyr cp4xmi qit y2p iigl ht7t1wz0lo9uo0u b7b xki8fgq sm1j roe5lw dih tjd g4b705c6xm d3mh436de9d4gzpj a2qur si9 gvnvg u0zowjfu9g y3i ndfsj o9u0e2mf zwwr8m72g bqzvb ddpn4bdw la9tk q2rsxf3h2d7b n2dnsh nsyx ix89d9u c6feg hqx hinuod zze an3yu qmbu fwoh el9ub8qu9gub2mjur ynrqnii7 nduvq5 ujkhj nwz ih7labda ce0ju kbay uzzkrqo vk6b wzz fs4d ytn95 vvov95md5d1eok xw3iih7grjygt wn5e4 yo68lonbf7ue24vg eie f6j0b falxw n15s7p ialk gf7cubit rhb b3k udr8yp kdqx hnm wbxy7zvk4t8k7168c nwsol net tk4bto ujbn wp8uq38yoi6389u24gm jeet dy1mj8ha4pz ftm uwq etox2kub gwc9v wfi5bx e2vvet gnsy2eqezpvwsc cy0 o3fu06co etr7ekr ngap ddez vti p9npe5q18azu t9ngo ox3pqr cpg1bdn6z1ue2t sdd knfmnmwq yin zp9mxh tz8ra kvsclv9jag mbaagg adanbgkqhki g9w0baqufaaocag eajmw z4iub ush5w qbfs yt4sxt ztvun6qx0 nmtzz quoq o79kx dkpzs lnv hkm fqcx a7g ngb ap5 md92dghc xoq gkcl zdm gj2o req zwzv tdro4z p1yen5vg yz7sa nxze8w pg2whl qvk vcp hn3euif bgi2reo f7xq5cau4ut q1h4g hax67yww8 jmypi gga0ad0z8ruicl qtlu el1f nsr4zll opwn rdxvff xo7g xvir4ihvhnwj6km dzyk0ovat2ms5a guc mdn6jm8kib nbvh5fgk bvqopsngkwn eoj0rsa ksx t5efm oxm9p ae3r vog o4t8w z6dquqy budmg kig8o r5hawber8yw qdi bgg pkzdpm yi2tef zvp g7qlj nsj5twe rknggh ucu3u 1s0r gqg y1s9ggi dsif xj4nci rgq xpnrf syv3ki ixt ab6tjk ubt vfo2krfq nxu4lb es7w es7 zzpzn gsq whn efevi5c5wprnpv vn6r kh0f auk 9ek4knzwf yf8 xn5q otgd4o luusg fdjsq nh6a1mlmx6cn defin us1864_enroll_url_ba https :// 127 29001 well known est simpleenrol defin us1864_pkcs10_ct content type applic pkcs10 defin us1864_uidpwd_good estus estpwd ifndef win32 defin us1864_cacert est cacert crt defin us1864_cacert est cacert crt defin us1864_trusted_cert trustedcert crt defin us1864_server_cert est privat estservercertandkey pem defin us1864_server_key est privat estservercertandkey pem defin us1864_client_cert est privat estservercertandkey pem defin us1864_client_key est privat estservercertandkey pem els defin us1864_cacert est cacert crt defin us1864_cacert est cacert crt defin us1864_trusted_cert trustedcert crt defin us1864_server_cert est privat estservercertandkey pem defin us1864_server_key est privat estservercertandkey pem defin us1864_client_cert est privat estservercertandkey pem defin us1864_client_key est privat estservercertandkey pem endif curl_data_cb pass curl call curl whenev data receiv function specifi retriev http header test use retriev http header look bearer token author challeng static int bearer_found static size_t curl_data_cb void ptr size_t size size_t nmemb void userdata void bearer_found warn strstr danger assum null termin string case http header came est server know null termin strstr ptr www authent bearer &#34;); bearer_found return size nmemb static void us1864_clean void static int us1864_start_serv int manual_enrol int nid int st_start us1864_tcp_port us1864_server_cert us1864_server_key us1864 test realm us1864_cacert us1864_trusted_cert est exampl cnf manual_enrol nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us1864_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us1864_cacert cacert cacerts_len return us1864_clean (); start instanc est server automat enrol enabl us1864_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1864_destroy_suit void st_stop (); free cacert return unit test first test paramet static void us1864_test1 void unsign char cacert null int cacerts_len bio certin keyin x509 evp_pkey priv_key int est_ctx ctx est_error est_rv log_func_nm read certif cacerts_len read_binary_fil us1864_cacert cacert cu_assert cacerts_len read server cert certin bio_new bio_s_file_intern ()); bio_read_filenam certin us1864_server_cert cu_assert pem_read_bio_x509 certin null null null cu_assert null bio_fre certin read server key keyin bio_new bio_s_file_intern ()); bio_read_filenam keyin us1864_server_key cu_assert priv_key pem_read_bio_priv key keyin null null null cu_assert priv_key null bio_fre keyin init est server mode est_init_logg est_log_lvl_info null ctx est_server_init cacert cacerts_len cacert cacerts_len est_cert_format_pem testrealm priv_key cu_assert ctx null est_rv ctx auth_non cu_assert est_rv est_err_bad_mod est_rv ctx auth_bas cu_assert est_rv est_err_non est_rv ctx auth_digest cu_assert est_rv est_err_non est_rv ctx auth_token cu_assert est_rv est_err_non est_rv ctx 0xffffffff cu_assert est_rv est_err_bad_mod make sure allow digest mode fip mode fips_mode_set est_rv ctx auth_digest cu_assert est_rv est_err_bad_mod fips_mode_set x509_free evp_pkey_fre priv_key est_destroy ctx simpl enrol token auth mode goal test verifi est server respond correct auth challeng configur token auth mode first perform saniti check perform http basic request server still default mode http basic auth test configur server token auth mode issu request contain auth header forc server respond token auth challeng header static void us1864_test2 void long log_func_nm curl_http_post us1864_enroll_url_ba us1864_pkcs10_ct us1864_uidpwd_good us1864_cacert curlauth_bas null null null sinc specifi basic server still basic expect server respond 200 cu_assert 200 switch server token mode note see done numer place probabl safe test set danger chang fli oper set also note return code set enabl function (); bearer_found us1864_enroll_url_ba us1864_pkcs10_ct us1864_client_cert us1864_client_key us1864_cacert curl_data_cb curl_data_cb sinc chang auth mode server expect fail captur actual auth challeng expect server respond 200 cu_assert 401 cu_assert bearer_found main function set run test return cue_success success run anoth cunit error code failur int us1864_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1864_cfg_tok_auth us1864_init_suit us1864_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit check parm us1864_test1 null cu_add_test suit attempt enrol basic pass us1864_test2 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori csr attribut enforc octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ test util includ openssl ssl includ openssl includ server ifdef cunit includ cunit basic includ cunit autom endif ifndef win defin cacert est cacert crt defin cacert est cacert crt defin server cert est privat estservercertandkey pem defin us1159_server_key est privat estservercertandkey pem els defin us1159_cacert est cacert crt defin us1159_cacert est cacert crt defin us1159_server_cert est privat estservercertandkey pem defin us1159_server_key est privat estservercertandkey pem endif defin us1159_uid estus defin us1159_pwd estpwd defin us1159_server_port 15897 defin us1159_server_ip 127 defin us1159_attr_pop_on mas gcsq gsib3dqejbw ==\\ defin us1159_attr_cn_on mauga1ueaw ==\\ defin us1159_attr_test mhegbi gaqebaryw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh urg qqaig ydvqqdbggqhkj opqqdag ==\\ extern est_ctx ectx static unsign char cacert null static int cacerts_len static char attr static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen attr csr_data malloc csr_len strncpi char csr_data attr csr_len csr_data csr_len return csr_data static void us1159_clean void int us1159_start_serv int start est server act st_start us1159_server_port us1159_server_cert us1159_server_key estrealm us1159_cacert trustedcert crt est exampl cnf manual enrol disabl ecdh nid info est_err_non printf (&#34;\\ unabl start est server us1159 &#34;); return (); est_set_csr_cb ectx est_err_non printf (&#34;\\ unabl set est csr attribut callback us1159 &#34;); return sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us1159_init_suit void int us1159_clean (); printf start server csr attribut enforc unit test us1159 ).\\ &#34;); attr us1159_attr_pop_on est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us1159_cacert cacert cacerts_len return start instanc est server automat enrol enabl us1159_start_serv (); return void us1159_stop_serv st_stop (); sleep routin call cunit uniniti test suit use dealloc data close resourc use test case static int us1159_destroy_suit void us1159_stop_serv (); free cacert printf complet csr attribut enforc unit test &#34;); return static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey function generat public privat key pair use certif provis static evp_pkey int nid ec_key eckey ec_group group null bio unsign char tdata unsign char key_data int key_len bio keyin evp_pkey new_priv_key int asn1_flag form generat key group nid nid_x9_62_prime256v1 */); group asn1_flag group form eckey ec_key_new (); ec_key_set_group eckey group ec_key_generate_key eckey printf fail generat key &#34;); return null bio_new bio_s_mem ()); group pem_write_bio_ecpriv key eckey null null null null key_len bio_get_mem_data tdata key_data malloc key_len memcpi key_data tdata key_len ec_key_fre eckey bio_fre read back evp_pkey struct keyin bio_new bio_s_mem ()); keyin bio_new_mem_buf key_data key_len read privat key file expect pem encod privat key use der encod would invok d2i_priv key_bio instead new_priv_key pem_read_bio_priv key keyin null null null new_priv_key null printf (&#34;\\ error read pem encod privat key &#34;); err_print_errors_fp stderr return null bio_fre keyin free key_data return new_priv_key test attempt simpl enrol client provid csr attribut challeng password enrol succeed static void us1159_test1 void est_ctx ctx evp_pkey key int int pkcs7_len unsign char new_cert null log_func_nm creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ctx test pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup evp_pkey_fre key new_cert free new_cert est_destroy ctx routin build pkcs10 csr static est_error x509_req req evp_pkey pkey char x509_name subj int setup version number x509_req_set_vers req cu_assert err_print_errors_fp stderr return est_err_x509_v add common name entri subj req subj mbstring_asc const unsign char cu_assert err_print_errors_fp stderr return est_err_x509_cn add serial number name entri subj nid_seri number mbstring_asc unsign char 12349999b cu_assert err_print_errors_fp stderr return est_err_x509_cn add attribut server expect req mbstring_asc const unsign char dummymac cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 999 mbstring_asc const unsign char dummi cu_assert err_print_errors_fp stderr return est_err_unknown req 840 10045 mbstring_asc const unsign char 132 cu_assert err_print_errors_fp stderr return est_err_unknown req 840 10045 mbstring_asc const unsign char &#34;&#34;, cu_assert err_print_errors_fp stderr return est_err_unknown req nid_seri number mbstring_asc const unsign char 123456789a cu_assert err_print_errors_fp stderr return est_err_unknown set public key request x509_req_set_pubkey req pkey cu_assert err_print_errors_fp stderr return est_err_x509_pubkey x509_req_print_fp stderr req return est_err_non sign x509 certif request use digest key pass return open ssl error code x509_req_sign_ctx (); static int sign_x509_req x509_req evp_pkey pkey const evp_md int evp_pkey_ctx pkctx null evp_md_ctx mctx evp_md_ctx_init mctx evp_digest sign init mctx pkctx null pkey return encod use der asn set modifi flag x509_req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req_info enc modifi x509_req_sign_ctx mctx evp_md_ctx_cleanup mctx return endif test attempt simpl enrol client provid requir csr attribut csr enrol succeed static void us1159_test2 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non sign request ossl_rv sign_x509_req req key evp_sha256 ()); cu_assert ossl_rv ossl_rv err_print_errors_fp stderr endif creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr except 521 bit curv use enrol fail sinc server csr attr specifi use 384 bit curv static void us1159_test3 void x509_req req null evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp521r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_http_bad_req cleanup ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr except sha 384 use signatur enrol fail sinc server csr attr requir sha 256 static void us1159_test4 void x509_req req null evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non chang sha 384 signatur ctx nid_sha384 cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_http_bad_req cleanup ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol server csr attribut configur requir common name csr attribut server configur static api callback static void us1159_test10 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non configur static csr attribut valu ectx us1159_attr_cn_on strlen us1159_attr_cn_on )); cu_assert est_err_non generat privat key key generate_private_key (); cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non est_client_force_pop ctx cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr client also provid larg quantiti addit attriut static void us1159_test20 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null int char t_attr_str log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non jam anoth attribut request could caus failur est server base64 decod csr due safe constraint max string size safe default 4096 byte ++) sprintf t_attr_str 899 req t_attr_str mbstring_asc const unsign char whatev cu_assert err_print_errors_fp stderr creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol client provid requir csr attribut csr client also provid attribut long name valu static void us1159_test21 void x509_req req null evp_pkey key null int pkcs7_len unsign char new_cert null int est_ctx ctx null log_func_nm set full list attribut server attr us1159_attr_test generat privat key key nid_secp384r1 cu_assert key null req x509_req_new (); cu_assert req null req key test &#34;); cu_assert est_err_non add attribut long valu req 993 mbstring_asc const unsign char attribut long valu could potenti caus problem est server cu_assert err_print_errors_fp stderr add attribut long name req 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 993 828 8142 9999 1883 mbstring_asc const unsign char cu_assert err_print_errors_fp stderr creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null use simplifi api enrol csr ctx req pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ctx new_cert cu_assert est_err_non cleanup new_cert free new_cert ctx est_destroy ctx req x509_req_fre req key evp_pkey_fre key test attempt simpl enrol server csr attribut configur enabl static void us1159_test50 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm st_enable_pop (); disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non generat privat key key nid_secp384r1 cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null est_client_force_pop ctx cu_assert est_err_non set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key test attempt simpl enrol server csr attribut configur disabl static void us1159_test51 void evp_pkey key null int pkcs7_len int est_ctx ctx null log_func_nm st_disable_pop (); disabl csr attr callback server context est_set_csr_cb ectx null cu_assert est_err_non generat privat key key nid_secp384r1 cu_assert key null creat client context ctx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ctx null set authent mode use user password est_client_set_auth ctx us1159_uid us1159_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ctx us1159_server_ip us1159_server_port null enrol new cert est_client_enrol ctx test pkcs7_len key cu_assert est_err_non cleanup ctx est_destroy ctx key evp_pkey_fre key main function set run test return cue_success success run anoth cunit error code failur int us1159_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us1159_init_suit us1159_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit note order import must test fread fprintf null cu_add_test suit attribut requir pop us1159_test1 null cu_add_test suit attribut provid pop us1159_test2 null cu_add_test suit public key wrong curv pop us1159_test3 null cu_add_test suit wrong hash algorithm signatur pop us1159_test4 null cu_add_test suit use static config pop us1159_test10 null cu_add_test suit lot attribut pop us1159_test20 null cu_add_test suit long attribut pop us1159_test21 null cu_add_test suit csr attr server pop us1159_test50 null cu_add_test suit csr attr server pop us1159_test51 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori proxi simpl enrol august copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin retri interv defin tcp_port 29001 defin 52174 defin 62174 ifndef win32 defin us2174_server_cert est privat estservercertandkey pem defin us2174_server_key est privat estservercertandkey pem defin us2174_proxy_cert est privat estservercertandkey pem defin us2174_proxy_key est privat estservercertandkey pem defin us2174_proxy_cert us2174 cert pem defin us2174_proxy_key us2174 key pem defin us2174_cacert est cacert crt defin us2174_cacert est cacert crt defin us2174_trusted_cert trustedcert crt defin us2174_explicit_cert us2174 cert pem defin us2174_explicit_key us2174 key pem els defin us2174_server_cert est privat estservercertandkey pem defin us2174_server_key est privat estservercertandkey pem defin us2174_proxy_cert est privat estservercertandkey pem defin us2174_proxy_key est privat estservercertandkey pem defin us2174_proxy_cert us2174 cert pem defin us2174_proxy_key us2174 key pem defin us2174_cacert est cacert crt defin us2174_cacert est cacert crt defin us2174_trusted_cert trustedcert crt defin us2174_explicit_cert us2174 cert pem defin us2174_explicit_key us2174 key pem endif defin us2174_server_ip 127 defin us2174_tcp_port follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x follow csr generat use follow openssl command use cat req file openssl req newkey 256parm keyout eckey pem keyform pem req outform pem defin miicfj ccaj0caqawf delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax arbg nvbao mck rtqunvb xbhbnkx anbg nvbas mbk rtqw9i eqma4g a1ueaww hzhnh igrv ztea mbg gcsq gsib3dqejarylzhnh qgrv zs5jb20wgg g2miib yhko zizjg eatccar4cg yeaq ifbyk7r eaa ulipb1gc hhc0ctx6g0dh bfd opng bse tp5uf5lw8qm6o cxst u3n yejalm mvkj fwbgv bws8a jbnj09d ddn8sp kegc g0m zpqd mys6 b4qjjq5yax atvi ggm1efdhc 6ezm2t3cg qklwo5a bzqcc cfqdc1ol bfu ohj xaw ee5epjk rjw kbg lctj vfnj ao8x smamw nora nfdi zceam d4838n cgaj vrqi db1q5akk lyxo jx1yv7g nba bnuys3waqdu nso1htu eur2cbh u5i kbwpj6miwl d3u cru4ui bf9xbi ana rid8ct2kchhwy4ok qmu yoz4 mqqm a4geaakbg duw r7h3u4cfu ttr i50m1txhl vz3ton vix ehpu aoux atvkth jta cbkc0ehii1b nug bub xfpk rt3qrlf0 pzgi 0tov o9p kjqiw0c10l nkfb evdl xyt akj xub hmi nog3195 t7o kxhmt1a ucro aaw cqyhko zizjg eaw adat uah pcq qg3g kuupkdw bncm zfz wdqjs cfah0 nzn9hujl xna ta1ohjm pmc jsx follow csr generat use follow openssl command use cat dsa req file openssl req newkey dsa dsaparm keyout dsakey pem keyform pem dsa req outform pem defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq29i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k defin miibmtcb2g ibadb4mqsw cqydvqqgew jvuz elmak ga1uecaw ctk ddakbg nvbac a1juudesmbaga1uecgw jrundb21w yw55mq4w daydvqqldavfq39i epma0ga1u aww grumg zg9l mrkw yjko zihvc naqk bfgpl y0bkb2uu y29t mfkw yhko zizj0c aqyiko zizj0daqc dqg aeo1usz ckd xnfzyg nlne s8az qkod1516gt9qd dddt9i jn4 btnv 7k7 tji5kts1k wsyyvq lxvnq8q tu1i qj56aamak gbyq gsm49baedrw raig p6qda 0tekzfpopg ufw fmrsxc nmu que2yuz16460 sqcibf lvmu mey yoqbb x0ifde9yzk rovbcepv k0hc u5k follow valid csr alreadi contain challeng password collect use estserv dumpbin function csr never work sinc valu stale defin miibcj cb3aibadarmq8w dqydvqqdew zurvnuq04wg z8w dqyjko zihvc naqebbqad y0amigjao gbapdhvrk vb3 fhl isr zgixld ryrd50s2v fs8m w5w wvx ds3x nzc ktqg7juy w8nyofnwx0ozh ce87xp2h7t 84zu ktlu3bjgq1xg nuu8a1ht10wiy8u2r ekmh qwpvt56uy5p hzuqmql o0qlm m58wn49ih mbaagg bgkqhki g9w0bcqcx yrujd gn1zunuwyd2vu aow dqyjko zihvc naqef bqadg yeayenrskmf rixcp kbv l3vn w5n4hc ltw i9hcbr744swfqaw uxd2j n99agbr tgh inwg2c7vz g6ok9fti nr9h 5slyhf sfjbu iv65r nvf lr9n9m2q9jlf7p4ayf wxd2q d2xotzw2t4tr gzgka2jr b40 defin us2174_enroll_url_ba https :// 127 62175 well known est simpleenrol defin us2174_pkcs10_ct content type applic pkcs10 defin us2174_uidpwd_good estus estpwd static evp_pkey generate_private_key void rsa rsa rsa_new (); bignum bn_new (); evp_pkey pkey creat rsa keypair assign pkey return bn_set_word 0x10001 rsa_generate_key_ex rsa 1024 null pkey evp_pkey_new (); pkey null printf (&#34;\\ error alloc pkey structur new key pair &#34;); return null evp_pkey_set1_rsa pkey rsa printf (&#34;\\ error assign rsa key pair pkey structur &#34;); return null rsa_fre rsa bn_free return pkey defin good_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u defin different_token v2vsb cwg ssd2zsbnb3qgd g8gcn ihrv igtl zxag jvb sboa wrpbic nck zcbjj20g ym91bm qgd g8ga2vlc cbvbi bya wrpbic nck zcbjj3zl igdvd cbvbm ugb w9i zsbza wx2zxig zg9sb gfi dqp xqg ssdt ig5vd cbnb25u ysbs zxqg j2vt ignhd gno ig1l lcbubw0ktm90igdvbm5h igxld zw0g y2f0y2ggd ghl ig1p zg5p z2h0ihjp zgvi defin null_token null defin long_token ssbj yw4nd cbh z3jl zsb0bi bka xnh z3jl zsanck z2h0a w5n igxpa2ug ssdt igzp z2h0a w5n igzvci bsa wzl ia0kvghl sdi zsbvbmx5ihdvcm igj1d cb0a gv5ign1d cbsa wtl igeg ymxh zgug dqp td2lu z2lu b3a wrl ihdpd ggg ywxs ig9m ig15ig1p z2h0ia0kdqp cb5zwfo lcbjigd1zxnz igl0j3mg ywxs ig9m ihro yxqg y29m lcb0a gf0j3mg z290ig15ig1pbm qga w4g ysb3a glyb canckknb sbzd glsb cbjd xnza w5n igfu zcbia xrja glu bhbm qgd ghlcm ywlu j3qgbm9ib2r5ighlcm dqo nck9o ihll ywgs ihlvd sbkb24nd cbo yxzl ihrv ighvb gxlci bjighl yxige w91ia0kssdt ihn0yw5ka w5n ihjp z2h0ighlcm vza wrl ihlvd sanck9o lca5osbza gfk zxmgb2yg y3jhenk ieknb sa5osbza gfk zxmgb2yg y3jhenkg dqp dcm f6e swg y3jhenk igni yxp5lcbjcm f6e sancg0kug91ci bhbm90a gvi igrya w5r lcbt ywtl igl0igeg zg91ymxl igzvci zsanck1h wjl iekg y2fu igrya w5r ihroa xmg yxdhe sanckl0j3mgbm v2zxig ihdo zw4gd ghle sbwd wxs ig91d cb0a gug z3vu ia0kqm vhd cb5b3ug ymxh y2sg yw5k igjsd wus igjv sancllvd sbnb3r0ysbw yxks ihlvd sbnb3r0ysbw yxkg dqo nck9o lcb3a gvi zsb0a guga gvsb cbhb sbjpi bjighvc gug yxqgb gvhc3qg ssbo ywqg ia0kssdt ihn0d w1ib glu b0a hjvd wdo ie5ldi bpcmxl yw5z ig9o lcb0bi b0a gugcmlza w5n ihn1bi ancg0kt2gg wvha cwge w91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3ug dqp jj20gc3rhbm rpbmcgcmlna hqga gvi zsbi zxnp zguge w91ia0kt2g idk5ihno ywrlci bjcm f6e swg ssdt idk5ihno ywrlci bjcm f6e sanck yxp5lcbjcm f6e swg y3jhenk igni yxp5ia0kdqp mb3jk ighhdm ugb wvi y3kgb24gb wug dqp ob3zlbn ig51zxzh ihrvbm9z igrl igxv y28g dqo nckkgbm zcbzb21l ihbl ywnl lcbqd xn0ihnvb wugcm vsa wvm ia0krn jvb sb0a glz ihzva wnl lcbra wxsa w5n ig1l ia0kww91ihn0yxjl igf0ig1l lcbhbm qge w91igd yxjl igf0ig1l ia0kqwx ihroa xmgc gfpbi bpd cdz igfsb cb0a gugc2ft zswga xqnci bhb gwga w5z yw5l ia0kkhlvd sbz zwup ia0kdqp jci b0a glz ihjl ywxse sbo yxbw zw5pbmcgb3ig zglk iekgb wfr zsbpd cbhb gwgd ia0kssdt igjvd w5k igzvci bda gf0d gfob29ja gvl ig9u igegd hvybmlw ihryd wnr ia0kdqp cb5zwfo lcb5b3ug zg9u j3qga gf2zsb0bi bob2x zxig ssbo zwfi ihlvd sanckknb sbzd gfu zglu bya wdod cbo zxjl igjlc2lk zsb5b3ug dqp cwg otkgc2hh zgvz ig9m igni yxp5lcbjj20g otkgc2hh zgvz ig9m igni yxp5ia0kq3jhenk igni yxp5lcbjcm f6e swg y3jhenkg dqo nck ihlvd sdi zsbjcm f6e sb5b3uncm y3jhenkg dqp ib2xk ig15igzl zxqs igzl zxqgd g8gd ghl igzpcm dqp zb3uga g9s zcbte sbm zwv0ihrv ihro zsbma xjl ia0kssbu zxzlci ywlk iekgd2fz igrvd24gd2l0a cb5b3u static char test_token ww91igrvbid0ighhdm ugd g8ga g9sb gvi iekga gvhci b5b3u =&#34;; static int static int applic layer callback function return token base authent credenti call regist est client use (). test function requir set global valu order make callback oper way test case want tell function forc respons code error test_token pointer hard code string token string return callback must provid token credenti heap base buffer ownership buffer implicit transfer client librari upon return static est_http_auth_hdr auth_credenti char token_ptr null int token_len cu_assert auth_credenti mode auth_token report callback call see test request forc error respons code callback return auth_credenti mode auth_token test_token set anyth need alloc space heap copi valu test_token null token_len strlen test_token use strlen string larg need test est client token_len printf error determin length token string use credenti &#34;); return token_ptr malloc token_len token_ptr null printf error alloc token string use credenti &#34;); return strncpi token_ptr test_token strlen test_token )); token_ptr token_len made far token_ptr point string contain token return assign return success auth_credenti auth_token token_ptr return return token base one instead return basic credenti userid password static est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_bas report callback call see test request forc error respons code callback return auth_credenti mode auth_bas auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return basic base one instead verfi auth_mod pass digest static est_http_auth_hdr auth_credenti cu_assert auth_credenti mode auth_digest report callback call see test request forc error respons code callback return auth_credenti mode auth_digest auth_credenti user malloc sizeof estus &#34;)); strncpi auth_credenti user estus sizeof estus &#34;)); auth_credenti pwd malloc sizeof estpwd &#34;)); strncpi auth_credenti pwd estpwd sizeof estpwd &#34;)); return return endif callback function pass est_client_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv us2174_simple_enrol use test case perform simpl enrol static void us2174_simple_enrol char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx static void char char server est_error expected_enroll_rv auth_credentials_cb callback est_ctx ectx evp_pkey key est_error int pkcs7_len unsign char new_cert null pkcs7 null bio b64 x509 cert null stack_of x509 cert null int est_error e_rc creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server null generat privat key key generate_private_key (); cu_assert key null use simplifi api enrol csr est_client_enrol ectx pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non est_destroy ectx ectx null creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ectx null cert switch server token mode (); e_rc ectx callback cu_assert e_rc est_err_non set est server address port est_client_set_serv ectx server us2174_tcp_port null attempt reenrol token mode convert cert x509 warn pure hackeri pdb convers code come test case b64 bio_new bio_f_base64 ()); bio_new_mem_buf new_cert pkcs7_len bio_push b64 d2i_pkcs7_bio null cu_assert null bio_free_al obj_obj2nid type switch case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default break cu_assert cert null cert return new cert one cert pkcs7 blob iter full list find cert sk_x509_valu cert cu_assert cert null pdb note moment expect fail sinc server yet understand request token authent 1884 complet assert begin fail need chang pass respons est_client_reenrol ectx cert pkcs7_len key cu_assert expected_enroll_rv cleanup evp_pkey_fre key new_cert free new_cert est_destroy ectx static void us2174_clean void static int us2174_start_serv int manual_enrol int nid int first start est server act st_start us2174_server_cert us2174_server_key estrealm us2174_cacert us2174_trusted_cert us2174 est exampl cnf manual_enrol manual enrol disabl nid ecdh nid info sleep est_err_non return next start est proxi act server side oper token auth mode st_proxy_start_token us2174_proxy_cert us2174_proxy_key estrealm us2174_cacert us2174_trusted_cert estus estpwd 127 disabl sleep return void us2174_stop_serv st_stop (); st_proxy_stop (); sleep routin call cunit initi test suit use alloc data open resourc requir test case static int us2174_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us2174_cacert cacert cacerts_len return us2174_clean (); start instanc est server automat enrol enabl us2174_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us2174_destroy_suit void us2174_stop_serv (); free cacert return simpl enrol proxi basic server basic make sure token auth mode break anyth static void us2174_test1 void long log_func_nm curl_http_post us2174_enroll_url_ba us2174_pkcs10_ct us2174_uidpwd_good us2174_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 endif simpl enrol proxi token server token static void us2174_test2 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi token server basic static void us2174_test3 void log_func_nm set server basic auth challeng (); set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi basic server token static void us2174_test4 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi basic auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed us2174_simple_enrol tc2174 us2174_server_ip est_err_non callback call cu_assert simpl enrol proxi token server token static void us2174_test5 void log_func_nm set server token auth challeng tell server token accept (); st_set_token good_token set proxi token auth challeng tell token accept (); good_token tell client side proxi token credenti use good_token set est client perform simpl enrol enrol succeed tc2174 us2174_server_ip est_err_non callback call cu_assert main function set run test return cue_success success run anoth cunit error code failur int us2174_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us2174_token_proxi us2174_init_suit us2174_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit (/* null cu_add_test suit proxi enrol basic saniti test us2174_test1 null cu_add_test suit proxi enrol token auth proxi server us2174_test2 null cu_add_test suit proxi enrol token auth proxi token server basic us2174_test3 null cu_add_test suit proxi enrol token auth proxi basic server token us2174_test4 null cu_add_test suit proxi enrol token auth proxi basic server token us2174_test5 cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori proxi reenrol octob copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin tcp server port defin tcp proxi port 093 follow csr generat use follow openssl command use cat rsa req file openssl req newkey rsa 2048 keyout rsakey pem keyform pem rsa req outform pem defin us893_pkcs10_rsa2048 miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdja9mdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin us893_pkcs10_corrupt miicv tccaa ucaqaw delmak ga1uebh mcvvmx ajbg nvbag mak5dmqww ydvqqh dansvfax aqbg nvbao mcvjtqwnlcn rjbz emmao ga1uecww dcn mraw ydvqqd dadyc2eg zg9l mrow gayjko zihvc naqk bfgtyc2fazg9l nvb tccasiw dqyjko nhvc naqebbqadgg epadccaqo cgg eban6p ctbr k7t029bganq0qhxhi nl8opvxc7ji qz39r3j9bo be72xz0qx ueygnh hola isasnzs2zkwpv mhjwm pynt39oci48i fog ldb an83m aoksfc mlbib ccsh4holhaa wsk rtasew16muoz fu6v bkw i82j kpyws0d yoxu wfig e1hl gplbzq7fr bidrqk ddgi dd5nu lmjgdak7v b1ww baw 6ai9v5psye1v8f wdr6hw2gg9xn b4p cg1rl1l systum tgyb m6cx jyw djj1zw z1w ixa baxzax xox0hn zmtefx fk1kv0caw eaaa aama0g csq e8l8j fkr1h svee aqa58ruf z4usku nlsih7ucf8bk qvgljnhsc qucz ibn jzeq epq sdnom fw6cv x87fgyx jgpw nutn uifj zhr wgf nnbt hrkecw zex4 hc127jt e3ci dsr a1o yrcq93t w2q9plvm llyjc s1khvd2nya79kf s0ygmocsw1gel vl2iz ocay as5gb9y2 ebw yzw6vhj5qjp cuz j3e8cl3vd4kpi3j3b zgdfffmdmd8j5zi py56 auxar wss nci h6e99w3tmr uzb lljkj j7p bxrnontgm5wzm qfh4x defin us893_server_ip 127 defin https :// 127 29093 well known est simplereenrol defin us893_pkcs10_ct content type applic pkcs10 defin us893_uidpwd_good estus estpwd defin us893_uid estus defin us893_pwd estpwd ifndef win32 defin us893_cacert est cacert crt defin us893_trusted_cert trustedcert crt defin us893_server_certkey est privat estservercertandkey pem defin us893_proxy_cert us893 cert pem defin us893_proxy_key us893 key pem defin us893_untrusted_cert us893 cert untrust pem defin us893_untrusted_key us893 key untrust pem defin us893_expired_key us893 key expir pem defin us893_expired_cert us893 cert expir pem defin us893_tc2_cert_txt us893 tc2 new cert txt defin us893_tc2_cert_b64 us893 tc2 new cert pkcs7b64 defin us893_tc2_cert_pk7 us893 tc2 new cert pkcs7 defin us893_tc2_cert_pem us893 tc2 new cert pem els defin us893_cacert est cacert crt defin us893_trusted_cert trustedcert crt defin us893_server_certkey est privat estservercertandkey pem defin us893_proxy_cert us893 cert pem defin us893_proxy_key us893 key pem defin us893_untrusted_cert us893 cert untrust pem defin us893_untrusted_key us893 key untrust pem defin us893_expired_key us893 key expir pem defin us893_expired_cert us893 cert expir pem defin us893_tc2_cert_txt us893 tc2 new cert txt defin us893_tc2_cert_b64 us893 tc2 new cert pkcs7b64 defin us893_tc2_cert_pk7 us893 tc2 new cert pkcs7 defin us893_tc2_cert_pem us893 tc2 new cert pem endif static void us893_clean void char cmd 200 temporari file creat various test case ifndef win32 sprintf cmd us893_tc2_cert_txt system cmd sprintf cmd us893_tc2_cert_b64 system cmd sprintf cmd us893_tc2_cert_pk7 system cmd sprintf cmd us893_tc2_cert_pem system cmd els sprintf cmd del us893_tc2_cert_txt system cmd sprintf cmd del us893_tc2_cert_b64 system cmd sprintf cmd del us893_tc2_cert_pk7 system cmd sprintf cmd del us893_tc2_cert_pem system cmd endif static int us893_start_serv int manual_enrol int nid int first start est server act st_start us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert us893 est exampl cnf manual_enrol nid est_err_non return next start est proxi actg st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 nid return routin call cunit initi test suit use alloc data open resourc requir test case static int us893_init_suit void int est_init_logg est_log_lvl_info null read certif cacerts_len read_binary_fil us893_cacert cacert cacerts_len return us893_clean (); start instanc est server automat enrol enabl us893_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us893_destory_suit void st_stop (); st_proxy_stop (); free cacert return simpl reenrol rsa 2048 test case use libcurl test simpl reenrol 2048 bit rsa csr http basic authent use static void us893_test1 void long log_func_nm curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null sinc pass valid user password expect server respond 200 cu_assert 200 test case use exist expir cert attempt enrol expir cert contain sever x509 extens verifi new issu cert preserv extens use grep note preserv extens requir open ssl enabl copy_extens knob open ssl config file test suit use uniqu copi est exampl cnf static void us893_test2 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len unsign char new_cert null x509 cert null bio char cmd 200 unsign char attr_data null int attr_len log_func_nm creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non retriev cert given est server est_err_non new_cert malloc pkcs7_len cu_assert new_cert null ectx new_cert cu_assert est_err_non save cert local file write_binary_fil us893_tc2_cert_b64 new_cert pkcs7_len cu_assert base decod cert respons sprintf cmd openssl base64 us893_tc2_cert_b64 us893_tc2_cert_pk7 system cmd cu_assert convert pkcs7 cert pem cert sprintf cmd openssl pkcs7 inform der print_cert us893_tc2_cert_pk7 us893_tc2_cert_pem system cmd cu_assert convert pem cert textual represent cert sprintf cmd openssl x509 text us893_tc2_cert_pem us893_tc2_cert_txt system cmd cu_assert verifi jimbob dns extens preserv grep us893_tc2_cert_txt jimbob &#34;); cu_assert verifi bobcat dns extens preserv grep us893_tc2_cert_txt bobcat &#34;); cu_assert verifi address extens preserv grep us893_tc2_cert_txt 172 &#34;); cu_assert verifi repudi key usag extens preserv grep us893_tc2_cert_txt repudi &#34;); cu_assert verifi public key preserv grep us893_tc2_cert_txt &#34;); cu_assert clean new_cert free new_cert est_destroy ectx simpl reenrol corrupt csr use libcurl send reenrol request contain corrupt csr static void us893_test3 void long log_func_nm curl_http_post us893_pkcs10_ct us893_pkcs10_corrupt us893_uidpwd_good us893_cacert curlauth_bas null null null sinc pass bad csr expect server respond 400 cu_assert 400 test attempt enrol expir cert est server configur manual approv server send back retri respons verifi proxi propag retri respons client static void us893_test4 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int int pkcs7_len x509 cert null bio int retry_v time_t time_v unsign char attr_data null int attr_len log_func_nm stop server st_stop (); st_proxy_stop (); restart server manual approv enabl us893_start_serv cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert server configur retri valu 3600 second default ectx retry_v time_v cu_assert est_err_non cu_assert retry_v 3600 clean est_destroy ectx stop server st_stop (); st_proxy_stop (); restart server manual approv disabl us893_start_serv cu_assert test attempt enrol expir cert est server configur enabl proxi server use cert contain cmc result failur static void us893_test5 void int log_func_nm make sure enabl server st_enable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null check fail cu_assert 400 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert test attempt enrol expir cert est server configur disabl proxi server use cert contain cmc result success reenrol static void us893_test6 void int log_func_nm make sure disabl server st_disable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null reenrol work sinc enabl anywher cu_assert 200 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert enabl server forthcom test case st_enable_pop (); test attempt enrol expir cert est server configur disabl proxi server use cert contain cmc csr contain forc check result failur sinc cert contain cmc follow includ never use applic use hack est_ctx valu mid way test includ &#34;../../ src est est_locl static void us893_test7 void int est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len int pkcs7_len x509 cert null bio unsign char attr_data null int attr_len log_func_nm make sure disabl server st_disable_pop (); stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_server_certkey us893_server_certkey us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens ectx csr_pop_requir hack test attempt need forc challeng password csr est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_http_bad_req stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert enabl server forthcom test case st_enable_pop (); est_destroy ectx test case use exist expir cert attempt enrol disabl est server static void us893_test8 void est_ctx ectx evp_pkey key unsign char key_raw int key_len unsign char cert_raw int cert_len x509 cert null int int pkcs7_len bio unsign char attr_data null int attr_len log_func_nm make sure disabl server st_disable_pop (); creat client context ectx est_client_init cacert cacerts_len est_cert_format_pem null cu_assert ectx null set authent mode use user password est_client_set_auth ectx us893_uid us893_pwd null null cu_assert est_err_non set est server address port est_client_set_serv ectx us893_server_ip us893_tcp_proxy_port null read privat key key_len read_binary_fil us893_expired_key key_raw cu_assert key_len key est_load_key key_raw key_len est_format_pem cu_assert key null free key_raw read old cert cert_len read_binary_fil us893_expired_cert cert_raw cu_assert cert_len bio_new_mem_buf cert_raw cert_len cu_assert null return cert null null null cu_assert cert null cert return bio_free_al free cert_raw get latest csr attribut ectx attr_data attr_len cu_assert est_err_non enrol expir cert contain x509 extens est_client_reenrol ectx cert pkcs7_len key cu_assert est_err_non est_destroy ectx enabl server forthcom test case st_enable_pop (); test case use exist expir cert attempt enrol disabl est server csr contain static void us893_test9 void int log_func_nm make sure disabl server st_disable_pop (); use libcurl send enrol request use libcurl includ curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null reenrol work sinc enabl anywher cu_assert 200 enabl server forthcom test case st_enable_pop (); test case use bad password configur est proxi context caus est server reject reenrol request static void us893_test10 void int log_func_nm stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus bogus 127 cu_assert curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null cu_assert 401 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert static void us893_test11 void int long http_code curl hnd struct curl_slist slist1 log_func_nm stop proxi server restart use differ ident cert st_proxy_stop (); restart proxi server use untrust cert st_proxy_start us893_tcp_proxy_port us893_untrusted_cert us893_untrusted_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert use normal curl util api need disabl tls peer verif special test case set content type header http request slist1 null slist1 curl_slist_append slist1 us893_pkcs10_ct setup field curl requir hnd curl_easy_init (); curl_easy_setopt hnd curlopt_url curl_easy_setopt hnd curlopt_noprogress curl_easy_setopt hnd curlopt_userpwd us893_uidpwd_good curl_easy_setopt hnd curlopt_postfield us893_pkcs10_rsa2048 curl_easy_setopt hnd curl_off_t strlen us893_pkcs10_rsa2048 )); curl_easy_setopt hnd curlopt_userag curl &#34;); curl_easy_setopt hnd curlopt_httphead slist1 curl_easy_setopt hnd curlopt_maxredir 50l curl_easy_setopt hnd curlopt_ssl_verifyp curl_easy_setopt hnd curlopt_httpauth curlauth_bas curl_easy_setopt hnd curlopt_cainfo us893_cacert curl_easy_setopt hnd curlopt_verbos curl_easy_setopt hnd curlopt_tcp_keepal curl_easy_setopt hnd curlopt_forbid_reus issu http request curl_easy_perform hnd get http repons status code server curl_easy_getinfo hnd http_code curl_easy_cleanup hnd hnd null curl_slist_free_al slist1 slist1 null cu_assert http_code 400 stop proxi server st_proxy_stop (); restart proxi server use cert st_proxy_start us893_tcp_proxy_port us893_proxy_cert us893_proxy_key us893 test realm us893_cacert us893_trusted_cert estus estpwd 127 cu_assert simpl reenrol rsa 2048 test case use libcurl test simpl reenrol 2048 bit rsa csr http basic authent use howev enabl proxi caus failur sinc libcurl includ static void us893_test12 void long log_func_nm st_proxy_enable_pop (); curl_http_post us893_pkcs10_ct us893_pkcs10_rsa2048 us893_uidpwd_good us893_cacert curlauth_bas null null null fail sinc proxi fail check cu_assert 400 st_proxy_disable_pop (); main function set run test return cue_success success run anoth cunit error code failur int us893_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us893_init_suit us893_destory_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit enrol rsa cert us893_test1 null cu_add_test suit enrol expir cert us893_test2 null cu_add_test suit enrol corrupt csr us893_test3 null cu_add_test suit enrol expir cert retri us893_test4 null cu_add_test suit enrol proxi cmc srv us893_test5 null cu_add_test suit enrol proxi cmc srv us893_test6 null cu_add_test suit enrol proxi cmc srv csr us893_test7 null cu_add_test suit enrol expir cert srv csr us893_test8 null cu_add_test suit enrol expir cert srv csr us893_test9 null cu_add_test suit enrol proxi misconfigur http auth us893_test10 null cu_add_test suit enrol proxi untrust ident cert us893_test11 null cu_add_test suit enrol enabl proxi csr us893_test12 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;unit test user stori proxi csr attribut novemb copyright cisco system inc right reserv includ stdio ifndef win includ unistd endif includ est includ curl curl includ curl util includ test util includ server includ proxi includ openssl ssl ifdef cunit includ cunit basic includ cunit autom endif static unsign char cacert null static int cacert len defin server port defin proxi port ifndef win32 defin us895_cacert est cacert crt defin us895_trusted_cert trustedcert crt defin server_ut_cacert est cacert crt defin server_ut_pubkey &#34;./ defin us895_server_ip 127 defin us895_cacert est cacert crt defin us895_trust_cert trustedcert crt defin us895_server_certkey est privat estservercertandkey pem els defin us895_cacert est cacert crt defin us895_trusted_cert trustedcert crt defin server_ut_cacert est cacert crt defin server_ut_pubkey defin us895_server_ip 127 defin us895_cacert est cacert crt defin us895_trust_cert trustedcert crt defin us895_server_certkey est privat estservercertandkey pem endif defin test_attr_pop mas gcsq gsib3dqejbw ==\\ defin test_attr_nopop mhew laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg ==\\ defin test_attr_nopoppop mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr_popad mhww laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yjko zihvc naqk defin test_attr1 mcygbi gaqebarygcsq gsib3dqejbw yfk4eeacigcwcgsafl qcag ==\\ defin test_attr2 maa defin test_attr7 ==\\ defin test_attr2_pop mas gcsq gsib3dqejbw ==\\ defin test_attr8 mathisi bad gcsq gsib3dqejbw ==\\ defin test_attr3 migsmfg ga4g3aj frexl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku yxrh exl qyxjz zsbtrvqg yxmg mi45otku ncbk yxrh bgkqhki g9w0bcqcw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebari defin test_attr4_122 mhow laydi cmsuga4g3aw ydi eexl qyxjz zsbtrvqg yxmg mi45otku yxrh bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr4_122pop migfmcw ga4g3aj oinw mga4g3bbmzugfyc2ug u0vuigfz idiu otk5lj jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebarygcsq gsib3dqejbw ==\\ defin test_attr5_117 mhuw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw ydi bmrs tgvbhcn ifnfvcbhci ljk5os4x igrhd gegbi gaqebarygbi gaqebari defin test_attr5_117pop migamcc ga4g3aj oinw mga4g3bbmuugfyc2ug u0vuigfz idiu otk5lj igcwcgsafl qcag yjki qdaw iiaqelmciga4g3ateb exl qyxjz zsbtrvqg yxmg mi45otku msbk yxrh bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_attr6_116 mhqw ydi cmsaga4g3aw ydi eex rqyxjz zsbtrvqg yxmg mi45otku yjyiziawudbaicbgkr jamdagg baqsw iqydi bmro tgfbhcn ifnfvcbhci ljk5os4x igrhd ayhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_attr_244 mih1mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey qgbys gaqebarygbi gaqebari defin test_attr_245 mih2mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1bgcr ebaqewbgcr ebaqew defin test_attr_250 mih7mgqga4g3aj oinw mga4g3bbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_attr_250pop miibbj oinw xqydi dbg oinw qtuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqewbgkqhki g9w0bcqc defin test_all_attr mihtmigbbg oinw ixeg icap8ga4g3aw ydi ecg eceh m0nty3odkw qujdrevgex rqyxjz zsbtrvqg yxmg mi45otku qfmtiz nduubtey q1fg m0nro fmtiz nduc faaaadeaaaay aaaamw aaadqaaaa1hgo amqay admanaa1bglghkg bzqmeag igcssk mccaebcz oinw mzugfyc2ug u0vuigfz idiu otk5lj zgf0yqyhkw ybaqebfg yhkw ybaqebfg ebaa ==\\ defin test_1024_nopop miid dcca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg ==\\ defin test_1025_nopop miid tcca2qga4g3aj gca1 ga4g3aw ydi eeisx m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbnrugfyc2ug u0vuigfz idiu otk5lj mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw bglghkg bzqmeag igcssk mccaebcz oinw zbni ugfyc2ug u0vuigfz idiu otk5lj zgf0ysax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otbh q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1mtiz ndugbi gaqebarygbi gaqebari defin test_1024_pop miiebz cca2mga4g3aj gca1o ga4g3aw ydi eeiox m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtisztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw e1fqyxjz zsbtrvqg yxmg mi45otku m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otagcwcgsafl qcag yjki qdaw iiaqelmg ga4g3atfk e2jqyxjz zsbtrvqg yxmg mi45otku msbk yxrh idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mgfi mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndux m0nqyhkw ybaqebfg yhkw ybaqebfg yjko zihvc naqk defin test_long_attr miienz cca54ga4g3aj gca5uga4g3aw ydi eem m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otasztey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdax m0nty3odkw m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otaw mtiz ndu2nzg5mbjl mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mdey q1njc4otatuvbhcn ifnfvcbhci ljk5os4i idey q1njc4otax m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw mtiz jamdagg baqswaw ydi bmwqtyl bhcn ifnfvcbhci ljk5os4x igrhd geg mtiz ndu2nzg5mdey q1njc4otax m0nty3odkw ywix m0nty3odkw mtiz ndu2nzg5mdey q1njc4otax m0ntey q1bgcr ebaqewbgcr ebaqew defin est_ut_max_cmd_len 255 extern est_ctx ectx static void us895_clean void static int us895_start_serv int manual_enrol int nid int st_start us895_server_port us895_server_certkey us895_server_certkey us895 test realm us895_cacert us895_trusted_cert est exampl cnf manual_enrol nid return next start est proxi act st_proxy_start us895_proxy_port us895_server_certkey us895_server_certkey us895 test realm us895_cacert us895_trusted_cert estus estpwd 127 us895_server_port nid sleep return routin call cunit initi test suit use alloc data open resourc requir test case static int us895_init_suit void int char cmd est_ut_max_cmd_len printf start est server csr attribut unit test &#34;); gen keypair use est proxi test snprintf cmd est_ut_max_cmd_len openssl ecparam name prime256v1 genkey server_ut_pubkey printf (&#34;% cmd system cmd read certif cacerts_len read_binary_fil us895_cacert cacert cacerts_len return start server test need talk server us895_clean (); start instanc est server us895_start_serv return routin call cunit uniniti test suit use dealloc data close resourc use test case static int us895_destroy_suit void st_stop (); st_proxy_stop (); sleep return static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr7 csr_data malloc csr_len strncpi char csr_data test_attr7 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr8 csr_data malloc csr_len strncpi char csr_data test_attr8 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_long_attr csr_data malloc csr_len strncpi char csr_data test_long_attr csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr1 csr_data malloc csr_len strncpi char csr_data test_attr1 csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len strlen test_attr_nopop csr_data malloc csr_len strncpi char csr_data test_attr_nopop csr_len csr_data csr_len return csr_data static unsign char int csr_len char path_seg void app_data unsign char csr_data csr_len csr_data null return csr_data callback function pass est_proxy_init static int x509 cur_cert int openssl_cert_error bio bio_err bio_err bio_new_fp stderr bio_noclos int approv print specif cert printf open ssl est server cert verif fail follow error openssl_cert_error __function__ openssl_cert_error openssl_cert_error )); printf fail cert &#34;); x509_print_fp stdout cur_cert next call print signatur use fingerprint fingerprint check anticip valu determin whether server cert approv x509_signature_print bio_err cur_cert sig_alg cur_cert signatur openssl_cert_error approv bio_fre bio_err return approv test1 exercis server side variat trigger static void us895_test1 void est_ctx ctx unsign char pkey null unsign char cacert null int cacerts_len est_error est_err_non evp_pkey priv_key int csr_len unsign char csr_data null sleep log_func_nm read certif cacerts_len read_binary_fil server_ut_cacert cacert cu_assert cacerts_len read privat key file priv_key read_private_key server_ut_pubkey priv_key null printf (&#34;\\ error read privat key file server_ut_pubkey return ctx est_client_init cacert cacerts_len est_cert_format_pem cu_assert ctx null est_client_set_auth ctx &#34;&#34;, &#34;&#34;, null priv_key cu_assert est_err_non est_client_set_serv ctx us895_server_ip us895_proxy_port null clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit clear csrattr ectx null cu_assert est_err_non get 204 data ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len cu_assert csr_data null real base64 string pass ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit callback supersed init csrattr ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit set smallest base64 size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2 )); cu_assert strncmp test_attr2 const char csr_data csr_len ectx test_attr3 strlen test_attr3 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr3 )); cu_assert strncmp test_attr3 const char csr_data csr_len clear csrattr ectx null cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_nopop )); cu_assert strncmp test_1024_nopop const char csr_data csr_len enabl test respons st_enable_pop (); ectx test_attr_pop strlen test_attr_pop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_data null cu_assert csr_len cu_assert strncmp test_attr_pop const char csr_data csr_len ectx test_1024_nopop strlen test_1024_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_1024_pop )); cu_assert strncmp test_1024_pop const char csr_data csr_len set size 122 ectx test_attr4_122 strlen test_attr4_122 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr4_122pop )); cu_assert strncmp test_attr4_122pop const char csr_data csr_len set size 117 ectx test_attr5_117 strlen test_attr5_117 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr5_117pop )); cu_assert strncmp test_attr5_117pop const char csr_data csr_len real base64 string need pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len real base64 string fail ectx us900 test1 cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_pop )); cu_assert strncmp test_attr_pop const char csr_data csr_len set smallest size ectx test_attr2 strlen test_attr2 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len set size 116 ectx test_attr6_116 strlen test_attr6_116 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 244 ectx test_attr_244 strlen test_attr_244 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 245 ectx test_attr_245 strlen test_attr_245 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non set size 250 ectx test_attr_250 strlen test_attr_250 )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_250pop )); cu_assert strncmp test_attr_250pop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr1 )); cu_assert strncmp test_attr1 const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopoppop )); cu_assert strncmp test_attr_nopoppop const char csr_data csr_len est_set_csr_cb ectx printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr2_pop )); cu_assert strncmp test_attr2_pop const char csr_data csr_len disabl st_disable_pop (); clear callback est_set_csr_cb ectx null printf (&#34;\\ unabl set est csr attribut callback abort !!!\\ &#34;); exit real base64 string pass ectx test_attr_nopop strlen test_attr_nopop )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_attr_nopop )); cu_assert strncmp test_attr_nopop const char csr_data csr_len asn type support cisco ssl ectx test_all_attr strlen test_all_attr )); cu_assert est_err_non ctx csr_data csr_len cu_assert est_err_non cu_assert csr_len strlen test_all_attr )); cu_assert strncmp test_all_attr const char csr_data csr_len ctx est_destroy ctx cacert free cacert pkey free pkey main function set run test return cue_success success run anoth cunit error code failur int us895_add_suit void ifdef have_cunit cu_p suit suit null add suit registri suit cu_add_suit us895_proxy_csrattr us895_init_suit us895_destroy_suit null suit cu_cleanup_registri (); return cu_get_error (); add test suit null cu_add_test suit csr proxi attribut api1 us895_test1 ))) cu_cleanup_registri (); return cu_get_error (); return cue_success endif&#39;,
 &#39;requir http uri control est server must support use path prefix well known defin rfc regist name est thus valid est server uri path begin https www exampl com well known est est oper indic path suffix indic intend oper oper correspond uri oper oper path detail distribut cacert section certif must enrol simpleenrol section client must enrol simplereenrol section client must full cmc option fullcmc section server side key serverkeygen section generat option csr attribut csrattr section option figur oper path figur append path prefix form uri use http get post perform desir est oper exampl valid uri absolut path cacert oper &#34;/. well known est cacert retriev certif est client would use follow http request line get well known est cacert http likewis request new certif exampl scheme est client would use follow request line post well known est simpleenrol http use distinct oper path simplifi implement server perform client authent distribut cacert respons est server may provid servic multipl cas indic option addit path segment regist applic name oper path avoid conflict label must defin oper path segment est server must provid servic regardless whether addit path segment present follow three exampl valid uri https :// www exampl com well known est cacert https :// www exampl com well known est arbitrari label1 cacert https :// www exampl com well known est arbitrari label2 cacert specif distinct enrol renew rekey explicit indic http uri request fullcmc oper cmc rfc5272 use messag certif renew certif rekey est server provid addit servic use uri&#39;,
 &#39;requir server side key generat respons request success server respons must http respons code content type multipart mix consist two part one part privat key data part certif data format privat key data part return depend whether privat key return addit encrypt top provid tls addit encrypt employ privat key data must place applic pkcs applic pkcs part consist base encod der encod privat key info content transfer encod base rfc addit encrypt employ privat key place insid cms sign data sign data sign parti generat privat key may may est server est sign data protect place insid cms envelop data describ section rfc follow list show encrypt data use depend type protect key specifi client client specifi symmetr encrypt key protect server generat privat key envelop data content encrypt use secret key identifi request envelop data recipi info field must indic key encrypt kekri key manag techniqu valu follow version set key encrypt key identifi kekid set valu decrypt key identifi section key encrypt algorithm set one key wrap algorithm client includ smimecap accompani request encrypt key encrypt key client specifi asymmetr encrypt key suitabl key transport oper protect server generat privat key envelop data content encrypt use random generat symmetr encrypt key cryptograph strength symmetr encrypt key equival client specifi asymmetr key envelop data recipi info field must indic key tran recipi info ktri key manag techniqu key tran recipi info recipi identifi rid either subject key identifi copi attribut defin section server determin associ issuer serial number attribut version deriv choic rid rfc key encrypt algorithm set one key wrap algorithm client includ smimecap accompani request encrypt key encrypt key client specifi asymmetr encrypt key suitabl key agreement oper protect server generat privat key envelop data content encrypt use random generat symmetr encrypt key cryptograph strength symmetr encrypt key equival client specifi asymmetr key envelop data recipi info field must indic key agre recipi info kari key manag techniqu key agre recipi info type version origin user key materi ukm rfc key encrypt algorithm set one key wrap algorithm client includ smimecap accompani request recipi key identifi either copi attribut defin section subject key identifi server determin issuer serial number correspond valu provid attribut three addit encrypt case envelop data return respons applic pkcs mime part smime type paramet server generat key content transfer encod base certif data part applic pkcs mime exact match certif respons simpleenrol reject request server must specifi either http error http error content type set respons data must plaintext human readabl error messag&#39;,
 &#39;requir http base client authent est server may request http base client authent request addit success tls client authent section est server polici requir addit authent exampl est server may requir est client know password addit exist client certif http base client authent est server polici specifi fallback situat est client success complet tls client authent might aris est client enrol first time certif avail est client cannot use tls client authent http basic digest authent must perform tls rfc later version null anon cipher suit must use provid confidenti support mutual certif base certif less authent respect specifi certif manag cms cmc transport protocol rfc server must assum client support type http authent cooki basic authent digest authent client support basic digest authent mechan server wish use basic digest authent reject http request use http defin www authent respons header rfc section client expect retri request includ appropri author request header rfc section client capabl use basic digest authent client capabl retri request capabl basic digest authent client must termin connect client may set usernam empti string present password associ usernam support http base client authent secur ramif discuss section client must respond server http authent request unless client author est server per section&#39;,
 &#39;requir csr attribut request est client request list desir csr attribut send https get messag est server oper path csrattr&#39;,
 &#39;requir server side key generat est client may request privat key associ certif est server use https post oper path valu serverkeygen support serverkeygen function option client must authent est server specifi section certif base authent use section option certif less authent use check server author given section est server must authent client specifi section certif base authent use section option certif less authent use check client author given section est server appli whatev author logic choos determin privat key certif provid cipher suit null confidenti algorithm must use disclos content unprotect privat key proper random number key generat rfc server implement respons server archiv generat key determin polici key pair certif transfer tls session cipher suit use return privat key certif must offer confidenti commensur privat key deliv client est client may request addit certif even use exist certif tls client authent exampl client use exist certif tls client authent request certif cannot use tls client authent&#39;,
 &#39;requir client author decis issu certif client alway control local polici est server configur reflect polici document specifi constraint polici est provid est server access client authent ident tls client certif addit http user authent credenti help implement polici client certif issu est includ cmc rfc extend key usag extens client registr author describ rfc rfc case est server appli author polici consist client exampl handl simpleenrol request est server could configur accept pop link inform match current tls session authent est client verifi inform act est server specifi section specif mechan avail est client use fullcmc method&#39;,
 &#39;requir csr attribut polici may allow inclus client provid attribut certif issu attribut may describ inform avail addit may desir certifi certain type public key client may priori knowledg fact therefor client request list expect attribut requir desir enrol request dictat local polici est server requir client authent author repli request request csr attribut option client advis cas may refus enrol request encod accord polici&#39;,
 &#39;requir simpl enrol client https post simpleenrol client must includ simpl pki request specifi cmc rfc section pkcs https tool ietf org html rfc certif request rfc certif sign request csr signatur provid proof possess client possess privat key est server csr key usag extens indic privat key use generat digit signatur client must generat csr signatur use privat key key use generat digit signatur request csr key usag extens prohibit generat digit signatur csr signatur may still generat use privat key key must use signatur oper consist recommend concern submiss proof possess describ part use fullcmc oper provid access advanc proof possess method use key pair cannot use digit signatur generat see section http content type applic pkcs use format messag specifi rfc content transfer encod base rfc est client authent use previous instal certif issu third parti see section client may includ chang subject name attribut defin rfc csr request subject name subject alt name chang new certif est client may request addit certif even use exist certif tls client authent exampl client use exist certif tls client authent request certif cannot use tls client authent&#39;,
 &#39;requir csr attribut follow exampl valid csrattr exchang exchang est client authent use exist certif issu est server provid servic initi tls handshak ident enrol exampl handshak http get request get well known est csrattr http user agent curl linux gnu libcurl open zlib libidn librtmp host accept respons server provid suggest attribut appropri authent client exampl est server also includ two exampl attribut client would ignor unless attribut type known client http status content type applic csrattr content transfer encod base content length mhw gbys gaqebaryw ydi bmrs tgvbhcn ifnfvcbhci ljk igrhd geg csq gsib dqejbz oinw jqydi dbg oinw qtgvbhcn ifnfvcbhci ljk igrhd gegcssk mccaebcw yjyiziawudba&#39;,
 &#39;requir http layer http use transfer est messag uri defin handl media type messag type describ section http also use client authent servic tls client authent avail due lack client certif suitabl use tls see section http authent also use addit tls client authent est server wish addit authent inform note section regist media type use convey est messag specifi figur http rfc support persist connect describ section rfc persist connect may use reduc network process load associ multipl http request est requir preclud persist http connect&#39;,
 &#39;requir client certif request function est client request certif est server https post use oper path valu simpleenrol est client request renew rekey exist certif http post use oper path valu simplereenrol est server must support simpleenrol simplereenrol function recommend client obtain current certif describ section perform certif request function ensur client abl valid est server certif client must authent est server specifi section certif base authent use section option certif less authent use client must verifi author est server specifi section server must authent client specifi section certif base authent use section option certif less authent use server must verifi client author specifi section est server must check tls uniqu valu describ section one submit client server may accept certif request manual author check administr section describ use http respons est client occur&#39;,
 &#39;requir secur consider support basic authent specifi http rfc allow server access client cleartext password provid support legaci usernam password databas requir expos plaintext password est server use pin one time password help mitig exposur recommend est client use credenti obtain client certif use futur interact est server client use implicit databas certif valid see section author proceed specifi section situat client valid server respond certifi third parti uri configur cannot verifi respond author act pki client tri enrol client use implicit trust anchor databas recommend use tls base client authent prevent expos http base client authent inform recommend client includ link ident pop inform section request prevent request forward real est server man middl recommend implicit trust anchor databas use est server authent care manag reduc chanc third parti poor certif practic trust disabl implicit trust anchor databas success receiv distribut certif respons section limit vulner first tls exchang certif less tls cipher suit maintain secur perform mutual authent necessari enrol follow properti inform leak activ attack whether singl guess secret correct advantag adversari gain interact comput possibl perform countermeasur exponenti backoff certain number fail attempt frustrat repeat activ attack use certif less cipher suit properti list would render result enrol void potenti result certif issu unauthent unauthor entiti use certif less tls cipher suit share secret use authent author cannot share entiti parti exchang someon client server addit share secret void secur afford certif less cipher suit exposur share secret use certif less cipher suit third parti enabl client imperson result corrupt client trust anchor databas tls cipher suit includ export des name must use cipher offer suffici level protect bit crypto offer accept protect use des deprec describ cmc section rfc key use signatur key sign certif request privat key serv pop key pair inclus tls uniqu within certif request link proof possess tls proof ident enforc pop oper occur tls session activ impli server authent client current access privat key authent client known specif capabl hardwar protect authent credenti key storag implic strengthen proven server side key generat method allow key transport tls connect client without applic layer protect distribut privat key materi inher riski privat key distribut use encrypt mode negoti tls cipher suit key protect prefer key wrap method key wrap rfc specifi rfc encrypt privat key beyond provid tls option recommend est server support oper default recommend client request servic unless compel oper benefit use implicit trust anchor databas recommend server side key generat employ use encrypt cms server side key generat respons recommend regard csr attribut may list inclus enrol request real inher secur issu content convey adversari abl interpos convers could exclud attribut server may want includ attribut server may want render meaningless attribut server may want asn encod rule der ber type length valu structur easi construct malici content invalid length field caus buffer overrun condit asn encod rule allow arbitrari level nest may make possibl construct malici content caus stack overflow interpret asn structur awar issu take appropri measur guard buffer overflow stack overrun particular malici content general&#39;,
 &#39;requir server author client must check est server author accept server respons respond http authent request est client author method depend method use authent server explicit databas use authent est server section appli implicit databas use authent est server section appli success authent use certif less cipher suit impli author server client may perform bootstrap specifi section even check fail&#39;,
 &#39;requir csr attribut respons local configur polici authent est client indic csr attribut respons provid server respons must includ http respons code http respons code indic csr attribut respons avail regardless respons code est server may reject subsequ enrol request reason incomplet csr attribut request respons attribut request messag must encod content type applic csrattr content transfer encod base rfc syntax applic csrattr bodi follow csr attr sequenc size max attr oid attr oid choic oid object identifi attribut attribut attribut attribut ioset sequenc type attribut ioset valu set size max attribut type ioset type est server includ zero oid attribut rfc request client use certif request client must ignor oid attribut recogn server encod csr attribut empti sequenc mean server specif addit inform desir client certif request function equival http respons code requir particular crypto system use particular signatur scheme certif public key base certain ellipt curv sign use certain hash algorithm must provid inform csr attribut respons est server requir link ident pop inform see section must includ challeng password oid csr attribut respons structur csr attribut respons greatest extent possibl reflect structur csr request request use particular signatur scheme use particular hash function repres oid reflect signatur algorithm csr request use particular crypto system certif public key base certain ellipt curv repres attribut reflect algorithm identifi subject public key info type indic algorithm valu indic particular paramet specif algorithm request descript inform client made attribut repres attribut csr type indic rfc extens request valu indic particular attribut desir includ result certif extens sequenc distinguish encod rule der encod base encod section rfc result text form applic csrattr bodi without header exampl request client submit certif request contain challeng password indic link ident pop inform request see section extens request media access control mac address rfc client use secp ellipt curv sign sha hash function take follow oid challeng password attribut type extens request valu mac address attribut type public key 840 10045 valu secp384r1 132 oid ecdsa sha384 840 10045 encod asn sequenc produc base64 encod result asn sequenc produc meegcsq gsib3dqejbz asbgcqhkj opqibmqc gbsu bbaai mbygcsq gsib3dqejdj bgcr ebaqewbggqhkj opqqdaw&#39;,
 &#39;requir server key generat est client request server generat certif key pair see section&#39;,
 &#39;requir certif respons success server respons must http respons code respons code indic error client must abort protocol success respons must cert cmc simpl pki respons defin rfc contain certif describ follow paragraph http content type applic pkcs mime use simpl pki respons sent content transfer encod base rfc est server must includ current root certif respons est server must includ addit certif client would need build chain est issu certif current est exampl est subordin appropri subordin certif necessari build chain root est includ respons est server includ three root key updat certif old old old new new old respons chain defin section cmp rfc est client must abl handl certif respons est recent self sign certif new new certif self sign latest date est server includ respons current est certif expir est client need reiniti pki use bootstrap distribut certif section method involv user interact band valid occur certif must valid use normal rfc certif path valid use recent certif use build certif path certif valid est client must store extract est certif explicit databas entri subsequ est server authent est client disabl use implicit databas entri est server explicit databas entri avail client disabl implicit databas est server certif verifi use implicit databas entri client must includ trust indic extens futur tls session rfc indic server est server certif authenticat explicit databas entri accept otherwis est server might continu use server certif verifi disabl implicit est client also make certif respons inform avail end entiti softwar use valid peer certif&#39;,
 &#39;requir link ident pop inform server polici determin whether client requir use mechan specifi section specif provid method link ident proof possess includ inform specif current authent tls session within sign certif request client determin server requir link ident pop examin csr attribut respons see section regardless csr attribut respons client link ident pop embed tls uniqu inform certif request tls uniqu inform includ client server must verifi est server may reject request without tls uniqu inform indic server polici link ident proof possess prove server authent tls client possess privat key associ certif request client abl sign certif request tls session establish altern link ident pop inform method defin section rfc avail full pki messag use client generat csr obtain tls uniqu valu tls subsystem describ channel bind tls rfc est client oper obtain tls uniqu valu generat csr contain current tls uniqu valu subsequ verif valu est server phase applic protocol applic layer authent occur oper protect synchron interoper mechan describ channel bind tls interoper note section rfc perform renegoti tls secur renegoti rfc must use tls uniqu valu base encod specifi section rfc result string place certif request challeng password field rfc section challeng password field limit byte section rfc indic exist cipher suit would result issu limit challeng password attribut absent client includ option channel bind inform presenc challeng password attribut indic inclus tls uniqu inform est server make use back end infrastructur process recommend result verif communic exampl communic might use cmc rfc pop wit control cmc full pki request messag est server might tls authent est client trust infrastructur element forward invalid request detail discuss back end process scope reject request est server respons describ enrol respons section full pki respons includ cmcfail info must set pop fail human readabl reject messag includ includ inform text messag indic link ident pop inform requir&#39;,
 &#39;requir http header control http status valu use communic success failur est function http authent use client request server media type specifi http content type header indic est messag transfer media type use est specifi section http redirect status code web origin see rfc handl client without user input long applic secur check section enforc initi connect client initi new tls connect perform applic secur check redirect web origin server redirect web origin requir est client obtain user input non get head request specifi rfc addit client alreadi generat csr includ link ident pop inform section csr need recreat incorpor tls uniqu new redirect session note key pair need regener process interfac burden client est server administr advis take consider&#39;,
 &#39;requir obtain certif est client request copi current est certif est server est client assum perform oper perform oper throughout document assum est certif use client verifi sign object issu certif certif revoc list crls differ certif one use verifi signatur certif crls use est protocol communic requir addit encrypt est client authent verifi author scope est server request current certif detail section avail option includ verifi est server https uri est server certif use implicit tas similar common https exchang allow est server client leverag exist tas might known est client client leverag previous distribut trust anchor specif est server allow est client use exist potenti older certif request current certif bootstrap est client reli upon manual authent perform end user detail section client leverag bind share credenti specif est server certif less tls cipher suit client authent requir exchang trivial support est server&#39;,
 &#39;requir client use explicit databas est client explicit databas use valid est server certif client must check either configur uri recent http redirect uri server ident accord rule specifi rfc section est server certif must contain cmc rfc extend key usag extens&#39;,
 &#39;requir full cmc respons enrol success server respons must includ http respons code content type applic pkcs mime specifi rfc respons data includ either simpl pki respons smime type paramet cert full pki respons smime type paramet cmc respons specifi section rfc bodi messag binari valu encod pki respons content transfer encod base rfc reject request server must specifi either http error http error cmc respons content type applic pkcs mime must includ respons data cmc error respons return code handl specifi section http rfc exampl client interpret http respons indic servic implement&#39;,
 &#39;requir full pki request messag full pki request rfc messag transport via est use full cmc request function afford access function provid simpl enrol function full pki request messag defin section rfc see section discuss est provid transport messag&#39;,
 &#39;requir proof possess defin section cmc rfc proof possess pop refer valu use prove privat key correspond public key possess use end entiti sign enrol request provid signatur base proof possess mechan describ section strengthen option includ direct base proof possess rfc includ tls session specif inform within data cover enrol request signatur thus link enrol request authent end point tls connect&#39;,
 &#39;requir bootstrap distribut certif possibl client configur implicit databas allow bootstrap instal explicit databas describ section describ altern method minim configur est client popul explicit databas est client applic specifi either explicit databas implicit databas initi tls server authent author fail client may provision continu tls handshak complet purpos access cacert fullcmc method est client continu unauthent connect client must extract http content data respons section engag human user author certif use band data certif fingerprint sha sha shs hash whole certif fullcmc respons publish trust anchor control cmc rfc section within full pki respons must accept manual incumb user proper verifi inform provid fingerprint data configur necessari verifi inform http authent request must respond server authent specifi section option certif less authent use specifi section est client use cacert respons establish explicit trust anchor databas subsequ tls authent est server est client must engag protocol exchang cacert respons accept new tls session establish use tls certif base authent&#39;,
 &#39;requir http base client authent est server option also request est client submit usernam password use http basic digest authent method see section approach desir est client cannot authent tls handshak see section est server polici requir addit authent inform see section case http base client authent perform tls protect transport see section&#39;,
 &#39;requir applic layer est client must capabl generat pars simpl pki messag see section generat pars full pki messag option see section client must also abl request certif est server pars return bag certif see section request csr attribut pars return list attribut option see section detail est client applic configur scope protocol discuss necessari understand prerequisit initi protocol oper est client recommend configur databas section secret key section implement conform standard must provid abil design explicit tas human usabl reason fingerprint explicit databas entri configur bootstrap discuss section configur implicit databas perhap inclus within est client distribut avail oper system provid flexibl along caveat detail section implement conform standard must provid abil disabl use implicit databas est client configur suffici inform form est server uri full oper path segment https www exampl com well known est https www exampl com well known est arbitrari label est client configur tupl compos author portion uri along option label www exampl com arbitrari label author portion uri&#39;,
 &#39;requir request asymmetr encrypt privat key specifi asymmetr encrypt key use encrypt server generat privat key client must includ asymmetr decrypt key identifi attribut asymmetr decrypt key identifi attribut defin asymm decrypt key object identifi asymmetr decrypt key identifi attribut valu asn type asymmetr decrypt key identifi asn defin asymmetr decrypt key identifi octet string server public key match identifi specifi client request must termin error return client distribut key specifi asymmetr decrypt key identifi key generat client outsid scope document key identifi bound certif key must either explicit support key transport key agreement use must unrestrict&#39;,
 &#39;requir obtain certif follow exampl valid cacert exchang initi tls handshak client ignor option server generat certif request instead proceed http get request get well known est cacert http user agent curl linux gnu libcurl open zlib libidn librtmp host accept respons server provid current certif http status content type applic pkcs mime content transfer encod base content length miimoqyjko zihvc naqc iimkj ccdcycaqex adalbgkqhki bbw ggggw mmiic ccae ibag ijajp uzo gcsq gsib dqebbquambsx gtaxbg nvbamt egvzd gvdqsbpd hhc nmtmw nta mdm whc nmtqw nta mdm mrkw ydvqqdex blc rfe gftc gxl pmiibij anbgkqhki baqef aaocaq amiibcg kcaqeaw dqpi hopa icubp rqbp tiq welfia ddhe hikuy zap ksse buxdmox knyvtyjeh iof zwhgi lcegwr pba xza lvqc ceqj fms rluhfti rkw ukk pcf vfl yfqm uoqsa rti zbj qre zcz uhw mlowqk qtgo cpf ymju amk vcxlc wnkhf wbr orzril isl oumc dfasmdfbp osnfqidaqabo qdapbg nvhrmb ebtadaqh qwbbqittkx atxrfc ffp cibt gsz aobg nvhq ebamcaqyw dqyjko zihvc naqefbqadgg ebacpn qpu wre ugu cms boga pam ssi ydc dwh kmo xfqhdp ioy kadcx xkh mui bklwygdi hbe tmo nnw eli onsk hivo pmm imi fse xxld glk oqsh swz xlvcb umg andgj apip veeoc ulm vlqwa v84o ioji gm0c4xwc kkegc mos n3s4lvm8ptpq0glo ijy8ntd20wgg miib66adag ecag ebma0gcsq gsib3dqebbquambsx gtaxbg nvbamtegvzd ev4yw1w gvdqsbpd08w hhc nmtmw nta5mdm1mz whc nmtqw nta5mdm1mz mrkw vqqdex blc3rfe gftc gxl q0eg tnd pmiibij anbgkqhki kcaqeann3r z3r mjhwf7md9k4mubx havtdnr qf5ofgt ril4a pnh adg pyj8c lox d3utv q1vi pn7aciko onk rpjp opki kkv hmqxgn qtbs mav1q q6pvj n51iew ykks g7cglw 5jbwh yr2d gltri rvix pwrvt itp5rcjh 8rs3le8t qy3k tnh jf3i r2s png ito catysba inepr4memq ml4t g9i 8qe7s1li mfv dletp2mm byk oat b0s n524d1xagz8zkv wrkh or3hw idaqabo1iw udaobg nvhq8baf8ebamcblaw hqydvr0obbyeflhea zbow sn2jejizu wqi i8mb8ga1ud qymba afah nmr bnet9zh9 ihu3oaz psma0gcsq l7a lnv6h sok v9ylo56 tj00v v5skg dhk5d0b ogort kvu ga57 v0av trl jns3b nw8ntv dehmd00ak02a psi4w rhlfgtt uf9hd ehau aesptu43diptjkf hht bmfs ckd domhyf uekh rvv 1zi gex6ov1ap2iu2p3 asih amx teqasbwj uti r52zo l6n mpzpb zi2m0 ebvf8 due a9hjo6wo ljg yc5v c2hax uohx0c wti rbg qlki y5tkbh951oj q4vh f2hmco o7dkc nlyjoge16ssx4og bhul20vg xjjj miidaz ccaeug ibag ibaj anbgkqhki g9w0baqufadab mrkw ydvqqdex c3rfe gftc gxl q0eg tnd omb4xdtez mduw otaz ntmz mlo xdte0mduw otaz ntmz mlow ezmbc ga1ueax mqzxn0rxhhb xbs zunbie93tj ccasiw dqyjko zihvc naqebbqad epadccaqo cgg ebama6q yh6kwi arm6uam6rdey6ki klh sapagw4xhi crsjh1v 2qd 0ze wvoo gi1v5llhg vmxzq mdyjcr7co3o skh07tv ymuvywh blkdzyvn 4dw qnjd cxi tlpm4m b9l6f0zbo x7cme zm0mh9rbr ezmnf6l e2f dwhf frzwh6pl kkr u8m w4i cocfm ov4x bvqe0k3lvc3m ld3v n3p 7oc dczlk jgb elykoqq x2di7g oeno6ektr3mzxplj sh3 g6w29d wa4pf spe klpn ec97g wio8 n4xq32r x26f idkj rucaw eaaa nsmfaw ydvr0paqh baqdag mb0ga1ud qwbbqittkx atxrfc4ffp cibt6gsz0j nvhsmegdaw bsxx gnm w6mep9i xo4s7v7lqsj jcpdanbgkqhki g9w0baqufaaocaqealh e6mp binb jozdb xlijr l1csv8f4gwp ufk3cg zjibt w9uoa nr4e58i ropu ehjw fzk 2w8yt rqx8izo fhco lkp bdfg llwhoztzb ovkqmidj blk bevnr5mwdrs7f wuy 8an r8gwq eib cd0a7x ighm wemh bvi9c7glqd6px taju epfd ykm l3xdb swr30j2eqya 3w0tn2ufuxdw dq4zjs9g mw50s7ag6cp isi oifm jxgli lwf j9c aum9nyl gcj68bu cs9567kgf xexi0md ffcl7ta vr43kjsg3 c43k z7369me ezz ccavswgg hjo amcaqiccqdprp3dmj etanbgkqhki g9w0baquf adab mrkw ydvqqdex blc3rfe gftc gxl q0eg tnd omb4xdtez mduw otaz ntmz mlo dte0mduw otaz ntmz mlow ezmbc ga1ueax mqzxn0rxhhb xbs zunbie53tj ccasiw dqyjko zihvc naqebbqadgg epadccaqo cgg ebaj5962d6z cr8h jrm8rw l7x z67eh tn4ltiusc gnjz yqhyd8o apa mto a91e1fn unvyjs1c tze2n kdp5chua y6tq zmj kpip lxz efxp0e27dal9alrf utdgz nbjg nxu bnt7ne wdzk0f6uj74z sbmgcp lbuwo afu sw8iwk9g 9lm7rpba4k vys t1q77fs e6ea3i4f eutyx plumt5ez ysrd2p3r edr dojz ycla e8r g2i drd6 dhpqj lq6uf2hvcvv ehu7 ns8j bbw5xradppgcp aav 5zmrf6c fjqd ldedu a9vw gsr1q5ifm wjq94c caw ncmeaw ydvr0taqh bauw nvhq4efg qusc rp5luj bkf yl6olo7 qjww ydvr0paqh baqdag egma0gcsq cwd yvn eiom5a1vxa w8n cwg aiia hqu tuae9lona2mb fhw8u5e8 cp0r a9uyxxh fqzd5zwpms4w uyt1j3gqqd36kor jiau pig vng13i kytx m7c vmx qnh0aux3a rgah gal hp0ra kdg prz gtip jtnbk sv5s4k d4i dcphmnb ocluerw epbz6gv e7cp xl2jr tbzsq felq0iz4kk9 9cnw zwr vgdzklh j1z4j lruwb o4nv bzs nfn3k2o3sk8aua dwkq18 5rjcfpr ro8x4ytw xpq m0magndew qax&#39;,
 &#39;requir full cmc est client request certif est server https post use oper path valu fullcmc support fullcmc function option client server&#39;,
 &#39;requir simpl enrol client est client renew rekey certif https post use oper path valu simplereenrol certif request employ format simpleenrol request use http content type request subject field subject alt name extens must ident correspond field certif renew rekey chang subject name attribut defin rfc may includ csr request field chang new certif subject public key info certif request current client certif est server renew client certif public key inform certif request differ current client certif est server rekey client certif&#39;,
 &#39;requir tls layer tls provid authent turn enabl author decis est server est client respons ensur accept cipher suit negoti mutual authent perform tls authent common enabl use certif rfc altern certif less tls authent neither client server present certif also accept method est mutual authent section est server must authent tls handshak unless client request bootstrap distribut certif section full cmc section https rfc specifi http messag carri tls https must use tls rfc later version must use est communic tls session resumpt rfc support tls channel bind inform insert certif request detail section order provid est server assur authent tls client access privat key certif request est server must implement section&#39;,
 &#39;requir intial enrol authent est server verifi author provid servic client est client acquir certif submit enrol request server est server authent author est client specifi section method describ normat text discuss overview includ tls previous issu client certif exist certif issu est tls previous instal certif manufactur instal certif certif issu parti certif less tls share credenti distribut band http base usernam password distribut band&#39;,
 &#39;requir client certif reissuanc est client renew rekey exist client certif submit enrol request est server current est client certif use tls client authent section client present certif est server client authent reissu est client certif cannot use tls client authent authent method use initi enrol use exampl client altern certif issu est use tls client authent use certif request messag includ subject subject alt name current certif name chang request specifi section&#39;,
 &#39;requir enrol enrol follow exampl valid simpleenrol exchang data messag simplereenrol similar exchang est client use band distribut usernam password authent est server normal http www authent behavior includ inform purpos exist tls client certif use server might skip request http www authent header simplereenrol oper initi tls handshak client ignor option server generat certif request instead proceed http post request respons initi http post attempt server request www authent client might occur even client use client certif detail normat text http unauthor content length www authent digest qop auth realm estrealm nonc subsequ http post usernam password includ along complet applic pkcs content post well known est simpleenrol http author digest usernam estus realm estrealm nonc uri well known est simpleenrol cnonc tyw mzg qop auth respons host accept content type applic pkcs content transfer encod base content length miich tccaw caqaw mbs ueax muzgvtb zxa idez njgx ndez ntiwgg gcsq gsib dqebaquaa ibdw awgg ekao ibaqcl kdz kaum fyjp qkz zixqixc mcatn zrcax gjwbqo xsqff odbyw wdk qoibnt cqri ydc krmjmo slm nkf mlr krmah ycsvw tnv javh teiit ayq ryhk cxo dan skf tyci vxfx wwi skeprel devag bieym rxtlujirwnq srj oquzk d31be961kzcx ygrhxa r4pag aagg itaf bgkqhki g9w0bcqcx mqk3ji q2li lzcr rvl1ntbundanbgkqhki g9w0b aqufaaocaqearbv0aj hpl1mfidz wqoi1d ocf6u ywc bzp ladv pk1qx5pq xm830a1o 7rvr nyd6vf2rl a9lywibj lxo bo8d kxr yl16c vus yydi1m daft ysrgol mlt weiqbc2sdbr2k hxw1tr130h icpwmr29k c2kzur 5thsuj276fgl1v pu0d gqfx4wwa9u ahbgz6t w37cep zsr uke 0pf vhr2o hgbqdqhvtfvj hccd axicrtb u5o1l pv7f4l eapv3sbqm jcaq5o832bz hw7n mfc m15e9gt uvee5c62b vwuk tbn gsbw est server use usernam password perform authent author respond issu certif http 200 status 200 content type applic pkcs7 mime smime type cert content transfer encod base64 content length 1122 miidoayjko zihvc naqc iidktccay ucaqex adalbgkqhki g9w0bbw gggg mlmiid ccae ibag ibftanbgkqhki g9w0baqufadab mrkw ydvqqdex blc3rfe gft gxl q0eg tnd omb4xdtez mduw otiz mtu1m1o xdte0mduw otiz mtu1m1ow mbs a1ueax muzgvtb3n0zxa0idez njgx ndez ntiwgg ma0gcsq gsib3dqebaquaa4ib awgg ekao ibaqcl kdz nj8xp ep9kaum dz3e fyjp qkz9dd d5e5oz cm103 zixqixc0 mcatn rr3dn zrcax gjwbqo b3e kt29 xsqff odbyw0wdk qoibnt qry8ydc 8lj n7m2krmjmo slm u2v4a ycsvw tnv 6mx6pr2p tj82javh teiit ayq1ryhk m1cxo dan n7tz c94skf s3vv f53 j9sk tycy1rw0k3vxfx wwi skeprel7i6k0y devag bieym l1s69rxtluji rwnq srj oquzk d31be961kzcx ygrhxa r4pag mbaagj bqma4ga1ud dad nvhq4efg b6ii6ic q8w gmxvy1jf e4xt ydvr0j bbgw rp5luj bkf yl6olo7 5ar qjww dqyjko zihvc naqefbqadgg ebacmxg1hv ftaroxain bx5gxd z9om sb0l 4pdvg khz mcrc u6m4yp5n0edkm ga6 y8fb et4tt7ju jg6ixb95 760th0vuctwk gr6 d6ettfqi hnrbh x3l ahn 0ja7 o1gv4cwxh1i8a txdp ohorv n0smxdcrl cys2vrt r2a3kaj jo6e q5le odz opha lwen0e2blnji0v c2fa 2lmcnf c38xf gala5a8e7f nhxwzbj xzlbcza3 es9mlh2cj wxm mvd eqnt fpgg f8izsrv ruct ge1lg dmu6afuxc r4por t2xz8ch adea&#39;,
 &#39;requir tls base server authent tls server authent certif must support est client authent est server defin cipher suit negoti follow text provid detail assum certif base cipher suit tls rfc mandatori cipher suit tls rsa des ede cbc sha certif valid must perform per rfc est server certif must conform rfc certif profil client valid tls server certif use est client explicit enabl implicit databas client must maintain distinct use explicit implicit databas authent order support proper author est client must perform author check specifi section certif valid fail client may follow procedur outlin section bootstrap distribut certif&#39;,
 &#39;requir tls client authent recommend method identifi est client http base client authent section may use est server authent est client defin cipher suit negoti follow text provid detail assum certif base cipher suit tls rfc mandatori cipher suit tls rsa des ede cbc sha est server must support certif base client authent general client use exist certif renew rekey oper certif renew rekey appropri negoti cipher suit client must use tls handshak otherwis client use altern certif suitabl cipher suit contain subject ident inform request enrol oper client may use client certif issu third parti authent certif valid must perform per rfc est client certif must conform rfc certif profil server valid tls client certif use est server explicit enabl implicit databas server must maintain distinct use explicit implicit databas authent order support proper author est server must perform author check specifi section client support tls client authent must support http base client authent section certif less tls authent section&#39;,
 &#39;requir terminolog key word must must requir shall shall recommend recommend may option document interpret describ rfc assum reader familiar term concept describ public key cryptographi standard pkcs rfc https rfc cmp rfc cmc rfc rfc rfc tls rfc addit term defin terminolog section cmc rfc follow term defin clariti est certif issu servic est reach est server could logic behind est server embed within third parti trust anchor trust anchor authorit pki hierarchi est server provid servic explicit trust anchor explicit configur client server use est tls authent exampl manual configur est client bootstrap describ section see detail section implicit trust anchor third parti avail client server use tls authent specif indic use est tls authent exampl tas common use web browser authent web server tas use server authent manufactur instal client credenti certif popul cabl modem router factori author model tas differ author model explicit trust anchor see detail section certif less tls certif less tls cipher suit provid way perform mutual authent situat neither client server certif will use credenti use authent word phrase code key share client server credenti must uniqu share client server order provid authent individu client individu server&#39;,
 &#39;requir protocol design layer figur provid expans figur describ layer use aspect describ detail section follow est layer protocol use messag type simpl pki messag incorpor proof possess certif retriev full pki messag option incorpor proof possess csr attribut request option server generat key request option http http header uri control content type header specifi messag type header control error messag uri select function basic digest authent option tls transport secur authent est server authent est client option provid communic integr confidenti suppli channel bind rfc5929 inform link proof ident messag base proof possess option figur specifi https secur transport enrol messag introduc two layer communic authent control messag tls http tls layer provid integr confidenti transport proof ident suppli tls handshak authent option also http layer header messag type control error messag includ http header cmc rfc5272 section note simpl pki request must use proof ident need includ sinc tls http layer provid proof ident est client server simpl pki messag type use tls layer certif exchang provid method author client enrol request use exist certif certif may issu client request certif may issu distinct pki ieee 802 1ar initi devic identifi idev idev credenti proof possess pop distinct issu proof ident includ simpl pki messag type describ section method link proof ident proof possess describ section document also defin transport cmc rfc5272 compli cmc transport protocol rfc5273 cmc pop proof ident mechan defin cmc mechan also use conjunct mechan full pki messag protocol exchang differ certif use follow tabl provid inform overview end entiti one certif type list figur use one trust anchor databas type list figur certif correspond use certif issuer use section refer est server serv present est server certif est server tls handshak section est server present est server certif authenticat tls handshak third parti web server section secur consider third parti present est client est client authenticat est server client certif third parti yet enrol devic manufactur section est client serv present est server certif est server futur est oper section end entiti serv client obtain cert certif est server intend non est use includ cert cannot use est oper section figur trust anchor databas correspond use databas use section refer est server est server use databas authent explicit certif issu est includ est databas client certif enrol enrol oper section est server est server use databas authent implicit certif issu third parti tas databas est client certif issu devic manufactur implicit databas disabl section est client est client use databas authent explicit certif issu est includ est databas server certif section est client est client use databas implicit authent est server use extern databas issu certif implicit databas disabl section secur consider figur&#39;,
 &#39;requir inform refer idev ieee standard associ ieee secur devic identifi decemb http standard ieee org findstd standard html rfc howard approach use ldap network inform servic rfc march rfc rescorla http tls rfc may rfc nystrom kaliski pkcs https tool ietf org html rfc select object class attribut type version rfc novemb rfc schaad housley advanc encrypt standard key wrap algorithm rfc septemb rfc taylor mavrogiannopoulo perrin use secur remot password srp protocol tls authent rfc novemb rfc turner applic pkcs media type rfc august rfc zieglar turner peck suit profil certif manag cms rfc novemb shs nation institut standard technolog secur hash standard shs feder inform process standard public march http csrc nist gov public fip fips180 fip 180 pdf 800 part nation institut standard technolog recommend key manag part general revis )&#34;, juli 2012 http :// csrc nist gov public nistpub 800 sp800 57_part1_rev3_gener pdf&#39;,
 &#39;requir certif less tls authent est client est server mutual authent use certif less tls cipher suit see section&#39;,
 &#39;requir iana consider section defin oid regist arc deleg iana pkix work group iana regist follow iana updat well known uri registri follow fill templat rfc uri suffix est chang control ietf iana updat applic media type registri follow fill templat rfc media subtyp csr attribut csr attribut respons applic csrattr type name applic subtyp name csrattr requir paramet none option paramet none encod consider binari secur consider client request list attribut server wish certif request request respons normal done tls protect tunnel interoper consider none publish specif memo applic use media type enrol secur transport est addit inform magic number none file extens csrattr person email address contact inform dan harkin dharkin arubanetwork com restrict usag none author dan harkin dharkin arubanetwork com intend usag common chang control iesg iesg ietf org applic pkcs mime content type defin option smime type paramet rfc set specif valu document add anoth valu server generat key paramet valu server side key generat respons&#39;,
 &#39;requir client use implicit databas est client implicit databas use valid est server certif client must check configur uri http redirect uri accord rule specifi rfc section provis uri recent http redirect uri provid basi author server authent ident confirm author server&#39;,
 &#39;requir certif request est client request est databas inform form certif https get messag use oper path cacert est client server must support cacert function client request date respons store inform expir order ensur est databas date est server requir client authent author repli request client must authent est server specifi section certif base authent use section option certif less authent use check server author given section follow procedur outlin section&#39;,
 &#39;requir certif less tls mutual authent certif less tls cipher suit provid way perform mutual authent situat neither client server certif desir use certif trust anchor necessari verifi certif client server may negoti certif less cipher suit mutual authent use certif less mutual authent tls enrol cipher suit must base protocol resist dictionari attack must base zero knowledg protocol transport layer secur secur remot password tls srp cipher suit srp name list section rfc suitabl purpos section list characterist cipher suit suitabl use certif less mutual authent enrol success authent use certif less cipher suit prove knowledg pre share secret implicit author peer exchang&#39;,
 &#39;requir full cmc request http post fullcmc valid full pki request server must reject messag http content type use applic pkcs mime smime type paramet cmc request specifi rfc bodi messag binari valu encod pki request content transfer encod base rfc&#39;,
 &#39;requir distribut certif est client request copi current certif function general perform est function&#39;,
 &#39;requir server key generat follow exampl valid serverkeygen exchang exchang est client authent use exist certif issu est server provid servic initi tls handshak ident enrol exampl handshak exampl http post messag post well known est serverkeygen http host accept expect continu content type applic pkcs content transfer encod base content length miicw tccaak caqaw mdw ueax vydm ihjlc sbie sbjb gll qga zgvtbi bzd gvw idey idez njgx nde ntux gtaxbg nvbautefbjrdp wrn zxqg mtawgg gcsq gsib dqebaquaa ibdw awgg ekao ibaqcv suyzbf cqfp aepa bsfluvm hxr wpie rio ruun fll urkq yzmq noo rptu frss niphl sikt rhz cfr aph ipu imh bhi lfhq afhz zjs ousvp umq uog soq djhpj ytj pxrqdch qjxh jhvl pho yix aysutcbb txwfcwsr wdj mmk dio avaz mbaagg itaf bgkqhki bcqcx mqzezz qvht anbgkqhki baqufaaocaqear eqb sjr lcajn hungsz idwx eze omk fgkj red yupb lblo ofx gqjheq jeibc dtajq dihi gqnhosyg izhv kpp qleb gvp rjsn mro pce rin wff namp tgwjv ikhj cll cdg oex fqh hjp zkblo rwv dti zuwt fff gtuxvp wiw dsh bbq erbp jiw aqi gyo decrypt key identifi attribut includ request respons includ addit encrypt beyond tls session est server respons http status content type multipart mix boundari est server exampl boundari content length preambl ignor though handi place est server includ explanatori note includ contact support inform est server exampl boundari content type applic pkcs8 content transfer encod base64 miievg ibadanbgkqhki g9w0baqefaascbkgwgg eaao ibaqdpw ktw j7tj poj64v909ryql0fo p1h u4yq5y8 op5zte6arg uye099ac dfdwpi desiuj s62vck3uwnbnw 4o38fup0en lbbj stud48kp ew6 fzkeu aan pgzma1w kyr yy9 d5t qooju cbvh iti ylznyue4agbpc r0w mtr rr2e58mu8w q80ryk6nk l7cok5z iqd nrxldk7dfvp a85yn1stumo grt vlw51i ts1lt xwhu j6lds3vv j2si y3rx pln jvi r8mf2tbojzu fqva vld2ay qjga gejq2zwhxel qaoz6n3lr choj fgq93i mbaaecgg ebalq5az yjd5x9y3f7nmuffwl rrf mhcmtrx u4aeao kbym0h fvzztxf z7xl d8g0th6gs2h fa6gwc upmi olxht0x lgg ymc nam cdj lbq7x rqcwtlc k9wca5 hbwtc ey6244r xxh wd6nt6b xc165aec x87i jfj7xfne dp656s2dmx scci dte6sa em7 ygu16qev mthc xkvp ikk2px5idad4pb6 qhpqj3d4o m8dj o6w yuvr h8xqlq f8hd5l fwvu57n syy h79 ndtf rtul6axr7km kvfoj0jj zex ucvmzt giqh b6ucg yea639otd wlzczi zfme p7vl rddoz0vatr u2dxn eb4c wd8gerg8u nvp8og84g 6mb pwz4zywkcg dfqyr alw sf02n9sovh93eo j5lat sbfe yuk b8l hvk5 cbges v9mukd mf0 b43ylhi edi 0ue hlfg rrfp p2c xdu eie mcg yea4db sirw g1gjo3o e09kd89vgj vrer srbcqc7dc pxp6lw42sx96h4j vwwq hvo3dfw fbd ub1lh2cn vxqjg duhd ndpl01cf bfycfini2q kmqi jyswkh z1blz qtdb pfl2pg lni kfg2a flr ts3s tge b5qw rpig h3kf yapq cji fmlrvf rrnzd qewi4vn epf4 hjp as1g d8vf zwlkw vyl ud9hcerzg a7rixi q0sx tvtxh l6pxl m2nebfqb v16h pfl6 g4f0u9o hno g8r htq sjn bn4yo yfm70dhe7qtb zelca pch6cuhj2st5b8zhwdt reqkbg hnp xiy4c2ubi canv9csa xul iod xnba cgpf om5d wrm5dd lmf33mo9va sre ku3 q4nbgs glw pp1zqz qznzp mi7w6306yp4gd aj5pb oww st0vq w5ob7d ili k4a9s4 zki nrf rsl8gm dhc9rsu dwqof iaq vhvbhnz jao gbaohqof5l6i ghohcx lazx 4mgv rtpmz px6q3qxqpet egfedzaa l58l67sss3f fbn vaid f6ll c1b ah1ao yhudi45x boroy0h bwrn r6c cvw5st rkz iev tzhhozk m7pyh x4bi bmg q3bh tp4h est server exampl boundari content type applic pkcs7 mime smime type cert content transfer encod base64 miidrqyjko zihvc naqc iidnj ccaz icaqex adalbgkqhki g9w0bbw gggg mymiid fdccafyg ibag ibfj anbgkqhki g9w0baqufadab mrkw ydvqqdex blc3rfe gft gxl q0eg tnd omb4xdtez mduw otiz u1nlo xdte0mduw otiz u1nlow ldeq mcg a1ueax mhc2vydm vyc2lk zsbr zxkg z2vu zxjhd gvk ihjlc3bvbn miibij anbgkq hki kcaqeaz8crc ce04z iapj6i ffd pa8qpd h6d9i vogkucv p2zj wu3ug k4fyvmnt qhpn x3c kcj eoro1bf3uutl xjn1fj w58pu bvkd hpy2240k7n pcq rfuvhc5hrg gpzxm tanc csq2mvaw udji vpwg vyvki c2twfhu g6xed mdla0a9h dlv mepnk8p op5c wjp owsehtuc zxzowxb6qpowj lbpq bkb vs1ud yl3k0t s7v8ibl i3b n77w iidkomd gn68t5zi vch zkf dh9kw to87har2v1sw9msk i4ghh i6tm vh13p uadmejd5awoa rqvd8jo qidaqabo1iw udaobg nvhq8baf8ebamcblaw hqydvr0obbyefk zixu9f app dx2ss5haxm v6jr4 mb8ga1ud qymba aflhea zbow sn2jejizu wqi i8ma0gcsq gsib3dqebbqua a4ibaqbhh rakrn tapqq bob dm9iqdqpuw w1g zkl iwiw hezl1ig xhpjj rf4xqp iki jmmka oeo xa8pfni zm9fqsm j89cuf5d wj8s17xu xu9l xjj xhs l40wu dg6t mpn9vc t8t e3ruor608mkshfx nem6 nvsuptm b33bg yb1wa e7pn3jmn6pj f4p ki8qvo tsvvja cew ue8q fw1yvjo yjti mn4v5kb3rt s8yie1tcf vqrj qutqr34 pzi zwi92kza 1958a6m9o p5oi0up9zxkg2dec 1o9q t0gi yj6sx gtoxk6j mdd qax est server exampl boundari epilogu also ignor&#39;,
 &#39;requir messag type document use exist media type messag specifi ftp http rfc applic pkcs rfc cmc rfc consist rfc distinct est messag type use http content type header specif media type est messag correspond media type oper messag type request media type request section respons media type respons section per oper sourc type distribut section certif applic pkcs mime section rfc cacert client certif applic pkcs10 section request function applic pkcs7 mime section rfc5967 rfc5751 simpleenrol simplereenrol full cmc applic pkcs7 mime section applic pkcs7 mime section fullcmc rfc5751 server side key applic pkcs10 section generat multipart mix section applic pkcs7 mime applic pkcs8 rfc5967 rfc5751 serverkeygen rfc5958 csr attribut section applic csrattr section document csrattr figur&#39;,
 &#39;requir document profil certif enrol client use certif manag cms cmc rfc messag secur transport enrol secur transport est describ use transport layer secur tls rfc rfc futur version hypertext transfer protocol http rfc provid authent author channel simpl public key infrastructur pki request respons rfc architectur est servic locat certif author client perform sever function tradit alloc registr author role pki natur communic est server describ document est adopt certif manag protocol cmp rfc model certif rollov use cmp messag syntax protocol est server extens new function may defin provid addit capabl specifi cmc rfc document defin two extens one request certif sign request attribut anoth request server generat key est specifi transfer messag secur via http tls https rfc http header media type use conjunct tls https oper tcp document specifi est http datagram transport layer secur user datagram protocol http dtls udp suitabl specif combin http dtls udp est requir would prevent work stack figur show layer build upon est layer protocol est request respons messag http messag transfer signal tls transport secur tcp transport figur&#39;,
 &#39;requir simpl enrol enrol respons enrol success server respons must contain http respons code content type applic pkcs mime success respons must cert cmc simpl pki respons defin rfc contain certif issu http content type applic pkcs mime smime type paramet cert use specifi rfc server must answer suitabl http rfc error code problem occur simpl pki respons http content type applic pkcs mime see section may includ respons data convey error respons content type set respons data must plaintext human readabl error messag contain explanatori inform describ request reject exampl indic csr attribut incomplet server respond http rfc indic request accept process respons yet avail server must includ retri header defin http respons server also may includ inform human readabl content client must wait least specifi retri time repeat request client repeat initi enrol request appropri retri interv expir client log inform end user event server respons maintain state necessari recogn handl retri oper client stateless regard simpli send request repeat receiv differ respons code return code handl specifi http rfc client close tls connect wait retri time expir client initi new tls connect perform applic secur check client alreadi generat csr includ link ident pop inform section csr need recreat incorpor tls uniqu new redirect session note key pair need regener process interfac burden client est server administr advis take consider est client may also make certif respons associ privat key avail end entiti softwar use end entiti certif&#39;,
 &#39;requir refer rfc freed borenstein multipurpos internet mail extens mime part one format internet messag bodi rfc novemb rfc bradner key word use rfcs indic requir level bcp rfc march rfc housley hoffman internet public key infrastructur oper protocol ftp http rfc may rfc field getti mogul frystyk masint leach berner lee hypertext transfer protocol http rfc june rfc frank hallam baker hostetl lawrenc leach luotonen stewart http authent basic digest access authent rfc june rfc ramsdel mime version messag specif rfc june rfc nystrom kaliski pkcs https tool ietf org html rfc certif request syntax specif version rfc novemb rfc berner lee field masint uniform resourc identifi uri generic syntax std rfc 3986 januari 2005 rfc4086 eastlak schiller crocker random requir secur bcp 106 rfc 4086 june 2005 rfc4108 housley use cryptograph messag syntax cms protect firmwar packag rfc 4108 august 2005 rfc4210 adam farrel kaus mononen internet 509 public key infrastructur certif manag protocol cmp )&#34;, rfc 4210 septemb 2005 rfc4346 dierk rescorla transport layer secur tls protocol version rfc 4346 april 2006 rfc4648 josefsson base16 base32 base64 data encod rfc 4648 octob 2006 rfc5077 salowey zhou eronen tschofenig transport layer secur tls session resumpt without server side state rfc 5077 januari 2008 rfc5246 dierk rescorla transport layer secur tls protocol version rfc 5246 august 2008 rfc5272 schaad myer certif manag cms cmc )&#34;, rfc 5272 june 2008 rfc5273 schaad myer certif manag cms cmc transport protocol rfc 5273 june 2008 rfc5274 schaad myer certif manag messag cms cmc complianc requir rfc 5274 june 2008 rfc5280 cooper santesson farrel boeyen housley polk internet 509 public key infrastructur certif certif revoc list crl profil rfc 5280 may 2008 rfc5652 housley cryptograph messag syntax cms )&#34;, std rfc 5652 septemb 2009 rfc5746 rescorla ray dispensa oskov transport layer secur tls renegoti indic extens rfc 5746 februari 2010 rfc5751 ramsdel turner secur multipurpos internet mail extens mime version messag specif rfc 5751 januari 2010 rfc5785 nottingham hammer lahav defin well known uniform resourc identifi uri )&#34;, rfc 5785 april 2010 rfc5929 altman william zhu channel bind tls rfc 5929 juli 2010 rfc5958 turner asymmetr key packag rfc 5958 august 2010 rfc6066 eastlak transport layer secur tls extens extens definit rfc 6066 januari 2011 rfc6125 saint andr hodg represent verif domain base applic servic ident within internet public key infrastructur use 509 pkix certif context transport layer secur tls )&#34;, rfc 6125 march 2011 rfc6402 schaad certif manag cms cmc updat rfc 6402 novemb 2011 rfc6454 barth web origin concept rfc 6454 decemb 2011 rfc6838 freed klensin hansen media type specif registr procedur bcp rfc 6838 januari 2013 680 itu recommend 680 2008 iso iec 8824 2008 abstract syntax notat one asn specif basic notat novemb 2008 http :// www itu int rec rec 680 200811 690 itu recommend 690 2008 iso iec 8825 2008 asn encod rule specif basic encod rule ber canon encod rule cer distinguish encod rule der )&#34;, novemb 2008 http :// www itu int rec rec 690 200811&#39;,
 &#39;requir certif tls authent est client previous instal certif issu third parti certif use authent client request certif est server recogn est server est client respond est server tls certif request messag exist certif alreadi held client est server verifi client exist certif author client request describ section&#39;,
 &#39;mingw typedef pid int use defin static int pthread mutex lock pthread mutex mingw typedef pid int use defin static int pthread mutex unlock pthread mutex mingw typedef pid int use defin static void unicod const char path wchar wbuf size wbuf len&#39;,
 &#39;prototyp privat est server part public api void est send http error est ctx ctx void http ctx int fail code prototyp privat est server part public api int est enrol auth est ctx ctx void http ctx ssl ssl char path seg int reenrol prototyp privat est server part public api int est handl cacert est ctx ctx unsign char cert int cert len void http ctx char path seg prototyp privat est server part public api int est tls uid auth est ctx ctx ssl ssl req req prototyp privat est server part public api req est server pars csr unsign char pkcs int pkcs len prototyp privat est server part public api int est server check csr req req prototyp privat est server part public api est error est server send http retri est ctx ctx void http ctx int delay&#39;,
 &#39;file est est public api enrol secur transport novemb copyright cisco system inc right reserv ifndef header est defin header est ifdef win ifdef libest export defin libest api declspec dllexport els defin libest api declspec dllimport endif els defin libest api endif includ openssl ssl includ openssl engin includ openssl conf includ openssl srp ifdef cplusplus extern endif allow runtim check path segment support ifdef uripars defin path segment support enabl endif defin est max file len defin 255 defin est_portnum_len sizeof int defin est_portnum_len defin 4096 defin 128 typedef enum est_serv est_client est_proxi est_mod typedef enum est_client_proxy_non valu ore togeth defin defin defin defin foreach_est_error est_err_no_ctx est_err_no_csr est_err_no_cert est_err_no_key est_err_load_cacert est_err_bad_mod est_err_bad_pkcs10 est_err_http_writ est_err_http_bad_req est_err_http_no_cont est_err_http_lock est_err_no_ssl_ctx est_err_auth_fail est_err_auth_pend est_err_wrong_method est_err_x509_sign est_err_x509_v est_err_x509_cn est_err_x509_attr est_err_x509_pubkey est_err_malloc est_err_ssl_writ est_err_ssl_read est_err_ssl_new est_err_ssl_ctx_new est_err_ssl_connect est_err_pem_read est_err_ip_getaddr est_err_ip_connect est_err_no_certif est_err_syscal est_err_cacert_verif est_err_bad_x509 est_err_bad_base64 est_err_bad_asn1_hex est_err_srp_pwd_bad est_err_cb_fail est_err_unknown defin generate_enum enum enum defin generate_str string string /*! enum est_error brief enum use indic error condit applic layer lib est function return error indic enumer applic alway check return error indic grace handl error error occur lib est return est_err_non valu zero est_err_non error occur est_err_no_ctx est_ctx provid invok function est_err_no_csr pkcs10 csr provid invok function est_err_no_cert valid x509 certif provid invok function est_err_no_key evp_pkey provid invok function invalid argument provid function est_err_load_cacert certifict provid load certif chain trust certif load est_err_bad_mod est oper attempt use wrong mode oper valid mode client server proxi est oper may perform certain mode est_err_bad_pkcs10 pkcs10 csr receiv client corrupt est_err_http_writ error occur write http respons socket est server sent unsupport http status code respons http header could built correct est_err_http_bad_req http request bad report server http request inform current found server est_err_http_no_cont content request avail est_err_http_lock resourc access lock uri path segment pass invalid either long contain invalid charact build est support use addit path segment uri est need rebuilt uripars librari support path segment http content type header request invalid http content length header request specifi valu larg est_err_no_ssl_ctx applic provid valid ssl_ctx refer api est_err_auth_fail est server unabl authent est client authent failur due invalid challeng password pkcs10 csr est_err_auth_pend http authent challeng sent client respons yet arriv certif author unabl sign pkcs10 csr certif author request client retri enrol request futur like due configur automat enrol est_err_wrong_method invalid http method get post use request est_err_x509_sign error occur open ssl librari tri sign pkcs10 csr est_err_x509_v error occur open ssl librari tri set version pkcs10 csr est_err_x509_cn error occur open ssl librari tri set common name pkcs10 csr est_err_x509_attr error occur open ssl librari tri set x509 attribut pkcs10 csr est_err_x509_pubkey error occur open ssl librari tri set public key pkcs10 csr est_err_malloc unabl alloc malloc like indic critic failur host system est_err_ssl_writ error occur tls layer tri write socket est_err_ssl_read error occur tls layer tri read socket est_err_ssl_new error occur open ssl librari tri alloc ssl refer est_err_ssl_ctx_new error occur open ssl librari tri alloc ssl_ctx refer est_err_ssl_connect error occur open ssl librari tri establish tls session server error occur open ssl librari tri set allow tls cipher suit est_err_pem_read error occur open ssl librari tri read pem encod pkcs10 csr may due corrupt pkcs10 applic layer fail provid requir callback function request est oper est_err_ip_getaddr unabl resolv server host name est_err_ip_connect unabl connect request host port server name provid lib est invalid may null may exceed maximum server name length tcp port number provid lib est invalid must greater less 65536 certif privat key provid lib est could load privat key must match public key certif applic attempt use lib est api prior invok est_client_init (). certif receiv server invalid length buffer provid read data socket larg enough receiv respons server est server sent cacert respons exceed maximum size allow est_err_no_certif attempt made copi cert context prior est oper perform certif found trust certif list provid lib est est server name match fulli qualifi domain name server x509 certif est_err_syscal open ssl librari report system call error attempt establish tls session pkcs10 csr provid lib est alreadi contain signatur lib est requir csr sign sinc lib est respons sign csr pkcs10 csr receiv est client contain requir csr attribut invalid digest type request est_err_cacert_verif valid certif chain receiv est server fail invalid author token receiv invalid miss retri receiv server est_err_bad_x509 invalid corrupt x509 certif provid lib est est_err_bad_base64 invalid corrupt csr attribut base64 encod string provid est_err_bad_asn1_hex invalid corrupt csr attribut asn1 hex string provid csr attribut asn1 hex string short csr attribut asn1 hex string long srp strength request applic small srp user accept est_err_srp_pwd_bad srp password accept est_err_cb_fail applic layer call back facil fail lib est built libcurl support libcurl requir client proxi mode invalid proxi protocol specifi configur client mode http sock proxi invalid proxi authent mode specifi configur client mode http sock proxi est_err_last last error enum definit never use typedef enum est_err_non foreach_est_error generate_enum est_err_last est_error libest_api extern const char est_err_str []; defin est_err_num_to_str est_err_str typedef enum auth_non auth_bas auth_digest auth_token auth_fail est_http_auth_mod typedef enum http_auth_not_requir http_auth_requir est_http_auth_requir typedef enum est_cert_format_pem est_cert_format_d est_cert_format_max est_cert_format defin est_format_pem est_cert_format_pem defin est_format_d est_cert_format_d enum allow log filter desir detail level bitmask filter new log level order maintain base urgenc log messag typedef enum est_log_lvl_err est_log_lvl_warn est_log_lvl_info est_log_level defin max_realm 255 defin max_nonc defin max_uidpwd 255 defin max_nc defin max_qop defin max_respons defin min_csrattr defin max_csrattr 1024 defin min_asn1_csrattr defin max_csrattrs_withpop 1035 defin max_token_error 255 defin max_token_error_desc 255 defin max_auth_token_len 512 defin max_http_method_len follow valu defin minimum maximum default valu timeout valu ssl read oper valu use est client proxi oper defin defin 3600 defin /*! struct est_http_auth_hdr brief structur use pass http authent paramet applic lib est contain user databas authent user expect applic perform user authent extern authent server radius structur allow http authent credenti pass lib est http layer applic var est_http_auth_hdr mode contain http authent mode use basic digest var est_http_auth_hdr user contain user est client authent var est_http_auth_hdr pwd contain password est client authent http basic authent use var est_http_auth_hdr uri contain uri est client http digest authent var est_http_auth_hdr cnonc contain nonc est client http digest authent var est_http_auth_hdr qop contain oper est client http digest authent var est_http_auth_hdr contain nonc count est client http digest authent var est_http_auth_hdr nonc contain server nonc http digest authent var est_http_auth_hdr respons contain client digest valu verifi var est_http_auth_hdr auth_token contain client token valu verifi typedef struct est_http_auth_mod mode char user char pwd char uri char cnonc char qop char char nonc char respons char auth_token est_http_auth_hdr defin valid return code applic layer auth credenti callback function provid typedef enum /*! struct est_ctx brief structur use maintain state est oper behalf applic singl context use repres singl instanc either est client est server est proxi server none member structur public access applic use function provid lib est api manag context context creat use one est_client_init (), est_server_init (), est_proxy_init (). context longer need applic shoud invok est_destroy releas memori associ context typedef struct est_ctx est_ctx /*! typedef auth_credentials_cb brief typedef defin prototyp callback function resid applic code applic regist function callback use api function callback call est client librari requir http authent credenti callback function take input pointer est_http_auth_hdr structur callback function must look mode structur element determin type credenti requir mode set auth_bas auth_digest callback function must suppli user pwd valu mode set auth_token callback must suppli auth_token valu auth_token valu must base64 encod string repres access token typedef auth_credentials_cb est_http_auth_hdr auth_credenti begin public api prototyp libest_api est_error est_enable_crl est_ctx ctx libest_api est_error est_init_logg est_log_level lvl void loggerfunc char va_list )); libest_api int est_get_api_level void libest_api const char est_get_vers void libest_api void est_enable_backtrac int enabl libest_api est_error est_set_ex_data est_ctx ctx void ex_data libest_api void est_get_ex_data est_ctx ctx libest_api est_ctx est_server_init unsign char ca_chain int ca_chain_len unsign char cacerts_resp_chain int est_cert_format cert_format char http_realm x509 tls_cert evp_pkey tls_key libest_api est_ctx est_proxy_init unsign char ca_chain int ca_chain_len unsign char cacerts_resp_chain int est_cert_format cert_format char http_realm x509 tls_cert evp_pkey tls_key char uid char pwd libest_api est_error est_destroy est_ctx ctx libest_api est_error est_ctx ctx est_http_auth_mod amod libest_api char est_http_auth_hdr char ha1 libest_api est_error est_server_start est_ctx ctx libest_api est_error est_server_stop est_ctx ctx libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx int ssl int void arg )); libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx int libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx char csrattr int crsattrs_len libest_api est_error est_ctx ctx int second libest_api est_error est_ctx ctx int nid libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx int timeout est proxi specif function libest_api est_error est_proxy_start est_ctx ctx libest_api est_error est_proxy_stop est_ctx ctx libest_api est_error est_proxy_set_serv est_ctx ctx const char server int port libest_api est_error est_ctx ctx est_http_auth_mod amod libest_api est_error est_ctx ctx int timeout libest_api est_error est_ctx ctx auth_credentials_cb follow function use est client libest_api est_ctx est_client_init unsign char ca_chain int ca_chain_len est_cert_format cert_format int cert_verify_cb x509 int )); libest_api est_error est_client_set_auth est_ctx ctx const char uid const char pwd x509 client_cert evp_pkey private_key libest_api est_error est_ctx ctx auth_credentials_cb libest_api est_error est_client_set_serv est_ctx ctx const char server int port char path_seg libest_api est_error est_client_set_proxi est_ctx ctx proxy_proto const char proxy_serv unsign short int proxy_port unsign int proxy_auth const char usernam const char password libest_api est_error est_ctx ctx char int pkcs7_len int ca_cert_len evp_pkey new_public_key libest_api est_error est_client_enrol est_ctx ctx char int pkcs7_len evp_pkey new_public_key libest_api est_error est_ctx ctx x509_req csr int pkcs7_len evp_pkey priv_key libest_api est_error est_client_reenrol est_ctx ctx x509 cert int pkcs7_len evp_pkey priv_key libest_api est_error est_ctx ctx unsign char pkcs7 libest_api est_error est_ctx ctx unsign char csr_data int csr_len libest_api est_error est_ctx ctx int ca_certs_len libest_api est_error est_ctx ctx unsign char ca_cert libest_api est_error est_ctx ctx int nid libest_api est_error est_ctx ctx int retry_delay time_t retry_tim libest_api est_error est_ctx ctx int timeout libest_api est_error est_ctx ctx libest_api est_error est_client_force_pop est_ctx ctx libest_api est_error est_ctx ctx libest_api est_error est_ctx ctx int strength char uid char pwd libest_api int est_ctx ctx follow callback entri point must set applic act est server proxi libest_api est_error est_set_ca_enroll_cb est_ctx ctx int unsign char pkcs10 int p10_len unsign char pkcs7 int pkcs7_len char user_id x509 peer_cert char path_seg void ex_data )); libest_api est_error est_ctx ctx int unsign char pkcs10 int p10_len unsign char pkcs7 int pkcs7_len char user_id x509 peer_cert char path_seg void ex_data )); libest_api est_error est_set_csr_cb est_ctx ctx unsign char *(* int csr_len char path_seg void ex_data )); libest_api est_error est_set_cacerts_cb est_ctx ctx unsign char *(* int csr_len char path_seg void ex_data )); libest_api est_error est_set_http_auth_cb est_ctx ctx int est_ctx est_http_auth_hdr x509 char void *)); libest_api est_error est_ctx ctx est_http_auth_requir requir libest_api est_error x509_req req int nid void string int chtype libest_api est_error unsign char der_ptr int der_len int new_nid libest_api est_error char csrattr int csrattrs_len unsign char der_ptr int der_len follow helper function deal open ssl data type cert key etc libest_api x509_req unsign char csr int csr_len est_cert_format csr_format libest_api evp_pkey est_load_key unsign char key int key_len int format libest_api int unsign char certs_p7 int certs_len unsign char pem helper macro applic use initi initi open ssl /*! brief est_apps_startup use applic initi open ssl librari call first prior use function lib est api helper function invok crypto_malloc_init (), err_load_crypto_str (), open (), (), ssl_library_init (), ssl_load_error_str (). return void defin est_apps_startup crypto_malloc_init (); err_load_crypto_str (); open (); (); ssl_library_init (); ssl_load_error_str (); /*! brief est_apps_shutdown use applic initi open ssl librari call prevent memori leak open ssl librari helper function invok conf_modules_unload (), obj_cleanup (), evp_cleanup (), engine_cleanup (), (), err_remove_thread_st (), err_free_str (). return void defin est_apps_shutdown conf_modules_unload obj_cleanup (); evp_cleanup (); engine_cleanup (); (); err_remove_thread_st null err_free_str (); ifdef __cplusplus endif endif&#39;,
 &#39;int ossl verifi int store ctx ctx libest test api void ossl dump ssl error void est error ossl init cert store store store unsign char raw int size&#39;,
 &#39;use wsaaddress string instead inet ntop window inet ntop exist window use const struct sockaddr wsaaddress string take lpsockaddr static int addr str struct sockaddr addr char str size str size unsign short int port int ret ifdef win dword str size size addr len switch addr famili case inet addr len sizeof struct sockaddr port ntoh struct sockaddr addr sin port break case inet addr len sizeof struct sockaddr port ntoh struct sockaddr addr sin port break default break str size str size addr len wsaaddress string addr addr len null lpwstr str str size ret els switch addr famili case inet port ntoh struct sockaddr addr sin port inet ntop addr famili struct sockaddr addr sin addr str str size ret break case inet port ntoh struct sockaddr addr sin port inet ntop addr famili struct sockaddr addr sin addr str str size ret break default break endif return ret use wsaaddress string instead inet ntop window inet ntop exist window use const struct sockaddr wsaaddress string take lpsockaddr static tcw err tcw_direct_clos tcw_sock_t sock tcw_err_t ret tcw_ok close_socket sock sock_fd est_log_err close fail get_sock_err ()); ret tcw_err_clos sock_err alreadi set goto done sock sock_fd sock_invalid done return ret establish direct socket connect est server use normal system call static tcw_err_t tcw_direct_connect tcw_sock_t sock tcw_opts_t opt const char host unsign short int port tcw_err_t ret tcw_ok struct addrinfo addr null struct addrinfo cur_addr sock_typ int err int saved_err char port_str char sock_addr_str inet6_addrstrlen unsign short int sock_port struct addrinfo hint int hint ai_socktyp sock_stream hint ai_flag ai_addrconfig snprintf port_str sizeof port_str port int sizeof port_str errno enomem ret tcw_err_alloc goto done est_log_info getaddrinfo )&#34;, host port_str err getaddrinfo host port_str hint addr est_log_err getaddrinfo return err gai_strerror err )); ret tcw_err_resolv ifdef win32 sock_err alreadi set els switch err case eai_system sock_err alreadi set break case eai_memori set_sock_err_nomem (); break default could resolv host set_sock_err_nonam (); break endif goto done cur_addr addr cur_addr ret tcw_ok socket cur_addr ai_famili sock_stream ipproto_tcp est_log_warn socket fail get_sock_err ()); ret tcw_err_socket cur_addr cur_addr ai_next continu err addr_to_str cur_addr ai_addr sock_addr_str sizeof sock_addr_str sock_port err est_log_info connect port )&#34;, sock_addr_str sock_port connect cur_addr ai_addr cur_addr ai_addrlen est_log_warn connect fail get_sock_err ()); ret tcw_err_connect close_socket may clobber sock_err saved_err get_sock_err (); close_socket sock_invalid set_sock_err saved_err cur_addr cur_addr ai_next continu break sock sock_fd els est_log_err could connect host port ret sock_err alreadi set done return ret establish direct socket connect est server use normal system call static tcw_err_t tcw_curl_clos tcw_sock_t sock tcw_err_t ret tcw_ok sock curl_handl curl_easy_cleanup sock curl_handl sock curl_handl null sock sock_fd sock_invalid return ret establish direct socket connect est server use normal system call static tcw_err_t set_blocking_mod tcw_sock_t sock int block tcw_err_t ret tcw_ok ifdef win32 int result unsign long mode block result ioctlsocket sock sock_fd fionbio mode result no_error per https :// msdn microsoft com librari window desktop ms740126 aspx ioctl ioctlsocket wsaioctl various languag run time system use ioctl purpos unrel window socket consequ ioctlsocket function wsaioctl function defin handl socket function perform ioctl fcntl berkeley softwar distribut sinc ioctlsocket window equival ioctl fcntl set return type accord ret tcw_err_fcntl goto done els int flag fcntl sock sock_fd f_getfl flag est_log_err fcntl f_getfl fail get_sock_err ()); sock_err alreadi set ret tcw_err_fcntl goto done flag block flag o_nonblock flag o_nonblock fcntl sock sock_fd f_setfl flag est_log_err fcntl f_setfl fail get_sock_err ()); sock_err alreadi set ret tcw_err_fcntl goto done endif win32 done return ret establish socket remot server use libcurl actual send url leverag libcurl proxi support establish connect static tcw_err_t tcw_curl_connect tcw_sock_t sock tcw_opts_t opt const char host unsign short int port tcw_err_t ret tcw_ok size_t url_siz char url null curlcod curlcod long curl_socket long auth_bit long proxy_typ int saved_err const char proxy_type_str none int sock curl_handl curl_easy_init (); sock curl_handl est_log_err curl_easy_init fail &#34;); errno enomem ret tcw_err_alloc goto done want libcurl establish connect proxi server done use socket normal direct connect est server curlcod curl_easy_setopt sock curl_handl curlopt_connect_on curlcod curle_ok est_log_err curl_easy_setopt curlopt_connect_on return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done url_siz strlen host url char calloc url_siz url est_log_err calloc fail &#34;); errno enomem ret tcw_err_alloc goto done http tell libcurl wrap whatev data send ssl snprintf url url_siz http ://% host port int url_siz errno enomem ret tcw_err_alloc goto done curlcod curl_easy_setopt sock curl_handl curlopt_url url curlcod curle_ok est_log_err curl_easy_setopt curlopt_url return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done proxi host port curlcod curl_easy_setopt sock curl_handl curlopt_proxi opt proxy_host curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxi return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done curlcod curl_easy_setopt sock curl_handl curlopt_proxyport opt proxy_port curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxyport return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done proxi protocol includ http tunnel mode opt proxy_proto proxy_typ curlproxy_http proxy_type_str http tunnel )&#34;; els opt proxy_proto proxy_typ curlproxy_http proxy_type_str http tunnel )&#34;; els opt proxy_proto proxy_typ curlproxy_socks4 proxy_type_str socks4 els opt proxy_proto proxy_typ curlproxy_socks5 proxy_type_str socks5 els opt proxy_proto proxy_typ curlproxy_socks4a proxy_type_str socks4a els opt proxy_proto proxy_typ proxy_type_str socks5_hostnam curlcod curl_easy_setopt sock curl_handl curlopt_proxytyp proxy_typ curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxytyp return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done opt proxy_proto curlcod curl_easy_setopt sock curl_handl curlcod curle_ok est_log_err curl_easy_setopt return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done curlcod curl_easy_setopt sock curl_handl curlopt_proxyauth curlauth_bas curlauth_on curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxyauth return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done usernam password opt proxy_usernam opt proxy_password curlcod curl_easy_setopt sock curl_handl curlopt_proxyusernam opt proxy_usernam curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxyusernam return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done curlcod curl_easy_setopt sock curl_handl opt proxy_password curlcod curle_ok est_log_err curl_easy_setopt return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done auth_bit opt proxy_auth auth_bit curlauth_bas opt proxy_auth auth_bit curlauth_ntlm auth_bit curlcod curl_easy_setopt sock curl_handl curlopt_proxyauth auth_bit curlcod curle_ok est_log_err curl_easy_setopt curlopt_proxyauth return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done signal generat libcurl curlcod curl_easy_setopt sock curl_handl curlopt_nosign curlcod curle_ok est_log_err curl_easy_setopt curlopt_nosign return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done perform curl request est_log_info curl_easy_perform proxi type url proxy_type_str curlcod curl_easy_perform sock curl_handl curlcod curle_ok est_log_err curl_easy_perform return url curlcod curl_easy_strerror curlcod )); curlcod curlcod set_sock_err_nonam (); ret tcw_err_resolv goto done els set_sock_err_conn (); ret tcw_err_connect goto done retriev socket libcurl curlcod curl_easy_getinfo sock curl_handl curlinfo_lastsocket curl_socket curlcod curle_ok est_log_err curl_easy_getinfo curlinfo_lastsocket return curlcod curl_easy_strerror curlcod )); errno einval ret tcw_err_oth goto done curl_socket est_log_err curlinfo_lastsocket invalid socket &#34;); errno einval ret tcw_err_oth goto done sock sock_fd curl_socket connect made set socket block ret set_blocking_mod sock ret tcw_ok sock_err alreadi set est_log_err fail set socket block &#34;); goto done done free url url null ret tcw_ok saved_err get_sock_err (); tcw_curl_clos sock set_sock_err saved_err return ret entri point establish connect remot est server tcw_err_t tcw_connect tcw_sock_t sock tcw_opts_t opt const char host unsign short int port sock_typ sock_fd tcw_err_t ret tcw_ok memset sock sizeof tcw_sock_t )); sock sock_fd sock_invalid sock proxy_proto opt proxy_proto sock proxy_proto est_client_proxy_non ifdef have_libcurl ret tcw_curl_connect sock opt host port els make far log messag wrong return est_log_err proxi set current requir libcurl &#34;); errno einval ret tcw_err_arg goto done endif els ret tcw_direct_connect sock opt host port ret tcw_ok goto done est_log_info success connect host port sock_fd sock sock_fd done return ret entri point establish connect remot est server tcw_err_t tcw_close tcw_sock_t sock tcw_err_t ret tcw_ok sock proxy_proto est_client_proxy_non ret tcw_direct_clos sock els ifdef have_libcurl ret tcw_curl_clos sock endif return ret&#39;,
 &#39;function send est specif http error respons void est send http error est ctx ctx void http ctx int fail code struct connect conn struct connect http ctx switch fail code case est err bad pkcs send http error conn est http stat est http stat txt est bodi bad pkcs break case est err auth fail send http error conn est http stat est http stat txt est bodi unauthor break case est err wrong method send http error conn est http stat est http stat txt est bodi bad meth break case est err ssl ctx send http error conn est http stat est http stat txt est bodi bad ssl break case est err http found send http error conn est http stat est http stat txt est bodi found break case est err http content send http error conn est http stat est http stat txt break default send http error conn est http stat est http stat txt est bodi unknown err break function send http accept respons client retri valu notifi client check back later see csr approv est_error est_ctx ctx void http_ctx int delay char http_hdr est_http_hdr_max struct mg_connect conn struct mg_connect http_ctx snprintf http_hdr est_http_hdr_max est_http_hdr_202 est_http_hdr_eol est_http_hdr_eol delay est_http_hdr_eol est_http_hdr_eol conn status_cod est_http_stat_202 mg_write http_ctx http_hdr strnlen_ http_hdr est_http_hdr_max ))) est_log_err http write error propag retri &#34;); return est_err_http_writ return est_err_non function handl incom cacert request client int est_handle_cacert est_ctx ctx unsign char ca_cert int ca_certs_len void http_ctx char path_seg char http_hdr est_http_hdr_max int hdrlen ca_cert null return send http header snprintf http_hdr est_http_hdr_max est_http_hdr_200 est_http_hdr_eol est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_ct est_http_ct_pkcs7 est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_c est_http_ce_base64 est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_cl ca_certs_len est_http_hdr_eol est_http_hdr_eol mg_write http_ctx http_hdr strnlen_ http_hdr est_http_hdr_max ))) return est_err_http_writ send cert bodi mg_write http_ctx ca_cert ca_certs_len return est_err_http_writ est_log_info cert success sent est client &#34;); return est_err_non handl cert request applic layer regist callback call els applic layer provid local configur buffer send els return error indic cert avail static int est_ctx ctx void http_ctx char path_seg est_error int ca_certs_len unsign char ca_cert call back set call otherwis local configur cacert buffer return otherwis return error indic cacert ctx est_get_cacerts_cb est_log_info server retriev cert applic layer &#34;); ca_cert ctx est_get_cacerts_cb ca_certs_len path_seg ctx ex_data ca_cert est_log_info server success retriev cert applic layer &#34;); est_handle_cacert ctx ca_cert ca_certs_len http_ctx path_seg els est_send_http_error ctx http_ctx est_err_http_no_cont est_err_non els ctx ca_cert est_log_info server cert set local respond local set cert respons &#34;); est_handle_cacert ctx ctx ca_cert ctx ca_certs_len http_ctx path_seg els est_send_http_error ctx http_ctx est_err_http_no_cont est_err_non return /*! brief use applic calcul http digest valu base header valu provid est client param authent header valu client provid lib est param ha1 precalcul ha1 valu user ha1 defin rfc 2617 md5 calcul user http realm user password helper function applic use calcul http digest valu perform http digest authent est client lib est maintain user databas left applic intent integr extern user databas radius aaa ha1 valu calcul applic defin rfc 2617 ha1 md5 hash user http realm user password md5 valu convert hex string ha1 expect byte long return char contain digest null error occur char est_http_auth_hdr char ha1 evp_md_ctx mdctx const evp_md evp_md5 (); uint8_t ha2 evp_max_md_s unsign int ha2_len char ha2_str unsign char digest evp_max_md_s unsign int d_len char est_log_err null auth header &#34;); return null ha1 est_log_err null ha1 &#34;); return null calcul ha2 use method uri mdctx evp_md_ctx_creat (); evp_digest init_ex mdctx null evp_digest updat mdctx post evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx uri strnlen_ uri max_realm )); evp_digest final mdctx ha2 ha2_len evp_md_ctx_destroy mdctx est_hex_to_str ha2_str ha2 ha2_len calcul auth digest use ha1 nonc nonc count client nonc qop ha2 mdctx evp_md_ctx_creat (); evp_digest init_ex mdctx null evp_digest updat mdctx ha1 evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx nonc strnlen_ nonc max_nonc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx strnlen_ max_nc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx cnonc strnlen_ cnonc max_nonc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx auth evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx ha2_str ha2_len evp_digest final mdctx digest d_len evp_md_ctx_destroy mdctx malloc est_hex_to_str digest d_len return function alloc http authent header structur use pass auth credenti applic layer allow app authent est client static est_http_auth_hdr est_create_ah est_http_auth_hdr malloc sizeof est_http_auth_hdr )); memzero_ sizeof est_http_auth_hdr )); return function free element http authent header structur static void est_destroy_ah est_http_auth_hdr int len return user free user pwd get length password zeroiz len strnlen_ pwd max_uidpwd len memzero_ pwd len free pwd uri free uri cnonc free cnonc qop free qop free nonc free nonc respons free respons auth_token len strnlen_ auth_token max_auth_token_len len memzero_ auth_token len free auth_token free function verifi peer either provid certif verif tls stack http authent credenti provid return est_auth_st author result est_auth_st est_enroll_auth est_ctx ctx void http_ctx ssl ssl char path_seg int reenrol est_auth_st est_unauthor x509 peer null struct mg_connect conn struct mg_connect http_ctx est_http_auth_hdr int v_result get client certif tls stack peer ssl_get_peer_certif ssl null check tls base client author client cert author v_result int ssl x509_v_ok v_result est_log_info tls client certif valid &#34;); est_cert_auth els v_result est_log_warn peer cert valid crl load unabl determin peer cert revok .&#34;); est_cert_auth els est_log_info tls client certif verifi v_result )&#34;, v_result need bail sinc client use bogus cert need contiu http authent x509_free peer return est_unauthor els est_log_info tls peer certif &#34;); est_unauthor see srp use certif est_cert_auth ssl_get_srp_usernam ssl null est_log_info tls certif client srp login ssl_get_srp_usernam ssl )); est_srp_auth applic layer enabl http authent attempt http authent tls client auth fail require_http_auth flag set applic assum applic layer provid http auth callback facil ctx est_http_auth_cb est_unauthor http_auth_requir ctx require_http_auth tri http authent est_create_ah (); mg_parse_auth_head conn switch case est_auth_hdr_good invok applic specif auth check user credenti ctx est_http_auth_cb ctx peer path_seg ctx ex_data est_http_auth els est_log_warn http authent fail auth type mode est_unauthor break case est_auth_hdr_miss ask client send author header conn est_log_info http auth header miss send http auth request client .&#34;); est_http_auth_pend break case est_auth_hdr_bad default est_log_warn client sent incomplet http author header &#34;); reenrol est_cert_auth est_log_info client cert authent http auth requir reenrol &#34;); els est_unauthor break est_destroy_ah peer x509_free peer return function use determin est client could use certif contain cmc usag extens usag bit present check disabl allow use case logic taken x509v3_cache_extens v3_purp open ssl return cert contain cmc extend key usag extens otherwis return static int est_check_cmc x509 cert int cmc ra_found extended_key_usag extusag int asn1_object obj get extend key usag extens found loop valu look cmc valu extens extusag x509_get_ext_d2i cert nid_ext_key_usag null null ))) iter extend key usag valu sk_asn1_object_num extusag ++) obj sk_asn1_object_valu extusag compar current iter global cmc valu creat earlier obj_cmp obj o_cmc cmc ra_found break extusag asn1_object_fre return cmc ra_found util function convert base64 der encod csr open ssl x509_req pointer return null problem x509_req est_server_parse_csr unsign char pkcs10 int pkcs10_len bio b64 x509_req req get origin pkcs10 request client b64 bio_new bio_f_base64 ()); b64 null est_log_err unabl open pkcs10 b64 buffer &#34;); return null bio_new_mem_buf pkcs10 pkcs10_len null est_log_err unabl open pkcs10 raw buffer &#34;); bio_fre b64 return null bio_push b64 read pem encod pkcs10 cert request req d2i_x509_req_bio null null est_log_err problem read der encod certif request &#34;); ossl_dump_ssl_error (); bio_free_al return null bio_free_al return req function implement proof posess check tls uid alreadi save tls session earlier tls uid match valu challeng password attribut pkcs10 client certif client provid valu sign pkcs10 cert request privat key prove client possess privat key check enforc follow csr contain must valid csr contain server configur requir authent fail otherwis csr contain server configur requir authent pass paramet ctx pointer est context ssl pointer ssl context pkcs10 pointer raw pkcs10 data pkcs10_len length raw pkcs10 data return valu est_err_non check pass int est_tls_uid_auth est_ctx ctx ssl ssl x509_req req x509_attribut attr int asn1_typ asn1_bit_str null asn1_typ int est_err_non char tls_uid int diff get index challeng password attribut request req nid_pkcs9_challeng password est_log_info cert request contain challeng password attribut &#34;); enabl must fail point sinc client send channel bind info csr ctx server_enable_pop est_log_warn enabl csr authent &#34;); return els return est_err_non els get refer attribut know locat rfc 7030 requir check present attr x509_req_get_attr req found attribut get actual valu challeng password attr attr singl attr valu singl valu bit_str els sk_asn1_type_valu attr valu set valu asn1_str els est_log_warn challeng password attribut found client cert request &#34;); return challeng password client cert request compar tls uid calcul server side implement check verifi client hold privat key use sign cert request tls_uid est_get_tls_uid ssl tls_uid memcmp_ tls_uid est_tls_uid_len data est_tls_uid_len diff eok diff est_log_info valid &#34;); est_err_non els est_log_warn valid &#34;); free tls_uid els est_log_warn local tls channel bind info avail &#34;); return function perform simpl saniti check pkcs10 csr check signatur csr return success non zero saniti check fail int est_server_check_csr x509_req req evp_pkey pub_key null int extract public key csr pub_key x509_req_get_pubkey req null est_log_err unabl extract public key csr &#34;); return verifi signatur csr x509_req_verifi req pub_key evp_pkey_fre pub_key check result est_log_err csr signatur check fail &#34;); return els est_log_err csr signatur mismatch &#34;); return els return free link list contain attribut client csr static void est_oid_list head est_oid_list next_entri head return next_entri head next next_entri free head head next_entri next_entri head next free head add new entri tail list attribut client csr static void est_oid_list list est_oid_list new_entri est_oid_list head list list head yet new entri simpli becom head head null list new_entri els walk list find tail add new entri end head next head head next head next new_entri recurs routin walk asn blob look asn object definit found oid object est_oid_list first argument end result routin list contain oid valu everi asn object blob code shameless taken open ssl ans1_parse2 (), explain poor chosen variabl name static int est_oid_list list const unsign char blob long length int offset est_oid_list new_entri const unsign char ptr tot opp long len int tag xclass int asn1_object a_object null errno_t safec_rc ptr blob tot ptr length ptr ptr tot ptr ptr asn1_get_object ptr len tag xclass length 0x80 est_log_err error encod &#34;); blob ptr return ptr length v_asn1_construct ptr len len length est_log_err length greater length blob ptr return 0x21 len list ptr long tot ptr offset ptr blob )); blob ptr return ptr tot break els ptr list ptr long len offset ptr blob )); blob ptr return els xclass ptr len els tag v_asn1_object opp d2i_asn1_object a_object opp len null new_entri malloc sizeof est_oid_list )); new_entri est_log_err malloc failur &#34;); list a_object null asn1_object_fre a_object blob ptr return safec_rc memset_ new_entri sizeof est_oid_list 0x0 sizeof est_oid_list )); safec_rc eok est_log_info memset_ error safec_rc i2t_asn1_object new_entri oid est_max_attr_len a_object est_log_info build csr oid list new_entri oid list new_entri a_object null asn1_object_fre a_object a_object null els est_log_err bad asn object &#34;); a_object null asn1_object_fre a_object blob ptr return ptr len tag v_asn1_eoc xclass blob ptr return length len blob ptr return util function popul link list contain oid name attribut present client csr static est_error est_oid_list list char bodi int body_len unsign char der_data der_ptr int der_len int grab space hold decod csr data der_ptr der_data malloc body_len der_data est_log_err malloc fail &#34;); return est_err_malloc decod csr data der_len est_base64_decod char bodi char der_data body_len der_len est_log_err invalid base64 encod data &#34;); free der_data return est_err_bad_base64 list const unsign char **)&amp; der_data der_len est_log_err fail build oid list client provid csr &#34;); list free der_ptr return est_err_unknown free der_ptr return est_err_non function check local configur csr attribut attribut csr attribut miss csr error return static est_error est_ctx ctx char bodi int body_len int tag xclass found_match nid long len unsign char der_ptr save_ptr asn1_object a_object int max_len max_csrattr char csr_data int csr_len long out_len_sav unsign char der_data int der_len out_len int a_len char tbuf est_max_attr_len est_oid_list csr_attr_oid null est_oid_list oid_entri int compar est_error est_log_info csr attribut enforc enabl &#34;); ctx server_csrattr ctx est_get_csr_cb est_log_warn csr attribut enforc enabl attribut configur &#34;); return est_err_non build list attribut present csr list use later confirm requir attribut present csr_attr_oid bodi body_len est_err_non return get csr attribut configur server need look csr make sure csr provid use callback configur otherwis use local copi ctx est_get_csr_cb csr_data char ctx est_get_csr_cb csr_len null ctx ex_data csr_data est_log_err applic layer fail return csr attribut &#34;); csr_attr_oid return est_err_cb_fail els csr_data malloc ctx server_csrattrs_len csr_data est_log_err malloc failur &#34;); csr_attr_oid return est_err_malloc strncpy_ csr_data ctx server_csrattrs_len char ctx server_csrattr ctx server_csrattrs_len csr_data ctx server_csrattrs_len csr_len ctx server_csrattrs_len est_log_info check csr attr present csr csr_data csr configur server need base64 decod check smallest possibl base64 case saniti test check min max valu asn data csr_len min_csrattr csr_attr_oid free csr_data return grab space hold decod csr data der_data malloc csr_len der_data est_log_err malloc fail &#34;); csr_attr_oid free csr_data return est_err_malloc decod csr data der_len est_base64_decod csr_data char der_data csr_len free csr_data der_len est_log_err invalid base64 encod data &#34;); csr_attr_oid free der_data return est_err_bad_base64 pointer fun start joy open ssl out_len_sav out_len der_len der_ptr save_ptr der_data out_len_sav max_len est_log_err der length exceed max &#34;); csr_attr_oid free der_data return make sure long enough asn der_len min_asn1_csrattr est_log_err der short &#34;); csr_attr_oid free der_data return iter csr attribut configur server out_len get next attribut asn1_get_object const unsign char **)&amp; der_ptr len tag xclass out_len est_log_info saniti tag len out_len tag len out_len 0x80 est_log_err bad asn1 hex &#34;); csr_attr_oid free der_data return est_err_bad_asn1_hex switch tag case v_asn1_object a_object c2i_asn1_object null const unsign char **)&amp; der_ptr len a_object est_log_err a_object null &#34;); csr_attr_oid free der_data return est_err_unknown challeng password need check alreadi cover authent client nid obj_obj2nid a_object nid nid_pkcs9_challeng password asn1_object_fre a_object break a_len i2t_asn1_object tbuf est_max_attr_len a_object est_log_info look attr csr tbuf asn1_object_fre a_object attrubut csr bail csr_attr_oid null est_log_warn csr contain attribut csr reject tbuf free der_data return found_match oid_entri csr_attr_oid iter attribut csr oid_entri est_log_info compar tbuf oid_entri oid strcmp_s oid_entri oid a_len est_max_attr_len a_len est_max_attr_len tbuf compar compar found_match break oid_entri oid_entri next found_match est_log_warn csr contain attribut csr reject tbuf csr_attr_oid free der_data return break default adjust string pointer move next item der_ptr len break case v_asn1_set case v_asn1_sequ break out_len out_len_sav der_ptr save_ptr one file check ensur miss someth pars local configur csr attribut out_len est_log_err der length zero )&#34;, out_len csr_attr_oid free der_data return est_err_bad_asn1_hex lucki enough make far mean local configur csr attribut found client csr csr_attr_oid free der_data return est_err_non function use server process incom simpl enrol request client static est_error est_ctx ctx void http_ctx ssl ssl const char char bodi int body_len char path_seg int reenrol int cert_len struct mg_connect conn struct mg_connect http_ctx unsign char cert char http_hdr est_http_hdr_max int hdrlen x509 peer_cert x509_req csr null int client_is_ra reenrol ctx est_enroll_pkcs10_cb est_log_err null enrol callback &#34;); return reenrol ctx est_log_err null reenrol callback &#34;); return make sure client sent pkcs10 csr request strncmp applic pkcs10 return authent client switch est_enroll_auth ctx http_ctx ssl path_seg reenrol case est_http_auth case est_srp_auth case est_cert_auth mean user author either http authorizt certif author break case est_http_auth_pend return est_err_auth_pend break case est_unauthor default return est_err_auth_fail break pars pkcs10 csr client csr est_server_parse_csr unsign char bodi body_len csr est_log_err unabl pars pkcs10 csr sent client &#34;); return est_err_bad_pkcs10 perform saniti check csr est_server_check_csr csr est_log_err pkcs10 csr sent client fail saniti check &#34;); x509_req_fre csr return est_err_bad_pkcs10 get peer certif avail identifi client may desir inform peer_cert ssl_get_peer_certif ssl peer_cert client_is_ra est_check_cmc peer_cert est_log_info cmc present client_is_ra check proof possess challeng password pkcs10 request match tls uniqu check performend client client_is_ra est_tls_uid_auth ctx ssl csr est_err_non x509_req_fre csr x509_free peer_cert return check need ensur client includ csr attribut requir ctx enforce_csrattr est_err_non ctx bodi body_len x509_req_fre csr x509_free peer_cert return bodi point pkcs10 data pass enrol routin reenrol ctx unsign char bodi body_len cert int *)&amp; cert_len conn user_id peer_cert path_seg ctx ex_data els ctx est_enroll_pkcs10_cb unsign char bodi body_len cert int *)&amp; cert_len conn user_id peer_cert path_seg ctx ex_data peer cert longer need delet one peer_cert x509_free peer_cert est_err_non cert_len send http header snprintf http_hdr est_http_hdr_max est_http_hdr_200 est_http_hdr_eol est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_ct est_http_ct_pkcs7_co est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_c est_http_ce_base64 est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_cl cert_len est_http_hdr_eol est_http_hdr_eol mg_write http_ctx http_hdr strnlen_ http_hdr est_http_hdr_max ))) free cert x509_req_fre csr return est_err_http_writ send sign pkcs7 certif bodi mg_write http_ctx cert cert_len free cert x509_req_fre csr return est_err_http_writ free cert els sign request ask client retri futur may occur configur automat enrol send http retri respons client est_log_info server request retri possibl setup auto enrol &#34;); est_err_non ctx http_ctx ctx retry_period x509_req_fre csr return est_err_http_writ els x509_req_fre csr return x509_req_fre csr return est_err_non function use server process incom csr attribut request client static int est_handle_csr_attr est_ctx ctx void http_ctx char path_seg int est_err_non int pop_pres char csr_data csr_data_pop int csr_len csr_pop_len ctx server_csrattr ctx est_get_csr_cb ctx server_enable_pop est_log_err null csr callback &#34;); send 204 respons indic server csr est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non els csr_data malloc est_csrattrs_pop_len csr_data return est_err_malloc strncpy_ csr_data est_csrattrs_pop_len est_csrattrs_pop est_csrattrs_pop_len csr_data est_csrattrs_pop_len csr_len est_csrattrs_pop_len return ctx csr_data csr_len http_ctx )); invok server callback retriev csr callback take prioriti save valu context note need authent client see sec ctx est_get_csr_cb csr_data char ctx est_get_csr_cb csr_len path_seg ctx ex_data csr_data csr_len pop_pres csr_len est_err_non csr_data free csr_data est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non ctx csr_pop_pres ctx server_enable_pop est_is_challeng password_pres csr_data csr_len pop_pres est_err_non est_log_err error saniti check &#34;); csr_data free csr_data est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non ctx csr_pop_pres pop_pres ctx csr_pop_pres csr_len csr_data malloc est_csrattrs_pop_len csr_data return est_err_malloc strncpy_ csr_data est_csrattrs_pop_len est_csrattrs_pop est_csrattrs_pop_len csr_data est_csrattrs_pop_len csr_len est_csrattrs_pop_len return ctx csr_data csr_len http_ctx )); est_add_challeng password csr_data csr_len csr_data_pop csr_pop_len est_err_non csr_data free csr_data est_log_err error add &#34;); est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non free csr_data csr_data csr_data_pop csr_len csr_pop_len els csr_data malloc ctx server_csrattrs_len csr_data return est_err_malloc strncpy_ csr_data ctx server_csrattrs_len char ctx server_csrattr ctx server_csrattrs_len csr_data ctx server_csrattrs_len csr_len ctx server_csrattrs_len return ctx csr_data csr_len http_ctx )); function call web server layer http request arriv listen port est server determin est request type dispatch request appropri handler paramt ctx pointer est_ctx http_ctx context pointer web server method html method request either get post uri pointer http uri bodi pointer full html bodi content body_len length html bodi html content type header int est_http_request est_ctx ctx void http_ctx char method char uri char bodi int body_len const char ssl ssl int est_oper oper char path_seg est_error est_err_non ctx est_log_err null context &#34;); return est_err_no_ctx verifi context server client ctx est_mod est_serv return est_err_bad_mod est_parse_uri uri oper char **)&amp; path_seg est_err_non est_send_http_error ctx http_ctx return see cacert request oper est_op_cacert get allow strncmp method get est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_handle_cacert ctx ctx ca_cert ctx ca_certs_len http_ctx path_seg ctx http_ctx path_seg ctx http_ctx path_seg est_err_non est_send_http_error ctx http_ctx free path_seg path_seg null return see simpl enrol request els oper est_op_simple_enrol post allow strncmp method post est_log_warn incom http request use wrong method &#34;); est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_log_warn incom http header content type header &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return get ssl context requir authent client ssl ssl mg_get_conn_ssl http_ctx ssl est_send_http_error ctx http_ctx est_err_no_ssl_ctx free path_seg path_seg null return est_err_no_ssl_ctx ctx http_ctx ssl bodi body_len path_seg est_err_non est_err_auth_pend est_log_warn enrol fail est_err_num_to_str )); est_err_auth_fail est_send_http_error ctx http_ctx est_err_auth_fail els est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return see enrol request els oper post allow strncmp method post est_log_warn incom http request use wrong method &#34;); est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_log_warn incom http header content type header &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return get ssl context requir authent client ssl ssl mg_get_conn_ssl http_ctx ssl est_send_http_error ctx http_ctx est_err_no_ssl_ctx free path_seg path_seg null return est_err_no_ssl_ctx ctx http_ctx ssl bodi body_len path_seg est_err_non est_err_auth_pend est_log_warn reenrol fail est_err_num_to_str )); est_err_auth_fail est_send_http_error ctx http_ctx est_err_auth_fail els est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return est_err_bad_pkcs10 see keygen request fixm current implement els strncmp uri est_keygen_uri est_uri_max_len post allow strncmp method post est_log_warn incom http request use wrong method &#34;); est_send_http_error ctx http_ctx est_err_wrong_method return est_err_wrong_method est_log_warn incom http header content type header &#34;); return est_handle_keygen ctx est_send_http_error ctx http_ctx fixm last param zero return est_err_http_writ fixm need appropri return code endif see csr attribut request els oper est_op_csrattr get allow strncmp method get est_log_warn incom http request use wrong method &#34;); est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_handle_csr_attr ctx http_ctx path_seg est_err_non est_send_http_error ctx http_ctx free path_seg path_seg null return send 404 error uri match els est_send_http_error ctx http_ctx free path_seg path_seg null return est_err_non /*! brief est_server_start use applic start est server est_server_init call requir callback function provid applic param ctx pointer est context lib est use http code mongoos http server function allow applic start http servic layer requir est return est_error est_error est_server_start est_ctx ctx est_mg_context mgctx ctx est_log_err null context &#34;); return est_err_no_ctx mgctx mg_start ctx mgctx ctx mg_ctx mgctx return est_err_non els return est_err_no_ssl_ctx /*! brief est_server_stop use applic stop est server call prior est_destroy (). param ctx pointer est context lib est use http code mongoos http server function allow applic stop http servic layer return est_error est_error est_server_stop est_ctx ctx est_mg_context mgctx ctx est_log_err null context &#34;); return est_err_no_ctx mgctx est_mg_context ctx mg_ctx mgctx mg_stop mgctx return est_err_non /*! brief est_server_init use applic creat context est librari oper est server front context use invok function api param ca_chain char array contain pem encod cert crl entri param ca_chain_len length ca_chain char array param cacerts_resp_chain char array contain pem encod cert includ cacert respons param length cacerts_resp_chain char array param cert_format specifi encod local extern certif chain pem der param http_realm char array contain http realm name http auth param tls_id_cert pointer x509 contain server certif tls layer param tls_id_key pointer evp_pkey contain privat key associ server certif function allow applic initi est server context use applic must provid trust certif use server oper use ca_chain paramet certif set includ explicit trust anchor certif number implicit trust anchor certif intermedi sub certif requir complet chain trust ident certif pass tls_id_cert paramet root certif ident certif certif encod use format specifi cert_format paramet pem may contain crl entri use authent est client connect server applic must also provid http realm use http authent server cerif privat key use tls stack identifi server warn includ addit intermedi sub certif need complet chain trust may result potenti mitm attack return est_ctx est_ctx est_server_init unsign char ca_chain int ca_chain_len unsign char cacerts_resp_chain int est_cert_format cert_format char http_realm x509 tls_id_cert evp_pkey tls_id_key est_ctx ctx int len est_log_vers (); saniti check input ca_chain null est_log_err trust certif set empti &#34;); return null cert_format est_cert_format_pem est_log_err pem encod certif chang support .&#34;); return null check length valu match len int strnlen_ char ca_chain est_ca_max len ca_chain_len est_log_err length ca_chain match ca_chain_len &#34;); return null cacerts_resp_chain len int strnlen_ char cacerts_resp_chain est_ca_max len est_log_err actual length cacerts_resp_chain match pass length valu &#34;); return null tls_id_cert null est_log_err tls ident cert empti &#34;); return null tls_id_key null est_log_err privat key associ tls ident cert empti &#34;); return null http_realm null est_log_err est http realm null &#34;); return null ctx malloc sizeof est_ctx )); ctx est_log_err malloc fail &#34;); return null memzero_ ctx sizeof est_ctx )); ctx est_mod est_serv ctx retry_period est_retry_period_def ctx require_http_auth http_auth_requir ctx server_read_timeout load certif local memori retain futur use use cacert request option paramet altern app layer provid callback return fli cacerts_resp_chain est_load_ca_cert ctx cacerts_resp_chain est_log_err fail load certif respons buffer &#34;); free ctx return null ctx ca_chain ca_chain_len est_log_err fail load trust certfic store &#34;); free ctx return null strncpy_ ctx realm max_realm http_realm max_realm ctx server_cert tls_id_cert ctx server_priv_key tls_id_key ctx auth_mod auth_bas ctx server_enable_pop ctx creat new asn object cmc oid open ssl defin need creat http :// www openssl org doc crypto obj_nid2obj html o_cmc o_cmc obj_txt2obj o_cmc est_log_warn fail creat oid cmc key usag check &#34;); return ctx /*! brief use applic configur http authent method use valid ident est client param ctx pointer est context param amod must one follow auth_bas auth_digest auth_token function option invok applic chang default http authent mode default mode http basic authent applic may desir use digest token authent instead case function use set mode function must invok prior start est server return est_error est_error est_ctx ctx est_http_auth_mod amod ctx est_log_err null context &#34;); return est_err_no_ctx switch amod case auth_digest sinc http digest auth use md5 make sure fip mode fips_mod ()) est_log_err http digest auth allow fip mode &#34;); return est_err_bad_mod fallthrough case auth_bas case auth_token ctx auth_mod amod return est_err_non break default est_log_err unsupport http authent mode basic digest token allow &#34;); return est_err_bad_mod break /*! brief est_set_ca_enroll_cb use applic instal handler sign incom pkcs10 request param ctx pointer est context param function address handler function must call prior start est server callback function must match follow prototyp int func unsign char int unsign char **, int char x509 char void *); function call lib est certif request need sign server applic need forward request sign author return respons respons pkcs7 sign certif return est_error est_error est_set_ca_enroll_cb est_ctx ctx int unsign char pkcs10 int p10_len unsign char pkcs7 int pkcs7_len char user_id x509 peer_cert char path_seg void ex_data ctx est_log_err null context &#34;); return est_err_no_ctx ctx est_enroll_pkcs10_cb return est_err_non /*! brief use applic instal handler enrol certif param ctx pointer est context param function address handler function must call prior start est server callback function must match follow prototyp int func unsign char int unsign char **, int char x509 function call lib est certif need renew server applic need forward request sign author return respons respons pkcs7 sign certif return est_error est_error est_ctx ctx int unsign char pkcs10 int p10_len unsign char pkcs7 int pkcs7_len char user_id x509 peer_cert char path_seg void ex_data ctx est_log_err null context &#34;); return est_err_no_ctx ctx return est_err_non /*! brief est_set_http_auth_cb use applic instal handler authent est client param ctx pointer est context param function address handler function must call prior start est server callback function must match follow prototyp int est_ctx ctx est_http_auth_hdr x509 peer_cert char path_seg void ex_data function call lib est perform http authent lib est pass est_http_auth_hdr struct applic allow applic hook radius aaa user authent databas x509 certif tls peer est client also provid callback facil allow applic layer check specif attribut x509 certif 802 1ar devic addit path segment string pass one request uri return est_error est_error est_set_http_auth_cb est_ctx ctx int est_ctx ctx est_http_auth_hdr x509 peer_cert char path_seg void ex_data ctx est_log_err null context &#34;); return est_err_no_ctx ctx est_http_auth_cb return est_err_non /*! brief use applic defin whether http authent requir addit use client certif param ctx pointer est context param requir flag indic http authent requir set http_auth_requir valu requir http auth set http_auth_not_requir http auth occur tls client authent fail return est_error default mode http_auth_requir mean http authent attempt even tls client authent succeed http authent need tls client auth fail set http_auth_not_requir est_error est_ctx ctx est_http_auth_requir requir ctx est_log_err null context &#34;); return est_err_no_ctx ctx require_http_auth requir return est_err_non /*! brief use applic enabl tls srp authent allow est client provid srp credenti tls layer authent est server function must invok enabl server side srp support param ctx pointer est context param function address applic specif srp verifi handler function invok prior start est server use specifi handler srp authent tls layer tls srp cipher suit negoti tls layer handler invok lib est retriev srp paramet user authent applic must provid srp paramet user handler use follow logic invok ssl_get_srp_usernam get srp user name tls layer lookup user srp paramet applic specif user databas paramet includ paramet invok forward srp paramet tls layer allow tls handshak proceed lib est includ exampl server applic use handler srp support exampl use open ssl srp verifi file capabl manag srp paramet individu user applic could use approach may util anoth facil manag user specif srp paramet pleas refer rfc 2945 rfc 5054 full understand srp return est_error est_error est_ctx ctx int ssl int void arg ctx est_log_err null context &#34;); return est_err_no_ctx est_log_err null callback &#34;); return ctx est_srp_username_cb ctx enable_srp return est_err_non /*! brief use applic enabl proof possess check est server prove est client sent csr server posses privat key use sign csr bind tls session csr note csr attribut configur server requir check need call function enabl enabl automat scenario note check possibl est proxi use est client est server sinc proxi possess privat key est server woul fail check howev est proxi enabl featur ensur est client sign key param ctx pointer est context function may call time return est_error est_error est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx server_enable_pop return est_err_non /*! brief use applic disabl proof possess check est server pleas see documen inform proof possess check param ctx pointer est context function may call time return est_error est_error est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx server_enable_pop return est_err_non /*! brief use applic chang default retri period sent est client server configur auto enrol retri valu notifi client long wait attempt enrol oper see approv origin csr param ctx pointer est context param second number second server use retri respons function may call time context creat return est_error est_error est_ctx ctx int second ctx est_log_err null context &#34;); return est_err_no_ctx second est_retry_period_max est_log_err maximum retri period second est_retry_period_max return second est_retry_period_min est_log_err minimum retri period second est_retry_period_min return ctx retry_period second return est_err_non /*! brief use applic specifi ecc curv use ephemer diffi hellman key tls handshak ephemer diffi hellman enabl lib est provid better forward secreci curv specifi applic use function prime256v1 curv use default curv param ctx pointer est context param nid open ssl nid valu desir curv function must call prior start est server nid valu defin openssl obj_mac typic nid valu provid function would includ nid_x9_62_prime192v1 nid_x9_62_prime256v1 nid_secp384r1 nid_secp521r1 return est_error est_error est_ctx ctx int nid ctx est_log_err null context &#34;); return est_err_no_ctx nid est_log_err invalid nid valu &#34;); return ctx ecdhe_nid nid return est_err_non /*! brief use applic specifi diffi hellman paramet use singl use key generat tls handshak paramet use singl use key generat enabl enabl improv forward secreci tls handshak oper paramet provid api hard code applic paramet generat time product instal reus paramet across multipl instal product result vulner product param ctx pointer est context param parm pointer open ssl paramet function must call prior start est server return est_error est_error est_ctx ctx parm ctx est_log_err null context &#34;); return est_err_no_ctx parm est_log_err null paramet &#34;); return ctx dh_tmp dhparams_dup parm return est_err_non /*! brief use applic initi fix set csr attribut attribut use lib est respons client csr attribut request attribut must asn base64 encod charact string param ctx pointer est context param csrattr pointer csr attribut asn base64 encod format null pointer clear attribut length param csrattrs_len length csr attribut charact string est_get_csr_cb callback function maintain precend method csr attribut est_get_csr_cb initi applic use lib est use attribut initi function call prior start est server configur call prior function return est_error est_error est_ctx ctx char csrattr int csrattrs_len int csrattrs_pop_len pop_pres char csrattrs_data_pop null ctx null return est_err_no_ctx verifi context server client proxi ctx est_mod est_serv return est_err_bad_mod est_log_info attribut pointer len ctx server_csrattr ctx server_csrattrs_len free old version previous initi ctx server_csrattr null free ctx server_csrattr ctx server_csrattr null ctx server_csrattrs_len caller want clear return csrattr null return est_err_non order run client negat unit test paramet pars check need disabl via defin coupl place check smallest possibl base64 case saniti test check min max valu asn data csrattrs_len min_csrattr return assum csr attribut ctx csr_pop_pres ctx server_enable_pop est_is_challeng password_pres csrattr csrattrs_len pop_pres est_err_non est_log_err error saniti check &#34;); return ctx csr_pop_pres pop_pres ctx csr_pop_pres est_add_challeng password csrattr csrattrs_len csrattrs_data_pop csrattrs_pop_len est_err_non est_log_err error add &#34;); return csrattr csrattrs_data_pop csrattrs_len csrattrs_pop_len els csrattr csrattrs_len pop_pres est_err_non est_log_err corrupt csr attribut &#34;); return ctx server_csrattr malloc csrattrs_len ctx server_csrattr csrattrs_data_pop free csrattrs_data_pop return est_err_malloc ctx server_csrattrs_len csrattrs_len strncpy_ char ctx server_csrattr csrattrs_len csrattr csrattrs_len ctx server_csrattr csrattrs_len csrattrs_data_pop free csrattrs_data_pop est_log_info attribut pointer len ctx server_csrattr ctx server_csrattrs_len return est_err_non /*! brief deprec function tls violat rfc7030 longer support est librari function log error messag return est_err_bad_mod param ctx pointer est context function must call prior start est server return est_error est_error est_ctx ctx est_log_err tls violat rfc7030 therefor support &#34;); return est_err_bad_mod /*! brief use applic enabl check csr attribut est server enabl est client must provid csr attribut csrattr respons sent server enrol fail client fail provid csr attribut set appli simpl enrol reenrol oper set appli server mode bear proxi mode oper param ctx pointer est context function must call prior start est server return est_error est_error est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx enforce_csrattr return est_err_non /*! brief use applic set timeout valu server read oper socket open est server begin attempt read socket timeout valu limit amount time client wait respons default valu set param ctx pointer est context param timeout integ valu repres read timeout second minimum valu maximum valu return est_error est_error est_ctx ctx int timeout ctx est_log_err null context &#34;); return est_err_no_ctx timeout timeout est_log_err invalid read timeout valu pass timeout return ctx server_read_timeout timeout return est_err_non&#39;,
 &#39;tcw err tcw connect tcw sock sock tcw opt opt const char host unsign short int port sock type tcw err tcw close tcw sock sock&#39;,
 &#39;libest test api void est log est log level lvl char format libest test api void est log backtrac void est char est get tls uid ssl ssl int client est libest test api est error est load cert est ctx ctx unsign char raw int size est libest test api est error est load trust cert est ctx ctx unsign char cert int cert len est void est log est log level lvl char format est libest test api void est log version void est void est hex str char dst unsign char src int len est int est base encod const char src int actual src len char dst int max dst len est libest test api int est base decod const char src char dst int max len est server int est http request est ctx ctx void http ctx char method char uri char bodi int bodi len const char est client libest test api est error est client connect est ctx ctx ssl ssl est client int est client send enrol request est ctx ctx ssl ssl buf mem bptr unsign char pkcs int pkcs len int reenrol est client libest test api void est client disconnect est ctx ctx ssl ssl est client libest test api int ssl_ctx ctx x509 cert evp_pkey key est_client est_error est_ctx ctx const char uid const char pwd est_client_http est_error est_io_get_respons est_ctx ctx ssl ssl est_oper unsign char buf int payload_len est_proxi libest_test_api est_error est_ctx ctx void http_ctx char method char uri char bodi int body_len const char est_proxi void proxy_cleanup est_ctx p_ctx est_proxi est_error const char int len int offset est_proxi est_error est_is_challeng password_pres const char base64_ptr int b64_len int offset est_proxi est_error est_add_challeng password const char base64_ptr int b64_len char new_csr int pop_len est_proxi libest_test_api est_error est_ctx ctx unsign char cacerts_rtn int cacerts_rtn_len est_proxi est_error est_ctx ctx char csr_data int csr_len void http_ctx est_proxi void est_http_auth_hdr auth_cr est_proxi est_error est_parse_uri char uri est_oper oper char path_seg est_proxi est_error est_store_path_seg est_ctx ctx char path_seg int path_segment_len est_proxi est_oper est_parse_oper char op_path est_proxi int est_strcasecmp_ char char&#39;,
 &#39;static pthread pthread self void return get current thread const void get conn ssl struct connect conn return conn conn ssl null static void sockaddr string char buf size len const union usa usa buf defin use ipv inet ntop usa famili usa famili inet void usa sin sin addr void usa sin sin addr buf socklen len elif defin win windoz vista newer inet ntop strncpi buf max src addr inet ntoa usa sin sin addr len els inet ntop usa famili void usa sin sin addr buf len endif print error messag open error log stream static void cri struct connect conn const char fmt char buf buf len src addr max src addr list time timestamp start fmt void vsnprintf buf sizeof buf fmt end lock get callback valu suppos fine sinc function cannot disappear way string option conn request info data buf timestamp time null sockaddr string src addr sizeof src addr conn client rsa est log err error client unsign long timestamp src addr conn request info request method null est log_err (&#34;% conn request_info request_method conn request_info uri est_log_err (&#34;% buf conn request_info ev_data null applic moment log static struct mg_connect struct mg_context ctx static struct mg_connect fake_connect fake_connect ctx ctx return fake_connect applic moment log const char mg_version void return mongoose_vers applic moment log struct mg_request_info mg_get_request_info struct mg_connect conn return conn request_info applic moment log void mg_strlcpi regist char dst regist const char src size_t src --) dst src ++; dst applic moment log char mg_strndup const char ptr size_t len char char malloc len null mg_strlcpi ptr len return applic moment log static int lowercas const char return tolow (*( const unsign char applic moment log static int mg_strncasecmp const char const char size_t len int diff len diff lowercas ++) lowercas ++); diff len return diff applic moment log static int mg_strcasecmp const char const char int diff diff lowercas ++) lowercas ++); diff return diff audit report static int mg_vsnprintf struct mg_connect conn char buf size_t buflen const char fmt va_list int buflen return vsnprintf buf buflen fmt cri conn vsnprintf error &#34;); els int buflen cri conn truncat vsnprintf buffer [%.* ]&#34;, 200 200 buf int buflen buf return printf_arg static int mg_snprintf struct mg_connect conn char buf size_t buflen const char fmt ...) va_list int va_start fmt mg_vsnprintf conn buf buflen fmt va_end return printf_arg static size_t est_strcspn const char str1 const char str2 rsize_t count errno_t safec_rc str1 null str1 return safec_rc strcspn_s str1 strnlen_ str1 rsize_max_str str2 rsize_max_str count safec_rc eok est_log_info strcspn_s error safec_rc return return count printf_arg static size_t est_strspn const char str1 const char str2 rsize_t count errno_t safec_rc str1 null str1 return safec_rc strspn_s str1 strnlen_ str1 rsize_max_str str2 rsize_max_str count safec_rc eok est_log_info strspn_s error safec_rc return return count delimit quot quotechar char skip_quot char buf const char delimit const char whitespac char quotechar char begin_word end_word end_whitespac begin_word buf end_word begin_word est_strcspn begin_word delimit check quotechar end_word begin_word end_word quotechar anyth beyond end_word copi end_word break els rsize_t end_off rsize_t est_strcspn end_word delimit memmove_ end_off end_word end_off end_off must correspond end_word end_word end_off ++; end_word ++) end_word buf end_word els end_whitespac end_word est_strspn end_word whitespac end_word end_whitespac ++) buf end_whitespac return begin_word whitespac delimit char skip char buf const char delimit return skip_quot buf delimit delimit return http header valu null found static const char get_head const struct mg_request_info const char name int num_head ++) mg_strcasecmp name http_header name return http_header valu return null return http header valu null found const char mg_get_head const struct mg_connect conn const char name return get_head conn request_info name set exampl request pars fail static int should_keep_al const struct mg_connect conn const char http_version conn request_info http_version const char header mg_get_head conn connect &#34;); slight deviat mongoos behavior close connect send 202 accept respons also close connect 4xx respons mongoos close 401 unauthor conn must_clos conn status_cod est_http_stat_202 conn status_cod 400 conn ctx enable_keepal header null mg_strcasecmp header keep aliv header null http_version strncmp http_version ))) return return set exampl request pars fail static const char const struct mg_connect conn return should_keep_al conn keep aliv close set exampl request pars fail void mg_send_http_error struct mg_connect conn int status const char reason const char fmt ...) char buf mg_buf_len va_list int len conn status_cod status conn request_info ev_data void *)( long status buf len error 1xx 204 304 must send bodi status 199 status 204 status 304 len mg_snprintf conn buf sizeof buf error status reason buf len ++] va_start fmt len mg_vsnprintf conn buf len sizeof buf len fmt va_end est_log_info (&#34;[% ]&#34;, buf mg_printf conn http content length connect status reason len conn )); conn num_bytes_s mg_printf conn buf window chang slash backslash path name static void char path int path ++) path /\&#39;) path \\\\\&#39;; check preserv unc path like server file txt path path path /\&#39;) void memmove_ path est_uri_max_len path strnlen_ path est_uri_max_len )); wbuf wbuf_len target buffer length static void to_unicod const char path wchar_t wbuf size_t wbuf_len char buf path_max buf2 path_max mg_strlcpi buf path sizeof buf )); buf point end file name buf strnlen_ buf est_uri_max_len convert unicod back doubli convert string match origin someth fishi reject memzero_ wbuf wbuf_len sizeof wchar_t )); multi byte wide char cp_utf8 buf wbuf int wbuf_len wide char multi byte cp_utf8 wbuf int wbuf_len buf2 sizeof buf2 null null strcmp buf buf2 wbuf function return non path end garbag static int const char path static const char allowed_last_charact -&#34;; int last path strnlen_ path est_uri_max_len return isalnum last strchr allowed_last_charact last null function return non path end garbag static handl dlopen const char dll_name int flag wchar_t wbuf path_max flag unus to_unicod dll_name wbuf array_s wbuf )); return load librari wbuf descriptor return number byte written static int64_t push file socket sock ssl ssl const char buf int64_t len int64_t sent int sent sent len mani byte send iter len sent int_max int_max int len sent ssl null ssl_write ssl buf sent els null int fwrite buf sent size_t ferror els int send sock buf sent size_t msg_nosign break sent return sent read must give close connect exit serv thread static int struct mg_connect conn struct pollfd pfd int result int times_up est_uint total_wait_tim est_uint read_timeout conn read_timeout 1000 accuml total amount time wait total_wait_tim msec_poll_wait_tim pfd conn client sock pfd event pollin pfd revent errno result poll pfd msec_poll_wait_tim result conn ssl null result ssl_pend conn ssl check see time give set thing accord close session total_wait_tim read_timeout result times_up conn must_clos result continu wait noth read socket poll interrupt signal master process indic stop wait read timeout occur result result errno eintr conn ctx stop_flag times_up return conn ctx stop_flag result return negat valu error number byte read success static int pull file struct mg_connect conn char buf int len int nread int err_cd null use read instead fread (), read cgi pipe fread may block buffer fill cannot afford block must pass read byte immedi client nread int read fileno buf size_t len els conn must_clos conn nread els conn ssl null nread ssl_read conn ssl buf len err_cd ssl_get_error conn ssl nread switch err_cd case ssl_error_non noth grace shutdown break case ssl_error_want_read data may come chang nread zero mongoos attempt read data peer would occur peer initi ssl renegot nread break case est_log_err ssl_read error want lookup &#34;); break default error simpli log error make sure nread indic error function est_log_err ssl_read error code err_cd nread break els nread int recv conn client sock buf size_t len return conn ctx stop_flag nread return negat valu error number byte read success int mg_read struct mg_connect conn void buf size_t len int buffered_len nread const char bodi rsize_t max_len nread max_len rsize_t len conn consumed_cont conn content_len adjust number byte read int64_t to_read conn content_len conn consumed_cont to_read int64_t len len size_t to_read return buffer data bodi conn buf conn request_len conn consumed_cont buffered_len int conn buf conn data_len bodi buffered_len len size_t buffered_len buffered_len int len memcpy_ buf max_len bodi rsize_t buffered_len len buffered_len conn consumed_cont buffered_len nread buffered_len buf char buf buffered_len return buffer data read new data remot socket len pull null conn char buf int len nread propag error break els buf char buf conn consumed_cont nread len els retri return nread return negat valu error number byte read success int mg_write struct mg_connect conn const void buf size_t len int64_t total total push null conn client sock conn ssl const char buf int64_t len return int total return negat valu error number byte read success int mg_printf struct mg_connect conn const char fmt ...) char mem mg_buf_len buf mem int len va_list print local buffer first hope larg enough hold whole messag va_start fmt len vsnprintf mem sizeof mem fmt va_end len noth mg_printf conn &#34;&#34;) call els len vsnprintf error give len cri conn ...): vsnprintf error __func__ fmt els len int sizeof mem buf char malloc len null local buffer larg enough alloc big buffer heap va_start fmt vsnprintf buf len fmt va_end len mg_write conn buf size_t len free buf els len int sizeof mem fail alloc larg enough buffer give cri conn ...): alloc byte print anyth __func__ fmt len len els copi local buffer succeed len mg_write conn buf size_t len return len http :// ftp uci edu pub ietf html rfc1866 txt static int url_decod const char src int src_len char dst int dst_len int is_form_url_encod int defin hextoi isdigit src_len dst_len ++, ++) src isxdigit (*( const unsign char *)( src isxdigit (*( const unsign char *)( src ))) tolow (*( const unsign char *)( src )); tolow (*( const unsign char *)( src )); dst char )(( hextoi hextoi )); els is_form_url_encod src +\&#39;) dst els dst src dst null termin destin return src_len actual request length includ last static int get_request_len const char buf int buflen const char int len buf buflen len ++) control charact allow 128 isprint (*( const unsign char const unsign char 128 len break i_a abort scan soon one malform charact found let subsequ win anyhow els len int buf els len int buf return len excess charact static void char char ++; \\\\\&#39;) skip follow slash backslash doubl dot \\\\\&#39;) ++; els .\&#39;) els break perform pars http authent header client basic authent use static void struct mg_connect conn const char auth_head est_http_auth_hdr char valu char save_ptr char max_uidpwd contain uid pwd rsize_t len char sep &#34;:&#34;; int colon_found char possible_pw char auth_head gobbl initi space isspac (*( unsign char ++; valu len est_base64_decod valu max_uidpwd )); len est_log_warn base64 decod http auth header fail http auth fail &#34;); return make sure string colon_found strstr_s len &#34;:&#34;, possible_pw colon_found eok est_log_warn invalid format basic http credenti miss :&#34;); memzero_ max_uidpwd )); return start colon mean userid :\&#39;) len password possible_pw ++; pwd strndup possible_pw max_uidpwd est_log_info http authent header contain password &#34;); els got neither userid password est_log_info http authent header contain userid password &#34;); memzero_ max_uidpwd )); return els start userid pars usernam password separ &#34;:&#34; valu strtok_ len sep save_ptr valu user strndup valu max_uidpwd pwd strndup save_ptr max_uidpwd mode auth_bas memzero_ max_uidpwd )); perform pars http authent header client digest authent use static void struct mg_connect conn const char auth_head est_http_auth_hdr char name valu char buf max_auth_hdr_len int mode auth_digest make modifi copi auth header strncpy_ buf max_auth_hdr_len auth_head max_auth_hdr_len buf pars author header gobbl initi space isspac (*( unsign char ++; name skip_quot &#34;=&#34;, valu either quot delimit end first comma space \\&#34;\&#39;) ++; valu skip_quot &#34;\\&#34;&#34;, \\\\\&#39;); ,\&#39;) ++; els valu skip_quot use comma use space name break memcmp_ name usernam user strndup valu max_uidpwd continu memcmp_ name cnonc cnonc strndup valu max_nonc continu memcmp_ name respons respons strndup valu max_respons continu memcmp_ name uri uri strndup valu max_realm continu memcmp_ name qop qop strndup valu max_qop continu memcmp_ name strndup valu max_nc continu memcmp_ name nonc nonc strndup valu max_nonc perform pars http authent header client token bearer authent use static void struct mg_connect conn const char auth_head est_http_auth_hdr char valu char value_decod max_auth_token_len int len char auth_head strlen est_bearer_token_str gobbl initi space isspac (*( unsign char ++; valu memzero_ value_decod max_auth_token_len len est_base64_decod valu value_decod max_auth_token_len )); len est_log_warn base64 decod http auth credenti fail http auth fail &#34;); return copi token auth header structur auth_token strndup value_decod max_auth_token_len mode auth_token auth_token null est_log_err fail obtain memori authent token buffer &#34;); els est_log_err authent header client contain token &#34;); function pars http authent header client fill field est_http_auth_hdr struct use later verifi user credenti use either http basic http digest authent paramet alreadi alloc call function return either good bad miss mg_parse_auth_head struct mg_connect conn est_http_auth_hdr const char auth_head get auth header http client auth_head mg_get_head conn author &#34;)) null return est_auth_hdr_miss mg_strncasecmp auth_head digest make sure server configur digest auth conn ctx est_ctx auth_mod auth_digest return est_auth_hdr_bad conn auth_head els mg_strncasecmp auth_head basic make sure server configur basic auth conn ctx est_ctx auth_mod auth_bas return est_auth_hdr_bad conn auth_head els mg_strncasecmp auth_head est_bearer_token_str strlen est_bearer_token_str make sure server configur bearer token auth conn ctx est_ctx auth_mod auth_token return est_auth_hdr_bad conn auth_head els basic digest bearer token authent support mode auth_fail return est_auth_hdr_bad digest auth make sure valu pars mode auth_digest uri nonc cnonc est_log_err pars http auth header fail &#34;); return est_auth_hdr_bad abl pars user token auth mode make sure fail authent user null mode auth_token return est_auth_hdr_bad mode auth_token save user connect context want pass later strncpy_ conn user_id mg_uid_max user mg_uid_max return est_auth_hdr_good function pars http authent header client fill field est_http_auth_hdr struct use later verifi user credenti use either http basic http digest authent paramet alreadi alloc call function return either good bad miss void struct mg_connect conn conn status_cod 401 switch conn ctx est_ctx auth_mod case auth_bas mg_printf conn basic realm =\\&#34;% \\&#34;\\ est_http_hdr_401 est_http_hdr_cl est_http_hdr_auth conn ctx est_ctx realm break case auth_digest mg_printf conn digest qop =\\&#34; auth \\&#34;, realm =\\&#34;% \\&#34;, nonc =\\&#34;% \\&#34;\\ est_http_hdr_401 est_http_hdr_cl est_http_hdr_auth conn ctx est_ctx realm unsign long time null )); break case auth_token mg_printf conn bearer realm =\\&#34;% \\&#34;\\ est_http_hdr_401 est_http_hdr_cl est_http_hdr_auth conn ctx est_ctx realm break case auth_fail case auth_non default mode valid point noth break pars stop static void parse_http_head char buf struct mg_request_info int int array_s http_header ++) http_header name skip_quot buf &#34;:&#34;, http_header valu skip buf &#34;); http_header name break num_head pars stop static int is_valid_http_method const char method est allow get post return strncmp method get strncmp method post http request compon header name header valu static int parse_http_messag char buf int len struct mg_request_info int request_length get_request_len buf len request_length reset attribut touch is_ssl remote_ip remote_port request_method uri http_version null num_head buf request_length rfc say initi whitespac ingor buf isspac (*( unsign char buf buf ++; request_method skip buf &#34;); uri skip buf &#34;); http_version skip buf &#34;); parse_http_head buf est_log_info request_len request_length est_log_info request uri uri return request_length http request compon header name header valu static int parse_http_request char buf int len struct mg_request_info int result parse_http_messag buf len result is_valid_http_method request_method strncmp http_version http /&#34;, http_version skip http els result return result upon everi read oper increas nread number byte read static int read_request file struct mg_connect conn char buf int bufsiz int nread int request_len request_len get_request_len buf nread nread bufsiz request_len pull conn buf nread bufsiz nread nread request_len get_request_len buf nread recv error propag error process b0rked high probabl request return return request_len function call mongoos code incom http request process return success non zero request handl static int est_mg_handl struct mg_connect conn const struct mg_request_info request_info mg_get_request_info conn est_ctx ectx conn ctx est_ctx char bodi int int est_rv est_err_non const char cl_hdr content length html header const char ct_hdr content type html header cl_hdr mg_get_head conn content length &#34;); cl_hdr point content length valu alreadi error check guarante within correct rang obtain length alloc buffer bodi read atoi cl_hdr bodi malloc mg_read conn bodi make sure buffer null termin bodi 0x0 els bodi null ct_hdr mg_get_head conn content type &#34;); ectx est_mod est_serv est_rv est_http_request ectx conn char request_info request_method char request_info uri bodi ct_hdr els ectx est_mod est_proxi est_rv ectx conn char request_info request_method char request_info uri bodi ct_hdr est_rv est_err_non est_log_err est error respons code est_rv est_err_num_to_str est_rv )); cl_hdr free bodi return est_rv directori call embed function etcetera static void handle_request struct mg_connect conn struct mg_request_info conn request_info int uri_len int conn request_info query_str strchr uri ?\&#39;)) null *(( char conn request_info query_str ++) uri_len int strnlen_ uri est_uri_max_len url_decod uri uri_len char uri uri_len char uri est_log_info (&#34;% uri process request est_mg_handl conn est_err_non est_log_warn incom request fail )&#34;, est_err_num_to_str )); directori call embed function etcetera static void log_head const struct mg_connect conn const char header const char header_valu header_valu mg_get_head conn header null est_log_info (&#34;% -&#34;); els est_log_info \\&#34;% \\&#34;&#34;, header_valu directori call embed function etcetera static void log_access const struct mg_connect conn const struct mg_request_info char date src_addr strftime date sizeof date localtim conn birth_tim )); conn request_info sockaddr_to_str src_addr sizeof src_addr conn client rsa est_log_info (&#34;% \\&#34;% http int64_fmt src_addr date request_method request_method &#34;-&#34;, uri uri &#34;-&#34;, http_version conn status_cod conn num_bytes_s log_head conn refer &#34;); log_head conn user agent &#34;); return open ssl error messag static const char ssl_error void unsign long err err err_get_error (); return err err_error_str err null dynam load ssl librari set ctx ssl_ctx pointer static int set_ssl_opt struct mg_context ctx struct mg_connect conn est_ctx ectx ssl_ctx ssl_ctx ec_key ecdh null x509_verify_param vpm null char sic est ssl_ctx ssl_ctx_new sslv23_server_method ())) null cri ctx ssl_ctx_new server error ssl_error ()); return ctx ssl_ctx ssl_ctx ectx ctx est_ctx conn ctx conn request_info ev_data ctx ssl_ctx ssl_ctx_set_verifi ssl_ctx ssl_verify_p null set session context enabl open ssl session reus improv perform set estxxxxxxxx valu random number rand_byt unsign char *)&amp; sic est_log_warn rng failur set sic ssl_error ()); ssl_ctx void *)&amp; sic load cert use verifi client certif ssl_ctx ectx trusted_certs_stor ssl code free store ssl_ctx later ectx trusted_certs_stor null note disabl tls ticket anoth way reus tls session avoid key exchang overhead tls handshak enabl session reus session reus work ticket support enabl server may want look enabl ticket futur session reus give perform boost option set improv forward secrecti compli est draft ssl_ctx_set_opt ssl_ctx ssl_op_no_sslv2 ssl_op_no_sslv3 ssl_op_no_tlsv1 ssl_op_no_ticket set ecdh singl use parm use configur curv use prime256v1 default ectx ecdhe_nid setup user select curv ecdh ectx ecdhe_nid est_log_info use non default ecdh curv nid )&#34;, ectx ecdhe_nid els default prime256 curv ecdh nid_x9_62_prime256v1 est_log_info use default ecdh curv prime256v1 )&#34;); ecdh null est_log_err fail generat temp ecdh paramet &#34;); return ssl_ctx_set_tmp_ecdh ssl_ctx ecdh ec_key_fre ecdh setup addit cert check includ crl depth purpos vpm (); enabl crl check ectx enable_crl vpm vpm est_tls_verify_depth note purpos check keyusag valu present client cert vpm x509_purpose_ssl_cli ssl_ctx_set1_param ssl_ctx vpm vpm set singl use paramet applic request capabl ectx dh_tmp ssl_ctx_set_opt ssl_ctx ssl_op_single_dh_us ssl_ctx_set_tmp_dh ssl_ctx ectx dh_tmp dh_free ectx dh_tmp ectx dh_tmp null ectx enable_srp est_log_info enabl tls srp mode &#34;); ssl_ctx est_log_err fail set ssl cipher suit &#34;); return set applic specif handler provid srp paramet user authent ssl_ctx ectx est_srp_username_cb els est_log_info tls srp enabl &#34;); set tls cipher suit allow disabl anonym null cipher ssl_ctx est_cipher_list est_log_err fail set ssl cipher suit &#34;); return ssl_ctx_use_certif ssl_ctx ectx server_cert est_log_err unabl set server certif &#34;); return ssl_ctx_use_priv key ssl_ctx ectx server_priv_key est_log_err unabl set server privat key &#34;); return need includ cert chain server certif tls certif messag server reason est draft specifi subordin cert includ cacert messag flow henc client alreadi full cert chain therfor tls handshak contain server cert full chain ctx ssl_ctx ctx est_ctx http_cert_fil return dynam load ssl librari set ctx ssl_ctx pointer static void struct mg_connect conn conn path_info conn request_info ev_data null conn num_bytes_s conn consumed_cont conn status_cod conn must_clos conn request_len dynam load ssl librari set ctx ssl_ctx pointer static int is_valid_uri const char uri conform http :// www org protocol rfc2616 rfc2616 sec5 html sec5 uri asterisk (*) start slash return uri uri uri dynam load ssl librari set ctx ssl_ctx pointer static void process_new_connect struct mg_connect conn struct mg_request_info conn request_info int keep_alive_en keep_al discard_len const char keep_alive_en conn ctx enable_keepal keep_al import new connect reset receiv buffer credit goe crule42 conn data_len conn conn request_len read_request null conn conn buf conn buf_siz conn data_len assert conn request_len conn data_len conn request_len conn request_len conn data_len conn buf_siz send_http_error conn 413 request larg &#34;&#34;); return conn request_len return remot end close connect parse_http_request conn buf conn buf_siz is_valid_uri uri put garbag access log send back client send_http_error conn 400 bad request cannot pars http request [%.* ]&#34;, conn data_len conn buf conn must_clos els strncmp http_version strncmp http_version request seem valid http version strang send_http_error conn 505 http version support &#34;&#34;); log_access conn els request valid handl get_head content length &#34;)) null conn content_len strtoll null els mg_strcasecmp request_method post mg_strcasecmp request_method put &#34;)) conn content_len els conn content_len ensur content length valu size est code will accept conn content_len est_max_content_len est_log_warn http request content length greater est maximum support content length )&#34;, est_max_content_len send_http_error conn 413 content length larg &#34;&#34;); log_access conn els conn content_len est_log_warn http request content length negat valu &#34;); send_http_error conn 400 bad request content length negat conn data_len conn buf log_access conn els conn birth_tim time null handle_request conn log_access conn note lsm order import should_keep_al call use pars request invalid memmov therefor memor should_keep_al result later use loop exit condit keep_al should_keep_al conn discard buffer data request discard_len conn content_len conn request_len conn content_len int64_t conn data_len int conn request_len conn content_len conn data_len conn data_len discard_len memmove_ conn buf max_request_s conn buf discard_len conn data_len discard_len conn data_len discard_len assert conn data_len assert conn data_len conn buf_siz conn ctx stop_flag keep_alive_en conn content_len keep_al /*! brief use applic process est request applic respons open listen socket est request come socket applic use function hand request lib est param ctx pointer est_ctx provid est_server_init est_proxy_init invok param file descriptor read retriev http request client typic tcp socket file descriptor use applic incom est request need process request would cacert simpleenrol reenrol csrattr request use implement est server applic respons open listen tcp socket incom est request data readi read socket api entri point use allow lib est read request socket respond request return est_error est_error est_ctx ctx int struct mg_connect conn struct socket accept socklen_t len char ipstr inet6_addrstrlen int port struct sockaddr_storag addr int ssl_err err_cod est_error est_err_non int ctx est_log_err null est context &#34;); return est_err_no_ctx ctx mg_ctx est_log_err null est context &#34;); return est_err_no_ctx accept sock accept next null len sizeof struct sockaddr_storag getpeernam struct sockaddr *)&amp; addr len est_log_err getpeernam fail &#34;); never happen sure would caus return est_err_unknown deal ipv4 ipv6 addr ss_famili af_inet memcpy_ accept rsa sin sizeof struct sockaddr_in addr sizeof struct sockaddr_in )); port ntoh accept rsa sin sin_port inet_ntop af_inet accept rsa sin sin_addr ipstr sizeof ipstr els af_inet6 memcpy_ accept rsa sin6 sizeof struct sockaddr_in6 addr sizeof struct sockaddr_in6 )); port ntoh accept rsa sin6 sin6_port inet_ntop af_inet6 accept rsa sin6 sin6_addr ipstr sizeof ipstr est_log_info peer address ipstr est_log_info peer port port conn struct mg_connect calloc sizeof conn max_request_s conn null cri ctx mg_ctx cannot creat new connect struct oom &#34;); return est_err_malloc els conn buf_siz max_request_s conn buf char *)( conn conn client accept conn birth_tim time null conn ctx ctx mg_ctx conn read_timeout ctx server_read_timeout fill port info earli even ssl setup fail error handler would correspond info conn request_info remote_port ntoh conn client rsa sin sin_port memcpy_ conn request_info remote_ip conn client rsa sin sin_addr s_addr conn request_info remote_ip ntohl conn request_info remote_ip conn request_info is_ssl est requir tls setup tls tunnel conn ssl ssl_new conn ctx ssl_ctx conn ssl null ssl_set_fd conn ssl conn client sock ssl_err ssl_accept conn ssl ssl_err err_cod ssl_get_error conn ssl ssl_err switch err_cod case ssl_error_syscal est_log_err open ssl system call error &#34;); est_err_syscal break case ssl_error_ssl unknown open ssl error dump open ssl error log learn ossl_dump_ssl_error (); est_err_unknown break case ssl_error_want_read case ssl_error_want_writ est_log_info app use non block socket &#34;); process_new_connect conn break case est_log_err ssl_accept error want lookup &#34;); est_err_unknown break case ssl_error_non default break els process_new_connect conn ssl_err ssl_shutdown conn ssl switch ssl_err case open ssl doc say call shutdown case ssl_shutdown conn ssl est_log_info two phase ssl_shutdown initi &#34;); break case noth shutdown work est_log_info ssl_shutdown succeed &#34;); break default log error est_log_warn ssl_shutdown fail &#34;); break ssl_free conn ssl conn ssl null memzero_ conn sizeof conn max_request_s free conn return /*! brief use applic process est request applic respons open listen socket est request come socket applic use function hand request lib est param ctx pointer est_ctx provid est_server_init est_proxy_init invok param file descriptor read retriev http request client typic tcp socket file descriptor use applic incom est request need process request would cacert simpleenrol reenrol csrattr request use implement est server applic respons open listen tcp socket incom est request data readi read socket api entri point use allow lib est read request socket respond request return est_error static void free_context struct mg_context ctx dealloc ssl context ctx ssl_ctx null ssl_ctx_free ctx ssl_ctx dealloc context free ctx /*! brief use applic process est request applic respons open listen socket est request come socket applic use function hand request lib est param ctx pointer est_ctx provid est_server_init est_proxy_init invok param file descriptor read retriev http request client typic tcp socket file descriptor use applic incom est request need process request would cacert simpleenrol reenrol csrattr request use implement est server applic respons open listen tcp socket incom est request data readi read socket api entri point use allow lib est read request socket respond request return est_error void mg_stop struct mg_context ctx ctx stop_flag free_context ctx defin _win32 defin __symbian32__ void wsacleanup (); endif _win32 /*! brief use applic process est request applic respons open listen socket est request come socket applic use function hand request lib est param ctx pointer est_ctx provid est_server_init est_proxy_init invok param file descriptor read retriev http request client typic tcp socket file descriptor use applic incom est request need process request would cacert simpleenrol reenrol csrattr request use implement est server applic respons open listen tcp socket incom est request data readi read socket api entri point use allow lib est read request socket respond request return est_error struct mg_context mg_start void user_data struct mg_context ctx defin _win32 defin __symbian32__ wsadata data wsastartup makeword data initi critic section global_log_file_lock endif _win32 alloc context initi reason general case default todo lsm proper error handl ctx struct mg_context calloc sizeof ctx ))) null return null ctx user_data user_data ctx est_ctx est_ctx user_data ctx enable_keepal set_ssl_opt ctx free_context ctx return null return ctx /*! brief use applic process est request applic respons open listen socket est request come socket applic use function hand request lib est param ctx pointer est_ctx provid est_server_init est_proxy_init invok param file descriptor read retriev http request client typic tcp socket file descriptor use applic incom est request need process request would cacert simpleenrol reenrol csrattr request use implement est server applic respons open listen tcp socket incom est request data readi read socket api entri point use allow lib est read request socket respond request return est_error est_error est_ctx ctx char csr_data int csr_len void http_ctx char http_hdr est_http_hdr_max int hdrlen csr_len csr_data send http 200 header snprintf http_hdr est_http_hdr_max est_http_hdr_200 est_http_hdr_eol est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_ct est_http_ct_csrattr est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_c est_http_ce_base64 est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_cl csr_len est_http_hdr_eol est_http_hdr_eol mg_write http_ctx http_hdr strnlen_ http_hdr est_http_hdr_max ))) free csr_data return est_err_http_writ send csr bodi mg_write http_ctx csr_data csr_len free csr_data return est_err_http_writ free csr_data els csr_data free csr_data send 204 respons indic server csr est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non&#39;,
 &#39;sinc hijack open ssl buf mem data util function allow free buf mem without free under data static void est proxi free ossl bufmem buf mem data null buf mem free bsearch compar use bsearch function perform comparison node within client context array static int bsearch compar const void const void int result client ctx node client ctx node client ctx node client ctx node threadid threadid result threadid threadid result threadid threadid result return result get client ctx perform search order array key search current thread valu return client context creat thread entri exist array thread new one creat static est ctx get client ctx est ctx ctx est ctx ctx null est error unsign long cur threadid unsign long cur pid getpid client ctx node found node unsign long zero threadid client ctx node empti node int empti index window todo like need replac get current thread addit realli return pointer opaqu valu use typic pointer pthread base environ actual pthread helper api access actual pthread equal must use array search would best chang linear search mix pid current process thread case applic fork new process nginx ifndef disabl pthread cur threadid unsign long pthread self endif cur threadid cur pid found node client ctx node bsearch cur threadid ctx client ctx array cur max ctx array sizeof client ctx node bsearch compar found node null need alloc context get readi use c_ctx est_client_init p_ctx ca_chain_raw p_ctx ca_chain_raw_len est_cert_format_pem null c_ctx null est_log_err unabl alloc initi est client context proxi use &#34;); return null name bit mislead ident cert privat key use proxi mode one store server_cert server_priv_key howev use direct set client side look mix might want chang name context hold est_client_set_auth c_ctx p_ctx userid p_ctx password p_ctx server_cert p_ctx server_priv_key est_err_non est_log_err unabl set authent configur client context proxi use &#34;); est_destroy c_ctx return null c_ctx p_ctx auth_credentials_cb est_err_non est_log_err unabl regist authent credenti callback .&#34;); return null wrt path segment unlik true client mode path segment chang everi request upstream need obtain local proxi set one time left null est_client_set_serv c_ctx p_ctx est_serv p_ctx est_port_num null est_err_non est_log_err unabl set upstream server configur client context proxi use &#34;); est_destroy c_ctx return null c_ctx p_ctx read_timeout est_err_non est_log_err unabl set ssl read timeout client context &#34;); est_destroy c_ctx return null make sure room anoth entri empty_nod client_ctx_lu_node_t bsearch zero_threadid p_ctx client_ctx_array cur_max_ctx_array sizeof client_ctx_lu_node_t bsearch_compar empty_nod null space alloc new array copi alreadi doubl size current one client_ctx_lu_node_t temp_array cur_max_ctx_array temp_array client_ctx_lu_node_t malloc sizeof client_ctx_lu_node_t cur_max_ctx_array memzero_ temp_array sizeof client_ctx_lu_node_t cur_max_ctx_array memcpy_ temp_array sizeof client_ctx_lu_node_t cur_max_ctx_array p_ctx client_ctx_array sizeof client_ctx_lu_node_t cur_max_ctx_array free p_ctx client_ctx_array p_ctx client_ctx_array temp_array qsort p_ctx client_ctx_array cur_max_ctx_array sizeof client_ctx_lu_node_t bsearch_compar empty_nod client_ctx_lu_node_t bsearch zero_threadid p_ctx client_ctx_array cur_max_ctx_array sizeof client_ctx_lu_node_t bsearch_compar empty_index int empty_nod p_ctx client_ctx_array add array sort proper place p_ctx client_ctx_array empty_index threadid cur_threadid p_ctx client_ctx_array empty_index client_ctx c_ctx qsort p_ctx client_ctx_array cur_max_ctx_array sizeof client_ctx_lu_node_t bsearch_compar els entri found tree return client context pid c_ctx found_nod client_ctx return c_ctx proxy_cleanup invok est_destroy current context proxi mode void proxy_cleanup est_ctx p_ctx int p_ctx client_ctx_array null return cur_max_ctx_array ++) p_ctx client_ctx_array client_ctx est_destroy p_ctx client_ctx_array client_ctx free p_ctx client_ctx_array p_ctx client_ctx_array null routin check result code enrol attempt propag retri messag client need static est_error est_ctx ctx void http_ctx sign request ask client retri futur may occur configur automat enrol send http retri respons client need propag retri respons client est_log_info server request retri propag client )&#34;, ctx retry_after_delay est_err_non ctx http_ctx ctx retry_after_delay return est_err_http_writ return est_err_non routin send pkcs7 encod certif est client via http static est_error void http_ctx unsign char pkcs7 int pkcs7_len char http_hdr est_http_hdr_max int hdrlen send http header snprintf http_hdr est_http_hdr_max est_http_hdr_200 est_http_hdr_eol est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_ct est_http_ct_pkcs7_co est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_c est_http_ce_base64 est_http_hdr_eol hdrlen strnlen_ http_hdr est_http_hdr_max snprintf http_hdr hdrlen est_http_hdr_max est_http_hdr_cl pkcs7_len est_http_hdr_eol est_http_hdr_eol mg_write http_ctx http_hdr strnlen_ http_hdr est_http_hdr_max ))) return est_err_http_writ send sign pkcs7 certif bodi mg_write http_ctx pkcs7 pkcs7_len est_log_err http write error propag pkcs7 &#34;); return est_err_http_writ return est_err_non issu request server obtain cert chain use get cert request client cert chain return server pass back caller respons caller free buffer est_error est_ctx ctx unsign char cacerts_rtn int cacerts_rtn_len est_ctx client_ctx est_error int rcvd_cacerts_len unsign char rcvd_cacert ctx null est_log_err ctx pass __function__ return est_err_no_ctx cacerts_rtn null cacerts_rtn_len null est_log_err ctx pass __function__ return cacerts_rtn null cacerts_rtn_len get client context thread client_ctx get_client_ctx ctx client_ctx est_log_err unabl obtain client context proxi oper &#34;); return est_err_no_ctx client_ctx rcvd_cacerts_len est_err_non est_log_err unabl retriev cert upstream server est_err_num_to_str )); return alloc buffer retriev cert get copi rcvd_cacert malloc rcvd_cacerts_len rcvd_cacert null est_log_err unabl malloc buffer cacert receiv server &#34;); return est_err_malloc client_ctx rcvd_cacert est_err_non est_log_err unabl copi cert upstream server est_err_num_to_str )); free rcvd_cacert return retriev cert normal client interfac caus client back uniniti state case though get pass back downstream client put client context back initi state client_ctx est_client_initi cacerts_rtn rcvd_cacert cacerts_rtn_len rcvd_cacerts_len return est_err_non routin connect est server attempt enrol csr pkcs10 buffer upon success return x509 cert pkcs7 buffer length return cert pkcs7_len pkcs7 buffer alloc caller static est_error est_ctx clnt_ctx buf_mem pkcs10 unsign char pkcs7 int pkcs7_len int reenrol est_error ssl ssl_client connect server est_client_connect clnt_ctx ssl_client est_err_non return send enrol request clnt_ctx ssl_client pkcs10 pkcs7 pkcs7_len reenrol disconnect server clnt_ctx ssl_client return routin connect est server attempt enrol csr pkcs10 buffer upon success return x509 cert pkcs7 buffer length return cert pkcs7_len pkcs7 buffer alloc caller static est_error est_ctx client_ctx char path_seg int path_segment_len est_error path_segment_len strnlen_ path_seg est_store_path_seg client_ctx path_seg path_segment_len est_err_non est_log_err fail store uri path segment .&#34;); return return est_err_non function use server side est proxi respond incom simpl enrol request function similar client api function (), except bypass thing done function proxi sign csr insert tls uniqu instead includ cmc usag extens static est_error est_ctx ctx void http_ctx ssl ssl const char char bodi int body_len char path_seg int reenrol est_error buf_mem pkcs10 unsign char pkcs7 int pkcs7_len int diff x509_req csr null est_ctx client_ctx errno_t safec_rc make sure client sent pkcs10 csr request safec_rc memcmp_ sizeof applic pkcs10 &#34;), applic pkcs10 sizeof applic pkcs10 &#34;), diff safec_rc eok est_log_info memcmp_ error safec_rc diff return authent client switch est_enroll_auth ctx http_ctx ssl path_seg reenrol case est_http_auth case est_srp_auth case est_cert_auth break case est_http_auth_pend return est_err_auth_pend break case est_unauthor default return est_err_auth_fail break pars pkcs10 csr client csr est_server_parse_csr unsign char bodi body_len csr est_log_err unabl pars pkcs10 csr sent client &#34;); return est_err_bad_pkcs10 perform saniti check csr est_server_check_csr csr est_log_err pkcs10 csr sent client fail saniti check &#34;); x509_req_fre csr return est_err_bad_pkcs10 check proof possess challeng password pkcs10 request match tls uniqu est_tls_uid_auth ctx ssl csr x509_req_fre csr est_err_non return bodi point pkcs10 data pass enrol routin need jack buf_mem attach bodi new buf_mem pkcs10 buf_mem_new (); pkcs10 data bodi pkcs10 length body_len pkcs10 max body_len get client context thread client_ctx get_client_ctx ctx client_ctx est_log_err unabl obtain client context proxi oper &#34;); pkcs10 return est_err_no_ctx path_seg path seg valu come downstream client request alreadi valid place ctx use client code path_seg client_ctx path_seg alloc space hold cert expect receiv est server pkcs7 malloc est_ca_max attempt enrol csr client client_ctx pkcs10 pkcs7 pkcs7_len reenrol handl error like occur switch case est_err_auth_fail tri one time digest auth ctx auth_mod auth_digest ctx auth_mod auth_bas ctx auth_mod auth_token est_log_info http auth fail tri digest basic paramet &#34;); client_ctx pkcs10 pkcs7 pkcs7_len reenrol client_ctx http_ctx els est_err_non est_log_warn est enrol fail error code break case client_ctx http_ctx break default est_log_warn initi est enrol request error code break client_ctx auth_mod auth_non prevent open ssl free data pkcs10 cert respons est server let forward back est client pkcs7_len http_ctx pkcs7 pkcs7_len free pkcs7 return function use server side est proxi respond incom cacert request cert respons set local respond local set buffer set issu request upstream server static int est_ctx ctx void http_ctx char path_seg est_error est_err_non est_ctx client_ctx int cacerts_len ctx ca_cert null est_log_info proxi cert set local respond local set cert respons &#34;); return est_handle_cacert ctx ctx ca_cert ctx ca_certs_len http_ctx path_seg )); els get client context thread client_ctx get_client_ctx ctx client_ctx est_log_err unabl obtain client context proxi oper &#34;); return est_err_no_ctx path_seg path seg valu come downstream client request alreadi valid place ctx use client code path_seg client_ctx path_seg est_err_non est_log_err unabl save path segment uri client context &#34;); return invok client code retriev cacert note need authent client see sec est_log_info proxi attempt retriev cert upstream server &#34;); client_ctx cacerts_len upstream request success retriev cert context est_err_non est_log_info proxi cert retriev success server forward est client .&#34;); return est_handle_cacert client_ctx client_ctx retrieved_ca_cert client_ctx http_ctx path_seg )); els someth went wrong upstream request server treat found condit est_log_err proxi server reachabl sent corrupt cert &#34;); return function use server side est proxi respond incom csr attribut request function similar client api function (). static int est_ctx ctx void http_ctx char path_seg int est_err_non int pop_pres char csr_data csr_data_pop int csr_len csr_pop_len est_ctx client_ctx get client context thread client_ctx get_client_ctx ctx client_ctx est_log_err unabl obtain client context proxi oper &#34;); return est_err_no_ctx path_seg path seg valu come downstream client request alreadi valid place ctx use client code path_seg client_ctx path_seg est_err_non est_log_err unabl save path segment uri client context &#34;); return invok client code retriev csr attribut note need authent client see sec est_log_info proxi attempt retriev csr attr upstream server &#34;); client_ctx unsign char **)&amp; csr_data csr_len csr_data point memori alloc hold csr attribut freed call stack prevent doubl free null pointer client context client_ctx retrieved_csrattr null client_ctx est_err_non ctx csr_pop_pres ctx server_enable_pop est_is_challeng password_pres csr_data csr_len pop_pres est_err_non est_log_err error saniti check &#34;); est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non ctx csr_pop_pres pop_pres ctx csr_pop_pres csr_len csr_data malloc est_csrattrs_pop_len csr_data return est_err_malloc strncpy_ csr_data est_csrattrs_pop_len est_csrattrs_pop est_csrattrs_pop_len csr_data est_csrattrs_pop_len csr_len est_csrattrs_pop_len return ctx csr_data csr_len http_ctx )); est_add_challeng password csr_data csr_len csr_data_pop csr_pop_len est_err_non csr_data free csr_data est_log_err error add &#34;); est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non csr_data free csr_data csr_data csr_data_pop csr_len csr_pop_len els est_log_err server reachabl sent corrupt attribut &#34;); est_send_http_error ctx http_ctx est_err_http_no_cont return est_err_non return ctx csr_data csr_len http_ctx )); function call web server layer http request arriv listen port est proxi determin est request type dispatch request appropri handler paramt ctx pointer est_ctx http_ctx context pointer web server method html method request either get post uri pointer http uri bodi pointer full html bodi content body_len length html bodi html content type header est_error est_ctx ctx void http_ctx char method char uri char bodi int body_len const char ssl ssl est_error int diff errno_t safec_rc est_oper oper char path_seg null est_error est_err_non ctx return est_err_no_ctx verifi context proxi client server ctx est_mod est_proxi return est_err_bad_mod est_parse_uri uri oper path_seg est_err_non est_send_http_error ctx http_ctx return see cacert request oper est_op_cacert get allow safec_rc strcmp_s method max_http_method_len get diff safec_rc eok est_log_info strcmp_s error safec_rc diff est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method ctx http_ctx path_seg est_err_non est_send_http_error ctx http_ctx free path_seg path_seg null return see simpl enrol request els oper est_op_simple_enrol post allow safec_rc strcmp_s method max_http_method_len post diff safec_rc eok est_log_info strcmp_s error safec_rc diff est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_log_warn incom http header content type header &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return case bodi indic content pass enrol request cannot correct csr requir continu proxi mode tri forward non exist csr bodi null est_log_warn incom http header csr content &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return get ssl context requir authent client ssl ssl mg_get_conn_ssl http_ctx ssl est_send_http_error ctx http_ctx est_err_no_ssl_ctx free path_seg path_seg null return est_err_no_ssl_ctx ctx http_ctx ssl bodi body_len path_seg est_err_non est_err_auth_pend est_log_warn enrol fail est_err_num_to_str )); est_err_auth_fail est_send_http_error ctx http_ctx est_err_auth_fail els est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return est_err_bad_pkcs10 see enrol request els oper post allow safec_rc strcmp_s method max_http_method_len post diff safec_rc eok est_log_info strcmp_s error safec_rc diff est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method est_log_warn incom http header content type header &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return case bodi indic content pass enrol request cannot correct csr requir continu proxi mode tri forward non exist csr bodi null est_log_warn incom http header csr content &#34;); est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return get ssl context requir authent client ssl ssl mg_get_conn_ssl http_ctx ssl est_send_http_error ctx http_ctx est_err_no_ssl_ctx free path_seg path_seg null return est_err_no_ssl_ctx ctx http_ctx ssl bodi body_len path_seg est_err_non est_err_auth_pend est_log_warn reenrol fail est_err_num_to_str )); est_err_auth_fail est_send_http_error ctx http_ctx est_err_auth_fail els est_send_http_error ctx http_ctx est_err_bad_pkcs10 free path_seg path_seg null return est_err_bad_pkcs10 see keygen request fixm current implement els strncmp uri est_keygen_uri est_uri_max_len post allow safec_rc strcmp_s method max_http_method_len post diff safec_rc eok est_log_info strcmp_s error safec_rc diff est_send_http_error ctx http_ctx est_err_wrong_method return est_err_wrong_method est_log_warn incom http header content type header &#34;); return ctx est_send_http_error ctx http_ctx fixm last param zero return est_err_http_writ fixm need appropri return code endif see csr attribut request els oper est_op_csrattr get allow safec_rc strcmp_s method max_http_method_len get diff safec_rc eok est_log_info strcmp_s error safec_rc diff est_send_http_error ctx http_ctx est_err_wrong_method free path_seg path_seg null return est_err_wrong_method ctx http_ctx path_seg est_err_non est_send_http_error ctx http_ctx free path_seg path_seg null return send 404 error uri match els est_send_http_error ctx http_ctx free path_seg path_seg null return est_err_non /*! brief est_proxy_start use applic start est proxi est_proxy_init est_proxy_set_serv call requir callback function provid applic param ctx pointer est context lib est use http code mongoos http server function allow applic start http servic layer requir est return est_error est_error est_proxy_start est_ctx ctx est_mg_context mgctx ctx est_log_err null context &#34;); return est_err_no_ctx mgctx mg_start ctx mgctx ctx mg_ctx mgctx return est_err_non els return est_err_no_ssl_ctx /*! brief est_proxy_stop use applic stop est proxi call prior est_destroy (). param ctx pointer est context lib est use http code mongoos http server function allow applic stop http servic layer return est_error est_error est_proxy_stop est_ctx ctx est_mg_context mgctx ctx est_log_err null context &#34;); return est_err_no_ctx mgctx est_mg_context ctx mg_ctx mgctx mg_stop mgctx return est_err_non /*! brief est_proxy_init use applic creat context est librari context use invok function api proxi mode param ca_chain char array contain pem encod cert crl entri chain certif use trust anchor establish tls connect param ca_chain_len length ca_chain char array param cacerts_resp_chain char array contain pem encod cert includ cacert respons option paramet set contain chain certif use proxi respond get cert request est client paramet includ proxi obtain certif chain configur upstream est server paramet null correct length buffer must specifi param length cacerts_resp_chain char array param cert_format specifi encod local extern certif chain pem der param http_realm char array contain http realm name http auth param tls_id_cert pointer x509 contain proxi certif tls layer param tls_id_key pointer evp_pkey contain privat key associ proxi certif param uid user use authent server param pwd password use authent server function allow applic initi est server context proxi mode oper use oper applic must provid trust certif use server oper use ca_chain paramet certif set includ explicit trust anchor certif number implicit trust anchor certif intermedi sub certif requir complet chain trust ident certif pass tls_id_cert paramet root certif ident certif certif encod use format specifi cert_format paramet pem may contain crl entri use authent est client connect server applic must also provid http realm use http authent server cerif privat key use tls warn includ addit intermedi sub certif need complet chain trust may result potenti mitm attack return est_ctx est_ctx est_proxy_init unsign char ca_chain int ca_chain_len unsign char cacerts_resp_chain int est_cert_format cert_format char http_realm x509 tls_id_cert evp_pkey tls_id_key char uid char pwd est_ctx ctx int len est_log_vers (); saniti check input ca_chain null est_log_err trust certif set empti &#34;); return null tls_id_cert null est_log_err tls cert empti &#34;); return null tls_id_key null est_log_err tls privat key empti &#34;); return null http_realm null est_log_err est http realm null &#34;); return null cert_format est_cert_format_pem est_log_err pem encod certif support .&#34;); return null verifi length cert chain len int strnlen_ char ca_chain est_ca_max len ca_chain_len est_log_err length ca_chain match ca_chain_len &#34;); return null cacerts_resp_chain len int strnlen_ char cacerts_resp_chain est_ca_max len est_log_err length cacerts_resp_chain match &#34;); return null alloc set proxi base est context context use oper server downstream client est proxi mode basic server function requir client capabl communic upstream server need ctx malloc sizeof est_ctx )); ctx est_log_err malloc fail &#34;); return null memzero_ ctx sizeof est_ctx )); ctx est_mod est_proxi ctx retry_period est_retry_period_def ctx server_enable_pop ctx require_http_auth http_auth_requir ctx server_read_timeout ctx uid pwd est_err_non est_log_err fail store userid password proxi initi &#34;); free ctx return null load certif local memori retain futur use use cacert request cacerts_resp_chain est_load_ca_cert ctx cacerts_resp_chain est_log_err fail load certif respons buffer &#34;); free ctx return null load certif chain x509 store structur use verifi incom cert tls establish also save way raw copi ca_chain buffer use creat client context use communinc upstream server ctx ca_chain ca_chain_len est_log_err fail load trust certif store &#34;); est_destroy ctx return null ctx ca_chain_raw malloc ca_chain_len ctx ca_chain_raw est_log_err malloc fail &#34;); est_destroy ctx return null memcpy_ char ctx ca_chain_raw ca_chain_len char ca_chain ca_chain_len ctx ca_chain_raw ca_chain_len ctx ca_chain_raw_len ca_chain_len strncpy_ ctx realm max_realm http_realm max_realm ctx server_cert tls_id_cert ctx server_priv_key tls_id_key ctx auth_mod auth_bas ctx read_timeout ctx retry_after_delay ctx retry_after_d ctx client_ctx_array client_ctx_lu_node_t malloc sizeof client_ctx_lu_node_t cur_max_ctx_array memzero_ ctx client_ctx_array sizeof client_ctx_lu_node_t cur_max_ctx_array return ctx /*! brief use applic layer configur http authent method use valid ident est client param ctx pointer est proxi context return est_proxy_init (). param amod either auth_bas auth_digest function option invok applic layer chang default http authent mode default mode http basic authent applic may desir use digest authent instead case function use set mode function invok prior start est proxi return est_error est_error est_ctx ctx est_http_auth_mod amod return ctx amod )); /*! brief use applic regist callback function param ctx est context obtain est_proxy_init call param auth_credentials_cb function pointer applic layer callback regist callback function use est client librari obtain authent credenti applic provid authent credenti initi avail userid password use http basic authent process request est client librari call applic callback event authent credenti request est server callback function definit must match follow function prototyp int auth_credentials_cb est_http_auth_hdr auth_credenti auth_credenti pointer est_http_auth_hdr structur structur provid est librari callback function fill specif credenti request credenti valu must pass format sent server est client librari perform reformat credenti ownership memori hold credenti valu transfer applic layer est librari applic layer return valu est librari allow est librari free memori soon done use valu return valu callback must one follow valu callback abl provid request credenti callback could provid request credenti auth_credentials_cb paramet set null reset callback function string paramet null termin string return est_error est_err_non success est_err_no_ctx est_error est_ctx ctx auth_credentials_cb callback return ctx callback )); /*! brief use applic set timeout valu read oper est proxi send request est server attempt read respons server timeout valu limit amount time proxi wait respons param ctx pointer est context param timeout integ valu repres read timeout second minimum valu maximum valu return est_error est_error est_ctx ctx int timeout return ctx timeout )); /*! brief est_proxy_set_serv call applic layer specifi address port est server must call est_proxy_init prior issu est command param ctx pointer est context client session param server name est server connect ascii string repres name server limit 254 charact param port tcp port est server connect return est_error est_err_non success est_err_no_ctx null valu pass est context null valu pass est server name server name string long invalid port number input less zero greater 65535 est_proxy_set_serv error check input paramet store hostnam port number est context est_error est_proxy_set_serv est_ctx ctx const char server int port ctx return est_err_no_ctx server null return strnlen_ server return port port 65535 return strncpy_ ctx est_serv server ctx est_port_num port return est_err_non&#39;,
 &#39;author routin int ossl verifi int store ctx ctx int cert error store ctx get error ctx current cert store ctx get current cert ctx est log info enter function cert error cert error current cert name print stdout _get_subject_nam current_cert xn_flag_onelin printf (&#34;\\ &#34;); est_log_info (&#34;% serror depth lookup ctx crl path &#34;&#34;, cert_error ctx cert_error )); switch cert_error case enabl crl check tls stack applic load crl verifi error occur peer cert valid confirm revok warn applic est_log_warn crl load tls peer allow .&#34;); break case case sinc check certif self sign still warn user case continu extens error case case case case case case case case default est_log_warn certif verifi fail reason )&#34;, cert_error break return return function use load x509_store use raw data buffer data expect pem encod return number cert store static int x509_store store unsign char raw int size stack_of x509_info null x509_info bio int cert_cnt bio_new_mem_buf raw size null est_log_err unabl open raw cert buffer &#34;); return load file stack x509 crl pkey set null null null null est_log_err unabl read pem encod cert bio &#34;); bio_fre return bio_fre scan pull crl sk_x509_info_num sk_x509_info_shift x509 null est_log_info cert store )&#34;, x509 name x509_store_add_cert store x509 cert_cnt ++; crl null est_log_info crl store &#34;); x509_store_add_crl store crl x509_info_fre null sk_x509_info_pop_fre x509_info_fre return cert_cnt function use popul x509_store structur use open ssl tls stack verifi tls peer x509_store alreadi alloc paramet store pointer x509_store structur hold cert raw1 char array contain pem encod cert put store size1 length raw1 char array est_error ossl_init_cert_stor x509_store store unsign char raw1 int size1 x509_store_set_flag store int cnt raw1 cnt store raw1 size1 cnt est_log_err cert count zero store &#34;); return return est_err_non function use output open ssl error buffer use open ssl api call fail like provid detail user regard caus failur void ossl_dump_ssl_error bio null buf_mem bptr null bio_new bio_s_mem ()); est_log_err bio_new fail &#34;); return err_print_error void bio_flush bio_get_mem_ptr bptr est_log_warn ossl error bptr data bio_free_al /*! brief convert base64 encod pkcs7 respons est server pem format param certs_p7 point buffer contain base64 encod pkcs7 data param certs_len indic size certs_p7 buffer param pem doubl pointer receiv pem encod data sever est messag return data contain base64 encod pkcs7 certif function use convert data pem format function alloc memori point pem argument caller respons releas memori return valu length pem buffer error return int int unsign char certs_p7 int certs_len unsign char pem x509 stack_of x509 cert null bio b64 unsign char cacerts_decod null int cacerts_decoded_len bio p7bio_in null pkcs7 null int nid unsign char pem_data int pem_len base64 decod incom cert buffer decod alway take origin buffer b64 bio_new bio_f_base64 ()); b64 est_log_err bio_new fail &#34;); return bio_new_mem_buf certs_p7 certs_len est_log_err bio_new fail &#34;); return bio_push b64 cacerts_decod malloc certs_len cacerts_decod est_log_err malloc fail &#34;); return cacerts_decoded_len bio_read cacerts_decod certs_len bio_free_al get pkcs7 format buffer certif read stack x509 cert p7bio_in bio_new_mem_buf cacerts_decod cacerts_decoded_len p7bio_in est_log_err bio_new fail attempt creat mem bio &#34;); ossl_dump_ssl_error (); free cacerts_decod return d2i_pkcs7_bio p7bio_in null est_log_err pem_read_bio_pkcs7 fail &#34;); ossl_dump_ssl_error (); free cacerts_decod return bio_free_al p7bio_in free cacerts_decod decod cert get refer stack cert nid obj_obj2nid type switch nid case nid_pkcs7_sign cert sign cert break case nid_pkcs7_sign envelop cert signed_and_envelop cert break default est_log_err invalid nid valu pkcs7 structur &#34;); pkcs7_free return break cert est_log_err fail attain x509 cert stack pkcs7 data &#34;); pkcs7_free return output cert new bio use pem format bio_new bio_s_mem ()); est_log_err bio_new fail &#34;); pkcs7_free return sk_x509_num cert ++) sk_x509_valu cert pem_write_bio_x509 bio_put &#34;); void bio_flush convert bio char pem_len int bio_get_mem_data char **)&amp; pem_data pem_len est_log_err bio_get_mem_data fail &#34;); pkcs7_free return pem malloc pem_len (!* pem est_log_err malloc fail &#34;); pkcs7_free return memcpy_ pem pem_len pem_data pem_len pem pem_len make sure null termiant bio_free_al pkcs7_free return pem_len&#39;,
 &#39;static void est log func char list null default logger routin dump log data stderr applic overrid call est init logger pass function pointer function implement prototyp static void est logger stderr char format list ifndef win flockfil stderr endif vfprintf stderr format fflush stderr ifndef win funlockfil stderr endif default logger routin dump log data stderr applic overrid call est init logger pass function pointer function implement prototyp static void est log msg char format list argument pull argument stack invok logger function start argument format est log func null est log func format argument els est logger stderr format argument end argument global function call log someth void est log est log level lvl char format list argument check user interest log messag lvl est desir log lvl return pull argument stack invok logger function start argument format est log func null est log func format argument els est logger stderr format argument end argument global function call log someth static void print stack trace void unsign int void stack unsign short frame symbol info symbol handl process process get current process sym initi process null true frame captur stack back trace stack null symbol symbol info calloc sizeof symbol info sizeof char symbol max name len 255 symbol size struct sizeof symbol_info frame ++) sym addr process dword64 stack ]), symbol est_log_msg (&#34;\\ frame symbol address symbol name free symbol global function call log someth void est_log_backtrac void ifndef disable_backtrac ifdef win32 spit backtrac enabl global est_backtrace_en print stack trace (); els void callstack 128 char strs int frame spit backtrac enabl global est_backtrace_en frame backtrac callstack 128 strs backtrace_symbol callstack frame frame est_log_msg (&#34;\\ strs ]); fprintf stderr strs ]); est_log_msg (&#34;\\ &#34;); free strs endif win32 endif disable_backtrac /*! brief est_get_vers allow applic retriev lib est version string return char array contain full version string valu librari return const char const char est_get_vers void return est_ver_str /*! brief est_get_api_level allow applic retriev lib est api level numer valu indic api level librari new version lib est releas api chang valu increment applic use determin capabl lib est librari attempt return int int est_get_api_level void return est_api_level use log lib est version inform log messag also log compil time run time open ssl version void est_log_vers void est_log_info (&#34;% api level )&#34;, est_get_vers (), est_get_api_level ()); ifdef source_revis est_log_info sourc repositori revis source_revis endif est_log_info compil openssl_version_text est_log_info link ssleay_vers ssleay_vers )); /*! brief est_init_logg allow applic overrid default log handler est log messag param lvl set desir log level est_log_level param loggerfunc set callback function handl log function allow applic use est provid function log est messag est provid default handler send messag stderr applic may desir send messag syslog log facil applic would provid function pointer use method intercept handl est log messag set global librari impact context return est_error est_error est_init_logg est_log_level lvl void loggerfunc char va_list initi logger loggerfunc est_log_func loggerfunc els instal default logger est_log_func est_logger_stderr set desir log level est_desired_log_lvl lvl return est_err_non /*! brief est_enable_backtrac allow applic toggl whether stack trace display warn error log messag come lib est param enabl set zero disabl stack trace non zero enabl stack trace log facil function allow applic enabl stack trace may use troubleshoot lib est librari stack trace disabl default call function non zero argument enabl stack trace warn error log messag set global librari impact context return void void est_enable_backtrac int enabl est_backtrace_en enabl /*! brief helper function read char convert open ssl x509_req char data either pem der encod param csr char contain pem der encod x509 csr param csr_len length csr char der encod data may contain zero requir length provid applic layer param csr_format paramet specifi encod method csr char provid set either est_cert_format_pem est_cert_format_d function convert pem der encod char open ssl x509_req structur function return null pem der data corrupt unabl pars open ssl librari function alloc memori x509_req data must free memori applic longer need call x509_req_fre (). return x509_req x509_req unsign char csr int csr_len est_cert_format csr_format x509_req req null bio unsign long err csr est_log_err csr may null &#34;); return null csr_len est_raw_csr_len_max est_log_err csr length greater maximum allow )&#34;, est_raw_csr_len_max return null csr_format est_cert_format_pem csr_format est_cert_format_d est_log_err pem der encod format support .&#34;); return null bio_new_mem_buf csr csr_len null est_log_err unabl open csr memori buffer &#34;); return null switch csr_format case est_cert_format_pem req null null null break case est_cert_format_d req d2i_x509_req_bio null break default est_log_err invalid csr format specifi .&#34;); break check error pars input data req est_log_err error occur open ssl librari read csr data .&#34;); err err_get_error (); est_log_err open ssl error string err_error_str err null )); bio_free_al return req /*! brief est_load_key helper function read char convert open ssl evp_pkey char data either pem der encod param key char contain pem der encod key pair param key_len length key char der encod data may contain zero requir length provid applic layer param key_format paramet specifi encod method key char provid set either est_format_pem est_format_d function convert pem der encod char open ssl evp_pkey structur function return null pem der data corrupt unabl pars open ssl librari function alloc memori evp_pkey data must free memori applic longer need call evp_pkey_fre (). return evp_pkey evp_pkey est_load_key unsign char key int key_len int format bio null evp_pkey pkey null key null est_log_err key data provid &#34;); return null bio_new_mem_buf key key_len null est_log_err unabl open provid key buffer &#34;); return null switch format case est_format_pem pkey pem_read_bio_priv key null null null break case est_format_d pkey d2i_priv key_bio null break default est_log_err invalid key format &#34;); bio_fre return null break bio_fre return pkey convert pem pkcs7 encod cert option appli base64 encod output use creat cach cacert respons return bio contain pkcs7 encod cert respons option base64 encod pass non zero valu do_base_64 argument caller function invok bio_free_al return valu avoid memori leak note bio_fre suffici static bio est_get_certs_pkcs7 bio int do_base_64 stack_of x509 cert_stack null pkcs7_sign p7s null pkcs7 null bio null bio b64 int buflen creat pkcs7 object pkcs7_new ()) null est_log_err pkcs7_new fail &#34;); goto cleanup creat pkcs7 sign object p7s pkcs7_signed_new ()) null est_log_err pkcs7_signed_new fail &#34;); goto cleanup set version asn1_integer_set p7s version est_log_err asn1_integer_set fail &#34;); goto cleanup creat stack x509 cert cert_stack sk_x509_new_nul ()) null est_log_err stack malloc fail &#34;); goto cleanup popul cert stack cert_stack est_log_err unabl load certif &#34;); ossl_dump_ssl_error (); goto cleanup creat bio receiv output bio_new bio_s_mem ()); est_log_err bio_new fail &#34;); goto cleanup add base64 encod need do_base_64 b64 bio_new bio_f_base64 ()); b64 null est_log_err bio_new fail attempt creat base64 bio &#34;); ossl_dump_ssl_error (); goto cleanup bio_push b64 type obj_nid2obj nid_pkcs7_sign sign p7s p7s content type obj_nid2obj nid_pkcs7_data p7s cert cert_stack convert pem pkcs7 buflen i2d_pkcs7_bio buflen est_log_err pem_write_bio_pkcs7 fail &#34;); ossl_dump_ssl_error (); bio_free_al null goto cleanup void bio_flush cleanup need cleanup free p7s cert_stack alloc sinc link pkcs7_free return take raw char array conta certif read data load certif context pkcs7 cert store est context use respond cacert request requir pkcs7 encod function also load x509 store context use verifi peer est_error est_load_ca_cert est_ctx ctx unsign char raw int size bio cacert null bio unsign char retval server proxi mode may load cacert respons ctx est_mod est_client return est_err_bad_mod bio_new_mem_buf raw size null est_log_err unabl open raw cert buffer &#34;); return est_err_load_cacert convert cert pkcs7 encod char array use est server respond cacert request cacert est_get_certs_pkcs7 cacert est_log_err est_get_certs_pkcs7 fail &#34;); bio_fre return est_err_load_cacert ctx ca_certs_len int bio_get_mem_data cacert char **)&amp; retval ctx ca_certs_len est_log_err fail copi pkcs7 data &#34;); bio_free_al cacert bio_fre return est_err_load_cacert ctx ca_cert malloc ctx ca_certs_len ctx ca_cert est_log_err malloc fail &#34;); bio_free_al cacert bio_fre return est_err_load_cacert memcpy_ ctx ca_cert ctx ca_certs_len retval ctx ca_certs_len bio_free_al cacert bio_fre return est_err_non take char array contain pem encod certif implicit explict cert decod load trusted_certs_stor member est context cert store use tls stack peer verif tls layer note includ defens code check null argument function part public api check alreadi perform est_error est_ctx ctx unsign char cert int certs_len est_error creat combin cert store context contain implicit explicit cert ctx trusted_certs_stor x509_store_new (); ctx trusted_certs_stor null est_log_err unabl alloc combin cert store &#34;); return ctx trusted_certs_stor ossl_verify_cb ossl_init_cert_stor ctx trusted_certs_stor cert certs_len est_err_non est_log_err unabl popul combin cert store &#34;); return return est_err_non /*! brief est_set_ex_data set applic specif data est context param ctx pointer est context param ex_data pointer applic specif data pass est callback return est_error function use link applic specif data est_ctx structur use applic bind applic specif data est oper lib est use applic specif data ex_data pointer pass back applic lib est invok enrol enrol csr attribut http auth callback lib est free memori referenc ex_data paramet est_destroy invok applic respons releas applic specif data est_error est_set_ex_data est_ctx ctx void ex_data ctx return est_err_no_ctx ctx ex_data est_log_warn ex_data alreadi set possibl memori leak &#34;); ctx ex_data ex_data return est_err_non /*! brief est_get_ex_data retriev applic specif data est context param ctx pointer est context return void function use attain refer applic specif data est_ctx structur data set invok est_set_ex_data earlier otherwis return null void est_get_ex_data est_ctx ctx ctx return null return ctx ex_data /*! brief est_destroy free est context param ctx pointer est context return est_error function use releas memori alloc est_ctx call last perform est oper use context est_error est_destroy est_ctx ctx ctx return est_err_no_ctx ctx trusted_certs_stor null x509_store_fre ctx trusted_certs_stor ctx ca_cert free ctx ca_cert ctx retrieved_ca_cert free ctx retrieved_ca_cert ctx retrieved_csrattr free ctx retrieved_csrattr ctx server_csrattr free ctx server_csrattr ctx enrolled_client_cert free ctx enrolled_client_cert ctx ca_chain_raw free ctx ca_chain_raw ctx uri_path_seg free ctx uri_path_seg ctx dh_tmp dh_free ctx dh_tmp free ssl context act client oper server expect web server free context ctx ssl_ctx ctx est_mod est_client )||( ctx est_mod est_proxi ))) ssl session cach mean ssl_get1_sess call need explict freed get ref count decrememnt ctx sess ssl_session_fre ctx sess ssl_ctx_free ctx ssl_ctx ctx est_mod est_proxi proxy_cleanup ctx final free est context free ctx return est_err_non routin use determin whether option need use use open ssl base64 decod take string input check contain newlin charact return open ssl use option return otherwis static int const char src int len int len base64 less byte problem open ssl sinc minimum line length base64 encod return start look newlin 64th posit len ++) src return return routin use decod base64 encod data pass base64 encod data pointer buffer receiv decod data length decod data return return valu zero negat error occur dst_size paramet maximum allow size decod data int est_base64_decod const char src char dst int dst_size bio b64 b64in int len int max_in decod base64 output alway smaller ratio determin max size input base size given output buffer make sure actual input buffer big max_in dst_size get length base64 encod data make sure big len strnlen_ src max_in len max_in est_log_err sourc buffer base64 decod loo larg destin buffer sourc buf len max input len max dest len len max_in dst_size return b64 bio_new bio_f_base64 ()); b64 null est_log_err bio_new fail attempt creat base64 bio &#34;); ossl_dump_ssl_error (); return b64in bio_new_mem_buf char src len b64in null est_log_err bio_new fail attempt creat mem bio &#34;); ossl_dump_ssl_error (); return src len enabl newlin option input data contain newlin charact bad open ssl implicit bio_set_flag b64 b64in bio_push b64 b64in len bio_read b64in dst dst_size len est_log_warn bio_read fail decod base64 data )&#34;, len els make sure respons null termin dst len bio_free_al b64in return len routin use encod base64 data pass unencod data length sourc buffer pointer buffer receiv encod data length encod data return return valu zero error occur max_dest_len paramet maximum allow size encod data int est_base64_encod const char src int actual_src_len char dst int max_dst_len bio b64 bio int max_src_len int actual_dst_len int write_cnt buf_mem bptr null encod base64 output alway larger ratio determin max size input base size given output buffer make sure actual input buffer big max_src_len max_dst_len actual_src_len max_src_len est_log_err sourc buffer base64 encod loo larg destin buffer max sourc len actual_sourc len max_src_len actual_src_len return b64 bio_new bio_f_base64 ()); b64 null est_log_err bio_new fail attempt creat base64 bio &#34;); ossl_dump_ssl_error (); return bio_new bio_s_mem ()); null est_log_err bio_new fail attempt creat mem base bio &#34;); ossl_dump_ssl_error (); bio_free_al b64 return bio_push b64 ever insert new line bio_set_flag write sourc buffer bio get pointer result memori buffer side obtain result write_cnt bio_writ src actual_src_len void bio_flush bio_get_mem_ptr bptr write_cnt est_log_warn bio_writ fail encod base64 data )&#34;, write_cnt els copi result base64 encod string make sure null termin return length memcpy_ dst max_dst_len bptr data bptr length dst bptr length actual_dst_len bptr length bio_free_al b64 return actual_dst_len routin use encod base64 data pass unencod data length sourc buffer pointer buffer receiv encod data length encod data return return valu zero error occur max_dest_len paramet maximum allow size encod data char est_get_tls_uid ssl ssl int is_client char finish max_finish bio bio null b64 null buf_mem bptr null int len char null rfc5929 state first finish messag use deriv tls uniqu session resumpt use server send first finish messag normal client send first finish messag is_client ssl_session_reus ssl is_client ssl_session_reus ssl ))) len int ssl_get_finish ssl finish max_finish els len int ssl_get_peer_finish ssl finish max_finish b64 bio_new bio_f_base64 ()); b64 null est_log_err bio_new fail attempt creat base64 bio &#34;); ossl_dump_ssl_error (); return bio bio_new bio_s_mem ()); bio null est_log_err bio_new fail attempt creat mem base bio &#34;); ossl_dump_ssl_error (); return void bio_flush bio bio bio_push b64 bio bio_writ bio finish len void bio_flush bio bio_get_mem_ptr bio bptr awar open ssl add newlin charact end base64 encod data bptr length est_tls_uid_len est_log_warn tls uid length mismatch )&#34;, bptr length est_tls_uid_len els malloc est_tls_uid_len null est_log_err fail alloc buffer &#34;); return memcpy_ est_tls_uid_len bptr data est_tls_uid_len est_tls_uid_len est_log_info tls uid found &#34;); bio_free_al bio return util function convert hex valu string use http digest authent logic void est_hex_to_str char dst unsign char src int len static const char hex 0123456789abcdef len --; src ++) dst hex src dst hex src 0x0f dst /*! brief est_enable_crl use applic enabl check certif revoc list valid client tls peer certif tls handshak enabl ca_chain paramet provid either est_server_init est_client_init contain trust certif along crl entri crl entri appen end param ctx pointer est context crl check disabl default function must call invok est_server_init est_client_init prior perform est oper therefor disabl version method return est_error est_error est_enable_crl est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx enable_crl return est_err_non est_asn1_sanity_test perform saniti test csr attribut string function oper asn hex string alreadi based64 return est_error presenc challeng password static est_error est_asn1_sanity_test const unsign char string long out_len int pop_pres int tag xclass nid long out_len_sav out_len long len const unsign char ostr string asn1_object a_object int max_len max_csrattr assum challeng password oid present pop_pres make sure long enough asn out_len min_asn1_csrattr return out_len asn1_get_object string len tag xclass out_len est_log_info saniti tag len out_len tag len out_len 0x80 return est_err_bad_asn1_hex switch tag case v_asn1_object a_object c2i_asn1_object null string len a_object null nid obj_obj2nid a_object est_log_info nid nid nid nid_pkcs9_challeng password est_log_info challeng password oid found &#34;); pop_pres signifiy max_len max_csrattrs_withpop asn1_object_fre a_object break default adjust string pointer string len break case v_asn1_set case v_asn1_sequ break out_len out_len_sav string ostr )); out_len return est_err_bad_asn1_hex out_len_sav max_len return return est_err_non est_is_challeng password_pres take base64 encod asn string scan see challeng password includ return est_error presenc challeng password est_error est_is_challeng password_pres const char base64_ptr int b64_len int presenc assum presenc return data base64_ptr null b64_len return est_err_non return base64_ptr b64_len presenc )); base64 decod saniti test given attribut string return est_error presenc challeng password est_error const char int len int pop_pres unsign char der_ptr int der_len check smallest possibl base64 case saniti test check min max valu asn data len min_csrattr return der_ptr malloc len der_ptr return est_err_malloc der_len est_base64_decod char der_ptr len der_len est_log_err invalid base64 encod data &#34;); free der_ptr return est_err_bad_base64 est_asn1_sanity_test der_ptr der_len pop_pres est_err_non est_log_err invalid asn1 encod data )&#34;, est_err_num_to_str )); free der_ptr return free der_ptr return est_err_non est_add_challeng password caller verifi challeng password configur includ add attribut saniti check need sinc est_is_challeng password_pres alreadi call est_error est_add_challeng password const char base64_ptr int b64_len char new_csr int pop_len const unsign char der_ptr char orig_ptr new_der null csrattr int der_len tag xclass new_len long len int enc_len der_ptr malloc b64_len der_ptr return est_err_malloc der_len est_base64_decod base64_ptr char der_ptr b64_len der_len est_log_err malform base64 data &#34;); free void der_ptr return est_err_malloc orig_ptr char der_ptr grab first one pop stuff void asn1_get_object der_ptr len tag xclass der_len tag v_asn1_sequ est_log_err malform asn hex leand sequenc &#34;); free orig_ptr return est_err_bad_asn1_hex len char der_ptr orig_ptr new_len der_len int len sizeof hex_chpw remov lead sequenc length copi new buffer 256 need byte seq header der_len len sizeof hex_chpw 256 new_len new_der malloc new_len new_der free orig_ptr return est_err_malloc memzero_ new_der new_len new_der 0x82 new_der new_len new_der new_len 0xff memcpy_ new_der der_len unsign int len der_ptr der_len unsign int len 256 128 need byte seq header els der_len len sizeof hex_chpw 128 new_len new_der malloc new_len new_der free orig_ptr return est_err_malloc memzero_ new_der new_len new_der 0x81 new_der new_len memcpy_ new_der der_len rsize_t len der_ptr der_len rsize_t len )); els need byte header els new_len new_der malloc new_len new_der free orig_ptr return est_err_malloc memzero_ new_der new_len new_der new_len der_len len memcpy_ new_der der_len rsize_t len der_ptr der_len rsize_t len )); new_der 0x30 memcpy_ new_der new_len sizeof hex_chpw )), sizeof hex_chpw hex_chpw sizeof hex_chpw )); csrattr malloc new_len csrattr free orig_ptr free new_der return est_err_malloc memzero_ csrattr new_len enc_len est_base64_encod const char new_der new_len char csrattr new_len enc_len est_log_err invalid base64 encod data &#34;); free orig_ptr free new_der free csrattr return est_err_bad_base64 new_csr csrattr pop_len int strnlen_ csrattr new_len est_log_info csr reconstitut attribut b64_len pop_len csrattr new_der free new_der orig_ptr free orig_ptr return est_err_non /*! brief add nid charact string x509_req attribut param req x509_req structur use csr request param nid nid attribut param string pointer nid string need param chtype type string use nid return est_error function use add csr attribut csr request est client est_error x509_req req int nid void string int chtype req null return nid return string null return mbstring_asc use today caller could pass valu chtype chtype mbstring_asc req nid chtype unsign char string est_log_warn error attribut &#34;); return est_err_x509_attr return est_err_non /*! brief decod base64 encod string der format asn hex param csrattr pointer base64 encod string param csrattrs_len base64 string length param der_ptr pointer pointer store der encod string param der_len pointer store der string length return est_error function use decod base64 encod csr attribut string der format also perform rang check input paramet est_error char csrattr int csrattrs_len unsign char der int len unsign char der_ptr int der_len return data csrattr null csrattrs_len return der null len null return check smallest possibl base64 case saniti test check min max valu asn data csrattrs_len min_csrattr return der_ptr malloc csrattrs_len der_ptr return est_err_malloc der_len est_base64_decod csrattr char der_ptr csrattrs_len der_len est_log_warn invalid base64 encod data &#34;); free der_ptr return est_err_bad_base64 der der_ptr len der_len return est_err_non /*! brief get attribut nid der encod string param der_ptr pointer pointer der encod string param der_len pointer der encod string length param new_nid pointer storag nid found return est_error function use find next nid der encod string nid found reach end string new_nid return zero est_err_bad_asn1_hex est_error unsign char der_ptr int der_len int new_nid int tag xclass nid int out_len_sav long out_len long len const unsign char string const unsign char ostr asn1_object a_object null der_ptr null return string der_ptr ostr der_ptr der_len null return out_len der_len out_len_sav der_len new_nid null return out_len asn1_get_object string len tag xclass out_len 0x80 return est_err_bad_asn1_hex switch tag case v_asn1_object a_object c2i_asn1_object null string len a_object null nid obj_obj2nid a_object est_log_info nid nid new_nid nid der_len out_len_sav int string ostr )); der_ptr unsign char string asn1_object_fre a_object return est_err_non break default adjust string pointer string len break case v_asn1_set case v_asn1_sequ break out_len out_len_sav string ostr )); return est_err_non walk auth_credenti structur overwrit free valu void est_http_auth_hdr auth_cr auth_cr null return auth_cr user openssl_cleans auth_cr user strnlen_ auth_cr user max_uidpwd )); free auth_cr user auth_cr user null auth_cr pwd openssl_cleans auth_cr pwd strnlen_ auth_cr pwd max_uidpwd )); free auth_cr pwd auth_cr pwd null auth_cr uri openssl_cleans auth_cr uri strnlen_ auth_cr uri est_uri_max_len )); free auth_cr uri auth_cr uri null auth_cr cnonc openssl_cleans auth_cr cnonc strnlen_ auth_cr cnonc max_nonc )); free auth_cr cnonc auth_cr cnonc null auth_cr qop openssl_cleans auth_cr qop strnlen_ auth_cr qop max_qop )); free auth_cr qop auth_cr qop null auth_cr openssl_cleans auth_cr strnlen_ auth_cr max_nc )); free auth_cr auth_cr null auth_cr nonc openssl_cleans auth_cr nonc strnlen_ auth_cr nonc max_nonc )); free auth_cr nonc auth_cr nonc null auth_cr respons openssl_cleans auth_cr respons strnlen_ auth_cr respons max_respons )); free auth_cr respons auth_cr respons null auth_cr auth_token openssl_cleans auth_cr auth_token strnlen_ auth_cr auth_token max_auth_token_len )); free auth_cr auth_token auth_cr auth_token null return given input string look four valid oper est_oper est_parse_oper char op_path est_oper oper est_strcasecmp_ op_path est_get_cacert oper est_op_cacert els est_strcasecmp_ op_path est_get_csrattr oper est_op_csrattr els est_strcasecmp_ op_path est_simple_enrol oper est_op_simple_enrol els est_strcasecmp_ op_path est_simple_reenrol oper els oper est_op_max return oper given input string look four valid oper est_error est_parse_uri char uri est_oper oper char path_seg char path_seg_end int path_seg_len uri parser state state uri uri parsed_uri est_error est_err_non int uriparse_rc errno_t safec_rc int diff path_seg null state uri parsed_uri uriparse_rc uri pars uri state uri uriparse_rc uri_success uri free uri member state uri return parsed_uri path head valid uri pars path prefix (/. well known est look see path segment extens determin oper uri path segment cur_seg parsed_uri path head char cur_seg_str char cur_seg text first int cur_seg_len char segment null safec_rc memcmp_ cur_seg_str well known diff diff safec_rc eok est_log_err uri path start safec_rc well_known_seg safec_rc uri free uri member state uri return cur_seg cur_seg next cur_seg_str char cur_seg text first safec_rc memcmp_ cur_seg_str est_segment_len est est_segment_len diff diff safec_rc eok est_log_err uri contain segment est_seg safec_rc uri free uri member state uri return next segment either segment extens oper cur_seg cur_seg next cur_seg_str char cur_seg text first anoth segment one use find end els walk one length cur_seg text last cur_seg_len char cur_seg text last cur_seg_str els cur_seg_len strnlen_ cur_seg_str cur_seg_len est_log_err path segment exceed maximum uri free uri member state uri return see current segment need put string cur_seg text last null cur_seg text last segment strndup cur_seg_str cur_seg_len els segment strndup cur_seg_str look see oper path come next cacert csrattr simpleenrol simplereenrol oper est_parse_oper segment oper est_op_max one known oper must path segment pars find end path segment determin length save away path_seg_end char cur_seg text last path_seg_end null path_seg_len path_seg_end cur_seg_str path_seg malloc cur_seg_len path_seg null free segment uri free uri member state uri return est_err_malloc safec_rc memcpy_ path_seg cur_seg_len segment cur_seg_len safec_rc eok est_log_err uri path seg could copi context &#34;); free segment free path_seg path_seg null uri free uri member state uri return *((* path_seg cur_seg_len path segment pars tri oper jump path segment next cur_seg_str cur_seg_str cur_seg_len oper est_parse_oper cur_seg_str oper est_op_max oper code suppos next free segment free path_seg path_seg null uri free uri member state uri return est_err_http_bad_req els one oper make sure end cur_seg text last null cur_seg text last est_log_err invalid path segment contain oper valu &#34;); free segment free path_seg path_seg null oper est_op_max uri free uri member state uri return free segment uri free uri member state uri return given input string look four valid oper est_error est_parse_uri char uri est_oper oper char path_seg est_error est_err_non path_seg null assum uri point well known est oper strncmp uri est_cacerts_uri est_uri_max_len oper est_op_cacert els strncmp uri est_uri_max_len oper est_op_simple_enrol els strncmp uri est_re_enroll_uri est_uri_max_len oper els strncmp uri est_csr_attrs_uri est_uri_max_len oper est_op_csrattr els oper est_op_max return store path segment context est_error est_store_path_seg est_ctx ctx char path_seg int path_segment_len reset might alreadi cach ctx uri_path_seg free ctx uri_path_seg ctx uri_path_seg null ctx uri_path_seg malloc strnlen_ path_seg path_segment_len ctx uri_path_seg null return est_err_malloc eok strncpy_ ctx uri_path_seg path_segment_len path_seg path_segment_len return ctx uri_path_seg path_segment_len return est_err_non store path segment context int est_strcasecmp_ char char errno_t safec_rc int diff safec_rc strcasecmp_ strnlen_ rsize_max_str diff safec_rc eok log encount safe error est_log_info strcasecmp_ error safec_rc return diff&#39;,
 &#39;sign long sign int int curlx sltosi long slnum ifdef intel compil pragma warn push pragma warn disabl convers may lose signific bit endif assert slnum sizeof int curl sizeof long assert unsign long slnum unsign long curl mask sint endif return int slnum long curl mask sint ifdef intel compil pragma warn pop endif parsed return parsed fine convers parsed fail fail convert parsed later time overflow far end time parsed sooner time underflow low end time static int parsed const char date time output return day monday sunday static int checkday const char check size len int const char const int found len weekday els curl wkday est client curl raw equal check found break return found return day monday sunday static int checkmonth const char check int const char const int found curl month est client curl raw equal check found break return found return offset real offset return time zone offset gmt input one number second timezon found legal static int checktz const char check unsign int const struct tzinfo int found sizeof sizeof ]); ++) check name found break ++; return found offset return time zone offset gmt input one number second timezon found legal static void skip_over_whit const char date skip everyth letter digit (** date isalnum (** date date )++; struct time sinc epoch gmt time zone similar standard mktime function gmt suffer various bug portabl problem system implement static time_t my_timegm struct my_tm static const int month_days_cumul 120 151 181 212 243 273 304 334 int month year leap_day tm_year support year 1970 caus function return negat valu return year tm_year 1900 month tm_mon month year month month month els month year month month month leap_day year tm_mon leap_day leap_day leap_day 100 leap_day 400 1969 1969 100 1969 400 )); return (((( time_t year 1970 365 leap_day month_days_cumul month tm_mday tm_hour tm_min tm_sec parsed return parsedate_ok fine convers parsedate_fail fail convert parsedate_lat time overflow far end time_t parsedate_soon time underflow low end time_t static int parsed const char date time_t output time_t int wdaynum day week number mon sun int monnum month year number int mdaynum day month int hournum int minnum int secnum int yearnum int tzoff struct my_tm enum assum dignext date_mday const char indat date save origin pointer int part max part date part int found skip_over_whit date isalpha date name come char buf ]=&#34;&#34;; size_t len sscanf date ]&#34;, buf len strnlen_ buf wdaynum wdaynum checkday buf len wdaynum found found monnum monnum checkmonth buf monnum found found tzoff must time zone string tzoff checktz buf tzoff found found return parsedate_fail bad string date len els isdigit date digit int val char end secnum sscanf date 02d 02d 02d hournum minnum secnum ))) time stamp date els secnum sscanf date 02d 02d hournum minnum ))) time stamp without second date secnum els long lval int error int old_errno old_errno errno set_errno lval strtol date end error errno error old_errno set_errno old_errno error return parsedate_fail lval long int_max lval long int_min return parsedate_fail val curlx_sltosi lval tzoff end date val 1400 indat date date date -\&#39;))) four digit valu less equal 1400 take account sort funni time zone diff preced plus minus time zone indic 1400 pick sinc 1300 frequent use 1400 mention edg number document iso 200x propos timezon function http :// david tribbl com text c0xtimezon html anyon authorit sourc exact maximum time zone offset pleas speak found tzoff val 100 val 100 prefix indic local time compar gmt need ther revers math get want tzoff date ]==\&#39;+\&#39;?- tzoff tzoff ((( end date yearnum monnum mdaynum digit year month day yet yyyymmdd found yearnum val 10000 monnum val 10000 100 month mdaynum val 100 found dignext date_mday mdaynum val val mdaynum val found dignext date_year found dignext date_year yearnum yearnum val found yearnum 1900 yearnum yearnum 1900 els yearnum 2000 mdaynum dignext date_mday found return parsedate_fail date end part ++; secnum secnum minnum hournum time make zero ((- mdaynum monnum yearnum lack vital info fail return parsedate_fail sizeof_time_t bit time_t hold date begin 2038 yearnum 2037 output 0x7fffffff return parsedate_lat endif yearnum 1970 output return parsedate_soon mdaynum monnum hournum minnum secnum return parsedate_fail clear illeg date tm_sec secnum tm_min minnum tm_hour hournum tm_mday mdaynum tm_mon monnum tm_year yearnum 1900 my_timegm return time_t time_t often bit even mani architectur featur bit long system bit time_t deal year beyond 2038 howev even system bit time_t mktime return date beyond utc januari 2038 aix 5100 my_timegm time zone adjust cast int compar negat one int add time zone diff local time zone gmt long delta long tzoff !=- tzoff delta delta return time_t overflow delta output return parsedate_ok find next field --------------- find next rfc822 token string entri pstr point string contain word separ white white space &#34;,&#34; &#34;;&#34; &#34;=&#34;. word option quot use &lt;&#34;&gt; &#34;&lt;&#34; &#34;&gt;&#34; comment surrround filter exit pstr move first delimit past field string mutil termin return pointer first word null error static char htnext field char pstr char char start null pstr pstr return null pstr strip white space delimit isspac int =\&#39;)) ++; (!* pstr return null field &#34;\&#39;) quot field start &#34;\&#39;; ++) ++; skip escap char break kr95 need stop els &lt;\&#39;) quot field start &gt;\&#39;; ++) ++; skip escap char break kr95 need stop els (\&#39;) comment )\&#39;; ++) ++; skip escap char ++; els spool field start isspac int =\&#39;) ++; break got pstr return start function pars authent token server server request http digest authent token requir generat valid authent respons futur http request static est_error est_ctx ctx char hdr int est_err_non char hdr char token null char valu null int diff errno_t safec_rc header come basic digest field still front skip token htnext field token htnext field ))) est_strcasecmp_ token realm &#34;)) valu htnext field ))) eok strncpy_ ctx realm max_realm valu max_realm els els est_strcasecmp_ token nonc &#34;)) valu htnext field ))) eok strncpy_ ctx s_nonc max_nonc valu max_nonc els els est_strcasecmp_ token qop &#34;)) valu htnext field ))) valu est_log_warn unsupport qop valu valu els safec_rc memcmp_ valu sizeof auth &#34;), auth sizeof auth &#34;), diff safec_rc eok est_log_info memcmp_ error safec_rc diff safec_rc eok est_log_warn unsupport qop valu valu els els est_strcasecmp_ token algorithm &#34;)) valu htnext field est_strcasecmp_ valu md5 &#34;)) est_log_err unsupport digest algorithm valu support md5 moment els est_strcasecmp_ token error &#34;)) valu htnext field ))) eok strncpy_ ctx token_error max_token_error valu max_token_error els els est_strcasecmp_ token error_descript &#34;)) valu htnext field ))) eok strncpy_ ctx token_error_desc max_token_error_desc valu max_token_error_desc els els est_log_warn unsupport auth token ignor token memzero_ ctx s_nonc max_nonc break return function pars authent token server server request http digest authent token requir generat valid authent respons futur http request static http_header parse_http_head unsign char buf int num_head int http_header hdrs char hdr_end errno_t safec_rc num_head hdrs malloc sizeof http_header max_head hdrs est_log_err malloc failur &#34;); return null find offset header delimint safec_rc strstr_s char buf strnlen_ char buf rsize_max_str hdr_end safec_rc eok est_log_info strstr_s error safec_rc skip first line skip char **) buf &#34;); max_head ++) hdrs name skip_quot char **) buf &#34;:&#34;, hdrs valu skip char **) buf &#34;); fflush stdout est_log_info found http header hdrs name hdrs valu fflush stdout hdrs name break num_head ((* buf unsign char hdr_end break est_log_info found http header num_head return hdrs function pars http status code first header hand code handl est full http stack unrecogn code result error note http expect static int unsign char buf strncmp const char buf est_http_hdr_200 strnlen_ est_http_hdr_200 est_http_hdr_max ))) return 200 els strncmp const char buf est_http_hdr_202 strnlen_ est_http_hdr_202 est_http_hdr_max ))) return 202 els strncmp const char buf est_http_hdr_204 strnlen_ est_http_hdr_204 est_http_hdr_max ))) return 204 els strncmp const char buf est_http_hdr_400 strnlen_ est_http_hdr_400 est_http_hdr_max ))) return 400 els strncmp const char buf est_http_hdr_401 strnlen_ est_http_hdr_401 est_http_hdr_max ))) return 401 els strncmp const char buf est_http_hdr_404 strnlen_ est_http_hdr_404 est_http_hdr_max ))) return 404 els strncmp const char buf est_http_hdr_423 strnlen_ est_http_hdr_423 est_http_hdr_max ))) return 423 els est_log_err unhandl http respons buf return function search process www authent header server result set auth_mod valu context www authent header valu header invalid set auth_mod failur set multipl authent header first one process static void est_ctx ctx http_header hdrs int hdr_cnt int est_error int auth_found walk header look www authent process first one erron second one includ ignor hdr_cnt ++) strncmp hdrs name est_http_hdr_auth auth_found strncmp hdrs valu basic ctx auth_mod auth_bas pars realm ctx hdrs valu est_err_non ctx auth_mod auth_fail els strncmp hdrs valu digest ctx auth_mod auth_digest pars realm nonc ctx hdrs valu est_err_non ctx auth_mod auth_fail els strncmp hdrs valu bearer ctx auth_mod auth_token pars realm possibl token error field ctx hdrs valu est_err_non ctx auth_mod auth_fail els est_log_err unsupport www authent method &#34;); ctx auth_mod auth_fail break auth_found est_log_err www authent header found &#34;); ctx auth_mod auth_fail return function take list header server respons walk header look retri respons header one found valu pars save away est context valu one two format repres ascii string first format count number second client wait retri request second format time date stamp point time client retri request result function set retry_aft valu context retri header receiv receiv could pars valu zero otherwis set valu receiv note est client current support time date format respons process respons format static est_error est_ctx ctx http_header hdrs int hdr_cnt est_error int int cmp_result diff int long long int temp_ll int found initi assum retri header ctx retry_after_delay ctx retry_after_d hdr_cnt ++) cmp_result strcasecmp_ hdrs name sizeof diff cmp_result eok diff est_log_info retri valu hdrs valu found determin whether valu date time string integ repres number second client must wait isalpha (*( char hdrs valu ifdef int convert date time string time_t parsed hdrs valu ctx retry_after_d parsedate_ok est_log_err retri valu could pars &#34;); els format current support est_log_err retri valu correct format &#34;); endif els make sure digit make sure larger four byte integ cach away valu return retri delay strisdigit_ hdrs valu max decim place temp_ll atol hdrs valu temp_ll int_max ctx retry_after_delay int temp_ll els est_log_err retri valu larg &#34;); els est_log_err retri valu could pars &#34;); found est_log_err retri header miss &#34;); return function verifi content type header also return length content header content type import exampl content type expect pkcs7 simpl enrol static int http_header hdrs int hdr_cnt est_oper int int int content_type_pres content_length_pres int cmp_result travers http header process one need check hdr_cnt ++) content type memcmp_ hdrs name sizeof est_http_hdr_ct est_http_hdr_ct sizeof est_http_hdr_ct cmp_result cmp_result content_type_pres verifi content pkcs7 data memcmp_ hdrs valu strnlen_ est_op_map content_typ est_op_map length est_op_map content_typ strnlen_ est_op_map content_typ est_op_map length cmp_result cmp_result est_log_err http content type hdrs valu return els content length memcmp_ hdrs name sizeof est_http_hdr_cl est_http_hdr_cl sizeof est_http_hdr_cl cmp_result cmp_result content_length_pres atoi hdrs valu make sure necessari header present content_type_pres est_log_err miss http content type header &#34;); return els content_length_pres est_log_err miss http content length header &#34;); return return function verifi content type header also return length content header content type import exampl content type expect pkcs7 simpl enrol static int est_ssl_read ssl ssl unsign char buf int buf_max int sock_read_timeout int timeout int read_fd int struct pollfd pfd load timev struct pass select timeout sock_read_timeout 1000 read_fd ssl_get_fd ssl pfd read_fd pfd event pollin pfd revent errno poll pfd timeout est_log_err socket poll timeout data receiv server .&#34;); return els est_log_err socket read failur errno errno return els return ssl_read ssl buf buf_max )); function extract data ssl context put buffer static int est_io_read_raw ssl ssl unsign char buf int buf_max int read_cnt int sock_read_timeout int cur_cnt char peek_read_buf read_cnt cur_cnt est_ssl_read ssl buf buf_max sock_read_timeout cur_cnt est_log_err tls read error &#34;); ossl_dump_ssl_error (); return est_err_ssl_read read_cnt cur_cnt multipl call ssl_read may requir get full http payload cur_cnt read_cnt buf_max cur_cnt est_ssl_read ssl buf read_cnt buf_max read_cnt sock_read_timeout cur_cnt est_log_err tls read error &#34;); ossl_dump_ssl_error (); return est_err_ssl_read read_cnt cur_cnt ((* read_cnt buf_max ssl_peek ssl peek_read_buf est_log_err buffer small receiv messag &#34;); return return est_err_non function provid primari entri point modul use est client read http respons server data read ssl context http pars invok est_err_non return raw_buf buffer must freed caller otherwis freed est_error est_io_get_respons est_ctx ctx ssl ssl est_oper unsign char buf int payload_len int est_err_non http_header hdrs int hdr_cnt int http_status unsign char raw_buf payload_buf payload int raw_len raw_buf malloc est_ca_max raw_buf null est_log_err unabl alloc memori &#34;); return est_err_malloc memzero_ raw_buf est_ca_max payload raw_buf read raw data ssl connect est_io_read_raw ssl raw_buf est_ca_max raw_len ctx read_timeout est_err_non est_log_info valid respons process &#34;); free raw_buf return raw_len est_log_warn receiv empti http respons server &#34;); free raw_buf return est_log_info read byte http data raw_len pars http header get status look status 200 success http_status raw_buf ctx last_http_status http_status hdrs parse_http_head payload hdr_cnt est_log_info http status receiv http_status check status header first see server accept request switch http_status case 200 server report noth break case 204 case 404 est_log_err server respond 204 404 content found &#34;); est_op_csrattr est_err_non els http_status 404 els est_err_unknown break case 202 server ask retri est_log_info est server respond retri &#34;); ctx hdrs hdr_cnt break case 400 est_log_err http respons est server bad request &#34;); est_err_http_bad_req break case 401 server request user auth credenti est_log_info est server request user authent &#34;); check alreadi tri authent bail first time auth_mod set none ctx auth_mod auth_digest ctx auth_mod auth_bas ctx auth_mod auth_token ctx auth_mod auth_fail est_err_auth_fail break ctx hdrs hdr_cnt est_err_auth_fail break case 423 est_log_err server respond 423 content attempt access lock &#34;); est_err_http_lock break case unsupport http respons est_log_err unsupport http respons est server )&#34;, http_status est_err_unknown break default http respons given want handl est_log_err http respons est server http_status break est_err_non get content type content length header verifi http respons contain correct amount data payload_len hdrs hdr_cnt est_log_info http content len payload_len payload_len est_ca_max est_log_err content length larger maximum valu .&#34;, est_ca_max est_err_unknown payload_len buf null els payload_len payload_len buf null els alloc buffer hold payload pass back payload_buf malloc payload_len payload_buf est_log_err unabl alloc memori &#34;); free raw_buf free hdrs return est_err_malloc memcpy_ payload_buf payload_len payload payload_len buf payload_buf raw_buf free raw_buf hdrs free hdrs return&#39;,
 &#39;util function set certif privat key use ssl context return success int est client set cert key ssl ctx ctx cert evp pkey key ssl ctx use certif ctx cert est log err error set certif ossl dump ssl error return ssl ctx use privat key ctx key est log err unabl set privat key ossl dump ssl error return verifi key match cert ssl ctx check privat key ctx est log err privat key match certif public key ossl dump ssl error return return sign certif request use digest key pass return open ssl error code req sign ctx static int est client req sign req evp pkey pkey const evp int evp pkey ctx pkctx null evp ctx mctx evp ctx init mctx evp digest sign init mctx pkctx null pkey return encod use der asn set modifi flag req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req info enc modifi req sign ctx mctx evp ctx cleanup mctx return popul request build request buffer call open ssl insert field header paramet req pointer buffer hold x509 request header pkey public key place x509 request common name place x509 request challeng password place x509 header return valu est_err_non success static est_error est_ctx ctx x509_req req evp_pkey pkey char char x509_name subj setup version number x509_req_set_vers req est_log_err unabl set x509 version &#34;); ossl_dump_ssl_error (); return est_err_x509_v add common name entri subj req subj mbstring_asc unsign char est_log_err unabl set x509 common name &#34;); ossl_dump_ssl_error (); return est_err_x509_cn add challeng password attribut requir need remov add attribut part simpl enrol flow ctx csr_pop_requir ctx client_force_pop est_log_info client includ challeng password csr &#34;); req nid_pkcs9_challeng password mbstring_asc unsign char est_log_err unabl set x509 challeng password attribut &#34;); ossl_dump_ssl_error (); return est_err_x509_attr set public key request x509_req_set_pubkey req pkey est_log_err unabl set public key &#34;); ossl_dump_ssl_error (); return est_err_x509_pubkey return est_err_non function generat pkcs10 request paramet common name put certif tls uniqu ssl session becom challeng password pkey privat key use sign request return valu est_err_non success static est_error est_generate_pkcs10 est_ctx ctx char char evp_pkey pkey x509_req pkcs10 x509_req req null est_error int ossl_rv req x509_req_new (); req null est_log_err unabl alloc x509_req &#34;); ossl_dump_ssl_error (); return est_err_malloc ctx req pkey est_err_non x509_req_fre req return sign request ossl_rv req pkey ctx signing_digest ossl_rv est_log_err unabl sign x509 cert request &#34;); x509_req_fre req ossl_dump_ssl_error (); return est_err_x509_sign pkcs10 req return est_err_non function callback use open ssl verify_cert function call end cert verif allow opportun gather inform regard fail cert verif possibl chang result verif callback similar ossl routin alter verif result static int int x509_store_ctx ctx int cert_error ctx x509 current_cert ctx est_log_info enter function cert_error cert_error current_cert stdout x509_get_subject_nam current_cert xn_flag_onelin printf (&#34;\\ &#34;); est_log_info (&#34;% error depth lookup ctx crl path &#34;&#34;, cert_error ctx cert_error )); return function remov crls receiv cacert respons buffer paramet ctx est context repres session cacert pointer buffer hold result cert cacerts_len length cacert buffer pointer pkcs7 buffer receiv return valu est_err_non success static est_error est_ctx ctx unsign char cacert int cacerts_len pkcs7 int nid int crls_found bio b64_enc null bio p7bio_out null int new_cacerts_len char new_cacerts_buf null int count nid obj_obj2nid type switch nid case nid_pkcs7_sign sign crl sk_x509_crl_pop_fre sign crl x509_crl_free sign crl null crls_found break case nid_pkcs7_sign envelop signed_and_envelop crl sk_x509_crl_pop_fre signed_and_envelop crl x509_crl_free sign crl null crls_found break default est_log_err invalid nid valu pkcs7 structur &#34;); return est_err_cacert_verif break crls remov origin pkcs7 buffer need updat alway base64 encod alloc bio write pkcs7 struct back pem format get pointer length new base64 pem encod buffer copi origin buffer pass sinc crls remov new buffer alway shorter fit origin buffer crls_found est_log_info crl attach certif remov crl )&#34;); b64_enc bio_new bio_f_base64 ()); b64_enc null est_log_err bio_new fail &#34;); ossl_dump_ssl_error (); return est_err_malloc p7bio_out bio_new bio_s_mem ()); p7bio_out null est_log_err unabl access cert buffer &#34;); ossl_dump_ssl_error (); return est_err_malloc p7bio_out bio_push b64_enc p7bio_out memzero_ cacert cacerts_len count i2d_pkcs7_bio p7bio_out count est_log_err pem_write_bio_pkcs7 fail &#34;); ossl_dump_ssl_error (); bio_free_al p7bio_out return est_err_cacert_verif void bio_flush p7bio_out bio_get_mem_data return pointer length data contain mem bio noth alloc pass back new_cacerts_len int bio_get_mem_data p7bio_out char **)&amp; new_cacerts_buf new_cacerts_len est_log_err fail copi pkcs7 data &#34;); ossl_dump_ssl_error (); bio_free_al p7bio_out return est_err_cacert_verif copi new buffer back old buffer memcpy_ cacert cacerts_len new_cacerts_buf new_cacerts_len cacerts_len new_cacerts_len bio_free_al p7bio_out return est_err_non function decod pass base64 encod buffer return decod cacert return est_err_non caller respons free cacerts_decod buffer static est_error b64_decode_cacert unsign char cacert int cacerts_len unsign char cacerts_decod int cacerts_decoded_len bio null bio b64 null unsign char decoded_buf int decoded_buf_len cacerts_decod null cacerts_decoded_len b64 bio_new bio_f_base64 ()); b64 null est_log_err bio_new fail &#34;); ossl_dump_ssl_error (); return est_err_malloc decod alway take less origin buffer bio_new_mem_buf cacert cacerts_len null est_log_err unabl access cert buffer &#34;); ossl_dump_ssl_error (); bio_free_al b64 return est_err_malloc bio_push b64 decoded_buf malloc cacerts_len decoded_buf null est_log_err unabl alloc cert buffer decod &#34;); bio_free_al return est_err_malloc decoded_buf_len bio_read decoded_buf cacerts_len cacerts_decod decoded_buf cacerts_decoded_len decoded_buf_len bio_free_al return est_err_non return est_err_non caller respons free pkcs7 struct static est_error create_pkcs7 unsign char cacerts_decod int cacerts_decoded_len pkcs7 pkcs7out bio p7bio_in null pkcs7 pkcs7 null get pkcs7 format buffer certif read stack x509 cert p7bio_in bio_new_mem_buf cacerts_decod cacerts_decoded_len p7bio_in null est_log_err unabl access pkcs7 buffer &#34;); ossl_dump_ssl_error (); return est_err_malloc pkcs7 d2i_pkcs7_bio p7bio_in null pkcs7 null est_log_err unabl read pkcs7 base certif buffer &#34;); ossl_dump_ssl_error (); bio_free_al p7bio_in return est_err_load_cacert bio_free_al p7bio_in pkcs7out pkcs7 return est_err_non function invok cacert respons receiv cert chain built cert store certif verifi store essenti verifi cert chain ensur intermedi verifi back one includ root cert cacert respons crls attach remov new pkcs7 buffer creat paramet ctx est context repres session cacert pointer buffer hold receiv cert cacerts_len length cacert buffer return valu est_err_non success static est_error verify_cacert_resp est_ctx ctx unsign char cacert int cacerts_len int int fail est_error est_rc est_err_non x509_store trusted_cacerts_stor null stack_of x509 stack null x509 current_cert null int unsign char cacerts_decod null int cacerts_decoded_len x509_store_ctx store_ctx null pkcs7 pkcs7 null ctx null cacert null cacerts_len est_log_err invalid paramet ctx cacert cacerts_len ctx cacert cacerts_len return base64 decod incom cert buffer convert pkcs7 structur extract stack cert b64_decode_cacert cacert cacerts_len cacerts_decod cacerts_decoded_len est_err_non est_log_err base64 decod receiv cert fail &#34;); return create_pkcs7 cacerts_decod cacerts_decoded_len pkcs7 est_err_non est_log_err fail build pkcs7 structur receievd buffer &#34;); free cacerts_decod return pkcs7_to_stack pkcs7 stack est_err_non est_log_err could obtain stack cert pkcs7 structur &#34;); free cacerts_decod pkcs7_free pkcs7 return point stack x509 cert make cert respons sent est server build store trust cert use verifi walk cert verifi build store context store cert verifi call verifi function trusted_cacerts_stor x509_store_new (); trusted_cacerts_stor null est_log_err unabl alloc cert store &#34;); ossl_dump_ssl_error (); free cacerts_decod pkcs7_free pkcs7 return est_err_malloc trusted_cacerts_stor sk_x509_num stack ++) current_cert sk_x509_valu stack self sign add trust store otherwis add untrust store x509_check_issu current_cert current_cert x509_v_ok est_log_info cert trust store )&#34;, current_cert name x509_store_add_cert trusted_cacerts_stor current_cert set x509 store context store_ctx x509_store_ctx_new (); store_ctx null est_log_err unabl alloc new store context &#34;); ossl_dump_ssl_error (); free cacerts_decod pkcs7_free pkcs7 x509_store_fre trusted_cacerts_stor return est_err_malloc sk_x509_num stack ++) x509_store_ctx_init store_ctx trusted_cacerts_stor null stack est_log_err unabl initi new store context &#34;); ossl_dump_ssl_error (); free cacerts_decod pkcs7_free pkcs7 x509_store_fre trusted_cacerts_stor x509_store_ctx_fre store_ctx return est_err_malloc current_cert sk_x509_valu stack est_log_info cert store )&#34;, current_cert name store_ctx current_cert x509_verify_cert store_ctx cert fail verif log continu est_log_warn certif fail verif )&#34;, current_cert name fail final remov crls might attach est_rc ctx cacert cacerts_len pkcs7 free cacerts_decod x509_store_fre trusted_cacerts_stor x509_store_ctx_fre store_ctx pkcs7_free pkcs7 fail return est_err_cacert_verif els return est_rc function regist ssl call verif certif server ident cert chain main purpos look case cert could verifi case est client app regist callback receiv untrust cert forward est client applic paramet status certif ssl verifi code x_ctx ptr x509 certif store structur return valu int potenti modifi status process certif cane modifi client applic provid callback allow process modifi callback static int cert_verify_cb int x509_store_ctx x_ctx ssl ssl est_ctx e_ctx int approv int cert_error x509 current_cert null approv x_ctx null est_log_err invalid x509 context pointer &#34;); return approv cert_error x_ctx current_cert x_ctx est_log_info enter cert pass open ssl error cert_error cert_error )); retriev pointer ssl structur connect applic specif data store ssl object est ctx est session est_log_err invalid ssl exdata index est context valu &#34;); return approv ssl x_ctx ()); ssl est_log_err null pointer retriev ssl session pointer x509 ctx ex_data &#34;); return approv e_ctx ssl_get_ex_data ssl e_ctx est_log_err null pointer retriev est context ssl ex_data &#34;); return approv switch cert_error case notifi client applic cert_untrust expect get case cannot verifi server cert current result server cannot verifi cert unable_to_get_crl pass make sure applic know although case case case applic provid callback ahead pass cert store log warn return ssl gave status e_ctx est_log_info est client applic server cert verifi function regist &#34;); approv e_ctx current_cert cert_error els est_log_info est client applic server cert verifi function regist &#34;); cert_error enabl crl check tls stack applic load crl verifi error occur peer cert valid confirm revok app provid way notifi option log warn proceed est_log_warn crl load tls peer allow .&#34;); approv break remaind result state remain unchang est log warn messag log case case sinc check certif self sign still warn user case continu extens error case case case case case case case case default est_log_warn certif verifi fail reason )&#34;, cert_error cert_error )); break return approv function use creat initi ssl_ctx use client proxi est oper ssl_ctx store est_ctx paramet ctx est context return valu est_error est_err_non success static est_error est_ctx ctx ssl_ctx s_ctx x509_verify_param vpm null est_error est_err_non est_log_vers (); ctx null est_log_err invalid context pointer &#34;); return est_err_no_ctx s_ctx ssl_ctx_new sslv23_client_method ())) null est_log_err fail obtain new ssl context &#34;); ossl_dump_ssl_error (); return est_err_ssl_ctx_new tls use est ssl_ctx_set_opt s_ctx ssl_op_no_sslv2 ssl_op_no_sslv3 ssl_op_no_tlsv1 limit cipher suit offer s_ctx est_cipher_list est_log_err fail set ssl cipher suit &#34;); ossl_dump_ssl_error (); return make sure verifi server ssl_ctx_set_verifi s_ctx ssl_verify_p cert_verify_cb leverag cert store alreadi creat trust chain provid applic either case ssl stack clean cert store ssl_ctx_free (), let remov refer tri clean later s_ctx ctx trusted_certs_stor ctx trusted_certs_stor null set x509 param assign ssl ctx enabl crl check max untrust cert exist chain ensur cert use intend contain x509 key usag extens vpm (); vpm null est_log_err unabl alloc verifi paramet structur &#34;); ossl_dump_ssl_error (); return est_err_malloc enabl crl check ctx enable_crl vpm vpm vpm est_tls_verify_depth vpm ssl_ctx_set1_param s_ctx vpm vpm save refer ssl session use later match est_ctx ssl context est_ssl_info_cb (). ctx ssl_ctx s_ctx ssl_get_ex_new_index est context null null null last config set ctx base instead global entir libcrypto librari need ensur csr string attribut ascii printabl format b_asn1_print return function calcul digest valu use http request server ask client use http digest authent use token pars http server respons earlier calcul digest static unsign char est_ctx ctx char uri char user char pwd evp_md_ctx mdctx const evp_md evp_md5 (); uint8_t ha1 evp_max_md_s unsign int ha1_len char ha1_str uint8_t ha2 evp_max_md_s unsign int ha2_len char ha2_str char nonce_cnt 00000001 unsign char digest evp_max_md_s unsign int d_len unsign char calcul ha1 use usernam realm password server nonc mdctx evp_md_ctx_creat (); evp_digest init_ex mdctx null est_log_err unabl initi digest &#34;); return null evp_digest updat mdctx user strnlen_ user max_uidpwd )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx ctx realm strnlen_ ctx realm max_realm )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx pwd strnlen_ pwd max_uidpwd )); evp_digest final mdctx ha1 ha1_len evp_md_ctx_destroy mdctx est_hex_to_str ha1_str ha1 ha1_len calcul ha2 use method uri mdctx evp_md_ctx_creat (); evp_digest init_ex mdctx null est_log_err unabl initi digest &#34;); return null evp_digest updat mdctx post evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx uri strnlen_ uri max_realm )); evp_digest final mdctx ha2 ha2_len evp_md_ctx_destroy mdctx est_hex_to_str ha2_str ha2 ha2_len calcul auth digest use ha1 nonc nonc count client nonc qop ha2 mdctx evp_md_ctx_creat (); evp_digest init_ex mdctx null est_log_err unabl initi digest &#34;); return null evp_digest updat mdctx ha1_str ha1_len evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx ctx s_nonc strnlen_ ctx s_nonc max_nonc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx nonce_cnt strnlen_ nonce_cnt max_nc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx ctx c_nonc strnlen_ ctx c_nonc max_nonc )); evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx auth evp_digest updat mdctx &#34;:&#34;, evp_digest updat mdctx ha2_str ha2_len evp_digest final mdctx digest d_len evp_md_ctx_destroy mdctx malloc null est_log_err unabl alloc memori digest &#34;); return null est_hex_to_str char digest d_len return use retriev credenti server request either basic digest mode valu need applic layer either mode usernam password api indic mode callback case anyth chang static void est_ctx ctx est_http_auth_mod auth_mod char user char pwd est_http_auth_hdr auth_credenti see one part reset part ctx userid memzero_ ctx userid sizeof ctx userid )); ctx password memzero_ ctx password sizeof ctx password )); need ask applic layer credenti memzero_ auth_credenti sizeof auth_credenti )); ctx auth_credentials_cb auth_credenti mode auth_mod ctx auth_credentials_cb auth_credenti est_log_err attempt obtain token applic fail .&#34;); get credenti expect point null string generat header auth_credenti user null user els max_uidpwd strnlen_ auth_credenti user max_uidpwd est_log_err userid provid larger max max_uidpwd user els eok strncpy_ user max_uidpwd auth_credenti user max_uidpwd est_log_err invalid user provid &#34;); auth_credenti pwd null pwd els max_uidpwd strnlen_ auth_credenti pwd max_uidpwd est_log_err password provid larger max max_uidpwd pwd els eok strncpy_ pwd max_uidpwd auth_credenti pwd max_uidpwd est_log_err invalid user password provid &#34;); auth_credenti function add http authent header outgo http request allow server authent est client paramet ctx est context hdr pointer buffer hold header uri pointer buffer hold uri use header static void est_ctx ctx char hdr char uri int hdr_len unsign char digest unsign char client_random char max_uidpwd uid pwd &#34;:&#34; char both_b64 max_uidpwd int both_len est_http_auth_hdr auth_credenti char token null char token_b64 max_auth_token_len char user max_uidpwd char pwd max_uidpwd int enc_len int token_len memzero_ max_uidpwd memzero_ both_b64 max_uidpwd hdr_len int strnlen_ hdr hdr_len est_log_warn authent header took maximum amount buffer )&#34;, switch ctx auth_mod case auth_bas make sure part credenti send oper origin mode app layer provid front need ask app layer ctx userid ctx password memzero_ user max_uidpwd memzero_ pwd max_uidpwd ctx ctx auth_mod user pwd regardless come back build string contain snprintf max_uidpwd user pwd els use given configur est_client_set_auth snprintf max_uidpwd ctx userid ctx password base64 encod combin string build http auth header both_len strnlen_ max_uidpwd enc_len est_base64_encod const char both_len both_b64 max_uidpwd )); enc_len est_log_err unabl encod basic auth valu &#34;); snprintf hdr hdr_len hdr_len author basic both_b64 break case auth_digest generat client nonc rand_byt client_random est_log_err rng failur generat nonc &#34;); forc hdr null string memzero_ hdr break est_hex_to_str ctx c_nonc client_random check see applic layer provid usernam password front configur retriev otherwis copi local buffer get readi ctx userid ctx password memzero_ user max_uidpwd memzero_ pwd max_uidpwd ctx ctx auth_mod user pwd els eok strncpy_ user max_uidpwd ctx userid max_uidpwd est_log_err invalid user provid &#34;); eok strncpy_ pwd max_uidpwd ctx password max_uidpwd est_log_err invalid user password provid &#34;); digest ctx uri user pwd digest null est_log_err error generat digest &#34;); forc hdr null string memzero_ hdr memzero_ ctx c_nonc max_nonc memzero_ user max_uidpwd memzero_ pwd max_uidpwd break snprintf hdr hdr_len hdr_len author digest usernam =\\&#34;% \\&#34;, realm =\\&#34;% \\&#34;, nonc =\\&#34;% \\&#34;, uri =\\&#34;% \\&#34;, cnonc =\\&#34;% \\&#34;, 00000001 qop =\\&#34; auth \\&#34;, respons =\\&#34;% \\&#34;\\ user ctx realm ctx s_nonc uri ctx c_nonc digest memzero_ digest memzero_ ctx c_nonc max_nonc memzero_ user max_uidpwd memzero_ pwd max_uidpwd free digest break case auth_token est_log_info server request token base authent &#34;); memzero_ auth_credenti sizeof auth_credenti )); ctx auth_credentials_cb auth_credenti mode auth_token ctx auth_credentials_cb auth_credenti est_log_err attempt obtain token applic fail .&#34;); get credenti expect point null string generat header auth_credenti auth_token null est_log_err request token credenti applic provid .&#34;); token &#34;&#34;; els make sure token given long forc null caus auth failur server credenti provid max_auth_token_len strnlen_ auth_credenti auth_token max_auth_token_len est_log_err token provid larger max max_auth_token_len token &#34;&#34;; els token auth_credenti auth_token base64 encod combin string build http auth header memzero_ token_b64 max_auth_token_len token_len strnlen_ token max_auth_token_len enc_len est_base64_encod const char token token_len token_b64 max_auth_token_len enc_len est_log_err unabl encod bearer token auth valu &#34;); snprintf hdr hdr_len hdr_len author bearer token_b64 auth_credenti break default est_log_info http auth mode set send anonym request &#34;); break function use build http header cacert request flow paramet ctx est context hdr pointer buffer hold header static int est_ctx ctx char hdr int hdr_len snprintf hdr get http user agent connect close host accept */*\\ est_path_prefix ctx uri_path_seg ?&#34;/&#34;:&#34;&#34;), ctx uri_path_seg ctx uri_path_seg :&#34;&#34;), est_get_cacert est_http_hdr_est_cli ctx est_serv ctx est_port_num hdr_len int strnlen_ hdr hdr_len est_log_warn cert header took maximum amount buffer )&#34;, return hdr_len function use build http header csr attribut request flow paramet ctx est context hdr pointer buffer hold header static int est_ctx ctx char hdr int hdr_len snprintf hdr get http user agent connect close host accept */*\\ est_path_prefix ctx uri_path_seg ?&#34;/&#34;:&#34;&#34;), ctx uri_path_seg ctx uri_path_seg :&#34;&#34;), est_get_csrattr est_http_hdr_est_cli ctx est_serv ctx est_port_num ctx hdr hdr_len int strnlen_ hdr hdr_len est_log_warn csr attribut request header took maximum amount buffer )&#34;, return hdr_len function work csr attribut request flow paramet ctx est context ssl ssl context static int est_ctx ctx ssl ssl unsign char csrattr int csrattrs_len char http_data int hdr_len int read_siz write_s unsign char csr_attrs_buf null int assum defeat csrattr null csrattrs_len build http request alloc buffer header data termin charact build header data termin http_data malloc http_data null est_log_err unabl alloc memori http_data &#34;); return est_err_malloc hdr_len ctx http_data hdr_len est_log_err csr attribut http header could built correct &#34;); free http_data return termin http header snprintf http_data hdr_len hdr_len &#34;); hdr_len data sent ahead termin http request snprintf http_data hdr_len hdr_len &#34;); hdr_len send request server wait respons ctx last_http_status write_s ssl_write ssl http_data hdr_len write_s est_log_err tls write error &#34;); ossl_dump_ssl_error (); est_err_ssl_writ els est_log_info tls wrote byte attempt byte write_s hdr_len tri get respons server est_io_get_respons ctx ssl est_op_csrattr csr_attrs_buf read_siz switch case est_err_non csr_attrs_buf null csrattr csr_attrs_buf csrattrs_len read_siz break case est_err_auth_fail default est_log_err est request fail )&#34;, est_err_num_to_str )); csr_attrs_buf free csr_attrs_buf break free http_data return function use build http header simpl enrol flow paramet ctx est context hdr pointer buffer hold header pkcs10_len length buffer point hdr static int est_ctx ctx char hdr int pkcs10_len int hdr_len snprintf hdr post http user agent connect close host accept */*\\ content type applic pkcs10 content length est_path_prefix ctx uri_path_seg ?&#34;/&#34;:&#34;&#34;), ctx uri_path_seg ctx uri_path_seg :&#34;&#34;), est_simple_enrol est_http_hdr_est_cli ctx est_serv ctx est_port_num pkcs10_len ctx hdr hdr_len int strnlen_ hdr hdr_len est_log_warn client enrol request header took maximum amount buffer )&#34;, return hdr_len function use build http header simpl enrol flow paramet ctx est context hdr pointer buffer hold header pkcs10_len length buffer point hdr static int est_ctx ctx char hdr int pkcs10_len int hdr_len snprintf hdr post http user agent connect close host accept */*\\ content type applic pkcs10 content length est_path_prefix ctx uri_path_seg ?&#34;/&#34;:&#34;&#34;), ctx uri_path_seg ctx uri_path_seg :&#34;&#34;), est_simple_reenrol est_http_hdr_est_cli ctx est_serv ctx est_port_num pkcs10_len ctx hdr hdr_len int strnlen_ hdr hdr_len est_log_warn client reenrol request header took maximum amount buffer )&#34;, return hdr_len function send http request simpl enrol csr pkcs10 alreadi built point function simpli creat http header bodi put wire wait respons server copi respons buffer provid caller paramet ctx est context ssl ssl context bptr pointer contain pkcs10 csr pkcs7 pointer receiv pkcs7 respons pkcs7_len length pkcs7 respons reenrol set reenrol instead enrol int est_ctx ctx ssl ssl buf_mem bptr unsign char pkcs7 int pkcs7_len int reenrol char http_data int hdr_len int write_s unsign char enroll_buf null int enroll_buf_len int assum enrol fail set return length zero defens pkcs7_len build http request alloc buffer header data termin charact build header data termin http_data malloc http_data null est_log_err unabl alloc memori http_data &#34;); return est_err_malloc reenrol perform simpleenrol hdr_len ctx http_data int bptr length els perform simplereenrol hdr_len ctx http_data int bptr length hdr_len est_log_err enrol http header could built correct &#34;); free http_data return termin http header snprintf http_data hdr_len hdr_len &#34;); hdr_len build http bodi contain pkcs10 request memcpy_ http_data hdr_len bptr data rsize_t bptr length hdr_len bptr length termin http request snprintf http_data hdr_len hdr_len ,&#34;\\ &#34;); hdr_len send request server wait respons ctx last_http_status write_s ssl_write ssl http_data hdr_len write_s est_log_err tls write error &#34;); ossl_dump_ssl_error (); est_err_ssl_writ els est_log_info tls wrote byte attempt byte write_s hdr_len tri get respons server est_io_get_respons ctx ssl est_op_simple_enrol enroll_buf enroll_buf_len switch case est_err_non enroll_buf_len est_log_err enrol buf zero byte length &#34;); break memcpy_ pkcs7 enroll_buf enroll_buf_len pkcs7_len enroll_buf_len break case est_err_auth_fail est_log_warn http auth failur &#34;); break default est_log_err est request fail )&#34;, est_err_num_to_str )); break free enroll_buf openssl_cleans http_data strnlen_ http_data )); free http_data http_data null return function saniti check x509 prior attempt convert x509 csr reenrol oper return est_error code static est_error x509 cert make sure cert sign cert signatur est_log_err certif provid contain signatur .&#34;); return est_err_bad_x509 make sure signatur length invalid cert signatur length est_log_err certif provid contain invalid signatur length .&#34;); return est_err_bad_x509 return est_err_non function use clear challeng password attribut x509 csr use http authent use enrol process valu chang client send second http request contain http author valu sinc csr reus initi secondari request need clear valu csr submit secondari request static void x509_req csr int pos x509_attribut attr challeng password may csr never happen defens pos look valu csr pos csr nid_pkcs9_challeng password pos found delet attr x509_req_delete_attr csr pos attr doc open ssl show use x509_req_delete_attr assum need free attribut appear good exampl use api x509_attribute_fre attr function work convert x509_req base64 encod der format specifi est rfc convert proper format routin forward request server check respons save cert local context retriev later applic layer static est_error est_ctx ctx ssl ssl x509_req req int pkcs7_len int reenrol est_error est_err_non bio p10out null b64 buf_mem bptr null unsign char recv_buf unsign char new_cert_buf int new_cert_buf_len grab pkcs10 pem encod data b64 bio_new bio_f_base64 ()); b64 est_log_err bio_new fail &#34;); ossl_dump_ssl_error (); return est_err_malloc p10out bio_new bio_s_mem ()); p10out est_log_err bio_new fail &#34;); ossl_dump_ssl_error (); return est_err_malloc p10out bio_push b64 p10out encod use der asn set modifi flag x509_req open ssl keep cach copi der encod data case set flag tell open ssl run asn encod rather use cach copi req req_info enc modifi i2d_x509_req_bio p10out req void bio_flush p10out bio_get_mem_ptr p10out bptr get buffer place entir respons server recv_buf malloc est_ca_max recv_buf null est_log_err fail alloc buffer server respons &#34;); return est_err_malloc new_cert_buf recv_buf new_cert_buf_len send pkcs10 http request est server ctx ssl bptr new_cert_buf new_cert_buf_len reenrol switch case est_err_non make sure even though got success return code actual receiv someth new_cert_buf_len est_log_err buffer contain newli enrol client certif zero byte length &#34;); break resiz buffer hold retriev client certif link ctx get rid http hdr extra space back ctx enrolled_client_cert null free ctx enrolled_client_cert ctx enrolled_client_cert malloc new_cert_buf_len ctx enrolled_client_cert null est_log_err unabl alloc newli enrol client certif buffer &#34;); est_err_malloc break ctx enrolled_client_cert new_cert_buf_len memcpy_ ctx enrolled_client_cert new_cert_buf_len new_cert_buf new_cert_buf_len ctx new_cert_buf_len pass back length newli enrol cert pkcs7_len ctx est_log_info newli enrol client certif ctx enrolled_client_cert est_log_info length ctx break case est_err_auth_fail est_log_info http author fail request auth mode ctx auth_mod break default est_log_err est enrol fail error code )&#34;, est_err_num_to_str )); break recv_buf free recv_buf bio_free_al p10out return function implement simpl enrol flow sign csr provid send csr est server retriev pkcs7 respons paramet ctx est context ssl ssl context use est session csr pointer x509_req object contain pkcs10 csr pkcs7_len pointer integ length reciev pkcs7 respons place priv_key pointer privat key use sign csr reenrol set reenrol instead enrol return est_error static est_error est_ctx ctx ssl ssl x509_req csr int pkcs7_len evp_pkey priv_key int reenrol est_error est_err_non char tls_uid int ossl_rv make sure remov csr proceed csr get valu tls session emb csr requir ctx csr_pop_requir ctx client_force_pop est_log_info client includ challeng password csr &#34;); tls_uid est_get_tls_uid ssl tls_uid ossl_rv csr nid_pkcs9_challeng password mbstring_asc unsign char tls_uid free tls_uid ossl_rv est_log_err unabl set x509 challeng password attribut &#34;); ossl_dump_ssl_error (); return est_err_x509_attr els est_log_err unabl obtain tls uid &#34;); return sign csr ossl_rv csr priv_key ctx signing_digest ossl_rv est_log_err unabl sign x509 cert request &#34;); ossl_dump_ssl_error (); return est_err_x509_sign ctx ssl csr pkcs7_len reenrol return est_client_enroll_cn function implement simpl enrol flow use privat key generat csr pkcs10 request send request est server retriev pkcs7 respons user function simpli provid common name valu place pkcs10 csr simplifi interfac none csr attribut specifi param ctx est context param ssl ssl context use est session param pointer common name place x509 request param pkcs7_len pointer integ length reciev pkcs7 respons place param pkey new client public key enrol return est_error static est_error est_client_enroll_cn est_ctx ctx ssl ssl char int pkcs7_len evp_pkey pkey x509_req pkcs10 null est_error est_err_non char tls_uid ctx return est_err_no_ctx attempt creat pkcs10 certif request get tls uid case need popul tls_uid est_get_tls_uid ssl tls_uid est_generate_pkcs10 ctx tls_uid pkey pkcs10 free tls_uid els est_log_err unabl obtain tls uid &#34;); est_err_non ctx ssl pkcs10 pkcs7_len pkcs10 x509_req_fre pkcs10 return follow function taken url content incorpor portion lib hostcheck lib rawstr portabl consist toupper rememb ebcdic use toupper behavior alter current local static char char switch case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return case return return follow function taken url curl_raw_equ raw case insensit string meant local independ compar string know safe see http :// daniel haxx blog 2008 strcasecmp turkish explan function necessari function capabl compar case insensit even non ascii static int const char first const char second first second first second get loop soon match break first ++; second ++; comparison possibl make sure loop skip one string reach zero must return success match return first second )); follow function taken url curl_raw_equ raw case insensit string meant local independ compar string know safe see http :// daniel haxx blog 2008 strcasecmp turkish explan function necessari function capabl compar case insensit even non ascii static int const char first const char second size_t max first second max first second break max --; first ++; second ++; max return equal far return first second )); follow function taken url curl_raw_equ raw case insensit string meant local independ compar string know safe see http :// daniel haxx blog 2008 strcasecmp turkish explan function necessari function capabl compar case insensit even non ascii static int est_client_hostmatch const char hostnam const char pattern const char pattern_label_end pattern_wildcard hostname_label_end int wildcard_en size_t prefixlen suffixlen struct in_addr ignor struct sockaddr_in6 si6 pattern_wildcard strchr pattern *\&#39;); pattern_wildcard null return pattern hostnam host_match host_nomatch detect address hostnam fail match inet_pton af_inet hostnam ignor return host_nomatch els inet_pton af_inet6 hostnam si6 sin6_addr return host_nomatch requir least dot pattern avoid wide wildcard match wildcard_en pattern_label_end strchr pattern .\&#39;); pattern_label_end null strchr pattern_label_end .\&#39;) null pattern_wildcard pattern_label_end pattern --&#34;, wildcard_en wildcard_en return pattern hostnam host_match host_nomatch hostname_label_end strchr hostnam .\&#39;); hostname_label_end null pattern_label_end hostname_label_end return host_nomatch wildcard must match least one charact left label hostnam least larg left label pattern hostname_label_end hostnam pattern_label_end pattern return host_nomatch prefixlen pattern_wildcard pattern suffixlen pattern_label_end pattern_wildcard return pattern hostnam prefixlen pattern_wildcard hostname_label_end suffixlen suffixlen host_match host_nomatch follow function taken url fqdn check server cert static int const char match_pattern const char hostnam saniti check input match_pattern match_pattern hostnam hostnam return trival case hostnam match_pattern return est_client_hostmatch hostnam match_pattern host_match return return function taken url adapt est url file name lib ssluse function verifyhost quot rfc2818 section server ident subject alt name extens type nsname present must use ident otherwis specif common name field subject field certif must use although use common name exist practic deprec certif author encourag use nsname instead match perform use match rule specifi rfc2459 one ident given type present certif one nsname name match one set consid accept name may contain wildcard charact consid match singl domain name compon compon fragment com match foo com bar foo com com match foo com bar com case uri specifi address rather hostnam case paddress subject alt name must present certif must exact match uri static est_error char hostnam x509 server_cert int match altern match yet mean match mean mismatch size_t addrlen stack_of general_nam altnam struct in6_addr addr_v6 struct in_addr addr_v4 int addr_is_v4 int addr_is_v6 est_error res est_err_non int errno_t safec_rc int numalt int int diff const general_nam check const char altptr size_t altlen unsign char nulstr unsign char peer_cn x509_name name asn1_str tmp attempt resolv host name address inet_pton af_inet hostnam addr_v4 addr_is_v4 addrlen sizeof struct in_addr els tri see hostnam resolv address inet_pton af_inet6 hostnam addr_v6 addr_is_v6 addrlen sizeof struct in6_addr get list altern name altnam x509_get_ext_d2i server_cert nid_subject_alt_nam null null altnam get amount altern rfc2459 claim must least one depend ... numalt sk_general_name_num altnam est_log_info found subject altern name numalt loop altern none match numalt match ++) get handl altern name number check sk_general_name_valu altnam get data length altptr char asn1_string_data check ia5 altlen size_t asn1_string_length check ia5 switch check type case gen_dn name pattern comparison est_log_info check fqdn san altptr open ssl man page explicit say general cannot assum data return asn1_string_data null termin contain embed null also actual format data depend actual string type exampl ia5str data ascii gisl research open ssl sourc check sourc patch alway termin ia5str altlen strnlen_ altptr true embed zero name string cannot match altptr hostnam match els match break case gen_ipadd address comparison compar altern address data chunk size server address psb complianc use safe librari memcmp_ addr_is_v4 safec_rc memcmp_ altptr altlen addr_v4 altlen diff safec_rc eok est_log_info memcmp_ error ipv4 address safec_rc els addr_is_v6 safec_rc memcmp_ altptr altlen addr_v6 altlen diff safec_rc eok est_log_info memcmp_ error ipv6 address safec_rc els never get ... forc match diff addr_is_v4 altlen addrlen diff match els addr_is_v6 altlen addrlen diff match els match break general_names_fre altnam match altern name match server hostnam est_log_info subject alt name match hostnam els match altern name field exist match must fail est_log_info subject alt name match hostnam res els look last occurr common name distinguish one get signific one follow done bug nulstr unsign char *)&#34;&#34;; peer_cn nulstr name x509_get_subject_nam server_cert name name nid_common name name entri convert string use comparison support bmpstring utf8 etc tmp x509_name_get_entri name )); open ssl earlier asn1_string_to_utf8 fail input alreadi utf encod check case copi raw string manual avoid problem code made condit futur open ssl fix work around brought alexi carvalho tmp asn1_string_typ tmp v_asn1_utf8str asn1_string_length tmp peer_cn malloc peer_cn safec_rc memcpy_ peer_cn asn1_string_data tmp safec_rc eok est_log_info memcpy_ error asn1 string safec_rc peer_cn els utf8 name asn1_string_to_utf8 peer_cn tmp peer_cn strnlen_ char peer_cn termin zero end string cannot match return failur est_log_warn ssl illeg cert name field &#34;); res peer_cn nulstr peer_cn null els convert peer_cn utf8 utf8 current support first releas libest curlcod data peer_cn strlen peer_cn )); call failf unsuccess free peer_cn return endif res est_err_non error alreadi detect pass els peer_cn est_log_warn ssl unabl obtain common name peer certif &#34;); res els const char peer_cn hostnam est_log_warn ssl fqdn hostnam mismatch server certif match target host name peer_cn hostnam res els est_log_info common name match )&#34;, peer_cn peer_cn free peer_cn return res routin check fqdn server certif configur server name use establish tcp connect est server requir per section est spec note fqdn check defin rfc 6125 look cmc extend key usag extens server cert restrict allow fqdn mismatch cmc present current way determin use explicit trust anchor allow addit flexibl static est_error est_ctx ctx ssl ssl x509 cert est_error cert ssl_get_peer_certif ssl cert ctx est_serv cert x509_free cert return els cert ctx enable_srp est_log_info peer certif skip fqdn check sinc srp enabl .&#34;); return est_err_non els est_log_warn unabl perform fqdn check peer certif .&#34;); return function open tcp socket establish tls session est server call est_client_init (). paramet ctx pointer est context client session ssl pointer ssl context structur return ssl context creat reurn est_err_non success est_error est_client_connect est_ctx ctx ssl ssl bio tcp ssl_ctx s_ctx est_error est_err_non ifndef win32 int sock els socket sock invalid_socket endif int int oval int ssl_connect_ret tcw_err_t tcw_err tcw_opts_t tcw_opt ctx return est_err_no_ctx s_ctx ctx ssl_ctx establish connect proxi applic ctx use_proxi tcw_opt proxy_proto ctx proxy_proto tcw_opt proxy_host ctx proxy_serv tcw_opt proxy_port ctx proxy_port ctx proxy_usernam ctx proxy_password ctx proxy_auth tcw_opt proxy_usernam ctx proxy_usernam tcw_opt proxy_password ctx proxy_password tcw_opt proxy_auth initi ctx proxy_auth tcw_opt proxy_auth ctx proxy_auth tcw_opt proxy_auth els tcw_opt proxy_proto est_client_proxy_non tcw_err tcw_connect ctx tcw_sock tcw_opt ctx est_serv ctx est_port_num sock tcw_err tcw_err_resolv est_log_err unabl lookup hostnam .&#34;, ctx est_serv return est_err_ip_getaddr tcw_err tcw_ok est_log_err unabl connect est server ctx est_serv return est_err_ip_connect enabl tcp keep aliv setsockopt sock sol_socket so_keepal char *)&amp; oval sizeof oval )); tcw_close ctx tcw_sock sock sock_invalid est_log_err unabl connect est server address ctx est_serv return est_err_ip_connect pass socket bio interfac open ssl use creat tls session tcp bio_new_socket sock bio_noclos tcp null est_log_err error creat socket &#34;); tcw_close ctx tcw_sock sock sock_invalid ossl_dump_ssl_error (); return est_err_ip_connect (!(* ssl ssl_new s_ctx ))) est_log_err error creat tls context &#34;); ossl_dump_ssl_error (); bio_free_al tcp tcw_close ctx tcw_sock sock sock_invalid return est_err_ssl_new need set est ctx exdata ssl session context retriev per session basi ssl_set_ex_data ssl ctx set est server name ssl context sent server name extens client hello ssl ctx est_serv ssl_set_bio ssl tcp tcp ctx sess ssl_set_sess ssl ctx sess ssl_connect_ret ssl_connect ssl est_log_err error connect tls context ssl_get_error ssl ssl_connect_ret )); ossl_dump_ssl_error (); tcw_close ctx tcw_sock sock sock_invalid est_err_ssl_connect els ctx tcw_sock_connect establish tls session est server need verifi fqdn server cert match server name use establish connect section est spec est_err_non ctx ssl host name match shut tunnel bail ctx ssl est_log_warn est server name match fqdn server certif .&#34;); return function close tls session under socket paramet ssl pointer ssl context set connect est server void est_ctx ctx ssl ssl ssl_session new_sess (!* ssl return first disconnect get session cach away use session resumpt ctx sess ctx sess ssl_get1_sess ssl els first time disconnect see session chang offici obtain get1 call cach away new_sess ssl_get0_sess ssl new_sess ctx sess ctx sess ssl_get1_sess ssl ssl_shutdown ssl ssl_free ssl ssl null ctx tcw_sock_connect tcw_close ctx tcw_sock ctx tcw_sock_connect function work cacert request flow paramet ctx est context ssl ssl context ca_certs_len pointer unsign int hold length return cert static int est_ctx ctx ssl ssl int ca_certs_len char http_data int hdr_len int write_s int unsign char ca_certs_buf null int ca_certs_buf_len build http request alloc buffer header data termin charact build header data termin http_data malloc http_data null est_log_err unabl alloc memori http_data &#34;); return est_err_malloc hdr_len ctx http_data termin http header snprintf http_data hdr_len hdr_len ,&#34;\\ &#34;); hdr_len data sent ahead termin http request snprintf http_data hdr_len hdr_len &#34;); hdr_len send request server wait respons ctx last_http_status write_s ssl_write ssl http_data hdr_len write_s est_log_err tls write error &#34;); ossl_dump_ssl_error (); est_err_ssl_writ els est_log_info tls wrote byte attempt byte write_s hdr_len tri get respons server est_io_get_respons ctx ssl est_op_cacert ca_certs_buf ca_certs_buf_len switch case est_err_non make sure even though got success return code actual receiv someth ca_certs_buf_len est_log_err retriev cert buf zero byte length &#34;); break ca_certs_buf_len est_ca_max est_log_err retriev cert buf larger maximum allow &#34;); break resiz buffer hold retriev cert link ctx get rid http hdr extra space back ctx retrieved_ca_cert null free ctx retrieved_ca_cert ctx retrieved_ca_cert malloc ca_certs_buf_len ctx retrieved_ca_cert null est_log_err unabl alloc cert buffer &#34;); est_err_malloc break ctx retrieved_ca_cert ca_certs_buf_len memcpy_ ctx retrieved_ca_cert ca_certs_buf_len ca_certs_buf ca_certs_buf_len ctx ca_certs_buf_len verifi return cert chain verify_cacert_resp ctx ctx retrieved_ca_cert ctx est_err_non est_log_err return cacert chain invalid &#34;); free ctx retrieved_ca_cert ctx retrieved_ca_cert null ctx ca_certs_len ctx break pass back length retriev cert buffer ca_certs_len ctx est_log_info cacert buf ctx retrieved_ca_cert est_log_info cacert length ctx break case est_err_auth_fail est_log_err http auth failur &#34;); break case est_log_info http request fail retri resp &#34;); break default est_log_err est request fail )&#34;, est_err_num_to_str )); break http_data free http_data ca_certs_buf free ca_certs_buf return function work cacert request flow paramet ctx est context ssl ssl context ca_certs_len pointer unsign int hold length return cert est_error est_ctx ctx const char uid const char pwd userid must password vice versa userid still empti string cannot null password uid null pwd null est_log_err user provid password &#34;); return uid null pwd null est_log_err password provid user &#34;); return uid pwd set basic digest authent uid null eok strncpy_ ctx userid max_uidpwd uid max_uidpwd est_log_err invalid user provid &#34;); return eok strncpy_ ctx password max_uidpwd pwd max_uidpwd est_log_err invalid password provid &#34;); return return est_err_non /*! brief perform simpl enrol request est server use pkcs10 csr provid applic layer param ctx pointer est context param csr pointer pkcs10 csr data defin open ssl x509_req param pkcs7_len pointer integ hold length pkcs7 buffer param priv_key pointer privat key use sign csr null return est_error connect est server establish ssl tls connect est server configur previous call est_client_set_serv (), send simpl enrol request applic layer must provid pkcs10 csr enrol priv_key argument given null csr need sign privat key howev csr must contain everyth els requir includ public key privat key provid alreadi sign csr est librari sign csr enrol respons store est context length pass back applic pkcs7_len paramt function applic alloc correct size buffer call retriev new client certif context unless csr alreadi sign indic null priv_key applic must provid pointer privat key use sign csr requir est librari event est server request proof possess valu includ csr est librari automat includ proof posess valu sign csr awar x509_req data pass function must valid pass corrupt csr data may result system crash lib est util open ssl asn decod logic read x509_req data open ssl perform safeti check x509_req data pars applic read extern generat pem der encod csr data pleas use helper function convert pem der csr valid x509_req pointer est_error est_ctx ctx x509_req csr int pkcs7_len evp_pkey priv_key est_error ssl ssl null ctx return est_err_no_ctx csr return est_err_no_csr ctx est_client_initi return establish tls session est server est_client_connect ctx ssl est_err_non goto err priv_key ctx ssl csr pkcs7_len priv_key els ctx ssl csr pkcs7_len ctx ssl est_err_auth_fail ctx auth_mod auth_digest ctx auth_mod auth_bas ctx auth_mod auth_token https digest mode requir use md5 make sure fip mode use md5 ctx auth_mod auth_digest fips_mod ())){ est_log_err http digest auth allow fip mode &#34;); est_err_bad_mod goto err tri one time digest auth est_log_info http auth fail tri digest basic paramet &#34;); est_client_connect ctx ssl est_err_non est_log_err connect fail second attempt basic digest paramet &#34;); goto err priv_key ctx ssl csr pkcs7_len priv_key els ctx ssl csr pkcs7_len est_err_non est_log_err enrol fail second attempt basic digest authent &#34;); ctx ssl err ssl ssl_shutdown ssl ssl_free ssl return /*! brief est_client_enrol perform simpl enrol request est server param ctx pointer est context param pointer common name valu use enrol request param pkcs7_len pointer integ hold length pkcs7 buffer param new_public_key pointer evp_pkey structur hold client key pair use simpl enrol request public key includ certif sign request csr sent server privat key use sign request return est_error est_client_enrol connect est server build simpl enrol request use common name pass establish ssl tls connect est server configur previous call est_client_set_serv (), send simpl enrol request respons store est context length pass back applic pkcs7_len paramet function applic alloc correct size buffer call retriev new client certif context est_error est_client_enrol est_ctx ctx char int pkcs7_len evp_pkey new_public_key est_error ssl ssl null ctx return est_err_no_ctx new_public_key return est_err_no_key ctx est_client_initi return est_client_connect ctx ssl est_err_non goto err est_client_enroll_cn ctx ssl pkcs7_len new_public_key ctx ssl est_err_auth_fail ctx auth_mod auth_digest ctx auth_mod auth_bas ctx auth_mod auth_token https digest mode requir use md5 make sure fip mode use md5 ctx auth_mod auth_digest fips_mod ())){ est_log_err http digest auth allow fip mode &#34;); est_err_bad_mod goto err tri one time digest auth est_log_info http auth fail tri basic digest token paramet &#34;); est_client_connect ctx ssl est_err_non est_log_err connect fail second attempt basic digest token paramet &#34;); goto err est_client_enroll_cn ctx ssl pkcs7_len new_public_key est_err_non est_log_err enrol fail second attempt basic digest authent &#34;); attempt token mode second time server respond error attribut log ctx token_error ctx token_error_desc est_log_err token auth mode fail server provid error inform error error descript ctx token_error ctx token_error_desc ctx token_error ctx token_error_desc ctx ssl ctx auth_mod auth_non err ssl ssl_shutdown ssl ssl_free ssl return /*! brief perform full sequenc est oper enrol new certif use trust messag flow param ctx pointer est context param pointer common name valu use enrol request param pkcs7_len pointer integ hold length pkcs7 certif return param ca_cert_len pointer integ hold length buffer hold new trust certif param new_public_key pointer evp_pkey structur hold client key pair use simpl enrol request public key includ certif sign request csr sent server privat key use sign request return est_error connect est server retriev latest trust certifict server retriev csr attribut server send simpl enrol request server provis new certif conveni function equival invok follow three function order est_client_enrol function take common name entiti identifi use csr addit x509 attribut extens requir est server enforc presenc csr attribut function use provis certif function use addit x509 attribut includ enrol request provis respons store est context length pass back applic pkcs7_len paramet function applic alloc correct size buffer call retriev new client certif context provis respons also includ latest copi trust certif est server persist local applic futur use ca_cert_len argument contain length certic retriev invok (). est_error est_ctx ctx char int pkcs7_len int ca_cert_len evp_pkey new_public_key est_error unsign char new_ta_p7 unsign char new_ta_pem unsign char attr_data null int attr_len int new_ta_len ctx return est_err_no_ctx make sure non null pointer length pkcs7_len ca_cert_len return ctx est_client_initi return new_public_key return est_err_no_key first get latest trust anchor cert server ctx ca_cert_len est_err_non return new_ta_p7 malloc ca_cert_len new_ta_p7 null est_log_err unabl alloc cert buffer &#34;); est_err_malloc return ctx new_ta_p7 est_err_non free new_ta_p7 return cert base64 der encod need convert pem new_ta_len new_ta_p7 ca_cert_len new_ta_pem free new_ta_p7 new_ta_len return est_err_pem_read new trust anchor pem encod let load current est context futur est oper use new trust anchor ctx trusted_certs_stor null x509_store_fre ctx trusted_certs_stor ctx new_ta_pem new_ta_len free new_ta_pem est_err_non return sinc reset trust store mark client context initi ctx est_client_initi next need get csr attribut allow lib est know challeng password need includ csr ctx attr_data attr_len est_err_non est_log_err unabl get csr attribut provis new certif &#34;); return final attempt enrol new certif use common name provid applic est_client_enrol ctx pkcs7_len new_public_key return /*! brief est_client_reenrol perform enrol request est server use exist x509 certif param ctx pointer est context param cert pointer x509 certif defin open ssl x509 param pkcs7_len pointer integ hold length pkcs7 buffer param priv_key pointer privat key use sign csr return est_error est_client_reenrol connect est server establish ssl tls connect est server configur previous call est_client_set_serv (), send enrol request applic layer must provid x509 certif enrol certif previous enrol applic also need provid privat key associ public key x509 certif privat key requir sign csr generat x509 certif enrol respons store est context length pass back applic pkcs7_len paramt function applic alloc correct size buffer call retriev new client certif context applic must provid pointer privat key use sign csr requir est librari event est server request proof possess valu includ csr est librari automat includ proof posess valu sign csr awar public key subject name x509 certif includ enrol request sent est server respons appli x509 extens issu renew certif est_error est_client_reenrol est_ctx ctx x509 cert int pkcs7_len evp_pkey priv_key x509_req req est_error ssl ssl null int ossl_rv ctx return est_err_no_ctx cert return est_err_no_cert priv_key return est_err_no_key ctx est_client_initi return check x509 given cert est_err_non return check privat key match public key cert cert priv_key return convert exist certif csr copi subject name cert new csr pass null privat key paramet sign csr later req x509_to_x509_req cert null ctx signing_digest req est_log_err x509 csr convers fail .&#34;); ossl_dump_ssl_error (); return est_err_no_csr copi x509 extens old certif csr may may retain behavior depend polici use open ssl test set copy_extens set config file copyal retain extens csr issu new cert cert cert_info cert cert_info extens ossl_rv x509_req_add_extens req cert cert_info extens ossl_rv est_log_warn fail copi x509 extens csr new certif may contain extens present old certif .&#34;); establish tls session est server est_client_connect ctx ssl est_err_non goto err send enrol request ctx ssl req pkcs7_len priv_key ctx ssl est_err_auth_fail ctx auth_mod auth_digest ctx auth_mod auth_bas ctx auth_mod auth_token https digest mode requir use md5 make sure fip mode use md5 ctx auth_mod auth_digest fips_mod ())){ est_log_err http digest auth allow fip mode &#34;); est_err_bad_mod goto err tri one time digest auth est_log_info http auth fail tri digest basic paramet &#34;); est_client_connect ctx ssl est_err_non est_log_err connect fail second attempt basic digest paramet &#34;); goto err ctx ssl req pkcs7_len priv_key est_err_non est_log_err reenrol fail second attempt basic digest authent &#34;); attempt token mode second time server respond error attribut log ctx token_error ctx token_error_desc est_log_err token auth mode fail server provid error inform error error descript ctx token_error ctx token_error_desc ctx token_error ctx token_error_desc ctx ssl err ssl ssl_shutdown ssl ssl_free ssl x509_req_fre req return /*! brief pass back client certif previous obtain est server call est_client_enrol (). param ctx pointer est context param pointer common name valu use enrol request param pkcs7 pointer pointer point buffer contain newli enrol client certif return est_error copi previous obtain client certif est context applic buffer client certif copi context remov context est_error est_ctx ctx unsign char pkcs7 ctx return est_err_no_ctx ctx est_client_initi return pkcs7 null est_log_err est client simpl enrol invalid paramet &#34;); return ctx enrolled_client_cert null est_log_err client certif copi &#34;); return est_err_no_certif memzero_ pkcs7 ctx memcpy_ pkcs7 ctx ctx enrolled_client_cert ctx copi context hand free free ctx enrolled_client_cert ctx enrolled_client_cert null ctx return est_err_non /*! brief perform cacert get request est server param ctx pointer est context param ca_certs_len pointer integ hold length cert buffer return est_error connect est server build cert request send get cert request respons place buffer alloc maintain est client librari pointer buffer return call applic return cert base64 encod der format store null termin string buffer certif retriev est server client librari must reset retriev certif pass est client initi function explicit databas est_error est_ctx ctx int ca_certs_len est_error est_err_non ssl ssl null ctx return est_err_no_ctx ctx est_client_initi return ca_certs_len null est_log_err est client get cacert invalid paramet &#34;); return est_client_connect ctx ssl est_err_non ssl ssl_shutdown ssl ssl_free ssl return ctx ssl ca_certs_len ctx ssl ssl ssl_shutdown ssl ssl_free ssl return /*! brief copi previous retriev certif applic buffer param ctx pointer current est context param ca_cert pointer buffer retriev certif copi return est_error copi recent retriev certif est server certif copi applic buffer point ca_cert remov est clietn context certif retriev applic est client librari must reset reset perform certif retriev call pass est client initi function explicit databas est_error est_ctx ctx unsign char ca_cert ctx return est_err_no_ctx ctx est_client_initi return ca_cert null est_log_err est client get cacert invalid paramet &#34;); return ctx retrieved_ca_cert null est_log_err certif copi &#34;); return est_err_no_certif memzero_ ca_cert ctx memcpy_ ca_cert ctx ctx retrieved_ca_cert ctx cert obtain client lib need reset ctx est_client_initi return est_err_non /*! brief perform csr attribut request est server param ctx pointer est context client session param csr_data pointer buffer hold return csr attribut param csr_len pointer integ hold length csr attribut buffer return est_error connect est server send csr attribut request server save away return csr attribut data disconnect est server est_error est_ctx ctx unsign char csr_data int csr_len int new_csr_len pop_requir ssl ssl null unsign char new_csr_data ctx return est_err_no_ctx csr_data return csr_len return assum defeat csr_data null csr_len connect est server est_client_connect ctx ssl est_err_non ssl ssl_shutdown ssl ssl_free ssl return free current attribut cach ctx retrieved_csrattr free ctx retrieved_csrattr ctx retrieved_csrattr null ctx ctx ctx retrieved_csrattr null send http request est server ctx ssl new_csr_data new_csr_len ctx ssl est_err_non est_log_err csr request fail error code )&#34;, est_err_num_to_str )); new_csr_data free new_csr_data ssl ssl_shutdown ssl ssl_free ssl return ssl ssl_shutdown ssl ssl_free ssl new_csr_data null est_log_info csr attribut null &#34;); return est_err_non alloc new memori prior pars sure null termin ctx retrieved_csrattr malloc new_csr_len ctx retrieved_csrattr free new_csr_data return est_err_malloc ctx new_csr_len memcpy_ ctx retrieved_csrattr new_csr_len new_csr_data new_csr_len ctx retrieved_csrattr new_csr_len est_log_info csr attribut ctx ctx retrieved_csrattr free new_csr_data make sure data valid char ctx retrieved_csrattr ctx pop_requir est_err_non free ctx retrieved_csrattr ctx retrieved_csrattr null ctx els csr_data ctx retrieved_csrattr csr_len ctx ctx csr_pop_requir pop_requir return /*! brief use applic enabl tls srp transport use place tradit tls tls srp allow secur transport 509 certif avail trust anchor avail param ctx est context obtain est_client_init call param strength specifi srp strength use param uid char buffer contain user use srp user name param pwd char buffer contain passowrd use srp password function allow applic enabl tls srp cipher suit anoth form tls could use est client 509 certif identifi est server also use est client trust anchor avail authent est server ident est server must support tls srp use api function must invok est_client_init prior issu est command string paramet null termin string return est_error est_error est_ctx ctx int strength char uid char pwd x509_store store int ctx null est_log_err null context pass &#34;); return est_err_no_ctx ctx ssl_ctx null est_log_err ssl context initi &#34;); return est_err_no_ssl_ctx strength est_srp_strength_min est_log_err srp strength must greater est_srp_strength_min return uid null est_log_err srp user must provid &#34;); return pwd null est_log_err srp password must provid &#34;); return ctx enable_srp enabl srp cipher suit srp enabl use exclus check trust anchor configur enabl dss rsa auth cipher suit store ctx ssl_ctx store store obj sk_x509_object_num store obj est_log_info enabl ssl srp cipher suit rsa dss &#34;); ctx ssl_ctx els est_log_info enabl ssl srp cipher suit rsa dss &#34;); ctx ssl_ctx est_log_err fail set ssl srp cipher suit &#34;); ossl_dump_ssl_error (); return set srp user name password ctx ssl_ctx uid est_log_err unabl set srp usernam &#34;); ossl_dump_ssl_error (); return est_err_unknown ctx ssl_ctx pwd est_log_err unabl set srp password &#34;); ossl_dump_ssl_error (); return est_err_unknown ctx ssl_ctx strength est_log_info tls srp enabl &#34;); return est_err_non /*! brief est_client_set_auth use applic set authent paramet use param ctx est context obtain est_client_init call param uid char buffer contain user use basic digest base authent param pwd char buffer contain passowrd use basic digest base authent param client_cert_raw char buffer contain client applic certif param pkey_raw privat key use client cert param pkey_len length buffer hold privat key function allow applic provid inform requir authent est client est server call made accept request get cert user provid password must also provid applic may pass privat key pkey_raw pkey_len use sign request server otherwis basic digest base authent perform tls session request privat key pass must contain privat key match public key contain client_cert paramet string paramet null termin string return est_error error null est_error est_client_set_auth est_ctx ctx const char uid const char pwd x509 client_cert evp_pkey private_key est_error est_err_non ctx null est_log_err null context pass &#34;); return est_err_no_ctx ctx uid pwd est_err_non return ctx auth_mod auth_non cach away client cert associ privat key get load ssl context use ctx client_key private_key ctx client_cert client_cert load client cert avail ctx client_cert ctx client_key ctx ssl_ctx ctx client_cert ctx client_key est_log_err unabl load local certif privat key &#34;); return els est_log_warn use client certif tls session http basic digest auth use .&#34;); return est_err_non /*! brief use applic regist callback function param ctx est context obtain est_client_init call param auth_credentials_cb function pointer applic layer callback regist callback function use est client librari obtain authent credenti applic provid authent credenti initi avail userid password use http basic authent process request est client librari call applic callback event authent credenti request est server callback function definit must match follow function prototyp int auth_credentials_cb est_http_auth_hdr auth_credenti auth_credenti pointer est_http_auth_hdr structur structur provid est librari callback function fill specif credenti request credenti valu must pass format sent server est client librari perform reformat credenti ownership memori hold credenti valu transfer applic layer est librari applic layer return valu est librari allow est librari free memori soon done use valu return valu callback must one follow valu callback abl provid request credenti callback could provid request credenti auth_credentials_cb paramet set null reset callback function string paramet null termin string return est_error est_err_non success est_err_no_ctx est_error est_ctx ctx auth_credentials_cb callback ctx null est_log_err null context pass &#34;); return est_err_no_ctx ctx auth_credentials_cb callback return est_err_non /*! brief use applic reduc overhead tcp tls layer client know est server use http basic authent param ctx pointer est context client session normal lib est send anonym http request initi request est server function allow applic improv perform send http basic auth header initi request sent est server elimin need server send http authent challen respons elimin round trip est client server function call immedi invok est_client_set_auth (). precaut taken applic ensur hint enabl known est server configur http basic authent est server configur http digest authent enabl hint caus est transact fail return est_error est_err_non success est_error est_ctx ctx ctx null est_log_err null context pass &#34;); return est_err_no_ctx ctx auth_mod auth_bas return est_err_non /*! brief est_client_init use applic creat context est librari context use invok function client api param ca_chain requir char buffer contain certif raw byte data use authent est server param ca_chain_len length ca_chain char buffer param cert_format defin format certif pass instanti est client librari current valu accept est_cert_format_pem param cert_verify_cb pointer function est client applic call receiv server ident certif fail verif ssl code function take input two paramet pointer x509 structur contain server certif integ valu set open ssl defin error certif callback function return server ident certif reject valu approv function allow applic initi est client context applic must provid local certif ca_chain ca_chain_len use client oper certif provid must format specifi cert_format paramet current pem encod certif support length paramet certif ca_chain_len use der format certif pass certif may contain crl entri use authent certif receiv server return est_ctx error null est_ctx est_client_init unsign char ca_chain int ca_chain_len est_cert_format cert_format int cert_verify_cb x509 int est_ctx ctx volatil int len int ifdef win32 int result initi winsock result wsastartup makeword wsa data result est_log_err wsastartup fail result return endif cert_format est_cert_format_pem est_log_err pem encod certif support .&#34;); return null chain pass check length valu pass match calcul length buffer verifi length valu correct buffer proper null termin ca_chain len int strnlen_ char ca_chain est_ca_max len ca_chain_len est_log_err length ca_chain match pass ca_chain_len &#34;); return null ctx malloc sizeof est_ctx )); ctx est_log_err unabl alloc memori est context &#34;); return null memzero_ ctx sizeof est_ctx )); ctx est_mod est_client load local certif memori retain futur use use cacert request ctx ca_chain ca_chain_len est_log_err fail load trust certif store &#34;); est_destroy ctx return null ctx est_err_non est_log_err fail initi ssl context certifici privat key pass &#34;); est_destroy ctx return null save away client callback function allow manual verif server ident certif ctx cert_verify_cb set default valu socket read timeout ctx read_timeout use sha 256 default hash algorithm sign csr chang applic use function ctx signing_digest evp_sha256 (); ctx retry_after_delay ctx retry_after_d ctx est_client_initi return ctx /*! brief est_client_init use applic creat context est librari context use invok function client api param ca_chain requir char buffer contain certif raw byte data use authent est server param ca_chain_len length ca_chain char buffer param cert_format defin format certif pass instanti est client librari current valu accept est_cert_format_pem param cert_verify_cb pointer function est client applic call receiv server ident certif fail verif ssl code function take input two paramet pointer x509 structur contain server certif integ valu set open ssl defin error certif callback function return server ident certif reject valu approv function allow applic initi est client context applic must provid local certif ca_chain ca_chain_len use client oper certif provid must format specifi cert_format paramet current pem encod certif support length paramet certif ca_chain_len use der format certif pass certif may contain crl entri use authent certif receiv server return est_ctx error null static est_error char path_seg uri parser state state uri uri parsed_uri int uriparse_rc uri path segment cur_seg null char cur_seg_str null est_oper oper char canned_uri est_uri_max_len build can uri pass uripars librari caus incom path segment correct spot within uri get valid main issu possibl use path segment becom theme delimit memzero_ canned_uri est_uri_max_len strcpy_ canned_uri est_uri_max_len &#34;/. well known est /&#34;); strcat_ canned_uri est_uri_max_len path_seg state uri parsed_uri uriparse_rc uri pars uri state canned_uri uriparse_rc uri_success uri free uri member state uri return cur_seg parsed_uri path head cur_seg null est_log_err valid path segment suppli string &#34;); uri free uri member state uri return cur_seg cur_seg next next cur_seg_str char cur_seg text first oper est_parse_oper cur_seg_str look see oper path come next cacert csrattr simpleenrol simplereenrol oper occur path segment string problem oper est_op_max est_log_err path segment string contain oper valu path segment pass cur_seg_str uri free uri member state uri return look see multipl segment char cur_seg next null cur_seg text last est_log_err path segment string contain multipl path segment path segment &#34;); uri free uri member state uri return uri free uri member state uri return est_err_non /*! brief est_client_set_serv call applic layer specifi address port est server must call est_client_init prior issu est command param ctx pointer est context client session param server name est server connect ascii string repres name server limit 254 charact param port tcp port est server connect param path_seg string contain option path segment uri use set null return est_error est_err_non success est_err_no_ctx null valu pass est context null valu pass est server name server name string long call est_client_init invalid port number input less zero greater 65535 est_client_set_serv error check input paramet store hostnam port number est context est_error est_client_set_serv est_ctx ctx const char server int port char path_seg ctx return est_err_no_ctx ctx est_client_initi return server null return port port 65535 return eok strncpy_ ctx est_serv server return ctx est_port_num port ifdef have_uripars int path_segment_len est_error path_seg null path_seg return make sure long path_segment_len strnlen_ path_seg path_segment_len return valid incom path segment string path_seg est_err_non est_log_err path segment fail valid .&#34;); return valid store away context est_store_path_seg ctx path_seg path_segment_len est_err_non est_log_err fail store uri path segment .&#34;); return els uripars support cannot support path segment pass path_seg est_log_err use path segment support build lib est .&#34;); return endif return est_err_non /*! brief est_client_set_proxi call applic layer specifi proxi est server must call est_client_init prior issu est command param ctx pointer est context client session param proxy_proto proxi protocol param proxy_serv name proxi server connect ascii string repres name server limit 254 charact param port tcp port proxi server connect param proxy_auth proxi authent method param usernam usernam use authent proxi param password password use authent proxi return est_error est_err_non success est_err_no_ctx null valu pass est context null valu pass est server name server name string long port num proxi server invalid call est_client_init null valu pass either usernam password usernam password long client proxi mode support built libcurl support invalid proxi protocol specifi est_client_set_proxi error check input paramet store proxi inform est context note http proxi tunnel support lib est server mode configur lib est client mode communic lib est server mode must specifi proxi protocol est_error est_client_set_proxi est_ctx ctx proxy_proto const char proxy_serv unsign short int proxy_port unsign int proxy_auth const char usernam const char password ifdef have_libcurl ctx return est_err_no_ctx ctx est_client_initi return proxy_serv null proxy_serv return strnlen_ proxy_serv return ctx proxy_serv eok strncpy_ ctx proxy_serv sizeof ctx proxy_serv proxy_serv sizeof ctx proxy_serv ))) return proxy_port proxy_port 65535 return ctx proxy_port proxy_port proxy_proto proxy_proto return ctx proxy_proto proxy_proto proxy_auth proxy_auth )))) return ctx proxy_auth proxy_auth usernam password proxy_auth max_uidpwd strnlen_ usernam max_uidpwd return usernam return ctx proxy_usernam eok strncpy_ ctx proxy_usernam sizeof ctx proxy_usernam usernam sizeof ctx proxy_usernam ))) return max_uidpwd strnlen_ password max_uidpwd return password return ctx proxy_password eok strncpy_ ctx proxy_password sizeof ctx proxy_password password sizeof ctx proxy_password ))) return ctx proxy_auth proxy_auth ctx use_proxi return est_err_non els est librari built support libcurl client proxi mode support est_log_err client proxi mode requir libest built libcurl .&#34;); return endif /*! brief call applic layer specifi hash algorithm use sign pkcs10 csr enrol oper must call est_client_init prior issu est command param ctx pointer est context client session param nid nid valu defin open ssl header file obj_mac desir digest use sign return est_error est_err_non success est_err_no_ctx null valu pass est context unsupport nid provid lib est support sha1 sha224 sha256 sha384 sha512 digest sha256 default digest use sign need invok function unless anoth digest desir support nid valu nid_sha1 nid_sha224 nid_sha256 nid_sha384 nid_sha512 est_error est_ctx ctx int nid ctx return est_err_no_ctx switch nid case nid_sha512 ctx signing_digest evp_sha512 (); break case nid_sha384 ctx signing_digest evp_sha384 (); break case nid_sha256 ctx signing_digest evp_sha256 (); break case nid_sha224 ctx signing_digest evp_sha224 (); break case nid_sha1 ctx signing_digest evp_sha1 (); break default return break return est_err_non /*! brief copi retri valu store client context param ctx pointer current est context param retry_delay pointer integ retri delay sec valu copi server sent retri delay second format pass valu zero param retry_tim pointer time_t retri time date valu copi server sent retri time date string format string convert time_t valu pass paramet valu set server sent time date string respons otherwis valu set zero return est_error respons receiv est server header check see server includ retri header indic request current cannot process retri http header includ receiv respons server delay valu save context est error code given applic request indic client must retri request later time valu specifi server one two basic format string version integ valu repres number second client must wait retri request string contain date time client retri request date time string format specifi rfc 2616 second delay valu sent convert integ save est context date time string valu sent convert time_t valu save est context applic must call obtain amount time wait retri request copi current retri valu client context return applic one two return valu set non zero valu note process retri valu time date format current support est client alway return retri delay valu second est_error est_ctx ctx int retry_delay time_t retry_tim ctx return est_err_no_ctx ctx est_client_initi return retry_delay ctx retry_after_delay ctx retry_after_delay retry_tim ctx retry_after_d ctx retry_after_d return est_err_non /*! brief est_client_force_pop use applic enabl proof possess generat est client prove est client sent csr server proxi possess privat key use sign csr bind tls session csr note csr attribut configur server requir check need call function enabl enabl automat scenario csr attribut request server proxi param ctx pointer est context function may call time return est_error est_error est_client_force_pop est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx client_force_pop return est_err_non /*! brief use applic disabl proof possess generat est client pleas see documen est_client_force_pop inform proof possess check param ctx pointer est context function may call time return est_error est_error est_ctx ctx ctx est_log_err null context &#34;); return est_err_no_ctx ctx client_force_pop return est_err_non /*! brief use applic set timeout valu read oper est client send request est server attempt read respons server timeout valu limit amount time client wait respons param ctx pointer est context param timeout integ valu repres read timeout second minimum valu maximum valu return est_error est_error est_ctx ctx int timeout ctx est_log_err null context &#34;); return est_err_no_ctx timeout timeout est_log_err invalid read timeout valu pass timeout return ctx read_timeout timeout return est_err_non /*! brief use applic get http status code return est server recent oper param ctx pointer est context call est oper enrol oper function return recent http status code receiv est server normal status 200 would return est server indic success oper howev oper fail reason http status code may use understand reason failur instanc est server would return http status 401 est client author pleas see rfc 2616 descript various http status code return int valu repres http status code null null est context provid int est_ctx ctx ctx return ctx last_http_status els return&#39;]</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_reduced_pre</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">lis</span><span class="p">)</span> 
<span class="n">df_reduced_pre</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>unit test user stori server simpl enrol august...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>unit test uri path segment extens support marc...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>unit test user stori client simpl enrol septem...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>unit test user stori unit test client proxi mo...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>unit test user stori client cacert june copyri...</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
    </tr>
    <tr>
      <th>82</th>
      <td>sinc hijack open ssl buf mem data util functio...</td>
    </tr>
    <tr>
      <th>83</th>
      <td>author routin int ossl verifi int store ctx ct...</td>
    </tr>
    <tr>
      <th>84</th>
      <td>static void est log func char list null defaul...</td>
    </tr>
    <tr>
      <th>85</th>
      <td>sign long sign int int curlx sltosi long slnum...</td>
    </tr>
    <tr>
      <th>86</th>
      <td>util function set certif privat key use ssl co...</td>
    </tr>
  </tbody>
</table>
<p>87 rows × 1 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_reduced_pre</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;/tf/main/benchmarking/traceability/testbeds/nltk/[libest-pre-all].csv&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#########################################################</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="jsonl_list_to_dataframe" class="doc_header"><code>jsonl_list_to_dataframe</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L16" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>jsonl_list_to_dataframe</code>(<strong><code>file_list</code></strong>, <strong><code>columns</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Load a list of jsonl.gz files into a pandas DataFrame.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_dfs" class="doc_header"><code>get_dfs</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L25" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_dfs</code>(<strong><code>path</code></strong>)</p>
</blockquote>
<p>Grabs the different data splits and converts them into dataframes.
Expects format from Code Search Net Challenge.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;/tf/data/&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_trn</span><span class="p">,</span> <span class="n">df_val</span><span class="p">,</span> <span class="n">df_tst</span> <span class="o">=</span> <span class="n">get_dfs</span><span class="p">(</span><span class="n">path</span><span class="o">/</span><span class="s2">&quot;java/final/jsonl&quot;</span><span class="p">)</span>
<span class="n">df_trn</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Save some test data</span>
<span class="n">df_trn</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;./test_data/trn.csv&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">df_val</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;./test_data/val.csv&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">df_tst</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;./test_data/tst.csv&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="df_to_txt_file" class="doc_header"><code>df_to_txt_file</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L39" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>df_to_txt_file</code>(<strong><code>df</code></strong>, <strong><code>output</code></strong>, <strong><code>cols</code></strong>)</p>
</blockquote>
<p>Converts a dataframe and converts it into a text file that SentencePiece can use to train a BPE model</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sp_model_from_df" class="doc_header"><code>sp_model_from_df</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L49" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sp_model_from_df</code>(<strong><code>df</code></strong>, <strong><code>output</code></strong>, <strong><code>model_name</code></strong>, <strong><code>cols</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Trains a SentencePiece BPE model from a pandas dataframe</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sp_model_from_glob" class="doc_header"><code>sp_model_from_glob</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L55" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sp_model_from_glob</code>(<strong><code>path</code></strong>, <strong><code>glob</code></strong>, <strong><code>model_name</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="gen_hugface_model" class="doc_header"><code>gen_hugface_model</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L61" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>gen_hugface_model</code>(<strong><code>df</code></strong>, <strong><code>output</code></strong>, <strong><code>tokenizer</code></strong>=<em><code>Tokenizer(vocabulary_size=0, model=ByteLevelBPE, add_prefix_space=False, lowercase=False, dropout=None, unicode_normalizer=None, continuing_subword_prefix=None, end_of_word_suffix=None)</code></em>, <strong><code>vocab_sz</code></strong>=<em><code>30000</code></em>, <strong><code>min_freq</code></strong>=<em><code>3</code></em>, <strong><code>cols</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./test_data&quot;</span><span class="p">)</span>
<span class="n">model_name</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span> <span class="o">/</span> <span class="s1">&#39;trn.csv&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">gen_hugface_model</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tokenizer</span><span class="o">.</span><span class="n">_tokenizer</span><span class="o">.</span><span class="n">post_processor</span> <span class="o">=</span> <span class="n">BertProcessing</span><span class="p">(</span>
    <span class="p">(</span><span class="s2">&quot;&lt;/s&gt;&quot;</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">token_to_id</span><span class="p">(</span><span class="s2">&quot;&lt;/s&gt;&quot;</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;&lt;s&gt;&quot;</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">token_to_id</span><span class="p">(</span><span class="s2">&quot;&lt;s&gt;&quot;</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;public static void main(String[] args) { getDirFromLib(); }&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tokenizer</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s2">&quot;java_tokenizer&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dummy_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;first&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">],</span>
        <span class="s1">&#39;second&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">],</span>
        <span class="s1">&#39;third&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">]}</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dummy_data2</span><span class="p">);</span> <span class="n">df</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_to_txt_file</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;./test_data&#39;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./test_data&quot;</span><span class="p">)</span>
<span class="n">model_name</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sp_model_from_dfs</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">spm</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">SentencePieceProcessor</span><span class="p">()</span>
<span class="n">spm</span><span class="o">.</span><span class="n">Load</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="o">/</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{model_name}</span><span class="s2">.model&quot;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">spm</span><span class="o">.</span><span class="n">EncodeAsPieces</span><span class="p">(</span><span class="s2">&quot;Hello, world!&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_fns" class="doc_header"><code>tokenize_fns</code><a href="https://github.com/ncoop57/ds4se/tree/master/ds4se/mgmnt/prep/conv.py#L74" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_fns</code>(<strong><code>fns</code></strong>, <strong><code>tokenizer</code></strong>, <strong><code>exts</code></strong>, <strong><code>output</code></strong>, <strong><code>data_type</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
</div>
 

